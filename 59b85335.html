<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"klcc.cc","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>
<meta name="description" content="操作系统相关 操作系统就是一个协调、管理和控制计算机硬件资源和软件资源的控制程序">
<meta property="og:type" content="article">
<meta property="og:title" content="python-并发编程">
<meta property="og:url" content="https://klcc.cc/59b85335.html">
<meta property="og:site_name" content="klcc">
<meta property="og:description" content="操作系统相关 操作系统就是一个协调、管理和控制计算机硬件资源和软件资源的控制程序">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/9Ihf9e.jpg">
<meta property="og:image" content="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/RqtvS8.jpg">
<meta property="og:image" content="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/sfHAIh.png">
<meta property="og:image" content="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20211216191021094.png">
<meta property="og:image" content="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/ggLKKR.jpg">
<meta property="og:image" content="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/yFh1Wi.jpg">
<meta property="og:image" content="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/WK4tt1.jpg">
<meta property="og:image" content="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/dRjCYL.jpg">
<meta property="article:published_time" content="2021-12-16T00:31:30.496Z">
<meta property="article:modified_time" content="2022-01-18T07:21:51.204Z">
<meta property="article:author" content="klcc">
<meta property="article:tag" content="python">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/9Ihf9e.jpg">


<link rel="canonical" href="https://klcc.cc/59b85335.html">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://klcc.cc/59b85335.html","path":"59b85335.html","title":"python-并发编程"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>python-并发编程 | klcc</title>
  

  <script src="/js/third-party/analytics/baidu-analytics.js"></script>
  <script async src="https://hm.baidu.com/hm.js?725ad6b586949dd6e89c022fb8d748f7"></script>



  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">klcc</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">27</span></a></li>
        <li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">21</span></a></li>
        <li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">121</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9B%B8%E5%85%B3"><span class="nav-number">1.</span> <span class="nav-text">操作系统相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E9%81%93%E6%8A%80%E6%9C%AF"><span class="nav-number">1.1.</span> <span class="nav-text">多道技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3"><span class="nav-number">1.2.</span> <span class="nav-text">进程相关</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E3%80%81%E5%B9%B6%E8%A1%8C%E5%92%8C%E4%B8%B2%E8%A1%8C"><span class="nav-number">1.3.</span> <span class="nav-text">并发、并行和串行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">1.4.</span> <span class="nav-text">提交任务的两种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%E8%BF%90%E8%A1%8C%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="nav-number">1.5.</span> <span class="nav-text">一个任务运行的三种状态</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#multiprocessing%E6%A8%A1%E5%9D%97"><span class="nav-number">2.</span> <span class="nav-text">multiprocessing模块</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Process%E7%B1%BB"><span class="nav-number">2.1.</span> <span class="nav-text">Process类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.1.1.</span> <span class="nav-text">介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%B1%BB"><span class="nav-number">2.1.1.1.</span> <span class="nav-text">创建进程的类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.1.1.2.</span> <span class="nav-text">参数介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.1.1.3.</span> <span class="nav-text">方法介绍</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.1.1.4.</span> <span class="nav-text">属性介绍</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8"><span class="nav-number">2.1.2.</span> <span class="nav-text">使用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E5%90%AF%E8%BF%9B%E7%A8%8B%E6%96%B9%E5%BC%8F%E4%B8%80"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">开启进程方式一</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BC%80%E5%90%AF%E8%BF%9B%E7%A8%8B%E6%96%B9%E5%BC%8F%E4%BA%8C"><span class="nav-number">2.1.2.2.</span> <span class="nav-text">开启进程方式二</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%86%85%E5%AD%98%E7%A9%BA%E9%97%B4%E6%98%AF%E9%9A%94%E7%A6%BB%E7%9A%84"><span class="nav-number">2.1.2.3.</span> <span class="nav-text">进程之间的内存空间是隔离的</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95"><span class="nav-number">2.1.2.4.</span> <span class="nav-text">进程对象的方法</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E7%9B%B8%E5%85%B3-1"><span class="nav-number">3.</span> <span class="nav-text">进程相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.1.</span> <span class="nav-text">僵尸进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.2.</span> <span class="nav-text">孤儿进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="nav-number">3.3.</span> <span class="nav-text">守护进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81"><span class="nav-number">3.4.</span> <span class="nav-text">互斥锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E4%B8%80"><span class="nav-number">3.4.1.</span> <span class="nav-text">代码一</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%A0%81%E4%BA%8C"><span class="nav-number">3.4.2.</span> <span class="nav-text">代码二</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-number">3.4.3.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IPC%E6%9C%BA%E5%88%B6"><span class="nav-number">3.5.</span> <span class="nav-text">IPC机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%9F%E5%88%97"><span class="nav-number">3.5.1.</span> <span class="nav-text">队列</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="nav-number">3.6.</span> <span class="nav-text">生产者消费者模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="nav-number">3.7.</span> <span class="nav-text">信号量</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9B%B8%E5%85%B3"><span class="nav-number">4.</span> <span class="nav-text">线程相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%80%E5%90%AF%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="nav-number">4.1.</span> <span class="nav-text">开启线程的两种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">守护线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%94%81-1"><span class="nav-number">4.3.</span> <span class="nav-text">互斥锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F-1"><span class="nav-number">4.4.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Event"><span class="nav-number">4.5.</span> <span class="nav-text">Event</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="nav-number">4.6.</span> <span class="nav-text">定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8Bqueue"><span class="nav-number">4.7.</span> <span class="nav-text">线程queue</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E5%92%8C%E9%80%92%E5%BD%92%E9%94%81"><span class="nav-number">4.8.</span> <span class="nav-text">死锁和递归锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0TCP%E5%B9%B6%E5%8F%91"><span class="nav-number">4.9.</span> <span class="nav-text">多线程实现TCP并发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GIL%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81"><span class="nav-number">5.</span> <span class="nav-text">GIL全局解释器锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-1"><span class="nav-number">5.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GIL%E4%B8%8ELock"><span class="nav-number">5.2.</span> <span class="nav-text">GIL与Lock</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GIL%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">5.3.</span> <span class="nav-text">GIL与多线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95"><span class="nav-number">5.4.</span> <span class="nav-text">多线程性能测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">6.</span> <span class="nav-text">进程池与线程池</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E6%B1%A0"><span class="nav-number">6.1.</span> <span class="nav-text">进程池</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="nav-number">6.2.</span> <span class="nav-text">线程池</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8D%8F%E7%A8%8B"><span class="nav-number">7.</span> <span class="nav-text">协程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D-2"><span class="nav-number">7.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gevent%E6%A8%A1%E5%9D%97"><span class="nav-number">7.2.</span> <span class="nav-text">Gevent模块</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E6%A8%A1%E5%9E%8B"><span class="nav-number">8.</span> <span class="nav-text">IO模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">8.1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9B%9B%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%E7%AE%80%E4%BB%8B"><span class="nav-number">8.2.</span> <span class="nav-text">四种IO模型简介</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%98%BB%E5%A1%9EIO"><span class="nav-number">8.2.1.</span> <span class="nav-text">阻塞IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9EIO"><span class="nav-number">8.2.2.</span> <span class="nav-text">非阻塞IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8IO"><span class="nav-number">8.2.3.</span> <span class="nav-text">多路复用IO</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%82%E6%AD%A5IO"><span class="nav-number">8.2.4.</span> <span class="nav-text">异步IO</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="klcc"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">klcc</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">121</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">21</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">27</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="reading-progress-bar"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://klcc.cc/59b85335.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="klcc">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="klcc">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          python-并发编程
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
  
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2021-12-16 08:31:30" itemprop="dateCreated datePublished" datetime="2021-12-16T08:31:30+08:00">2021-12-16</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2022-01-18 15:21:51" itemprop="dateModified" datetime="2022-01-18T15:21:51+08:00">2022-01-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>34k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>31 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <h2 id="操作系统相关"><a href="#操作系统相关" class="headerlink" title="操作系统相关"></a>操作系统相关</h2><blockquote>
<p>操作系统就是一个协调、管理和控制计算机硬件资源和软件资源的控制程序</p>
</blockquote>
<span id="more"></span>
<h3 id="多道技术"><a href="#多道技术" class="headerlink" title="多道技术"></a>多道技术</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">一 操作系统的作用：</span><br><span class="line">    <span class="number">1</span>：隐藏丑陋复杂的硬件接口，提供良好的抽象接口</span><br><span class="line">    <span class="number">2</span>：管理、调度进程，并且将多个进程对硬件的竞争变得有序</span><br><span class="line"></span><br><span class="line">二 多道技术：</span><br><span class="line">    <span class="number">1.</span>产生背景：针对单核，实现并发</span><br><span class="line">    ps：</span><br><span class="line">    现在的主机一般是多核，那么每个核都会利用多道技术</span><br><span class="line">    有<span class="number">4</span>个cpu，运行于cpu1的某个程序遇到io阻塞，会等到io结束再重新调度，会被调度到<span class="number">4</span>个</span><br><span class="line">    cpu中的任意一个，具体由操作系统调度算法决定。</span><br><span class="line"></span><br><span class="line">    <span class="number">2.</span>空间上的复用：如内存中同时有多道程序</span><br><span class="line">    <span class="number">3.</span>时间上的复用：复用一个cpu的时间片</span><br><span class="line">    </span><br><span class="line">强调：CPU遇到I/O切，占用CPU时间过长也切，核心在于切之前将进程的状态保存下来，这样</span><br><span class="line">     才能保证下次切换回来时，能基于上次切走的位置继续运行</span><br></pre></td></tr></table></figure>

<h3 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h3><ul>
<li>进程:程序运行的过程，是一个动态的概念</li>
<li>程序:是一系列的代码文件，是一个静态的概念</li>
</ul>
<h3 id="并发、并行和串行"><a href="#并发、并行和串行" class="headerlink" title="并发、并行和串行"></a>并发、并行和串行</h3><ul>
<li>并发:是伪并行，多个任务看起来同时运行，单个CPU+多道技术就可以实现并发(并行也属于并发)</li>
<li>并行:多个任务真正意义上的同时运行，只有具备多个CPU才能实现并行</li>
<li>串行:一个任务运行完毕后才能开启下一个任务</li>
</ul>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/9Ihf9e.jpg" alt="9Ihf9e"></p>
<h3 id="提交任务的两种方式"><a href="#提交任务的两种方式" class="headerlink" title="提交任务的两种方式"></a>提交任务的两种方式</h3><ul>
<li><p>同步:发出一个功能调用时，在没有得到结果之前，该调用就不会返回</p>
</li>
<li><p>异步:当一个异步功能调用发出之后,调用者不能立刻得到结果，当该异步功能完成后，通过状态、通知或回调来通知调用者</p>
</li>
</ul>
<h3 id="一个任务运行的三种状态"><a href="#一个任务运行的三种状态" class="headerlink" title="一个任务运行的三种状态"></a>一个任务运行的三种状态</h3><ul>
<li><p>运行态:当前进程正在被CPU执行</p>
</li>
<li><p>阻塞态:正在执行的进程，由于等待某个事件而无法执行时，如遇到I/O</p>
</li>
<li><p>就绪态:当前进程没有被CPU执行</p>
</li>
</ul>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/RqtvS8.jpg" alt="RqtvS8"></p>
<h2 id="multiprocessing模块"><a href="#multiprocessing模块" class="headerlink" title="multiprocessing模块"></a>multiprocessing模块</h2><p>python中的多线程无法利用多核优势(<code>os.cpu_count()</code>查看)，在python大部分情况使用多进程，python提供了multipprocessing模块</p>
<p>multiprocess模块功能众多，支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件</p>
<p>与线程不同，进程没有任何共享状态，进程修改的数据，改动仅限于该进程内</p>
<h3 id="Process类"><a href="#Process类" class="headerlink" title="Process类"></a>Process类</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><h5 id="创建进程的类"><a href="#创建进程的类" class="headerlink" title="创建进程的类"></a>创建进程的类</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 由改类实例化的对象，表示一个子进程中的任务，还没有启动</span></span><br><span class="line">Process([group [,target [, name [, args [, kwargs]]]]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 需要使用关键字的方式来指定参数</span></span><br><span class="line"><span class="comment"># 2. args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号</span></span><br></pre></td></tr></table></figure>

<h5 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">group  参数未使用，值始终为<span class="literal">None</span></span><br><span class="line"></span><br><span class="line">target  表示调用对象，即子进程要执行的任务</span><br><span class="line"></span><br><span class="line">agrs  表示调用对象位置参数，是一个元组，agrs=(<span class="number">1</span>,)</span><br><span class="line"></span><br><span class="line">kwargs  表示调用对象的字典，kwargs=&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">name  表示子进程的名称</span><br></pre></td></tr></table></figure>

<h5 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">p.start()  启动进程</span><br><span class="line">  </span><br><span class="line">p.run()  进程启动时的运行方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法 </span><br><span class="line"></span><br><span class="line">p.terminate()  强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，</span><br><span class="line">    		  使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁</span><br><span class="line"></span><br><span class="line">p.is_alive()  判断是否运行，值为<span class="literal">True</span>或<span class="literal">False</span></span><br><span class="line"></span><br><span class="line">p.join([timeout])  主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是</span><br><span class="line">      可选的 超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程</span><br></pre></td></tr></table></figure>

<h5 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">p.daemon  默认值为<span class="literal">False</span>，如果设为<span class="literal">True</span>，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且此时					p不能创建自己的新进程，必须在p.start()之前设置</span><br><span class="line"></span><br><span class="line">p.name  进程名称</span><br><span class="line"></span><br><span class="line">p.pid  进程的pid</span><br><span class="line"></span><br><span class="line">p.exitcode  进程在运行时为<span class="literal">None</span>、如果为–N，表示被信号N结束</span><br><span class="line"></span><br><span class="line">p.authkey  进程的身份验证键,默认是由os.urandom()随机生成的<span class="number">32</span>字符的字符串。这个键的用途是为涉及网络连接的        底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><blockquote>
<p>在Windows中<code>Process()</code>必须放到<code>if name == &#39;main&#39;:</code>下</p>
</blockquote>
<h5 id="开启进程方式一"><a href="#开启进程方式一" class="headerlink" title="开启进程方式一"></a>开启进程方式一</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程: %s , 自己进程 %s 正在运行&#x27;</span> % (os.getppid(), os.getpid()))</span><br><span class="line">    time.sleep(n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程: %s , 自己进程 %s 正在运行&#x27;</span> % (os.getppid(), os.getpid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target=task, args=(<span class="number">3</span>,))</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主进程 %s &#x27;</span> % os.getpid())</span><br></pre></td></tr></table></figure>

<h5 id="开启进程方式二"><a href="#开启进程方式二" class="headerlink" title="开启进程方式二"></a>开启进程方式二</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span>(<span class="params">Process</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;父进程 %s , 自己 %s 正在运行&#x27;</span> % (os.getppid(), os.getpid()))</span><br><span class="line">        time.sleep(self.n)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;父进程 %s , 自己 %s 正在运行&#x27;</span> % (os.getppid(), os.getpid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = MyProcess(<span class="number">3</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主进程 %s &#x27;</span> % os.getpid())</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>os.getpid()</code>获取当前进程pid</p>
<p><code>os.getppid()</code>获取当前进程的父进程pid</p>
</blockquote>
<h5 id="进程之间的内存空间是隔离的"><a href="#进程之间的内存空间是隔离的" class="headerlink" title="进程之间的内存空间是隔离的"></a>进程之间的内存空间是隔离的</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">count = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;自己&#x27;</span>, count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target=task)</span><br><span class="line">    p.start()</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主 %s&#x27;</span> % count)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 100</span></span><br></pre></td></tr></table></figure>

<h5 id="进程对象的方法"><a href="#进程对象的方法" class="headerlink" title="进程对象的方法"></a>进程对象的方法</h5><ul>
<li><p><code>join() </code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span>(<span class="params">Process</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 正在运行, 进程号是 %s&#x27;</span> % (self.name, os.getpid()))</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 运行结束, 进程号是 %s &#x27;</span> % (self.name, os.getpid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = MyProcess(<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()  <span class="comment"># 保证子进程结束后才会向下执行，当前主线程处于等的状态，而p是处于运行的状态</span></span><br><span class="line">    <span class="comment"># p.join(2)  # 指定等待p子进程的时间，如果子进程p运行完直接往下执行，如果等了2s之后还没执行完也会向下执行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始 主进程 %s &#x27;</span> % os.getpid())</span><br></pre></td></tr></table></figure>

<p>该方法并不是串行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span>(<span class="params">Process</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 正在运行, 进程号是 %s&#x27;</span> % (self.name, os.getpid()))</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 运行结束, 进程号是 %s &#x27;</span> % (self.name, os.getpid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p1 = MyProcess(<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">    p2 = MyProcess(<span class="string">&#x27;p2&#x27;</span>)</span><br><span class="line">    p3 = MyProcess(<span class="string">&#x27;p3&#x27;</span>)</span><br><span class="line">    p4 = MyProcess(<span class="string">&#x27;p4&#x27;</span>)</span><br><span class="line">    p5 = MyProcess(<span class="string">&#x27;p5&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这几个进程是差不多一起一起的,并不是启动一个执行完之后再运行第二个进程,是让主进程等,而不是让后面的子进程等</span></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    p4.start()</span><br><span class="line">    p5.start()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># p_list = [p1, p2, p3, p4, p5]</span></span><br><span class="line">    <span class="comment"># for p in p_list:</span></span><br><span class="line">    <span class="comment">#     p.start()</span></span><br><span class="line">		</span><br><span class="line">    <span class="comment"># 但是当 p1 执行完成后确实要等后面的 p2-p5 进程执行完成后才能继续往后</span></span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    p3.join()</span><br><span class="line">    p4.join()</span><br><span class="line">    p5.join()</span><br><span class="line">    </span><br><span class="line">		<span class="comment">#for p in p_list:</span></span><br><span class="line">    <span class="comment">#    p.join()</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主进程 %s &#x27;</span> % os.getpid())</span><br></pre></td></tr></table></figure></li>
<li><p><code>terminate()和is_alive()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is run, task is %s &#x27;</span> % (name, os.getppid()))</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is end,task is %s &#x27;</span> % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target=task, args=(<span class="string">&#x27;test&#x27;</span>,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.terminate()  <span class="comment"># 关闭进程，不会立即关闭</span></span><br><span class="line">    <span class="built_in">print</span>(p.is_alive())  <span class="comment"># 所以此时查看进程是否存活时为True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main is start &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(p.is_alive())  <span class="comment"># 子进程已经关闭了，此时为False</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>name和pid</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span>(<span class="params">Process</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># self.name=name</span></span><br><span class="line">        <span class="comment"># super().__init__() #Process的__init__方法会执行self.name=Piao-1,</span></span><br><span class="line">        <span class="comment">#                    #所以加到这里,会覆盖我们的self.name=name</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#为我们开启的进程设置名字的做法</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is run&#x27;</span> % self.name)</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is end&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = MyProcess(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main is run&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(p.pid)  <span class="comment"># 查看pid</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="进程相关-1"><a href="#进程相关-1" class="headerlink" title="进程相关"></a>进程相关</h2><blockquote>
<p>参考: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/Anker/p/3271773.html">https://www.cnblogs.com/Anker/p/3271773.html</a></p>
</blockquote>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程</span><br><span class="line">僵尸进程虽然不会占用内存CPU等系统资源，但是PID号如果过多之后，操作系统也无法创建新PID号</span><br></pre></td></tr></table></figure>

<ul>
<li><p>产生僵尸进程</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子&#x27;</span>, os.getpid())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target=run)</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主&#x27;</span>, os.getpid())</span><br><span class="line">    time.sleep(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>查看僵尸进程<br><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/sfHAIh.png" alt="sfHAIh"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep Z  <span class="comment"># SATA 显示 Z 就是僵尸进程</span></span><br></pre></td></tr></table></figure></li>
<li><p>解决办法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 杀死父进程  </span><br><span class="line">			kill -CHLD 父进程的pid  </span><br><span class="line">  		kill -<span class="number">9</span> 父进程的pid</span><br><span class="line"><span class="number">2.</span> 对开启的子进程应该记得使用join，join会回收僵尸进程</span><br><span class="line"><span class="number">3.</span> https://blog.csdn.net/u010571844/article/details/<span class="number">50419798</span></span><br></pre></td></tr></table></figure></li>
<li><p>问题</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time,os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is running&#x27;</span> %os.getpid())</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p=Process(target=task)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join() <span class="comment"># 等待进程p结束后，join函数内部会发送系统调用wait，去告诉操作系统回收掉进程p的id号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(p.pid) <span class="comment">#？？？此时能否看到子进程p的id号</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># p.join()是像操作系统发送请求，告知操作系统p的id号不需要再占用了，回收就可以，</span></span><br><span class="line"><span class="comment"># 此时在父进程内还可以看到p.pid,但此时的p.pid是一个无意义的id号，因为操作系统已经将该编号回收</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程，由于进程不可能脱离进程树而独立存在，孤儿进程将被PID为<span class="number">1</span>的init进程所收养，并由init进程对它们完成状态收集工作。孤儿进程被收养后进行正常的释放，没有危害</span><br></pre></td></tr></table></figure>

<ul>
<li><p>演示代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子&#x27;</span>, os.getpid())</span><br><span class="line">    time.sleep(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p1 = Process(target=run)</span><br><span class="line">    p2 = Process(target=run)</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主&#x27;</span>, os.getpid())</span><br></pre></td></tr></table></figure></li>
<li><p>现象</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20211216191021094.png" alt="image-20211216191021094"></p>
<p>两个子进程并没有退出，此时两个子进程的父进程由 1 接管，当时间久了之后会被释放掉</p>
</li>
</ul>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>主进程创建守护进程</p>
<ol>
<li>守护进程会在主进程代码执行结束后就终止</li>
<li>守护进程内无法再开启子进程，否则抛出异常: AssertionError: daemonic processes are not allowed to have children</li>
</ol>
<p>注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止</p>
<ul>
<li><p>实例代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span>(<span class="params">Process</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is run&#x27;</span> % self.name)</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is end &#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = MyProcess(<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">p1.daemon = <span class="literal">True</span>  <span class="comment"># 一定要在p.start()前设置,设置p为守护进程,禁止p创建子进程,并且父进程代码执行结束,p即终止运行</span></span><br><span class="line"></span><br><span class="line">p1.start()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;main is run&#x27;</span>, os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：main is run 可以看到子线程没有执行 </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><blockquote>
<p>进程之间数据不共享,但是共享同一套文件系统,所以访问同一个文件,或同一个打印终端,是没有问题的</p>
<p>而共享带来的是竞争，竞争带来的结果就是错乱，如何控制，就是加锁处理</p>
</blockquote>
<h4 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h4><p> 没加锁的情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os, time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is run &#x27;</span> % os.getpid())</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is end &#x27;</span> % os.getpid())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        p = Process(target=work)</span><br><span class="line">        p.start()</span><br><span class="line"><span class="comment"># 并发运行,效率高,但竞争同一打印终端,带来了打印错乱</span></span><br></pre></td></tr></table></figure>



<p>加锁之后的情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#由并发变成了串行,牺牲了运行效率,但避免了竞争</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Lock</span><br><span class="line"><span class="keyword">import</span> os, time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">lock</span>):</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is run &#x27;</span> % os.getpid())</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is end &#x27;</span> % os.getpid())</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lock = Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        p = Process(target=work, args=(lock,))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>



<h4 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h4><p>文件当数据库,模拟抢票</p>
<p>不加锁的情况</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 并发运行，效率高，但是在竞争一个文件，数据写入错乱</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>():</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;db.json&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        dic = json.load(f)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\033[43m剩余票数%s\033[0m&#x27;</span> % dic[<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>():</span></span><br><span class="line">    dic = json.load(<span class="built_in">open</span>(<span class="string">&#x27;db.json&#x27;</span>))</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">if</span> dic[<span class="string">&#x27;count&#x27;</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        dic[<span class="string">&#x27;count&#x27;</span>] -= <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        json.dump(dic, <span class="built_in">open</span>(<span class="string">&#x27;db.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\033[43m购票成功\033[0m&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">lock</span>):</span></span><br><span class="line">    search()</span><br><span class="line">    get()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lock = Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        p = Process(target=task, args=(lock,))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<p>加锁之后</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查票还是并发，但是在购票的时候由并发变成了串行，牺牲了运行效率，但保证了数据安全</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>():</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;db.json&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        dic = json.load(f)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\033[43m剩余票数%s\033[0m&#x27;</span> % dic[<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>():</span></span><br><span class="line">    dic = json.load(<span class="built_in">open</span>(<span class="string">&#x27;db.json&#x27;</span>))</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">if</span> dic[<span class="string">&#x27;count&#x27;</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        dic[<span class="string">&#x27;count&#x27;</span>] -= <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        json.dump(dic, <span class="built_in">open</span>(<span class="string">&#x27;db.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\033[43m购票成功\033[0m&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;没票了&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">lock</span>):</span></span><br><span class="line">    search()</span><br><span class="line">    lock.acquire()</span><br><span class="line">    get()</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lock = Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        p = Process(target=task, args=(lock,))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。</span></span><br><span class="line">虽然可以用文件共享数据实现进程间通信，但问题是：</span><br><span class="line"><span class="number">1.</span>效率低（共享数据基于文件，而文件是硬盘上的数据）</span><br><span class="line"><span class="number">2.</span>需要自己加锁处理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#因此我们最好找寻一种解决方案能够兼顾：1、效率高（多个进程共享一块内存的数据）2、帮我们处理好锁问题。这就是mutiprocessing模块为我们提供的基于消息的IPC通信机制：队列和管道。</span></span><br><span class="line"><span class="number">1</span> 队列和管道都是将数据存放于内存中</span><br><span class="line"><span class="number">2</span> 队列又是基于（管道+锁）实现的，可以让我们从复杂的锁问题中解脱出来，</span><br><span class="line">我们应该尽量避免使用共享数据，尽可能使用消息传递和队列，避免处理复杂的同步和锁问题，而且在进程数目增多时，往往可以获得更好的可获展性。</span><br></pre></td></tr></table></figure>

<h3 id="IPC机制"><a href="#IPC机制" class="headerlink" title="IPC机制"></a>IPC机制</h3><p>进程彼此之间互相隔离，要实现进程之间通信（IPC），multiprocessing模块支持两种形式：队列和管道，这两种方式都是使用消息传递的</p>
<ul>
<li><p>管道</p>
<p>ps -ef |grep xx  前面的进程产生的数据交给后面的进程</p>
</li>
</ul>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><blockquote>
<p>底层就是以管道和锁定的方式实现</p>
</blockquote>
<p>创建队列的类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Queue([maxsize]):创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递</span><br><span class="line">maxsize是队列中允许最大项数，省略则无大小限制</span><br></pre></td></tr></table></figure>

<p>主要方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">q.put方法用以插入数据到队列中，put方法还有两个可选参数：blocked和timeout。blocked为<span class="literal">True</span>（默认值）如果</span><br><span class="line">队列满了就锁住了并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。如果超时，会</span><br><span class="line">抛出Queue.Full异常。如果blocked为<span class="literal">False</span>，但该Queue已满，会立即抛出Queue.Full异常。</span><br><span class="line"></span><br><span class="line">q.get方法可以从队列读取并且删除一个元素。同样，get方法有两个可选参数：blocked和timeout。如果blocked</span><br><span class="line">为<span class="literal">True</span>（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。如果</span><br><span class="line">blocked为<span class="literal">False</span>有两种情况存在，如果Queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出</span><br><span class="line">Queue.Empty异常.</span><br><span class="line"></span><br><span class="line">q.get_nowait():同q.get(<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">q.put_nowait():同q.put(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">q.empty():调用此方法时q为空则返回<span class="literal">True</span>，该结果不可靠，比如在返回<span class="literal">True</span>的过程中，如果队列中又加入了项目。</span><br><span class="line">    </span><br><span class="line">q.full()：调用此方法时q已满则返回<span class="literal">True</span>，该结果不可靠，比如在返回<span class="literal">True</span>的过程中，如果队列中的项目被取走。</span><br><span class="line"></span><br><span class="line">q.qsize():返回队列中目前项目的正确数量，结果也不可靠，理由同q.empty()和q.full()一样</span><br></pre></td></tr></table></figure>

<p>其他方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">q.cancel_join_thread():不会在进程退出时自动连接后台线程。可以防止join_thread()方法阻塞</span><br><span class="line">    </span><br><span class="line">q.close():关闭队列，防止队列中加入更多数据。调用此方法，后台线程将继续写入那些已经入队列但尚未写入的</span><br><span class="line">          数据，但将在此方法完成时马上关闭。如果q被垃圾收集，将调用此方法。关闭队列不会在队列使用者中</span><br><span class="line">          产生任何类型的数据结束信号或异常。例如，如果某个使用者正在被阻塞在get()操作上，关闭生产者中</span><br><span class="line">          的队列不会导致get()方法返回错误。</span><br><span class="line">        </span><br><span class="line">q.join_thread()：连接队列的后台线程。此方法用于在调用q.close()方法之后，等待所有队列项被消耗。默认</span><br><span class="line">                 情况下，此方法由不是q的原始创建者的所有进程调用。调用q.cancel_join_thread方法可</span><br><span class="line">                 以禁 止这种行为</span><br></pre></td></tr></table></figure>

<p>应用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">q = Queue(<span class="number">3</span>)  <span class="comment"># 创建共享的进程队列，指定队列长度为3，最多放三个值，超过3个无法放入</span></span><br><span class="line">q.put(<span class="number">1</span>)</span><br><span class="line">q.put(<span class="number">2</span>)</span><br><span class="line">q.put(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(q.full())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"><span class="built_in">print</span>(q.empty())</span><br><span class="line"><span class="comment"># print(q.get())  # 超值取不到q.get()默认为 q.get(block=True,timeout=None)</span></span><br><span class="line"><span class="comment"># print(q.get(block=True,timeout=3)) # 取不到三秒抛出异常</span></span><br><span class="line"><span class="built_in">print</span>(q.get(block=<span class="literal">False</span>))  <span class="comment"># 取不到值立马抛异常</span></span><br></pre></td></tr></table></figure>

<h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><blockquote>
<p>在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度</p>
</blockquote>
<ul>
<li><p>为什么要使用生产者和消费者模式</p>
<ul>
<li>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式</li>
</ul>
</li>
<li><p>什么是生产者消费者模式</p>
<ul>
<li>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力</li>
</ul>
</li>
<li><p>总结</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#程序中有两类角色</span></span><br><span class="line">    一类负责生产数据（生产者）</span><br><span class="line">    一类负责处理数据（消费者）</span><br><span class="line">    </span><br><span class="line"><span class="comment">#引入生产者消费者模型为了解决的问题是</span></span><br><span class="line">    平衡生产者与消费者之间的工作能力，从而提高程序整体处理数据的速度</span><br><span class="line">    </span><br><span class="line"><span class="comment">#如何实现</span></span><br><span class="line">    生产者&lt;--&gt;队列&lt;——&gt;消费者</span><br><span class="line"><span class="comment">#生产者消费者模型实现类程序的解耦和</span></span><br></pre></td></tr></table></figure>

<p>基于队列实现生产者消费者模型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> time, os, random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">q, name, courier</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        res = <span class="string">&#x27;%s  %s &#x27;</span> % (courier, i)</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        q.put(res)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 送来 %s &#x27;</span> % (name, res))</span><br><span class="line">    q.put(<span class="literal">None</span>)  <span class="comment"># 结束之后发送None信息到队里里面，有几个消费者就发几个None</span></span><br><span class="line">    q.put(<span class="literal">None</span>) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">q, name</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = q.get()</span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 拿到了 %s&#x27;</span> % (name, res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line"></span><br><span class="line">    p1 = Process(target=producer, args=(q, <span class="string">&#x27;快递员1&#x27;</span>, <span class="string">&#x27;sf&#x27;</span>))</span><br><span class="line">    p2 = Process(target=producer, args=(q, <span class="string">&#x27;快递员2&#x27;</span>, <span class="string">&#x27;yz&#x27;</span>))</span><br><span class="line">    p3 = Process(target=producer, args=(q, <span class="string">&#x27;快递员3&#x27;</span>, <span class="string">&#x27;jd&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    c1 = Process(target=consumer, args=(q, <span class="string">&#x27;拿货人1&#x27;</span>))</span><br><span class="line">    c2 = Process(target=consumer, args=(q, <span class="string">&#x27;拿货人2&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line"></span><br><span class="line">    c1.start()</span><br><span class="line">    c2.start()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is run &#x27;</span> % os.getpid())</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>JoinableQueue([maxsize])`</strong></p>
<blockquote>
<p>这就像是一个Queue对象，但队列允许项目的使用者通知生成者项目已经被成功处理。通知进程是使用共享的信号和条件变量来实现的。</p>
</blockquote>
<p>  介绍</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#参数介绍：</span></span><br><span class="line">   maxsize是队列中允许最大项数，省略则无大小限制。    </span><br><span class="line">  　 <span class="comment">#方法介绍：</span></span><br><span class="line">  JoinableQueue的实例p除了与Queue对象相同的方法之外还具有：</span><br><span class="line">  q.task_done()：使用者使用此方法发出信号，表示q.get()的返回项目已经被处理。如果调用此方法的次数大于从队列中删除项目的数量，将引发ValueError异常</span><br><span class="line">  q.join():生产者调用此方法进行阻塞，直到队列中所有的项目均被处理。阻塞将持续到队列中的每个项目均调用q.task_done（）方法为止</span><br></pre></td></tr></table></figure>

<p>优化上面队列代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, JoinableQueue</span><br><span class="line"><span class="keyword">import</span> time, os, random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">q, name, courier</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        res = <span class="string">&#x27;%s  %s &#x27;</span> % (courier, i)</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        q.put(res)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 送来 %s &#x27;</span> % (name, res))</span><br><span class="line">    q.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">q, name</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = q.get()</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 拿到了 %s&#x27;</span> % (name, res))</span><br><span class="line">        q.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = JoinableQueue()</span><br><span class="line"></span><br><span class="line">    p1 = Process(target=producer, args=(q, <span class="string">&#x27;快递员1&#x27;</span>, <span class="string">&#x27;sf&#x27;</span>))</span><br><span class="line">    p2 = Process(target=producer, args=(q, <span class="string">&#x27;快递员2&#x27;</span>, <span class="string">&#x27;yz&#x27;</span>))</span><br><span class="line">    p3 = Process(target=producer, args=(q, <span class="string">&#x27;快递员3&#x27;</span>, <span class="string">&#x27;jd&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    c1 = Process(target=consumer, args=(q, <span class="string">&#x27;拿货人1&#x27;</span>))</span><br><span class="line">    c2 = Process(target=consumer, args=(q, <span class="string">&#x27;拿货人2&#x27;</span>))</span><br><span class="line">    c1.daemon = <span class="literal">True</span>  <span class="comment"># 主进程结束顺便带走了守护进程</span></span><br><span class="line">    c2.daemon = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    p_l = [p1, p2, p3, c1, c2]</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> p_l:</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    p3.join()  <span class="comment"># p1、p2、p3都结束，代表队列一定被取空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is run &#x27;</span> % os.getpid())</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#主进程等---&gt;p1,p2,p3等----&gt;c1,c2</span></span><br><span class="line"><span class="comment">#p1,p2,p3结束了,证明c1,c2肯定全都收完了p1,p2,p3发到队列的数据</span></span><br><span class="line"><span class="comment">#因而c1,c2也没有存在的价值了,应该随着主进程的结束而结束,所以设置成守护进程</span></span><br></pre></td></tr></table></figure>

<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><blockquote>
<p>互斥锁 同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据 ，比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去，如果指定信号量为3，那么来一个人获得一把锁，计数加1，当计数等于3时，后面的人均需要等待。一旦释放，就有人可以获得一把锁</p>
<p>信号量与进程池的概念很像，但是要区分开，信号量涉及到加锁的概念</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Semaphore</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">go_wc</span>(<span class="params">sem, user</span>):</span></span><br><span class="line">    sem.acquire()  <span class="comment"># 运行的时候都会抢这把锁</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s 占到一个茅坑&#x27;</span> % user)</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">    sem.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sem = Semaphore(<span class="number">5</span>)  <span class="comment"># 创建信号量，自定义为5，相当于5把钥匙得到信号量对象</span></span><br><span class="line">    p_l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        p = Process(target=go_wc, args=(sem,<span class="string">&#x27;user%s&#x27;</span> % i,))</span><br><span class="line">        p.start()</span><br><span class="line">        p_l.append(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> p_l:</span><br><span class="line">        i.join()</span><br><span class="line">        </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">ps：互斥锁只能acquire一次，再有人来执行acquire，如果没有释放，下一个来拿的人就只能阻在原地无法拿到acquire。而信号量一把锁可以acquire指定5次（Semaphore(5)），如果第6个来在</span></span><br><span class="line"><span class="string">acquire的时候就没有了，相当于没有钥匙了，就只能在原地等着，只要5个人里面有人释放后面的人就</span></span><br><span class="line"><span class="string">可以拿到钥匙</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>     </span><br></pre></td></tr></table></figure>

<h2 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h2><p>线程是进程内代码运行的过程，线程是一个执行单位，CPU执行的就是线程。进程是一个资源单位</p>
<p>线程和进程的区别</p>
<ol>
<li>同一进程下的多个线程共享该进程的内存资源，线程之间可以互相通信</li>
<li>开启子线程的开销要远远小于开启子线程</li>
</ol>
<p><strong>线程相关的方法</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread实例对象的方法</span><br><span class="line">  <span class="comment"># isAlive(): 返回线程是否活动的。</span></span><br><span class="line">  <span class="comment"># getName(): 返回线程名。</span></span><br><span class="line">  <span class="comment"># setName(): 设置线程名。</span></span><br><span class="line"></span><br><span class="line">threading模块提供的一些方法：</span><br><span class="line">  <span class="comment"># threading.currentThread(): 返回当前的线程变量。</span></span><br><span class="line">  <span class="comment"># threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</span></span><br><span class="line">  <span class="comment"># threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</span></span><br></pre></td></tr></table></figure>



<h3 id="开启线程的两种方式"><a href="#开启线程的两种方式" class="headerlink" title="开启线程的两种方式"></a>开启线程的两种方式</h3><ul>
<li><p>方式一</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, current_thread</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is running &#x27;</span> % current_thread().name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = Thread(target=task)</span><br><span class="line">    t.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主线程&#x27;</span>, current_thread().name)</span><br></pre></td></tr></table></figure></li>
<li><p>方式二</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, current_thread</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="params">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is running &#x27;</span> % current_thread().name)  <span class="comment"># 打印当前线程名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = MyThread()</span><br><span class="line">    t.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主线程&#x27;</span>, current_thread().name)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/ggLKKR.jpg" alt="ggLKKR"></p>
<ul>
<li>线程之间数据相互影响</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, current_thread</span><br><span class="line">n = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = Thread(target=task)</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()  <span class="comment"># 让线程运行完成，避免有可能出现主线程先打印 n 的情况</span></span><br><span class="line">    <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>



<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><blockquote>
<p><strong>无论是进程还是线程，都遵循：守护xxx会等待主xxx运行完毕后被销毁</strong></p>
<p><strong>需要强调的是：运行完毕并非终止运行</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 对主进程来说，运行完毕指的是主进程代码运行完毕</span><br><span class="line">2. 对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才算运行完毕</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 主进程在其代码结束后就已经算运行完毕了（守护进程在此时就被回收）,然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源(否则会产生僵尸进程)，才会结束</span><br><span class="line">2. 主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束</span><br></pre></td></tr></table></figure>



<p>代码案例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, current_thread</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is running&#x27;</span> % current_thread().name)</span><br><span class="line">    time.sleep(n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is end&#x27;</span> % current_thread().name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = Thread(target=task, args=(<span class="number">2</span>,))</span><br><span class="line">    t2 = Thread(target=task, args=(<span class="number">3</span>,))</span><br><span class="line">    t3 = Thread(target=task, args=(<span class="number">300</span>,))</span><br><span class="line">    t3.daemon = <span class="literal">True</span>  <span class="comment"># t3最后的end并没有执行</span></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t3.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主&#x27;</span>)  <span class="comment"># 主线程要等子线程执行完后才结束</span></span><br></pre></td></tr></table></figure>

<h3 id="互斥锁-1"><a href="#互斥锁-1" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>现象: </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, current_thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">n = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    temp = n</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)  <span class="comment"># 线程速度太快了，如果不加sleep能减完，但是处理速度如果慢的情况下就会数据错乱</span></span><br><span class="line">    n = temp - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    thread_l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        t = Thread(target=task)</span><br><span class="line">        thread_l.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> thread_l:</span><br><span class="line">        obj.join()</span><br><span class="line">    <span class="built_in">print</span>(n)  <span class="comment"># 99</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>加锁</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, current_thread,Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">n = <span class="number">100</span></span><br><span class="line">mutex = Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    <span class="keyword">with</span> mutex:</span><br><span class="line">        temp = n</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        n = temp - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    thread_l = []</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        t = Thread(target=task)</span><br><span class="line">        thread_l.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> thread_l:</span><br><span class="line">        obj.join()</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;结果是 %s, 运行时间: %s &#x27;</span> % (n, end_time - start_time))  <span class="comment"># 结果是 0, 运行时间: 10.33482813835144 </span></span><br></pre></td></tr></table></figure>

<h3 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Semaphore</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    sm.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s get sm&#x27;</span> % threading.current_thread().getName())</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    sm.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sm = Semaphore(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">23</span>):</span><br><span class="line">        t = Thread(target=func)</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>

<h3 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h3><p>同进程的一样</p>
<p>线程的一个关键特性是每个线程都是独立运行且状态不可预测。如果程序中的其 他线程需要通过判断某个线程的状态来确定自己下一步的操作,这时线程同步问题就会变得非常棘手。为了解决这些问题,我们需要使用threading库中的Event对象。 对象包含一个可由线程设置的信号标志,它允许线程等待某些事件的发生。在 初始情况下,Event对象中的信号标志被设置为假。如果有线程等待一个Event对象, 而这个Event对象的标志为假,那么这个线程将会被一直阻塞直至该标志为真。一个线程如果将一个Event对象的信号标志设置为真,它将唤醒所有等待这个Event对象的线程。如果一个线程等待一个已经被设置为真的Event对象,那么它将忽略这个事件, 继续执行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">event.isSet()：返回event的状态值；</span><br><span class="line"></span><br><span class="line">event.wait()：如果 event.isSet()==<span class="literal">False</span>将阻塞线程；</span><br><span class="line"></span><br><span class="line">event.<span class="built_in">set</span>()： 设置event的状态值为<span class="literal">True</span>，所有阻塞池的线程激活进入就绪状态， 等待操作系统调度；</span><br><span class="line"></span><br><span class="line">event.clear()：恢复event的状态值为<span class="literal">False</span></span><br></pre></td></tr></table></figure>



<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/yFh1Wi.jpg" alt="yFh1Wi"></p>
<p><strong>案例代码一</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Event, Thread, current_thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">e = Event()  <span class="comment"># 全局变量为False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is running &#x27;</span> % current_thread().name)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    e.<span class="built_in">set</span>()  <span class="comment"># 全局变量为True</span></span><br><span class="line">    <span class="comment"># e.clear()  # 全局变量 = False</span></span><br><span class="line">    <span class="comment"># e.is_set()  # 判断是否set过</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">    e.wait()  <span class="comment"># 等全局变量变为True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is running &#x27;</span> % current_thread().name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = Thread(target=f1)</span><br><span class="line">    t2 = Thread(target=f2)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure>

<p><strong>模拟红绿灯</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Event, Thread, current_thread</span><br><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line">e = Event()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task1</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        e.clear()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;红灯亮了&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        e.<span class="built_in">set</span>()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;绿灯亮了&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task2</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> e.is_set():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;可以走了 %s&#x27;</span> % current_thread().name)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;正在等待 %s&#x27;</span> % current_thread().name)</span><br><span class="line">            e.wait()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    Thread(target=task1).start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">        Thread(target=task2).start()</span><br></pre></td></tr></table></figure>

<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><blockquote>
<p>定时器Timer类是Thread的派生类，用于在指定时间后调用一个方法。</p>
</blockquote>
<p>指定n秒后执行某操作</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>,n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = Timer(<span class="number">3</span>, hello, args=(<span class="number">1111</span>,))  <span class="comment"># 3秒之后执行</span></span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure>

<h3 id="线程queue"><a href="#线程queue" class="headerlink" title="线程queue"></a>线程queue</h3><blockquote>
<p>queue队列 ：使用import queue，用法与进程Queue一样</p>
<p>当信息必须在多个线程之间安全交换时，队列在线程编程中特别有用</p>
</blockquote>
<ul>
<li><p>基本方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">put 往线程队列里防止,超过队列长度,直接阻塞</span><br><span class="line">get 从队列中取值,如果获取不到,直接阻塞</span><br><span class="line">put_nowait: 如果放入的值超过队列长度,直接报错（linux）</span><br><span class="line">get_nowait: 如果获取的值已经没有了,直接报错</span><br></pre></td></tr></table></figure></li>
<li><p>用法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 队列：先进先出</span></span><br><span class="line">q = queue.Queue(<span class="number">3</span>) <span class="comment"># 指定队列的大小</span></span><br><span class="line">q.put(<span class="number">111</span>)  <span class="comment"># 整型</span></span><br><span class="line">q.put(<span class="string">&quot;aaa&quot;</span>) <span class="comment"># 字符串</span></span><br><span class="line">q.put((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)) <span class="comment"># 元组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">111</span></span><br><span class="line"><span class="string">aaa</span></span><br><span class="line"><span class="string">(1, 2, 3)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆栈：后进先出</span></span><br><span class="line">q = queue.LifoQueue(<span class="number">3</span>)</span><br><span class="line">q.put(<span class="number">111</span>)</span><br><span class="line">q.put(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">q.put((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(1, 2, 3)</span></span><br><span class="line"><span class="string">aaa</span></span><br><span class="line"><span class="string">111</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 优先级队列：</span></span><br><span class="line"><span class="comment"># 1.默认按照数字大小排序,然后会按照ascii编码在从小到大排序</span></span><br><span class="line"><span class="comment"># 2.先写先排,后写后排</span></span><br><span class="line">q = queue.PriorityQueue(<span class="number">3</span>)</span><br><span class="line">q.put((<span class="number">10</span>,<span class="number">111</span>))  <span class="comment"># 第一个值是优先级，第二值才是要放的元素</span></span><br><span class="line">q.put((<span class="number">11</span>,<span class="string">&quot;aaa&quot;</span>))</span><br><span class="line">q.put((-<span class="number">1</span>,(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(-1, (1, 2, 3))  # 数越小优先级越高</span></span><br><span class="line"><span class="string">(10, 111)</span></span><br><span class="line"><span class="string">(11, &#x27;aaa&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="死锁和递归锁"><a href="#死锁和递归锁" class="headerlink" title="死锁和递归锁"></a>死锁和递归锁</h3><blockquote>
<p>死锁是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程</p>
</blockquote>
<ul>
<li><p>代码演示</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">mutexA = Lock()</span><br><span class="line">mutexB = Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="params">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 抢到了A锁 &#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 抢到了B锁 &#x27;</span> % self.name)</span><br><span class="line">        mutexB.release()</span><br><span class="line"></span><br><span class="line">        mutexA.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">self</span>):</span></span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 抢到了B锁 &#x27;</span> % self.name)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 抢到了A锁 &#x27;</span> % self.name)</span><br><span class="line">        mutexA.release()</span><br><span class="line"></span><br><span class="line">        mutexB.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.f1()</span><br><span class="line">        self.f2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = MyThread(<span class="string">&#x27;线程1&#x27;</span>)</span><br><span class="line">    t2 = MyThread(<span class="string">&#x27;线程2&#x27;</span>)</span><br><span class="line">    t3 = MyThread(<span class="string">&#x27;线程3&#x27;</span>)</span><br><span class="line">    t4 = MyThread(<span class="string">&#x27;线程4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t3.start()</span><br><span class="line">    t4.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主线程&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 线程1 抢到了A锁 </span></span><br><span class="line"><span class="comment"># 线程1 抢到了B锁 </span></span><br><span class="line"><span class="comment"># 线程1 抢到了B锁 </span></span><br><span class="line"><span class="comment"># 线程2 抢到了A锁 </span></span><br><span class="line"><span class="comment"># 主线程</span></span><br><span class="line"><span class="comment"># 此时卡在这了</span></span><br></pre></td></tr></table></figure></li>
<li><p>解决方法</p>
<blockquote>
<p>递归锁，在Python中为了支持在同一线程中多次请求同一资源，python提供了可重入锁RLock</p>
<p> 这个RLock内部维护着一个Lock和一个计数（counter）变量，计数记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生死锁</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock, RLock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">mutexA = mutexB = RLock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="params">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 抢到了A锁 &#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 抢到了B锁 &#x27;</span> % self.name)</span><br><span class="line">        mutexB.release()</span><br><span class="line"></span><br><span class="line">        mutexA.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">self</span>):</span></span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 抢到了B锁 &#x27;</span> % self.name)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 抢到了A锁 &#x27;</span> % self.name)</span><br><span class="line">        mutexA.release()</span><br><span class="line"></span><br><span class="line">        mutexB.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.f1()</span><br><span class="line">        self.f2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = MyThread(<span class="string">&#x27;线程1&#x27;</span>)</span><br><span class="line">    t2 = MyThread(<span class="string">&#x27;线程2&#x27;</span>)</span><br><span class="line">    t3 = MyThread(<span class="string">&#x27;线程3&#x27;</span>)</span><br><span class="line">    t4 = MyThread(<span class="string">&#x27;线程4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t3.start()</span><br><span class="line">    t4.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主线程&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h3 id="多线程实现TCP并发"><a href="#多线程实现TCP并发" class="headerlink" title="多线程实现TCP并发"></a>多线程实现TCP并发</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">s = socket.socket()</span><br><span class="line">s.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">sock</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            res = sock.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(res) == <span class="number">0</span>: <span class="keyword">break</span></span><br><span class="line">            data = res.upper()</span><br><span class="line">            sock.send(data)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        sock.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    sock, address = s.accept()</span><br><span class="line">    <span class="built_in">print</span>(address)</span><br><span class="line">    t = Thread(target=task, args=(sock,))</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">c = socket.socket()</span><br><span class="line">c.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    cmd = <span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;&gt;:&#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(cmd) == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">    c.send(cmd.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    data = c.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="GIL全局解释器锁"><a href="#GIL全局解释器锁" class="headerlink" title="GIL全局解释器锁"></a>GIL全局解释器锁</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p><strong>GIL的全称是：Global Interpreter Lock,意思就是全局解释器锁</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">定义：</span><br><span class="line">In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple </span><br><span class="line">native threads from executing Python bytecodes at once. This lock is necessary mainly </span><br><span class="line">because CPython’s memory management is not thread-safe. (However, since the GIL </span><br><span class="line">exists, other features have grown to depend on the guarantees that it enforces.)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">结论：在Cpython解释器中，同一个进程下开启的多线程，同一时刻只能有一个线程执行，无法利用多核优势</span><br></pre></td></tr></table></figure>



<p>首先需要明确的一点是<code>GIL</code>并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念。就好比C++是一套语言（语法）标准，但是可以用不同的编译器来编译成可执行代码。有名的编译器例如GCC，INTEL C++，Visual C++等。Python也一样，同样一段代码可以通过CPython，PyPy，Psyco等不同的Python执行环境来执行。像其中的JPython就没有GIL。然而因为CPython是大部分环境下默认的Python执行环境。所以在很多人的概念里CPython就是Python，也就想当然的把<code>GIL</code>归结为Python语言的缺陷。所以这里要先明确一点：GIL并不是Python的特性，Python完全可以不依赖于GIL</p>
<p>GIL本质就是一把互斥锁，既然是互斥锁，所有互斥锁的本质都一样，都是将并发运行变成串行，以此来控制同一时间内共享数据只能被一个任务所修改，进而保证数据安全</p>
<p>综上：</p>
<p>如果多个线程的target=work，那么执行流程是</p>
<p>多个线程先访问到解释器的代码，即拿到执行权限，然后将target的代码交给解释器的代码去执行</p>
<p>解释器的代码是所有线程共享的，所以垃圾回收线程也可能访问到解释器的代码而去执行，这就导致了一个问题:对于同一个数据100，可能线程1执行x=100的同时，而垃圾回收执行的是回收100的操作，解决这种问题没有什么高明的方法，就是加锁处理，如下图的GIL，保证python解释器同一时间只能执行一个任务的代码</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/WK4tt1.jpg" alt="WK4tt1"></p>
<h3 id="GIL与Lock"><a href="#GIL与Lock" class="headerlink" title="GIL与Lock"></a>GIL与Lock</h3><p>只要在一个进程里就一定有GIL锁的存在，GIL锁不能保证python数据的安全，它保证的是解释器级别（内存管理）的安全，也可以说是背后存在的一种机制。可以肯定的一点是：保护不同的数据的安全，就应该加不同的锁。</p>
<p>GIL保护的是解释器级的数据，保护用户自己的数据则需要自己加锁处理，如下图：</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/dRjCYL.jpg" alt="dRjCYL"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">mutex = Lock()</span><br><span class="line">n = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line"></span><br><span class="line">    mutex.acquire()</span><br><span class="line">    temp = n</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    n = temp - <span class="number">1</span></span><br><span class="line">    mutex.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        t = Thread(target=task)</span><br><span class="line">        l.append(t)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> l:</span><br><span class="line">        obj.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(n)  <span class="comment"># 结果肯定为0，由原来的并发执行变成串行，牺牲了执行效率保证了数据安全</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">分析：</span></span><br><span class="line"><span class="string">1. 100个线程去抢GIL锁，即抢执行权限</span></span><br><span class="line"><span class="string">2. 肯定有一个线程先抢到GIL（暂且称为线程1），然后开始执行，一旦执行就会mutex.acquire()</span></span><br><span class="line"><span class="string">3. 极有可能线程1还未运行完毕，就有另外一个线程2抢到GIL，然后开始运行，但线程2发现互斥锁   	  lock还未被线程1释放，于是阻塞，被迫交出执行权限，即释放GIL</span></span><br><span class="line"><span class="string">4. 直到线程1重新抢到GIL，开始从上次暂停的位置继续执行，直到正常释放互斥锁lock，然后其他的</span></span><br><span class="line"><span class="string">   线程再重复2 3 4的过程</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="GIL与多线程"><a href="#GIL与多线程" class="headerlink" title="GIL与多线程"></a>GIL与多线程</h3><p>对计算来说，cpu越多越好，但是对于I/O来说，再多的cpu也没用</p>
<p>对运行一个程序来说，随着cpu的增多执行效率肯定会有所提高（不管提高幅度多大，总会有所提高），这是因为一个程序基本上不会是纯计算或者纯I/O，所以我们只能相对的去看一个程序到底是计算密集型还是I/O密集型，从而进一步分析python的多线程到底有无用武之地</p>
<p>场景：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">分析：</span><br><span class="line">我们有四个任务需要处理，处理方式肯定是要玩出并发的效果，解决方案可以是：</span><br><span class="line">方案一：开启四个进程</span><br><span class="line">方案二：一个进程下，开启四个线程</span><br><span class="line"></span><br><span class="line">单核情况下，分析结果: </span><br><span class="line">　　如果四个任务是计算密集型，没有多核来并行计算，方案一徒增了创建进程的开销，方案二胜</span><br><span class="line">　　如果四个任务是I/O密集型，方案一创建进程的开销大，且进程的切换速度远不如线程，方案二胜</span><br><span class="line"></span><br><span class="line">多核情况下，分析结果：</span><br><span class="line">　　如果四个任务是计算密集型，多核意味着并行计算，在python中一个进程中同一时刻只有一个线</span><br><span class="line">　　程执行用不上多核，方案一胜</span><br><span class="line">　　如果四个任务是I/O密集型，再多的核也解决不了I/O问题，方案二胜</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">结论：现在的计算机基本上都是多核，python对于计算密集型的任务开多线程的效率并不能带来多</span><br><span class="line">大性能上的提升，甚至不如串行(没有大量切换)，但是，对于IO密集型的任务效率还是有显著提升的。</span><br></pre></td></tr></table></figure>

<h3 id="多线程性能测试"><a href="#多线程性能测试" class="headerlink" title="多线程性能测试"></a>多线程性能测试</h3><ul>
<li><p>计算密集型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> os, time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span>():</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>):</span><br><span class="line">        res *= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    l = []</span><br><span class="line">    <span class="built_in">print</span>(os.cpu_count())  <span class="comment"># 查看cpu核数</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        p = Process(target=work)  <span class="comment"># 进程 7.7s多</span></span><br><span class="line">        <span class="comment"># p = Thread(target=work)  # 线程 28s多</span></span><br><span class="line">        l.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> l:</span><br><span class="line">        p.join()</span><br><span class="line">    stop_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;run time is %s &#x27;</span> % (stop_time - start_time))</span><br></pre></td></tr></table></figure></li>
<li><p>I/O密集型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> os, time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    l = []</span><br><span class="line">    <span class="comment"># print(os.cpu_count()) # 查看CPU核数</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        p=Process(target=work)  <span class="comment"># 使用进程</span></span><br><span class="line">        <span class="comment"># p = Thread(target=work)  # 使用线程比进程效率稍高</span></span><br><span class="line">        l.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> l:</span><br><span class="line">        p.join()</span><br><span class="line">    stop = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> % (stop - start))</span><br></pre></td></tr></table></figure></li>
<li><p>结论</p>
<p>多线程用于IO密集型，如socket，爬虫，web</p>
<p>多进程用于计算密集型，如金融分</p>
</li>
</ul>
<h2 id="进程池与线程池"><a href="#进程池与线程池" class="headerlink" title="进程池与线程池"></a>进程池与线程池</h2><p>​    在刚开始接触多进程或多线程时，我们迫不及待地基于多进程或多线程实现并发的套接字通信，然而这种实现方式的致命缺陷是：<strong>服务的开启的进程数或线程数都会随着并发的客户端数目地增多而增多，这会对服务端主机带来巨大的压力，甚至于不堪重负而瘫痪。</strong>于是我们必须对服务端开启的进程数或线程数加以控制，让机器在一个自己可以承受的范围内运行，这就是进程池或线程池的用途，例如进程池，就是用来存放进程的池子，本质还是基于多进程，只不过是对开启进程的数目加上了限制</p>
<ul>
<li><p>Python标准模块concurrent.futures</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、介绍</span></span><br><span class="line">concurrent.futures模块是用来创建并行的任务，提供了高度封装的异步调用接口</span><br><span class="line">concurent.future这个模块用起来非常方便，它的接口也封装的非常简单，既可以实现进程池，也可以实现线程池</span><br><span class="line">ThreadPoolExecutor：线程池，提供异步调用</span><br><span class="line">ProcessPoolExecutor: 进程池，提供异步调用</span><br><span class="line">两者都实现了同一个接口，这个接口是由抽象Executor类定义的。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、基本方法</span></span><br><span class="line">submit(fn, *args, **kwargs)</span><br><span class="line">异步提交任务</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>(func, *iterables, timeout=<span class="literal">None</span>, chunksize=<span class="number">1</span>) </span><br><span class="line">取代<span class="keyword">for</span>循环submit的操作</span><br><span class="line"></span><br><span class="line">shutdown(wait=<span class="literal">True</span>) </span><br><span class="line">相当于进程池的pool.close()+pool.join()操作</span><br><span class="line">wait=<span class="literal">True</span>，等待池内所有任务执行完毕回收完资源后才继续</span><br><span class="line">wait=<span class="literal">False</span>，立即返回，并不会等待池内的任务执行完毕</span><br><span class="line">但不管wait参数为何值，整个程序都会等到所有任务执行完毕</span><br><span class="line">submit和<span class="built_in">map</span>必须在shutdown之前</span><br><span class="line"></span><br><span class="line">result(timeout=<span class="literal">None</span>)</span><br><span class="line">取得结果</span><br><span class="line"></span><br><span class="line">add_done_callback(fn)</span><br><span class="line">回调函数</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># 介绍：</span></span><br><span class="line"><span class="string">ProcessPoolExecutor类是Executor的子类，它使用一个进程池来异步执行调用。ProcessPoolExecutor</span></span><br><span class="line"><span class="string">使用多处理模块，这允许它避免全局解释器锁，但也意味着只能执行和返回可pickle的对象。</span></span><br><span class="line"><span class="string">类concurrent.futures。ProcessPoolExecutor (max_workers = None, mp_context =没有)</span></span><br><span class="line"><span class="string">使用最多max_workers进程池异步执行调用的Executor子类。如果max_workers为None或未给出，则默认值为</span></span><br><span class="line"><span class="string">机器上的处理器数。如果max_workers小于或等于0，则会引发ValueError。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 用法：异步执行</span></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> current_thread</span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">n</span>):</span>  <span class="comment"># 定一个任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is runing&#x27;</span> %os.getpid()) <span class="comment"># 任务启动先打印任务的进程pid</span></span><br><span class="line">    <span class="comment"># I/O密集型的，一般用线程，用进程开销大耗时长</span></span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))  <span class="comment"># 随机睡1-3秒</span></span><br><span class="line">    <span class="keyword">return</span> n**<span class="number">2</span>   <span class="comment"># 返回值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">futrue</span>):</span> <span class="comment"># 处理任务的函数，拿到futrue对象</span></span><br><span class="line">    res = futrue.result() <span class="comment"># 拿到返回结果，一个任务运行完就会触发回调函数，所以不会阻塞</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s 正在处理结果：%s&quot;</span> %(os.getpid(),res))</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = ProcessPoolExecutor(max_workers=<span class="number">4</span>) <span class="comment"># 对于进程池如果不写max_works：默认的是cpu的数量是4个</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">19</span>):  <span class="comment"># 现在开了19个任务，如果是上百个任务，就不能无限开进程，就要考虑控制</span></span><br><span class="line">        pool.submit(task,i).add_done_callback(handle) <span class="comment"># 异步的方式提交任务</span></span><br><span class="line"></span><br><span class="line">    pool.shutdown(wait=<span class="literal">True</span>)  </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">解析:</span></span><br><span class="line"><span class="string">pool.submit(task,i)会返回一个futrue对象，这个任务对象可以调出add_done_callback()方法，</span></span><br><span class="line"><span class="string">叫回调函数，里面就一个参数handle，也就是说每提交一个任务捆绑一个函数，一旦一个任务运行完就会立</span></span><br><span class="line"><span class="string">马触发这个回调函数的运行,并且会自动的把任务对象当做第一个参数传给回调函数。</span></span><br><span class="line"><span class="string">在回调函数里处理任务，先拿到结果，一个任务运行完就会触发这个回调函数，所以不会阻塞在原地。打印</span></span><br><span class="line"><span class="string">一边在运行一边就会有人在处理结果，一边在运行着一边结果正在被处理，这个运行效率并不慢，一直都是</span></span><br><span class="line"><span class="string">主进程在处理任务，这就是回调函数的概念。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># 介绍：</span></span><br><span class="line"><span class="string">ThreadPoolExecutor是Executor的子类，它使用一个线程池来异步执行调用。</span></span><br><span class="line"><span class="string">类concurrent.futures。ThreadPoolExecutor (max_workers = None, thread_name_prefix = &quot;)</span></span><br><span class="line"><span class="string">一个Executor子类，使用最多max_workers线程池来异步执行调用。</span></span><br><span class="line"><span class="string">3.5版本的变化:如果max_workers没有或没有,它将默认为处理器的机器上,乘以5,假设ThreadPoolExecutor通常</span></span><br><span class="line"><span class="string">   用于重叠I / O而不是CPU工作和工人的数量应该为ProcessPoolExecutor高于工人的数量。</span></span><br><span class="line"><span class="string">3.6新版功能:添加了thread_name_prefix参数，允许用户控制线程。由池创建的工作线程的线程名，以便于调试。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 用法：</span></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> current_thread</span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is runing&#x27;</span> %current_thread().name)</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">return</span> n**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">futrue</span>):</span></span><br><span class="line">    res = futrue.result()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s 正在处理结果：%s&quot;</span> %(current_thread().name,res))</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=<span class="number">10</span>) <span class="comment"># 对于线程池如果不写max_works：默认的是cpu的数目*5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">19</span>): <span class="comment"># 同样是19个任务，线程池效率高了</span></span><br><span class="line">        pool.submit(task,i).add_done_callback(handle)</span><br><span class="line"></span><br><span class="line">    pool.shutdown(wait=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>​    协程是单线程下实现的并发,协程是一种用户态的轻量级线程，即协程是由用户程序自己控制调度的</p>
<p>​    对于单线程下，我们不可避免程序中出现io操作，但如果我们能在自己的程序中（即用户程序级别，而非操作系统级别）控制单线程下的多个任务能在一个任务遇到io阻塞时就切换到另外一个任务去计算，这样就保证了该线程能够最大限度地处于就绪态，即随时都可以被cpu执行的状态，相当于我们在用户程序级别将自己的io操作最大限度地隐藏起来，从而可以迷惑操作系统，让其看到：该线程好像是一直在计算，io比较少，从而更多的将cpu的执行权限分配给我们的线程。</p>
<p>​    python的线程属于内核级别的，即由操作系统控制调度（如单线程遇到io或执行时间过长就会被迫交出cpu执行权限，切换其他线程运行）</p>
<p>​    单线程内开启协程，一旦遇到io，就会从应用程序级别（而非操作系统）控制切换，以此来提升效率（！！！非io操作的切换与效率无关）</p>
<p>​    对比操作系统控制线程的切换，用户在单线程内控制协程的切换</p>
<ul>
<li><p>特点: 自己的应用程序实现多个人的调度</p>
<p>遇到I/O切换，可以将单线程的I/O降到最低，因此可以将单线程的威力发挥到最大</p>
</li>
<li><p>缺点: 不能实现并行</p>
<p>单线程下的多个任务一旦遇到I/O，整个线程都会阻塞，所有的任务都停滞</p>
</li>
<li><p>总结</p>
<ul>
<li>必须在只有一个单线程里实现并发</li>
<li>修改共享数据不需加锁</li>
<li>用户程序里自己保存多个控制流的上下文栈</li>
<li>附加：一个协程遇到IO操作自动切换到其它协程（如何实现检测IO，yield、greenlet都无法实现，就用到了gevent模块（select机制））**</li>
</ul>
<p><strong>yiled</strong>可以保存状态，<strong>yield</strong>的状态保存与操作系统的保存线程状态很像，但是<strong>yield是代码级别控制</strong>的，更轻量级send可以把一个函数的结果传给另外一个函数，以此实现<strong>单线程内程序之间的切换</strong></p>
</li>
</ul>
<h3 id="Gevent模块"><a href="#Gevent模块" class="headerlink" title="Gevent模块"></a>Gevent模块</h3><p>​        <strong>Gevent</strong>是一个第三方库，可以轻松通过gevent实现并发同步或异步编程，在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。</p>
<p>Gevent内部会用到greenlet这个模块，这个模块就是多个任务之间来回的切，切走之前把一个任务的状态保留下来，它们的底层都会用到yield，其实就是层层帮我们封装好了。greenlet内部会封装yield，Gevent就是对greenlet进行了进一步的封装，封装后greenlet会帮忙检测I/O，实现遇到I/O切换，这个才是我们所追求的协程</p>
<ul>
<li><p>使用方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">g1=gevent.spawn(func,<span class="number">1</span>,,<span class="number">2</span>,<span class="number">3</span>,x=<span class="number">4</span>,y=<span class="number">5</span>)创建一个协程对象g1，spawn括号内第一个参数是函数名，</span><br><span class="line">                如eat，后面可以有多个参数，可以是位置实参或关键字实参，都是传给函数eat的</span><br><span class="line"></span><br><span class="line">g2=gevent.spawn(func2)</span><br><span class="line"></span><br><span class="line">g1.join()  等待g1结束</span><br><span class="line"></span><br><span class="line">g2.join()  等待g2结束</span><br><span class="line"></span><br><span class="line">或者上述两步合作一步：gevent.joinall([g1,g2])</span><br><span class="line"></span><br><span class="line">g1.value<span class="comment">#拿到func1的返回值</span></span><br></pre></td></tr></table></figure>

<p>遇到IO阻塞时自动切换任务</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s eat 1&#x27;</span> %name) <span class="comment"># 1.吃了一口饭</span></span><br><span class="line">    gevent.sleep(<span class="number">2</span>)  <span class="comment"># 2.原地睡了2秒，相当于模拟遇到I/O了</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s eat 2&#x27;</span> %name) <span class="comment"># 6.接着打印又回来吃了一口饭</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s play 1&#x27;</span> %name)  <span class="comment"># 3.遇到I/O以后就切到了另外一个任务，玩了一下</span></span><br><span class="line">    gevent.sleep(<span class="number">1</span>)  <span class="comment"># 4.又遇到I/O了，睡了1秒，它先睡完</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s play 2&#x27;</span> %name) <span class="comment"># 5.接着又玩了一下，原本应该切到eat 2，但是仍在阻塞中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g1=gevent.spawn(eat,<span class="string">&#x27;egon&#x27;</span>) <span class="comment"># spawn提交eat任务，然后提交一个人名。协程1</span></span><br><span class="line">g2=gevent.spawn(play,name=<span class="string">&#x27;egon&#x27;</span>)<span class="comment"># spawn提交playt任务。协程2</span></span><br><span class="line">g1.join() <span class="comment"># 等着协程对象g1结束</span></span><br><span class="line">g2.join() <span class="comment"># 等着协程对象g2结束</span></span><br><span class="line"><span class="comment">#或者gevent.joinall([g1,g2])</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;主&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">上例gevent.sleep(2)模拟的是gevent可以识别的io阻塞,而time.sleep(2)或其他的阻塞,gevent是不能直接识别的需要用下面一行代码,打补丁,就可以识别了</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>打补丁</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">from gevent import monkey;monkey.patch_all()必须放到被打补丁者的前面，如time，socket模块之前或者我们干脆记忆成：要用gevent，需要将from gevent import monkey;monkey.patch_all()放到文件的开头</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey;monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;eat food 1&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;eat food 2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;play 1&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;play 2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">g1=gevent.spawn(eat)</span><br><span class="line">g2=gevent.spawn(play_phone)</span><br><span class="line">gevent.joinall([g1,g2])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;主&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">单线程下能抗住的并发已经非常非常高了，因为现在接触的软件大部分都是I/O密集型的</span></span><br><span class="line"><span class="string">其实单线程下完全可以一个任务运行完以后（它真正运行完花的时间是非常短的，大量时间都在做I/O）</span></span><br><span class="line"><span class="string">可以利用运行一段时间遇到I/O操作了就快速切换另一个任务再运行，在多任务之间快速的切</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>基于协程实现并发</p>
<p>  <strong>通过gevent实现单线程下的socket并发（from gevent import monkey;monkey.patch_all()一定要放到导入socket模块之前，否则gevent无法识别socket的阻塞）</strong></p>
<ul>
<li><p>服务端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先导了猴子补丁，打了补丁保证下面所有模块的I/O行为都能监测到</span></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey;monkey.patch_all() </span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *   <span class="comment"># 然后导了socket模块，准备写套接字</span></span><br><span class="line"><span class="keyword">import</span> gevent <span class="comment"># 最后导入gevent模块， 用来单线程下实现并发</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span>(<span class="params">server_ip,port</span>):</span> <span class="comment"># 套接字服务端任务1：建链接</span></span><br><span class="line">    s=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    s.setsockopt(SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>)</span><br><span class="line">    s.bind((server_ip,port)) <span class="comment"># 绑定ip和端口</span></span><br><span class="line">    s.listen(<span class="number">5</span>)  <span class="comment"># 监听</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn,addr=s.accept() <span class="comment"># 等待链接请求</span></span><br><span class="line">        <span class="comment"># 每建成一个链接，就提交一个协程对象进行通信，异步提交</span></span><br><span class="line">        gevent.spawn(talk,conn,addr) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">conn,addr</span>):</span>  <span class="comment"># 套接字服务端任务2：建通信</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            res=conn.recv(<span class="number">1024</span>) <span class="comment"># 收消息</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;client %s:%s msg: %s&#x27;</span> %(addr[<span class="number">0</span>],addr[<span class="number">1</span>],res))</span><br><span class="line">            conn.send(res.upper()) <span class="comment"># 回消息，大写回</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    server(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>) <span class="comment"># 把ip和端口传进去</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 注：没必要join在原地等了，因为服务端在启动运行起来后，服务端函数是一个死循环，</span></span><br><span class="line"><span class="comment"># 不会结束，既然主进程不会结束那就不用再等了</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">整体逻辑：就一个线程server，没有多线程也没有多进程，这个线程每建成一个链接就提交</span></span><br><span class="line"><span class="string">一个协程对象，gevent会帮你在多个任务之间遇到I/O来回快速的切换，从而实现并发效果</span></span><br><span class="line"><span class="string">如何证明并发的效果？</span></span><br><span class="line"><span class="string">服务端启动起来后，同时多个客户端连接过去，如果多个客户端能同时得到结果，并发效果</span></span><br><span class="line"><span class="string">就实现了</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>客户端</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可同时开多个客户端(客户端1、客户端2、客户端3)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">client.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    client.send(<span class="string">&quot;hello&quot;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment"># 在不停的向服务端发送“hello”</span></span><br><span class="line">    msg=client.recv(<span class="number">1024</span>) <span class="comment"># 收消息，在不停的收HELLO</span></span><br><span class="line">    <span class="built_in">print</span>(msg.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">解析：</span></span><br><span class="line"><span class="string">三个客户端都能同时不停的发消息和收消息，都有并发效果，但服务端没有开多线程，事实上</span></span><br><span class="line"><span class="string">就是服务端在多个任务之间来回的切换</span></span><br><span class="line"><span class="string">其实就是给第一个客户端执行一个seed来发送I/O请求，只要seed发出之后运行完就是操作</span></span><br><span class="line"><span class="string">系统的任务了，seed负责发消息，操作系统负责做I/O。gevent模块会利用你seed的过程</span></span><br><span class="line"><span class="string">直接切到下一个任务，再切到下下一个任务，一直往下切，给客户端的感觉就是每一个客户端</span></span><br><span class="line"><span class="string">都能被服务，并发就实现了</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>IO模型研究的主要是网络IO(linux系统)</p>
<ul>
<li>同步（synchronous）    大部分情况下会采用缩写的形式  sync</li>
<li>异步（asynchronous） async</li>
<li>阻塞（blocking） </li>
<li>非阻塞（non-blocking）</li>
</ul>
<p>五种IO模型：<br>    * blocking IO           阻塞IO<br>    * nonblocking IO          非阻塞IO<br>    * IO multiplexing          IO多路复用<br>    * signal driven IO         信号驱动IO<br>    * asynchronous IO            异步IO<br>    由signal driven IO（信号驱动IO）在实际中并不常用，所以主要介绍其余四种IO Model</p>
<h3 id="四种IO模型简介"><a href="#四种IO模型简介" class="headerlink" title="四种IO模型简介"></a>四种IO模型简介</h3><h4 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h4><pre><code>最为常见的一种IO模型 有两个等待的阶段(wait for data、copy data)
</code></pre>
<h4 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h4><pre><code>系统调用阶段变为了非阻塞(轮训) 有一个等待的阶段(copy data)
  轮训的阶段是比较消耗资源的
</code></pre>
<h4 id="多路复用IO"><a href="#多路复用IO" class="headerlink" title="多路复用IO"></a>多路复用IO</h4><pre><code>利用select或者epoll来监管多个程序 一旦某个程序需要的数据存在于内存中了 那么立刻通知该程序去取即可
</code></pre>
<h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h4><pre><code>只需要发起一次系统调用 之后无需频繁发送 有结果并准备好之后会通过异步回调机制反馈给调用者
</code></pre>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/python/" rel="tag"><i class="fa fa-tag"></i> python</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2ba065a.html" rel="prev" title="Mac上VMware的NAT网络设置">
                  <i class="fa fa-chevron-left"></i> Mac上VMware的NAT网络设置
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/627226e0.html" rel="next" title="vim的使用">
                  vim的使用 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">klcc</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">765k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">11:35</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdn.jsdelivr.net/npm/ribbon.js@1.0.2/dist/ribbon.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
