<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Python从入门到放弃</title>
    <url>/c1ca5201.html</url>
    <content><![CDATA[<h4 id="Python基础"><a href="#Python基础" class="headerlink" title="Python基础"></a>Python基础</h4><span id="more"></span>
<p> <a href="https://klcc.cc/c1fd5357.html">Python解释器与Pycharm</a><br> <a href="https://klcc.cc/daf175dd.html">pycharm使用及python变量、命名规范</a><br> <a href="https://klcc.cc/43f82467.html">数据类型、输入输出、基本运算符</a><br> <a href="https://klcc.cc/26ba1150.html">流程控制</a><br> <a href="https://klcc.cc/5bfa71b5.html">for循环及内置方法</a><br> <a href="https://klcc.cc/d645d15c.html">内置方法二</a><br> <a href="https://klcc.cc/bb5f959.html">内置方法三</a><br> <a href="https://klcc.cc/b8f382b7.html">编码和文件操作</a><br> <a href="https://klcc.cc/19603b60.html">文件操作</a><br> <a href="https://klcc.cc/a7f42e80.html">文件操作与函数</a><br> <a href="https://klcc.cc/c86b83ee.html">函数参数</a><br> <a href="https://klcc.cc/abc4492a.html">函数使用</a><br> <a href="https://klcc.cc/3a5cdcf8.html">装饰器</a><br> <a href="https://klcc.cc/d5376901.html">函数使用和生成式</a><br> <a href="https://klcc.cc/ccf84d2b.html">迭代器</a><br> <a href="https://klcc.cc/ae4233d7.html">生成器</a><br> <a href="https://klcc.cc/5c1fe23f.html">模块一</a><br> <a href="https://klcc.cc/26f31071.html">软件目录规范、正则表达式</a><br> <a href="https://klcc.cc/f32e795d.html">模块二</a><br> <a href="https://klcc.cc/8ddd5976.html">模块三</a><br> <a href="https://klcc.cc/779eb679.html">模块四</a><br> <a href="https://klcc.cc/832cc1e6.html">面向对象一</a><br> <a href="https://klcc.cc/e67db240.html">网络编程</a><br> <a href="https://klcc.cc/59b85335.html">并发编程</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库从入门到放弃</title>
    <url>/77f70f41.html</url>
    <content><![CDATA[<h4 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h4><span id="more"></span>
<p> <a href="https://klcc.cc/f88e38d3.html">二进制安装</a><br> <a href="https://klcc.cc/318aa70a.html">登录及密码管理</a><br> <a href="https://klcc.cc/3c4a0863.html">体系结构介绍</a><br> <a href="https://klcc.cc/d7227a45.html">用户权限等基础管理</a><br> <a href="https://klcc.cc/37f9f562.html">初始化配置</a><br> <a href="https://klcc.cc/8da0cafb.html">SQL基础应用</a><br> <a href="https://klcc.cc/5c917bb6.html">索引管理</a><br> <a href="https://klcc.cc/ff3d77ac">InnoDB存储引擎</a><br> <a href="https://klcc.cc/2386d3bc.html">日志管理</a><br> <a href="https://klcc.cc/2c2a11ca.html">备份恢复与迁移</a><br> <a href="https://klcc.cc/c813917a.html">主从复制</a><br> <a href="https://klcc.cc/2c9a5c07.html">基本优化</a></p>
<h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h4><p> <a href="https://klcc.cc/99ace97a.html">MongoDB简介</a><br> <a href="https://klcc.cc/55c06d78.html">安装部署</a><br> <a href="https://klcc.cc/ff4ef26d.html">用户管理</a><br> <a href="https://klcc.cc/3358d614.html">远程连接方式</a><br> <a href="https://klcc.cc/cb1bd433.html">基本的CRUD操作</a><br> <a href="https://klcc.cc/3bf43096.html">聚合框架</a><br> <a href="https://klcc.cc/37db6981.html">MongoDB复制集</a><br> <a href="https://klcc.cc/d8bf061a.html">分片集群搭建及扩容</a><br> <a href="https://klcc.cc/ec5ee46f.html">两地三中心部署</a><br> <a href="https://klcc.cc/2a426223.html">全球多写</a><br> <a href="https://klcc.cc/d4437f91.html">备份与恢复迁移</a><br> <a href="https://klcc.cc/8ba5944d.html">MongoDB监控</a></p>
<h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h4><h4 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h4>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux从运维到放弃</title>
    <url>/a4a81253.html</url>
    <content><![CDATA[<h4 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h4><span id="more"></span>
<p> <a href="https://klcc.cc/20cf8e98.html">Linux安装、远程连接</a><br> <a href="https://klcc.cc/5e2eb880.html">Linux目录结构</a><br> <a href="https://klcc.cc/627226e0.html">vim的使用</a><br> <a href="https://klcc.cc/684b776b.html">Linux系统目录结构</a><br> <a href="https://klcc.cc/117ba17a.html">Linux文件管理</a><br> <a href="https://klcc.cc/ef277b25.html">Linux用户管理</a><br> <a href="https://klcc.cc/ad5612ad.html">Linux文件权限管理</a><br> <a href="https://klcc.cc/891d6bd.html">Linux包管理及压缩命令</a><br> <a href="https://klcc.cc/c3540fc.html">Linux系统优化及定时任务</a><br> <a href="https://klcc.cc/47edf33b.html">Linux文本处理和find命令</a><br> <a href="https://klcc.cc/bfa86649.html">Linux三剑客</a><br> <a href="https://klcc.cc/51ea15a6.html">Linux命令总结</a><br> <a href="https://klcc.cc/f9ef965d.html">Linux磁盘挂载分区</a><br> <a href="https://klcc.cc/2efe136b.html">Linux防火墙iptables</a><br> <a href="https://klcc.cc/7efc43b.html">VPN搭建使用</a><br> <a href="https://klcc.cc/340a13f1.html">Rsync使用</a><br> <a href="https://klcc.cc/e15f268d.html">NFS搭建使用</a></p>
<h4 id="Ansible"><a href="#Ansible" class="headerlink" title="Ansible"></a>Ansible</h4><p> <a href="https://klcc.cc/1452b361.html">简介安装</a><br> <a href="https://klcc.cc/6beab3d3.html">常用模块</a><br> <a href="https://klcc.cc/c3cdc4c2.html">Playbook的使用</a><br> <a href="https://klcc.cc/27816ec8.html">变量和Register的使用</a><br> <a href="https://klcc.cc/d30594ae.html">Task控制</a><br> <a href="https://klcc.cc/658bdd20.html">jinja2和Role</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>jinja2和Role</title>
    <url>/658bdd20.html</url>
    <content><![CDATA[<h2 id="template模板"><a href="#template模板" class="headerlink" title="template模板"></a>template模板</h2><blockquote>
<p>模板是一个文本文件，可以做为生成文件的模版，并且模板文件中还可嵌套jinja语法。</p>
</blockquote>
<span id="more"></span>
<h3 id="jinja2语言"><a href="#jinja2语言" class="headerlink" title="jinja2语言"></a>jinja2语言</h3><blockquote>
<p>官方网站：</p>
<p><a href="http://jinja.pocoo.org/">http://jinja.pocoo.org/</a></p>
<p><a href="https://jinja.palletsprojects.com/en/2.11.x/">https://jinja.palletsprojects.com/en/2.11.x/</a></p>
</blockquote>
<p><img src="https://jinja.palletsprojects.com/en/3.0.x/_images/jinja-logo.png" alt="img"></p>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><strong>jinja2 语言支持多种数据类型和操作:</strong></p>
<ul>
<li>字符串：使用单引号或双引号,</li>
<li>数字：整数，浮点数</li>
<li>列表：[item1, item2, …]</li>
<li>元组：(item1, item2, …)</li>
<li>字典：{key1:value1, key2:value2, …}</li>
<li>布尔型：true/false</li>
<li>算术运算：+, -, *, /, //, %, **</li>
<li>比较操作：==, !=, &gt;, &gt;=, &lt;, &lt;=</li>
<li>逻辑运算：and，or，not</li>
<li>流表达式：For，If，When</li>
</ul>
<h3 id="template"><a href="#template" class="headerlink" title="template"></a>template</h3><p>template功能：可以根据和参考模块文件，动态生成相类似的配置文件，template文件必须存放于templates目录下，且命名为 .j2 结尾，yaml/yml 文件需和templates目录平级，目录结构如下示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> ./</span><br><span class="line">├── temnginx.yml</span><br><span class="line">└── templates</span><br><span class="line">    └── nginx.conf.j2Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>范例：利用template 同步nginx配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#准备templates/nginx.conf.j2文件</span></span><br><span class="line">[root@ansible ~]<span class="comment">#vim temnginx.yml</span></span><br><span class="line">---</span><br><span class="line">- hosts: web</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">    - name: template config to remote hosts</span><br><span class="line">     template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf</span><br><span class="line"> [root@ansible ~]<span class="comment">#ansible-playbook temnginx.ymlCopy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<h4 id="template变更替换"><a href="#template变更替换" class="headerlink" title="template变更替换"></a>template变更替换</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改文件nginx.conf.j2 </span></span><br><span class="line">[root@ansible ~]<span class="comment">#mkdir templates</span></span><br><span class="line">[root@ansible ~]<span class="comment">#vim templates/nginx.conf.j2</span></span><br><span class="line">......</span><br><span class="line">worker_processes &#123;&#123; ansible_processor_vcpus &#125;&#125;;</span><br><span class="line">......</span><br><span class="line">[root@ansible ~]<span class="comment">#vim temnginx2.yml</span></span><br><span class="line">---</span><br><span class="line">- hosts: web</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: install nginx</span><br><span class="line">      yum: name=nginx</span><br><span class="line">    - name: template config to remote hosts</span><br><span class="line">      template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf </span><br><span class="line">    - name: start service</span><br><span class="line">      service: name=nginx state=started enabled=yes</span><br><span class="line">       </span><br><span class="line">[root@ansible ~]<span class="comment">#ansible-playbook temnginx2.ymlCopy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<h4 id="常用的系统参数"><a href="#常用的系统参数" class="headerlink" title="常用的系统参数"></a>常用的系统参数</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible_all_ipv4_addresses：仅显示ipv4的信息</span><br><span class="line">ansible_devices：仅显示磁盘设备信息</span><br><span class="line">ansible_distribution：显示是什么系统，例：centos,suse等</span><br><span class="line">ansible_distribution_version：仅显示系统版本</span><br><span class="line">ansible_distribution_major_version：显示系统版本号（7）</span><br><span class="line">ansible_machine：显示系统类型，例：32位，还是64位</span><br><span class="line">ansible_eth0：仅显示eth0的信息</span><br><span class="line">ansible_hostname：仅显示主机名</span><br><span class="line">ansible_kernel：仅显示内核版本</span><br><span class="line">ansible_lvm：显示lvm相关信息</span><br><span class="line">ansible_memtotal_mb：显示系统总内存</span><br><span class="line">ansible_memfree_mb：显示可用系统内存</span><br><span class="line">ansible_memory_mb：详细显示内存情况</span><br><span class="line">ansible_swaptotal_mb：显示总的swap内存</span><br><span class="line">ansible_swapfree_mb：显示swap内存的可用内存</span><br><span class="line">ansible_mounts：显示系统磁盘挂载情况</span><br><span class="line">ansible_processor：显示cpu个数(具体显示每个cpu的型号)</span><br><span class="line">ansible_processor_vcpus：显示cpu个数(只显示总的个数)</span><br><span class="line">ansible_python_version：显示python版本</span><br></pre></td></tr></table></figure>

<h4 id="template算术运算"><a href="#template算术运算" class="headerlink" title="template算术运算"></a>template算术运算</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ansible]<span class="comment">#vim templates/nginx.conf.j2</span></span><br><span class="line">worker_processes &#123;&#123; ansible_processor_vcpus**3 &#125;&#125;;</span><br><span class="line">[root@ansible ansible]<span class="comment">#cat templnginx.yml</span></span><br><span class="line">---</span><br><span class="line">- hosts: websrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">    - name: install nginx</span><br><span class="line">      yum: name=nginx</span><br><span class="line">    - name: template config to remote hosts</span><br><span class="line">      template: src=nginx.conf.j2 dest=/etc/nginx/nginx.conf</span><br><span class="line">      notify: restart nginx</span><br><span class="line">    - name: start service</span><br><span class="line">      service: name=nginx state=started enabled=yes</span><br><span class="line"> handlers:</span><br><span class="line">    - name: restart nginx</span><br><span class="line">      service: name=nginx state=restarted</span><br><span class="line">[root@ansible ~]<span class="comment">#-playbook templnginx.yml --limit 10.0.0.8Copy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<h4 id="template中使用流程控制for和if"><a href="#template中使用流程控制for和if" class="headerlink" title="template中使用流程控制for和if"></a>template中使用流程控制for和if</h4><blockquote>
<p>template中也可以使用流程控制 for 循环和 if 条件判断，实现动态生成文件功能</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#temlnginx2.yml</span></span><br><span class="line">---</span><br><span class="line">- hosts: websrvs</span><br><span class="line"> remote_user: root</span><br><span class="line"> vars:</span><br><span class="line">   nginx_vhosts:</span><br><span class="line">     - 81</span><br><span class="line">     - 82</span><br><span class="line">     - 83</span><br><span class="line"> tasks:</span><br><span class="line">   - name: template config</span><br><span class="line">     template: src=nginx.conf2.j2 dest=/data/nginx.conf</span><br><span class="line"><span class="comment">#templates/nginx.conf2.j2</span></span><br><span class="line">&#123;% <span class="keyword">for</span> vhost <span class="keyword">in</span> nginx_vhosts %&#125;</span><br><span class="line">server &#123;</span><br><span class="line">   listen &#123;&#123; vhost &#125;&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line">ansible-playbook -C templnginx2.yml --<span class="built_in">limit</span> 192.168.15.8</span><br><span class="line"><span class="comment">#生成的结果：</span></span><br><span class="line">server &#123;</span><br><span class="line">   listen 81   </span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">   listen 82   </span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">   listen 83   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#templnginx4.yml</span></span><br><span class="line">- hosts: websrvs</span><br><span class="line"> remote_user: root</span><br><span class="line"> vars:</span><br><span class="line">   nginx_vhosts:</span><br><span class="line">     - listen: 8080</span><br><span class="line">       server_name: <span class="string">&quot;web1.oldboy.com&quot;</span></span><br><span class="line">       root: <span class="string">&quot;/var/www/nginx/web1/&quot;</span></span><br><span class="line">     - listen: 8081</span><br><span class="line">       server_name: <span class="string">&quot;web2.oldboy.com&quot;</span></span><br><span class="line">       root: <span class="string">&quot;/var/www/nginx/web2/&quot;</span></span><br><span class="line">     - &#123;listen: 8082, server_name: <span class="string">&quot;web3.oldboy.com&quot;</span>, root: </span><br><span class="line"><span class="string">&quot;/var/www/nginx/web3/&quot;</span>&#125;</span><br><span class="line"> tasks:</span><br><span class="line">   - name: template config </span><br><span class="line">     template: src=nginx.conf4.j2 dest=/data/nginx4.conf</span><br><span class="line">      </span><br><span class="line">   </span><br><span class="line"><span class="comment"># templates/nginx.conf4.j2</span></span><br><span class="line">&#123;% <span class="keyword">for</span> vhost <span class="keyword">in</span> nginx_vhosts %&#125;</span><br><span class="line">server &#123;</span><br><span class="line">   listen &#123;&#123; vhost.listen &#125;&#125;</span><br><span class="line">   server_name &#123;&#123; vhost.server_name &#125;&#125;</span><br><span class="line">   root &#123;&#123; vhost.root &#125;&#125;  </span><br><span class="line">&#125;&#123;% endfor %&#125; </span><br><span class="line"></span><br><span class="line">[root@ansible ~]<span class="comment">#ansible-playbook templnginx4.yml --limit 10.0.0.8</span></span><br><span class="line"><span class="comment">#生成结果：</span></span><br><span class="line">server &#123;</span><br><span class="line">   listen 8080</span><br><span class="line">   server_name web1.oldboy.com</span><br><span class="line">   root /var/www/nginx/web1/  </span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">   listen 8081</span><br><span class="line">   server_name web2.oldboy.com</span><br><span class="line">   root /var/www/nginx/web2/  </span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">   listen 8082</span><br><span class="line">   server_name web3.oldboy.com</span><br><span class="line">   root /var/www/nginx/web3/  </span><br><span class="line">&#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h4 id="playbook使用when"><a href="#playbook使用when" class="headerlink" title="playbook使用when"></a>playbook使用when</h4><p>when语句，可以实现条件测试。如果需要根据变量、facts或此前任务的执行结果来做为某task执行与否的前提时要用到条件测试,通过在task后添加when子句即可使用条件测试，jinja2的语法格式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tasks:</span><br><span class="line">  - name: <span class="string">&quot;shut down CentOS 6 and Debian 7 systems&quot;</span></span><br><span class="line">   <span class="built_in">command</span>: /sbin/shutdown -t now</span><br><span class="line">   when: (ansible_facts[<span class="string">&#x27;distribution&#x27;</span>] == <span class="string">&quot;CentOS&quot;</span> and ansible_facts[<span class="string">&#x27;distribution_major_version&#x27;</span>] == <span class="string">&quot;6&quot;</span>) or (ansible_facts[<span class="string">&#x27;distribution&#x27;</span>] == <span class="string">&quot;Debian&quot;</span> and ansible_facts[<span class="string">&#x27;distribution_major_version&#x27;</span>] == <span class="string">&quot;7&quot;</span>)Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h4 id="playbook使用迭代with-items-loop"><a href="#playbook使用迭代with-items-loop" class="headerlink" title="playbook使用迭代with_items(loop)"></a>playbook使用迭代with_items(loop)</h4><p>迭代：当有需要重复性执行的任务时，可以使用迭代机制对迭代项的引用，固定内置变量名为”item”，要在task中使用with_items给定要迭代的元素列表</p>
<p>注意: ansible2.5版本后,可以用loop代替with_items</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: websrvs</span><br><span class="line"> remote_user: root</span><br><span class="line">  </span><br><span class="line"> tasks:</span><br><span class="line">    - name: add several users</span><br><span class="line">     user: name=&#123;&#123; item &#125;&#125; state=present groups=wheel</span><br><span class="line">     with_items:</span><br><span class="line">        - testuser1</span><br><span class="line">        - testuser2</span><br><span class="line">        - testuser3</span><br><span class="line">        </span><br><span class="line"><span class="comment">#上面语句的功能等同于下面的语句</span></span><br><span class="line">    - name: add several users</span><br><span class="line">      user: name=testuser1 state=present groups=wheel</span><br><span class="line">    - name: add several users</span><br><span class="line">      user: name=testuser2 state=present groups=wheel</span><br><span class="line">    - name: add several users</span><br><span class="line">      user: name=testuser3 state=present groups=wheel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"><span class="comment">#remove mariadb server</span></span><br><span class="line">- hosts: 172.16.1.7</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">    - name: stop service</span><br><span class="line">      shell: /etc/init.d/mysqld stop</span><br><span class="line">    - name: delete files and dir</span><br><span class="line">      file: path=&#123;&#123;item&#125;&#125; state=absent</span><br><span class="line">      with_items:</span><br><span class="line">        - /usr/<span class="built_in">local</span>/mysql</span><br><span class="line">        - /usr/<span class="built_in">local</span>/mariadb-10.2.27-linux-x86_64</span><br><span class="line">        - /etc/init.d/mysqld</span><br><span class="line">        - /etc/profile.d/mysql.sh</span><br><span class="line">        - /etc/my.cnf</span><br><span class="line">        - /data/mysql</span><br><span class="line">    - name: delete user</span><br><span class="line">      user: name=mysql state=absent remove=yesCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><strong>迭代嵌套子变量：</strong>在迭代中，还可以嵌套子变量，关联多个变量在一起使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: websrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  </span><br><span class="line">  tasks:</span><br><span class="line">    - name: add some groups</span><br><span class="line">      group: name=&#123;&#123; item &#125;&#125; state=present</span><br><span class="line">      with_items:</span><br><span class="line">        - nginx</span><br><span class="line">        - mysql</span><br><span class="line">        - apache</span><br><span class="line">    - name: add some users</span><br><span class="line">      user: name=&#123;&#123; item.name &#125;&#125; group=&#123;&#123; item.group &#125;&#125; state=present</span><br><span class="line">      with_items:</span><br><span class="line">        - &#123; name: <span class="string">&#x27;nginx&#x27;</span>, group: <span class="string">&#x27;nginx&#x27;</span> &#125;</span><br><span class="line">        - &#123; name: <span class="string">&#x27;mysql&#x27;</span>, group: <span class="string">&#x27;mysql&#x27;</span> &#125;</span><br><span class="line">        - &#123; name: <span class="string">&#x27;apache&#x27;</span>, group: <span class="string">&#x27;apache&#x27;</span> &#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h3 id="管理节点过多导致的超时问题解决方法"><a href="#管理节点过多导致的超时问题解决方法" class="headerlink" title="管理节点过多导致的超时问题解决方法"></a>管理节点过多导致的超时问题解决方法</h3><blockquote>
<p>默认情况下，Ansible将尝试并行管理playbook中所有的机器。对于滚动更新用例，可以使用serial关键字定义Ansible一次应管理多少主机，还可以将serial关键字指定为百分比，表示每次并行执行的主机数占总数的比例</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#vim test_serial.yml</span></span><br><span class="line">---</span><br><span class="line">- hosts: all</span><br><span class="line">  serial: 2  <span class="comment">#每次只同时处理2个主机,将所有task执行完成后,再选下2个主机再执行所有task,直至所有主机</span></span><br><span class="line">  gather_facts: False</span><br><span class="line">  tasks:</span><br><span class="line">    - name: task one</span><br><span class="line">  comand: hostname</span><br><span class="line">    - name: task two</span><br><span class="line">      <span class="built_in">command</span>: hostname</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 案例2：</span></span><br><span class="line">- name: <span class="built_in">test</span> serail</span><br><span class="line">  hosts: all</span><br><span class="line">  serial: <span class="string">&quot;20%&quot;</span>   <span class="comment">#每次只同时处理20%的主机</span></span><br></pre></td></tr></table></figure>




<h1 id="Role"><a href="#Role" class="headerlink" title="Role"></a><a href="http://192.168.13.73:3000/#/file/roles%E8%A7%92%E8%89%B2?id=role">Role</a></h1><p>角色是ansible自1.2版本引入的新特性，用于层次性、结构化地组织playbook。roles能够根据层次型结构自动装载变量文件、tasks以及handlers等。要使用roles只需要在playbook中使用include指令即可。简单来讲，roles就是通过分别将变量、文件、任务、模板及处理器放置于单独的目录中，并可以便捷地include它们的一种机制。角色一般用于基于主机构建服务的场景中，但也可以是用于构建守护进程等场景中</p>
<p>运维复杂的场景：建议使用 roles，代码复用度高</p>
<p>roles：多个角色的集合目录， 可以将多个的role，分别放至roles目录下的独立子目录中,如下示例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">roles/</span><br><span class="line"> mysql/</span><br><span class="line"> nginx/</span><br><span class="line"> tomcat/</span><br><span class="line"> redis/Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p>默认roles存放路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/root/.ansible/roles</span><br><span class="line">/usr/share/ansible/roles</span><br><span class="line">/etc/ansible/rolesCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h2 id="Ansible-Roles目录编排"><a href="#Ansible-Roles目录编排" class="headerlink" title="Ansible Roles目录编排"></a><a href="http://192.168.13.73:3000/#/file/roles%E8%A7%92%E8%89%B2?id=ansible-roles%E7%9B%AE%E5%BD%95%E7%BC%96%E6%8E%92">Ansible Roles目录编排</a></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">├── nginx -------------role1名称</span><br><span class="line">│   ├── defaults  ---------必须存在的目录，存放默认的变量，模板文件中的变量就是引用自这里。defaults中的变量优先级最低，通常我们可以临时指定变量来进行覆盖</span><br><span class="line">│   │   └── main.yml</span><br><span class="line">│   ├── files -------------ansible中unarchive、copy等模块会自动来这里找文件，从而我们不必写绝对路径，只需写文件名</span><br><span class="line">│   │   ├── mysql.tar.gz</span><br><span class="line">│   │   └── nginx.tar.gz</span><br><span class="line">│   ├── handlers -----------存放tasks中的notify指定的内容</span><br><span class="line">│   │   └── main.yml</span><br><span class="line">│   ├── meta</span><br><span class="line">│   ├── tasks --------------存放playbook的目录，其中main.yml是主入口文件，在main.yml中导入其他yml文件，要采用import_tasks关键字，include要弃用了</span><br><span class="line">│   │   ├── install.yml</span><br><span class="line">│   │   └── main.yml -------主入口文件</span><br><span class="line">│   ├── templates ----------存放模板文件。template模块会将模板文件中的变量替换为实际值，然后覆盖到客户机指定路径上</span><br><span class="line">│   │   └── nginx.conf.j2</span><br><span class="line">│   └── varsCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h2 id="Roles各目录作用"><a href="#Roles各目录作用" class="headerlink" title="Roles各目录作用"></a><a href="http://192.168.13.73:3000/#/file/roles%E8%A7%92%E8%89%B2?id=roles%E5%90%84%E7%9B%AE%E5%BD%95%E4%BD%9C%E7%94%A8">Roles各目录作用</a></h2><ul>
<li><p>files/ ：存放由copy或script模块等调用的文件</p>
</li>
<li><p>templates/：template模块查找所需要模板文件的目录</p>
</li>
<li><p>tasks/：定义task,role的基本元素，至少应该包含一个名为main.yml的文件；其它的文件需要在此文件中通过include进行包含</p>
</li>
<li><p>handlers/：至少应该包含一个名为main.yml的文件；此目录下的其它的文件需要在此文件中通过</p>
</li>
<li><p>include进行包含</p>
</li>
<li><p>vars/：定义变量，至少应该包含一个名为main.yml的文件；此目录下的其它的变量文件需要在此文件中通过include进行包含</p>
</li>
<li><p>meta/：定义当前角色的特殊设定及其依赖关系,至少应该包含一个名为main.yml的文件，其它文件需在此文件中通过include进行包含</p>
</li>
<li><p>default/：设定默认变量时使用此目录中的main.yml文件，比vars的优先级低</p>
<h2 id="创建role"><a href="#创建role" class="headerlink" title="创建role"></a><a href="http://192.168.13.73:3000/#/file/roles%E8%A7%92%E8%89%B2?id=%E5%88%9B%E5%BB%BArole">创建role</a></h2></li>
</ul>
<blockquote>
<p>创建role的步骤</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1 创建以roles命名的目录</span><br><span class="line">2 在roles目录中分别创建以各角色名称命名的目录，如mysql等</span><br><span class="line">3 在每个角色命名的目录中分别创建files、handlers、tasks、templates和vars等目录；用不到的目录可以创建为空目录，也可以不创建</span><br><span class="line">4 在每个角色相关的子目录中创建相应的文件,如 tasks/main.yml,templates/nginx.conf.j2</span><br><span class="line">5 在playbook文件中，调用需要的角色</span><br><span class="line"></span><br><span class="line">[root@m01 package]<span class="comment"># mkdir -p /root/package/roles/nginx/&#123;files,handlers,tasks,templates,vars,meta&#125;</span></span><br><span class="line">[root@m01 package]<span class="comment"># tree</span></span><br><span class="line">.</span><br><span class="line">└── roles</span><br><span class="line">    └── nginx</span><br><span class="line">        ├── files</span><br><span class="line">        ├── handlers</span><br><span class="line">        ├── meta</span><br><span class="line">        ├── tasks</span><br><span class="line">        ├── templates</span><br><span class="line">        └── vars</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h3 id="针对大型项目使用Roles进行编排"><a href="#针对大型项目使用Roles进行编排" class="headerlink" title="针对大型项目使用Roles进行编排"></a><a href="http://192.168.13.73:3000/#/file/roles%E8%A7%92%E8%89%B2?id=%E9%92%88%E5%AF%B9%E5%A4%A7%E5%9E%8B%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8roles%E8%BF%9B%E8%A1%8C%E7%BC%96%E6%8E%92">针对大型项目使用Roles进行编排</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 范例</span></span><br><span class="line">nginx-role.yml </span><br><span class="line">roles/</span><br><span class="line">└── nginx </span><br><span class="line">     ├── files</span><br><span class="line">     │   └── main.yml </span><br><span class="line">     ├── tasks</span><br><span class="line">     │   ├── groupadd.yml </span><br><span class="line">     │   ├── install.yml </span><br><span class="line">     │   ├── main.yml </span><br><span class="line">     │   ├── restart.yml </span><br><span class="line">     │   └── useradd.yml </span><br><span class="line">     └── vars </span><br><span class="line">         └── main.ymlCopy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h2 id="playbook调用角色"><a href="#playbook调用角色" class="headerlink" title="playbook调用角色"></a><a href="http://192.168.13.73:3000/#/file/roles%E8%A7%92%E8%89%B2?id=playbook%E8%B0%83%E7%94%A8%E8%A7%92%E8%89%B2">playbook调用角色</a></h2><ul>
<li>调用角色方法1</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: web</span><br><span class="line">  remote_user: root</span><br><span class="line">  roles:</span><br><span class="line">    - mysql</span><br><span class="line">    - memcached</span><br><span class="line">    - nginx  Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<ul>
<li>调用角色方法2</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: all</span><br><span class="line">  remote_user: root</span><br><span class="line">  roles:</span><br><span class="line">    - mysql</span><br><span class="line">    - &#123; role: nginx, username: nginx &#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<ul>
<li>调用角色方法3</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: all</span><br><span class="line">  remote_user: root</span><br><span class="line">  roles:</span><br><span class="line">    - &#123; role: nginx, username: nginx, when: ansible_distribution_major_version == <span class="string">&#x27;7&#x27;</span> &#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<ul>
<li>调用角色方法4</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">- hosts: appsrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  roles:</span><br><span class="line">    - &#123; role: nginx ,tags: [ <span class="string">&#x27;nginx&#x27;</span>, <span class="string">&#x27;web&#x27;</span> ] ,when: ansible_distribution_major_version == <span class="string">&quot;6&quot;</span> &#125;</span><br><span class="line">    - &#123; role: httpd ,tags: [ <span class="string">&#x27;httpd&#x27;</span>, <span class="string">&#x27;web&#x27;</span> ] &#125;</span><br><span class="line">    - &#123; role: mysql ,tags: [ <span class="string">&#x27;mysql&#x27;</span>, <span class="string">&#x27;db&#x27;</span> ] &#125;</span><br><span class="line">    - &#123; role: mariadb ,tags: [ <span class="string">&#x27;mariadb&#x27;</span>, <span class="string">&#x27;db&#x27;</span> ] &#125;Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a><a href="http://192.168.13.73:3000/#/file/roles%E8%A7%92%E8%89%B2?id=%E6%A1%88%E4%BE%8B">案例</a></h2><h3 id="httpd角色"><a href="#httpd角色" class="headerlink" title="httpd角色"></a><a href="http://192.168.13.73:3000/#/file/roles%E8%A7%92%E8%89%B2?id=httpd%E8%A7%92%E8%89%B2">httpd角色</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建角色相关的目录</span></span><br><span class="line">[root@ansible ~]<span class="comment">#mkdir -pv /data/ansible/roles/httpd/&#123;tasks,handlers,files&#125;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">#创建角色相关的文件</span></span><br><span class="line">[root@ansible ~]<span class="comment">#cd /data/ansible/roles/httpd/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#main.yml 是task的入口文件</span></span><br><span class="line">[root@ansible ~]<span class="comment">#vim tasks/main.yml</span></span><br><span class="line">- include: group.yml</span><br><span class="line">- include: user.yml</span><br><span class="line">- include: install.yml</span><br><span class="line">- include: config.yml</span><br><span class="line">- include: index.yml</span><br><span class="line">- include: service.yml</span><br><span class="line"></span><br><span class="line">[root@ansible ~]<span class="comment">#vim tasks/group.yml</span></span><br><span class="line">- name: create apache group</span><br><span class="line">  group: name=apache system=yes gid=80</span><br><span class="line">  </span><br><span class="line">[root@ansible ~]<span class="comment">#vim tasks/user.yml</span></span><br><span class="line">- name: create apache user</span><br><span class="line">  user: name=apache system=yes shell=/sbin/nologin home=/var/www/ uid=80 group=apache</span><br><span class="line">  </span><br><span class="line">[root@ansible ~]<span class="comment">#vim tasks/install.yml</span></span><br><span class="line">- name: install httpd package</span><br><span class="line">  yum: name=httpd</span><br><span class="line">[root@ansible ~]<span class="comment">#vim tasks/config.yml</span></span><br><span class="line">- name: config file</span><br><span class="line">  copy: src=httpd.conf dest=/etc/httpd/conf/ backup=yes</span><br><span class="line">  notify: restart</span><br><span class="line">[root@ansible ~]<span class="comment"># tasks/index.yml</span></span><br><span class="line">- name: index.html</span><br><span class="line">  copy: src=index.html dest=/var/www/html/</span><br><span class="line">[root@ansible ~]<span class="comment">#vim tasks/service.yml</span></span><br><span class="line">- name: start service</span><br><span class="line">  service: name=httpd state=started enabled=yes</span><br><span class="line">[root@ansible ~]<span class="comment">#vim handlers/main.yml</span></span><br><span class="line">- name: restart</span><br><span class="line">  service: name=httpd state=restarted</span><br><span class="line">  </span><br><span class="line"><span class="comment">#在files目录下准备两个文件</span></span><br><span class="line">[root@ansible ~]<span class="comment">#ls files/</span></span><br><span class="line">httpd.conf index.html</span><br><span class="line">[root@ansible ~]<span class="comment">#tree /data/ansible/roles/httpd/</span></span><br><span class="line">/data/ansible/roles/httpd/</span><br><span class="line">├── files</span><br><span class="line">│   ├── httpd.conf</span><br><span class="line">│   └── index.html</span><br><span class="line">├── handlers</span><br><span class="line">│   └── main.yml</span><br><span class="line">└── tasks</span><br><span class="line">   ├── config.yml</span><br><span class="line">   ├── group.yml</span><br><span class="line">   ├── index.yml</span><br><span class="line">   ├── install.yml</span><br><span class="line">   ├── main.yml</span><br><span class="line">   ├── service.yml</span><br><span class="line">   └── user.yml</span><br><span class="line">3 directories, 10 files</span><br><span class="line"><span class="comment">#在playbook中调用角色</span></span><br><span class="line">[root@ansible ~]<span class="comment">#vim /data/ansible/role_httpd.yml</span></span><br><span class="line">---</span><br><span class="line"><span class="comment"># httpd role</span></span><br><span class="line">- hosts: websrvs</span><br><span class="line">  remote_user: root</span><br><span class="line">  roles:</span><br><span class="line">    - httpd</span><br><span class="line">    </span><br><span class="line"><span class="comment">#运行playbook</span></span><br><span class="line">[root@ansible ~]<span class="comment">#ansible-playbook /data/ansible/role_httpd.ymlCopy to clipboardErrorCopied</span></span><br></pre></td></tr></table></figure>

<h3 id="NGINX角色"><a href="#NGINX角色" class="headerlink" title="NGINX角色"></a><a href="http://192.168.13.73:3000/#/file/roles%E8%A7%92%E8%89%B2?id=nginx%E8%A7%92%E8%89%B2">NGINX角色</a></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@ansible ~]<span class="comment">#mkdir -pv /data/ansible/roles/nginx/&#123;tasks,handlers,templates,vars&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#创建task文件</span></span><br><span class="line">[root@ansible ~]<span class="comment">#cd /data/ansible/roles/nginx/</span></span><br><span class="line">[root@ansible nginx]<span class="comment">#vim tasks/main.yml </span></span><br><span class="line">- include: install.yml</span><br><span class="line">- include: config.yml</span><br><span class="line">- include: index.yml</span><br><span class="line">- include: service.yml</span><br><span class="line">[root@ansible nginx]<span class="comment">#vim tasks/install.yml </span></span><br><span class="line">- name: install</span><br><span class="line">  yum: name=nginx </span><br><span class="line"> </span><br><span class="line">[root@ansible nginx]<span class="comment">#vim tasks/config.yml </span></span><br><span class="line">- name: config file <span class="keyword">for</span> centos7</span><br><span class="line">  template: src=nginx7.conf.j2 dest=/etc/nginx/nginx.conf</span><br><span class="line">  when: ansible_distribution_major_version==<span class="string">&quot;7&quot;</span></span><br><span class="line">  notify: restart</span><br><span class="line">- name: config file <span class="keyword">for</span> centos8</span><br><span class="line">  template: src=nginx8.conf.j2 dest=/etc/nginx/nginx.conf</span><br><span class="line">  when: ansible_distribution_major_version==<span class="string">&quot;8&quot;</span></span><br><span class="line">  notify: restart</span><br><span class="line">  </span><br><span class="line"><span class="comment">#跨角色调用文件</span></span><br><span class="line">[root@ansible nginx]<span class="comment">#vim tasks/index.yml </span></span><br><span class="line">- name: index.html</span><br><span class="line">  copy: src=roles/httpd/files/index.html dest=/usr/share/nginx/html/</span><br><span class="line">[root@ansible nginx]<span class="comment">#vim tasks/service.yml </span></span><br><span class="line">- name: start service</span><br><span class="line">  service: name=nginx state=started enabled=yes</span><br><span class="line"><span class="comment">#创建handler文件</span></span><br><span class="line">[root@ansible nginx]<span class="comment">#cat handlers/main.yml </span></span><br><span class="line">- name: restart</span><br><span class="line">  service: name=nginx state=restarted</span><br><span class="line"><span class="comment">#创建两个template文件</span></span><br><span class="line">[root@ansible nginx]<span class="comment">#cat templates/nginx7.conf.j2</span></span><br><span class="line">...省略...</span><br><span class="line">user &#123;&#123;user&#125;&#125;;</span><br><span class="line">worker_processes &#123;&#123;ansible_processor_vcpus+3&#125;&#125;;   <span class="comment">#修改此行</span></span><br><span class="line">error_log /var/<span class="built_in">log</span>/nginx/error.log;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line">...省略...</span><br><span class="line">[root@ansible nginx]<span class="comment">#cat templates/nginx8.conf.j2</span></span><br><span class="line">...省略...</span><br><span class="line">user nginx;</span><br><span class="line">worker_processes &#123;&#123;ansible_processor_vcpus**3&#125;&#125;;  <span class="comment">#修改此行</span></span><br><span class="line">error_log /var/<span class="built_in">log</span>/nginx/error.log;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line">...省略...</span><br><span class="line"><span class="comment">#创建变量文件</span></span><br><span class="line">[root@ansible nginx]<span class="comment">#vim vars/main.yml </span></span><br><span class="line">user: daemon</span><br><span class="line"><span class="comment">#目录结构如下</span></span><br><span class="line">[root@ansible ~]<span class="comment">#tree /data/ansible/roles/nginx/</span></span><br><span class="line">/data/ansible/roles/nginx/</span><br><span class="line">├── handlers</span><br><span class="line">│   └── main.yml</span><br><span class="line">├── tasks</span><br><span class="line">│   ├── config.yml</span><br><span class="line">│   ├── file.yml</span><br><span class="line">│   ├── install.yml</span><br><span class="line">│   ├── main.yml</span><br><span class="line">│   └── service.yml</span><br><span class="line">├── templates</span><br><span class="line">│   ├── nginx7.conf.j2</span><br><span class="line">│   └── nginx8.conf.j2</span><br><span class="line">└── vars</span><br><span class="line">   └── main.yml</span><br><span class="line">4 directories, 9 files</span><br><span class="line"><span class="comment">#在playbook中调用角色</span></span><br><span class="line">[root@ansible ~]<span class="comment">#vim /data/ansible/role_nginx.yml </span></span><br><span class="line">---</span><br><span class="line"><span class="comment">#nginx role </span></span><br><span class="line">- hosts: web</span><br><span class="line"> roles:</span><br><span class="line">    - role: nginx</span><br><span class="line">    </span><br><span class="line"><span class="comment">#运行playbook</span></span><br><span class="line">[root@ansible ~]<span class="comment">#ansible-playbook /data/ansible/role_nginx.yml</span></span><br></pre></td></tr></table></figure>

<h2 id="创建Nginx的roles"><a href="#创建Nginx的roles" class="headerlink" title="创建Nginx的roles"></a>创建Nginx的roles</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建初始文件</span></span><br><span class="line">[root@m01 roles]<span class="comment"># ansible-galaxy init nginx</span></span><br><span class="line">- Role nginx was created successfully</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看目录层级结构</span></span><br><span class="line">baim0/</span><br><span class="line">└── roles</span><br><span class="line">    └── nginx</span><br><span class="line">        ├── defaults</span><br><span class="line">        │   └── main.yml</span><br><span class="line">        ├── files</span><br><span class="line">        ├── handlers</span><br><span class="line">        │   └── main.yml</span><br><span class="line">        ├── meta</span><br><span class="line">        │   └── main.yml</span><br><span class="line">        ├── README.md</span><br><span class="line">        ├── tasks</span><br><span class="line">        │   └── main.yml</span><br><span class="line">        ├── templates</span><br><span class="line">        ├── tests</span><br><span class="line">        │   ├── inventory</span><br><span class="line">        │   └── test.yml</span><br><span class="line">        └── vars</span><br><span class="line">            └── main.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>Task控制</title>
    <url>/d30594ae.html</url>
    <content><![CDATA[<h2 id="Task-Control"><a href="#Task-Control" class="headerlink" title="Task Control"></a><code>Task Control</code></h2><h3 id="when条件语句"><a href="#when条件语句" class="headerlink" title="when条件语句"></a><code>when</code>条件语句</h3><p>when 关键字主要针对 TASK 任务进行判断，对于此前我 们使用过的 yum 模块是可以自动检测软件包是否已被安 装，无需人为干涉；但对于有些任务则是需要进行判断 才可以实现的。</p>
<ul>
<li><p>web 节点都需要配置 nginx 仓库，但其他节 点并不需要，此时就会用到 when 判断</p>
</li>
<li><p>Centos 与 Ubuntu 都需要安装 Apache，而 Centos 系统软件包为 httpd，而 Ubuntu系统软件 包为httpd2，那么此时就需要判断主机系统，然后 为不同的主机系统安装不同的软件包</p>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 为所有主机安装 Apache 软件</span></span><br><span class="line">1.系统为CentOS：安装 httpd</span><br><span class="line">2.系统为Ubuntu：安装 httpd2</span><br><span class="line"></span><br><span class="line">cat facts4.yml</span><br><span class="line">- hosts: web</span><br><span class="line">  tasks:</span><br><span class="line">    - name: Centos Install httpd </span><br><span class="line">      yum:</span><br><span class="line">        name: httpd</span><br><span class="line">        state: present</span><br><span class="line">      when: (ansible_distribution ==<span class="string">&quot;CentOS&quot;</span>)</span><br><span class="line">    - name: Ubuntu Install httpd </span><br><span class="line">      yum:</span><br><span class="line">        name: apache2</span><br><span class="line">        state: present</span><br><span class="line">      when: (ansible_distribution ==<span class="string">&quot;Ubuntu&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<p>针对主机名为web的机器添加nginx仓库</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Add</span> <span class="string">Nginx</span> <span class="string">Yum</span> <span class="string">Repository</span></span><br><span class="line">    <span class="attr">yum_repository:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">ansible_web_nginx</span></span><br><span class="line">      <span class="attr">description:</span> <span class="string">Nginx</span> <span class="string">Repository</span></span><br><span class="line">      <span class="attr">baseurl:</span> <span class="string">http://nginx.org/packages/centos/7/$basearch/</span></span><br><span class="line">      <span class="attr">gpgcheck:</span> <span class="literal">no</span></span><br><span class="line">    <span class="attr">when:</span> <span class="string">(ansible_hostname</span> <span class="string">is</span> <span class="string">match(&quot;web*&quot;))</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="comment">#当然when也可以使用and与or方式</span></span><br><span class="line"><span class="comment">#when: (ansible_hostname is match(&quot;web*&quot;)) or</span></span><br><span class="line"><span class="comment"># (ansible_hostname is match(&quot;lb*&quot;))</span></span><br></pre></td></tr></table></figure>

<p>判断 httpd 服务是否处于运行状态</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断 httpd 服务是否处于运行状态</span></span><br><span class="line"><span class="comment"># 已运行：则重启服务</span></span><br><span class="line"><span class="comment"># 未运行：则不做处理</span></span><br><span class="line"><span class="comment"># 通过 register 将命令执行结果保存至变量，然后通过 when 语句进行判断</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Get</span> <span class="string">Httpd</span> <span class="string">Server</span> <span class="string">Status</span></span><br><span class="line">      <span class="attr">shell:</span></span><br><span class="line">        <span class="attr">cmd:</span> <span class="string">systemctl</span> <span class="string">status</span> <span class="string">httpd</span> <span class="string">&amp;&gt;/dev/null</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">Httpd_Check</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Debug</span></span><br><span class="line">      <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; Httpd_Check.rc &#125;&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restart</span> <span class="string">Httpd</span></span><br><span class="line">      <span class="attr">systemd:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">httpd</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">restarted</span></span><br><span class="line">      <span class="attr">when:</span> <span class="string">Httpd_Check.rc</span> <span class="string">==</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>为特定的主机执行任务</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有2台 server</span></span><br><span class="line"><span class="comment"># 第一台：172.16.1.7安装了 nginx</span></span><br><span class="line"><span class="comment"># 第二台：172.16.1.8没有安装 nginx</span></span><br><span class="line"><span class="comment"># 现在需要在没有安装 nginx的节点上做操作，需要通过 when 条件语句实现</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- hosts: all</span><br><span class="line">  tasks:</span><br><span class="line">    - name: Get System Install Nginx</span><br><span class="line">      shell:</span><br><span class="line">        cmd: rpm -qa nginx | wc -l</span><br><span class="line">      register: get_nginx</span><br><span class="line"></span><br><span class="line">    - name: Create Nginx File</span><br><span class="line">      file:</span><br><span class="line">        path: /tmp/nginx_not_install.txt</span><br><span class="line">        state: touch</span><br><span class="line">      when: get_nginx.stdout == <span class="string">&#x27;0&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="loop-循环语句"><a href="#loop-循环语句" class="headerlink" title="loop 循环语句"></a><code>loop</code> 循环语句</h3><p>在写 playbook 的时候发现了很多 task 都要重复引用 某个相同的模块，比如一次启动10个服务，或者一次拷 贝10个文件，如果按照传统的写法最少要写10次，这样 会显得 playbook 很臃肿。如果使用循环的方式来编写 playbook，这样可以减少重复编写 task 带来的臃肿</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 循环启动nginx和php-fpm</span></span><br><span class="line">- hosts: webservers</span><br><span class="line">  tasks:</span><br><span class="line"></span><br><span class="line">    - name: Systemd Nginx php</span><br><span class="line">      systemd:</span><br><span class="line">        name: <span class="string">&quot;&#123;&#123; item &#125;&#125;&quot;</span></span><br><span class="line">        state: started</span><br><span class="line">      loop:</span><br><span class="line">        - nginx</span><br><span class="line">        - php-fpm</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 循环安装httpd mariadb</span></span><br><span class="line">- hosts: webservers</span><br><span class="line">  tasks:</span><br><span class="line"></span><br><span class="line">    - name: Installed Httpd Mariadb Package</span><br><span class="line">      yum:</span><br><span class="line">        name: <span class="string">&quot;&#123;&#123; item &#125;&#125;&quot;</span></span><br><span class="line">        state: latest</span><br><span class="line">      loop:</span><br><span class="line">         - httpd</span><br><span class="line">         - mariadb-server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环拷贝配置文件</span></span><br><span class="line">- hosts: webservers</span><br><span class="line">  tasks:</span><br><span class="line"></span><br><span class="line">    - name: Rsync rsyncd.conf</span><br><span class="line">      copy:</span><br><span class="line">        src: <span class="string">&quot;&#123;&#123; item.src &#125;&#125;&quot;</span></span><br><span class="line">        dest: <span class="string">&quot;&#123;&#123; item.dest &#125;&#125;&quot;</span></span><br><span class="line">        owner: root</span><br><span class="line">        group: root</span><br><span class="line">        mode: <span class="string">&quot;&#123;&#123; item.mode &#125;&#125;&quot;</span></span><br><span class="line">      loop:</span><br><span class="line">        - &#123; src: rsyncd.conf , dest: /tmp/rsyncd.conf , mode: <span class="string">&quot;0644&quot;</span>  &#125;</span><br><span class="line">        - &#123; src: rsyncd.pass , dest: /root/rsync.pass , mode: <span class="string">&quot;0600&quot;</span> &#125;</span><br><span class="line">        - &#123; src: rsynnd.test , dest: /mnt/rsync.test , mode: <span class="string">&quot;0000&quot;</span> &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"><span class="comment"># 循环创建user</span></span><br><span class="line">- hosts: webservers</span><br><span class="line">  tasks:</span><br><span class="line">    - name: Add Users</span><br><span class="line">      user:</span><br><span class="line">        name: <span class="string">&quot;&#123;&#123; item.name &#125;&#125;&quot;</span></span><br><span class="line">        groups: <span class="string">&quot;&#123;&#123; item.groups &#125;&#125;&quot;</span></span><br><span class="line">        state: present</span><br><span class="line">      loop:</span><br><span class="line">        - &#123; name: <span class="string">&#x27;testuser1&#x27;</span>, groups: <span class="string">&#x27;bin&#x27;</span> &#125;</span><br><span class="line">        - &#123; name: <span class="string">&#x27;testuser2&#x27;</span>, groups: <span class="string">&#x27;root&#x27;</span> &#125;</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 循环创建文件</span></span><br><span class="line">- hosts: webservers</span><br><span class="line">  tasks:</span><br><span class="line"></span><br><span class="line">    - name: Create /data /backup</span><br><span class="line">      file:</span><br><span class="line">        path: <span class="string">&quot;&#123;&#123; item &#125;&#125;&quot;</span></span><br><span class="line">        state: directory</span><br><span class="line">      loop:</span><br><span class="line">        - /data</span><br><span class="line">        - /backup</span><br></pre></td></tr></table></figure>

<h3 id="Handlers和Notify"><a href="#Handlers和Notify" class="headerlink" title="Handlers和Notify"></a><code>Handlers</code>和<code>Notify</code></h3><p><code>Handlers</code> 是一个触发器，同时是一个特殊的 <code>tasks</code>， 它无法直接运行，它需要被 tasks 通知后才会运行</p>
<p>比如：httpd 服务配置文件发生变更，我们则可通过 Notify 通知给指定的 handlers 触发器，然后执行相 应重启服务的操作，如果配置文件不发生变更操作，则 不会触发 Handlers 任务的执行</p>
<p>handlers 注意事项 </p>
<ul>
<li><p>1.无论多少个 task 通知了相同的 <code>handlers</code>， <code>handlers</code>仅会在所有<code>tasks</code> 结束后运行一次</p>
</li>
<li><p>2.只有<code>task</code>发生改变了才会通知<code>handlers</code>，没 有改变则不会触发<code>handlers</code> </p>
</li>
<li><p>3.不能使用 handlers 替代 <code>tasks</code>、因为<code>handlers</code>是一个特殊的<code>tasks</code></p>
</li>
</ul>
<h3 id="tags任务标签"><a href="#tags任务标签" class="headerlink" title="tags任务标签"></a><code>tags</code>任务标签</h3><p>默认情况下，<code>Ansible</code> 在执行一个<code> playbook</code> 时，会执 行<code> playbook</code>中所有的任务。而标签功能是用来指定要 运行 <code>playbook</code>中的某个特定的任务；</p>
<ul>
<li><p>为 <code>playbook</code> 添加标签的方式有如下几种</p>
<ol>
<li>对一个<code>task</code>打一个标签 </li>
<li>对一个 <code>task</code>打多个标签 </li>
<li>对多个 <code>task</code>打一个标签</li>
</ol>
</li>
<li><p><code>task</code>打完标签使用的几种方式 </p>
<ol>
<li><code>-t</code> 执行指定<code>tag</code>标签对应的任务 </li>
<li><code>--skip-tags</code> 执行除<code> --skip-tags</code> 标签之外的所有任务</li>
</ol>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat f5.yml</span><br><span class="line">- hosts: nfs</span><br><span class="line">  tasks:</span><br><span class="line">    - name: Install Nfs Server</span><br><span class="line">      yum: name=nfs-utils state=present</span><br><span class="line">      tags:</span><br><span class="line">        - install_nfs</span><br><span class="line">        - install_nfs-server</span><br><span class="line">      </span><br><span class="line">    - name: Service Nfs Server</span><br><span class="line">      service: name=nfs-server state=started enabled=yes</span><br><span class="line">      tags: start_nfs-server</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">ansible-playbook f5.yml -t install_nfs</span><br><span class="line">ansible-playbook f5.yml --skip-tags install_nfs</span><br></pre></td></tr></table></figure>

<h3 id="include任务复用"><a href="#include任务复用" class="headerlink" title="include任务复用"></a><code>include</code>任务复用</h3><p>有时，我们发现大量的 Playbook 内容需要重复编写， 各 Tasks 之间功能需相互调用才能完成各自功能， Playbook 庞大到维护困难，这时我们需要使用 include 比如：A项目需要用到重启 httpd，B项目需要用到，重 启 httpd，那么我们可以使用 Include来减少重复编 写</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat main.yml</span><br><span class="line">- hosts: web</span><br><span class="line">  tasks:</span><br><span class="line">  - name: Install Tomcat8 Server</span><br><span class="line">    include: install_tomcat_8.yml</span><br><span class="line">    tags: install_tomcat_8</span><br><span class="line"></span><br><span class="line">  - name: Install Tomcat9 Server</span><br><span class="line">    include: install_tomcat_9.yml</span><br><span class="line">    tags: install_tomcat_9</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">install_tomcat_8.yml</span><br><span class="line">install_tomcat_9.yml</span><br><span class="line"></span><br><span class="line">ansible-playbook main.yml -t install_tomcat_8</span><br></pre></td></tr></table></figure>

<h2 id="Playbook异常处理"><a href="#Playbook异常处理" class="headerlink" title="Playbook异常处理"></a><code>Playbook</code>异常处理</h2><p>在 playbook 执行的过程中，难免会遇到一些错误。由 于 playbook 遇到错误后，不会执行之后的任务，不便 于调试，此时，可以使用 ignore_errors 来暂时忽略 错误，使得 playbook 继续执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- hosts: all</span><br><span class="line">  remote_user: root</span><br><span class="line">  tasks:</span><br><span class="line">    - name: Ignore False</span><br><span class="line">      <span class="built_in">command</span>: /bin/<span class="literal">false</span></span><br><span class="line">      ignore_errors: yes</span><br><span class="line"></span><br><span class="line">    - name: touch new file</span><br><span class="line">      file: path=/tmp/oldxu_ignore state=touch</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>Variable和Register的使用</title>
    <url>/27816ec8.html</url>
    <content><![CDATA[<h2 id="Ansible-Variable"><a href="#Ansible-Variable" class="headerlink" title="Ansible Variable"></a><code>Ansible Variable</code></h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">变量提供了便捷的方式来管理 ansible 项目中的动态值。</span><br><span class="line">比如 nginx-1.12，可能后期会反复的使用到这个版本的值，那么如果将此值设置为变量，后续使用和修改都将变得非常方便</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在 Ansible 中定义变量分为如下三种方式：</span><br><span class="line">1.通过命令行传递变量参数定义</span><br><span class="line">2.在play文件中进行定义变量</span><br><span class="line">    2.1 通过vars定义变量</span><br><span class="line">    2.2 通过vars_files定义变量</span><br><span class="line">3.通过inventory在主机组或单个主机中设置变量</span><br><span class="line">  3.1 通过host_vars对主机进行定义</span><br><span class="line">  3.2 通过group_vars对主机组进行定义</span><br><span class="line">  </span><br><span class="line">问题：如果定义的变量出现重复，造成冲突，如何解决？</span><br></pre></td></tr></table></figure>

<h3 id="在playbook中定义变量"><a href="#在playbook中定义变量" class="headerlink" title="在playbook中定义变量"></a>在playbook中定义变量</h3><h4 id="vars方式"><a href="#vars方式" class="headerlink" title="vars方式"></a>vars方式</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在 playbook 的文件中开头通过 vars 关键字进行变量定义</span></span><br><span class="line"></span><br><span class="line">- hosts: web</span><br><span class="line">  gather_facts: <span class="literal">false</span>  <span class="comment"># 不获取被控集机器的fact数据，速度会变快</span></span><br><span class="line">  vars:</span><br><span class="line">    - web_packages: httpd</span><br><span class="line">    - ftp_packages: vsftpd</span><br><span class="line"></span><br><span class="line">  tasks:</span><br><span class="line">    - name: Output Vaiables</span><br><span class="line">      debug:</span><br><span class="line">        msg:</span><br><span class="line">          - <span class="string">&quot;&#123;&#123; web_packages &#125;&#125;&quot;</span></span><br><span class="line">          - <span class="string">&quot;&#123;&#123; ftp_packages &#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="vars-file方式"><a href="#vars-file方式" class="headerlink" title="vars_file方式"></a><code>vars_file</code>方式</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">在 playbook 中使用 vars_files 指定文件作为变量文件，好处就是其他的 playbook 也可以调用</span><br><span class="line"></span><br><span class="line">cat vars.yml</span><br><span class="line">web_packages:</span><br><span class="line">  - httpd</span><br><span class="line">  - nginx</span><br><span class="line">ftp_packages: vsftpd</span><br><span class="line"></span><br><span class="line">cat f2.yml</span><br><span class="line">- hosts: web</span><br><span class="line">  gather_facts: <span class="literal">false</span></span><br><span class="line">  vars_files: ./vars.yml</span><br><span class="line">  tasks:</span><br><span class="line">    - name: Output Vaiables</span><br><span class="line">      debug:</span><br><span class="line">        msg:</span><br><span class="line">          - <span class="string">&quot;&#123;&#123; web_packages &#125;&#125;&quot;</span></span><br><span class="line">          - <span class="string">&quot;&#123;&#123; ftp_packages &#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="在inventory中定义变量"><a href="#在inventory中定义变量" class="headerlink" title="在inventory中定义变量"></a>在inventory中定义变量</h3><p>定义主机变量和组变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/ansible/hosts</span><br><span class="line">[webserver]</span><br><span class="line">172.16.1.7 myid=1 state=master    <span class="comment"># 定义的主机变量</span></span><br><span class="line">172.16.1.8 myid=2 state=backup</span><br><span class="line"></span><br><span class="line">[webserver:vars]</span><br><span class="line">port=80  <span class="comment"># 定义组变量</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟配置文件</span></span><br><span class="line">cat ./files/test.conf.j2</span><br><span class="line">hostrole: &#123;&#123; state  &#125;&#125;</span><br><span class="line">myid: &#123;&#123; myid &#125;&#125;</span><br><span class="line">port: &#123;&#123; port &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据变量替换公共配置文件，使不同的主机有不同的配置</span></span><br><span class="line">cat f3.yml</span><br><span class="line">- hosts: webserver</span><br><span class="line">  gather_facts: <span class="literal">false</span></span><br><span class="line">  tasks:</span><br><span class="line">    - name: Output Vaiables</span><br><span class="line">      template:</span><br><span class="line">        src: ./files/test.conf.j2</span><br><span class="line">        dest: /tmp/test.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">ansible-playbook f3.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录每一台主机进行检查配置文件查看是否根据变换配置</span></span><br></pre></td></tr></table></figure>

<h4 id="host-vars定义变量"><a href="#host-vars定义变量" class="headerlink" title="host_vars定义变量"></a>host_vars定义变量</h4><p>在项目目录中创建 host_vars目录，然后在创建一个 文件，文件的文件名称要与 inventory 清单中的主机名 称要保持完全一致，如果是ip地址，则创建相同ip地址 的文件即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hosts文件改回去</span></span><br><span class="line">cat /etc/ansible/hosts</span><br><span class="line">[webserver]</span><br><span class="line">172.16.1.7</span><br><span class="line">172.16.1.8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在当前项目创建这个固定的目录</span></span><br><span class="line">mkdir host_vars</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对应的IP文件，写入变量内容</span></span><br><span class="line">cat host_vars/172.16.1.7</span><br><span class="line">state: MASTER</span><br><span class="line">myid: 10</span><br><span class="line"></span><br><span class="line">cat host_vars/172.16.1.8</span><br><span class="line">state: BACKUP</span><br><span class="line">myid: 20</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行上述 f3.yml</span></span><br><span class="line">ansible-playbook f3.yml</span><br></pre></td></tr></table></figure>

<h4 id="group-vars定义变量"><a href="#group-vars定义变量" class="headerlink" title="group_vars定义变量"></a><code>group_vars</code>定义变量</h4><p>在项目目录中创建 group_vars目录，然后在创建一 个文件，文件的文件名称要与 inventory 清单中的组名 称保持完全一致，但是系统提供了特殊的 all 组，也就说在 group_vars 目录下创建一个 all 文件，定义变量对所 有的主机组都生效</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/ansible/hosts</span><br><span class="line">[webserver]</span><br><span class="line">172.16.1.7</span><br><span class="line">172.16.1.8</span><br><span class="line"></span><br><span class="line">mkdir group_vars</span><br><span class="line"></span><br><span class="line">cat group_vars/webserver</span><br><span class="line">port: 8080</span><br><span class="line"></span><br><span class="line">ansible-playbook f3.yml</span><br></pre></td></tr></table></figure>

<h3 id="Playbook传递变量"><a href="#Playbook传递变量" class="headerlink" title="Playbook传递变量"></a><code>Playbook</code>传递变量</h3><p>在执行Playbook时，可以通过命令行 –extra-vars 或 - e 外置传参设定变量</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -f group_vars/webserver</span><br><span class="line"></span><br><span class="line"><span class="comment"># 传递单个变量</span></span><br><span class="line">ansible-playbook f3.yml  -e <span class="string">&quot;port=9090&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用多个 -e 拼接或者在一个 &quot;&quot; 内，可以使用这个方法运行不同的组定义不同的变量</span></span><br><span class="line">cat group_vars/all</span><br><span class="line">port: 8080</span><br><span class="line"></span><br><span class="line">cat f4.yml</span><br><span class="line">- hosts: <span class="string">&quot;&#123;&#123; host &#125;&#125;&quot;</span></span><br><span class="line">  gather_facts: <span class="literal">false</span></span><br><span class="line">  tasks:</span><br><span class="line">    - name: Output Vaiables</span><br><span class="line">      template:</span><br><span class="line">        src: ./files/test.conf.j2</span><br><span class="line">        dest: /tmp/test.conf</span><br><span class="line"></span><br><span class="line">ansible-playbook f4.yml  -e <span class="string">&quot;host=lb port=9090 state=MasTer myid=23&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="变量优先级"><a href="#变量优先级" class="headerlink" title="变量优先级"></a>变量优先级</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">定义相同的变量不同的值，来测试变量的优先级。操作步骤如下:</span><br><span class="line">1）在plabook中定义vars变量</span><br><span class="line">2）在playbook中定义vars_files变量</span><br><span class="line">3）在host_vars中定义变量</span><br><span class="line">4）在group_vars中定义变量</span><br><span class="line">5）通过执行命令传递变量</span><br><span class="line"></span><br><span class="line">结果(从高到低):</span><br><span class="line">命令行传参</span><br><span class="line">playbook中的vars_files</span><br><span class="line">playbook中的vars</span><br><span class="line">host_vars</span><br><span class="line">group_vars</span><br><span class="line">group_vars/all</span><br></pre></td></tr></table></figure>

<h3 id="使用变量改写NFS"><a href="#使用变量改写NFS" class="headerlink" title="使用变量改写NFS"></a>使用变量改写<code>NFS</code></h3><p>变量文件已经配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat exports.j2</span><br><span class="line">&#123;&#123; nfs_share_data &#125;&#125; (rw,all_squash,anonuid=&#123;&#123; nfs_uid &#125;&#125;,anongid=&#123;&#123; nfs_gid &#125;&#125;)</span><br><span class="line"></span><br><span class="line">cat nfs_variables.yml</span><br><span class="line">nfs_share_data: /fff</span><br><span class="line">nfs_uid: 5655</span><br><span class="line">nfs_gid: 5655</span><br><span class="line">nfs_group: dddd</span><br><span class="line">nfs_user: dddd</span><br></pre></td></tr></table></figure>

<p>playbook文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">nfs-server</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars_files:</span> <span class="string">./nfs_variables.yml</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="number">1.</span><span class="string">Install</span> <span class="string">NFS</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">yum:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nfs-utils</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="number">2.</span><span class="string">Configure</span> <span class="string">NFS</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">template:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">./exports.j2</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/etc/exports</span></span><br><span class="line">      <span class="attr">notify:</span> <span class="string">Restart</span> <span class="string">NFS</span> <span class="string">Server</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="number">3.</span><span class="string">Created</span> <span class="string">Group</span></span><br><span class="line">      <span class="attr">group:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; nfs_group &#125;&#125;</span>&quot;</span></span><br><span class="line">        <span class="attr">gid:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; nfs_gid &#125;&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="number">4.</span><span class="string">Created</span> <span class="string">User</span></span><br><span class="line">      <span class="attr">user:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; nfs_user &#125;&#125;</span>&quot;</span></span><br><span class="line">        <span class="attr">uid:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; nfs_uid &#125;&#125;</span>&quot;</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; nfs_group &#125;&#125;</span>&quot;</span></span><br><span class="line">        <span class="attr">shell:</span> <span class="string">/sbin/nologin</span></span><br><span class="line">        <span class="attr">create_home:</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="number">5.</span><span class="string">Init</span> <span class="string">Create</span>  <span class="string">Directory</span></span><br><span class="line">      <span class="attr">file:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; nfs_share_data &#125;&#125;</span>&quot;</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">directory</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; nfs_user &#125;&#125;</span>&quot;</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; nfs_group &#125;&#125;</span>&quot;</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">&quot;0755&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="number">6.</span><span class="string">Started</span> <span class="string">NFS</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">systemd:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nfs</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">started</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">handlers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restart</span> <span class="string">NFS</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">systemd:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nfs</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">restarted</span></span><br><span class="line">        </span><br><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">localhost</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">vars_files:</span> <span class="string">./nfs_variables.yml</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="number">7.</span><span class="string">Install</span> <span class="string">NFS</span> <span class="string">Cli</span></span><br><span class="line">      <span class="attr">yum:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nfs-utils</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="number">8</span><span class="string">.</span> <span class="string">Cli</span> <span class="string">Mount</span></span><br><span class="line">      <span class="attr">mount:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">&quot;192.168.100.7:<span class="template-variable">&#123;&#123; nfs_share_data &#125;&#125;</span>&quot;</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/mnt</span></span><br><span class="line">        <span class="attr">fstype:</span> <span class="string">nfs</span></span><br><span class="line">        <span class="attr">opts:</span> <span class="string">defaults</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">mounted</span></span><br></pre></td></tr></table></figure>

<h2 id="Ansible-Register"><a href="#Ansible-Register" class="headerlink" title="Ansible Register"></a><code>Ansible Register</code></h2><p>register 可以将 task 执行的任务结果存储至某个变 量中，便于后续的引用</p>
<p>输出命令的结果</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Get</span> <span class="string">Network</span> <span class="string">Port</span></span><br><span class="line">      <span class="attr">shell:</span> <span class="string">netstat</span> <span class="string">-lntp</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">System_Port</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">debug</span></span><br><span class="line">      <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&quot;执行了 <span class="template-variable">&#123;&#123; System_Port.cmd &#125;&#125;</span> 命令&quot;</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; System_Port.stdout_lines  &#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<p>批量修改随机主机名称</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">gather_facts:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">String</span></span><br><span class="line">      <span class="attr">shell:</span> <span class="string">echo</span> <span class="string">$RANDOM</span> <span class="string">|md5sum</span> <span class="string">|</span> <span class="string">cut</span> <span class="string">-c</span> <span class="number">2</span><span class="number">-10</span></span><br><span class="line">      <span class="attr">register:</span> <span class="string">systemd_sj</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">debug</span></span><br><span class="line">      <span class="attr">debug:</span></span><br><span class="line">        <span class="attr">msg:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; systemd_sj.stdout &#125;&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Chanage</span> <span class="string">Hostname</span></span><br><span class="line">      <span class="attr">hostname:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&quot;web_<span class="template-variable">&#123;&#123; systemd_sj.stdout &#125;&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="Facts-Variables"><a href="#Facts-Variables" class="headerlink" title=" Facts Variables"></a><code> Facts Variables</code></h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Ansible facts 变量主要用来自动采集，“被控端主机”自身的状态信息。 比如：被动端的，主机名、IP地址、系统版本、CPU数 量、内存状态、磁盘状态等等。</span><br><span class="line"></span><br><span class="line">使用场景:</span><br><span class="line">1.通过facts变量检查被控端硬件CPU信息，从而生成不同的Nginx配置文件</span><br><span class="line">2.通过facts变量检查被控端内存状态信息，从而生成不同的memcached的配置文件</span><br><span class="line">3.通过facts变量检查被控端主机名称信息，从而生成不同的Zabbix配置文件</span><br><span class="line">4.通过facts变量检查被控端主机IP地址信息，从而生成不同的redis配置文件</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可以获取被控端的主机信息</span></span><br><span class="line">ansible localhost -m setup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看被控端的hostname IP 系统类型，注：gather_facts 此时就不能为 false 了</span></span><br><span class="line">- hosts: web</span><br><span class="line">  tasks:</span><br><span class="line">    - name: Print msg</span><br><span class="line">      debug:</span><br><span class="line">        msg: <span class="string">&quot;&#123;&#123; ansible_nodename &#125;&#125; &#123;&#123; ansible_default_ipv4.address &#125;&#125; &#123;&#123; ansible_distribution &#125;&#125;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="根据主机地址IP生成配置"><a href="#根据主机地址IP生成配置" class="headerlink" title="根据主机地址IP生成配置"></a>根据主机地址IP生成配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat ./files/tes2t.conf.j2</span><br><span class="line">IP_Server: &#123;&#123; ansible_default_ipv4.address &#125;&#125;</span><br><span class="line"></span><br><span class="line">cat facts2.yml</span><br><span class="line">- hosts: web</span><br><span class="line">  tasks:</span><br><span class="line">    - name: Output Vaiables</span><br><span class="line">      template:</span><br><span class="line">        src: ./files/test2.conf.j2</span><br><span class="line">        dest: /tmp/test2.conf</span><br><span class="line"></span><br><span class="line">ansible-playbook facts2.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查web组内的每个主机查看 /tmp/test2.conf 是否按照IP生成了对应内容</span></span><br></pre></td></tr></table></figure>

<h3 id="批量修改主机名"><a href="#批量修改主机名" class="headerlink" title="批量修改主机名"></a>批量修改主机名</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat facts3.yml</span><br><span class="line">- hosts: web</span><br><span class="line">  tasks:</span><br><span class="line">    - name: Get msg</span><br><span class="line">      debug:</span><br><span class="line">        msg: <span class="string">&quot;&#123;&#123; ansible_default_ipv4.address &#125;&#125;&quot;</span></span><br><span class="line">        </span><br><span class="line">    - name: Change hostname</span><br><span class="line">      hostname: </span><br><span class="line">        name: <span class="string">&quot;web_&#123;&#123; ansible_default_ipv4.address.split(&#x27;.&#x27;)[-1] &#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">ansible-playbook facts3.yml</span><br></pre></td></tr></table></figure>

<h3 id="Redis缓存facts变量加速"><a href="#Redis缓存facts变量加速" class="headerlink" title="Redis缓存facts变量加速"></a><code>Redis</code>缓存<code>facts</code>变量加速</h3><p>当我们使用 gather_facts: no 关闭 facts，确实能加速 Ansible 执行，但是有时候又需要使用 facts 中的内容，还希望执行的速度快一点，这时候可以设置facts 的缓存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[defaults]</span><br><span class="line"><span class="comment"># smart 表示默认收集 facts，但 facts 已有的情况下不会收集，即使用缓存 facts</span></span><br><span class="line"><span class="comment"># implicit 表示默认收集 facts，要禁止收集，必须使用 gather_facts: False；</span></span><br><span class="line"><span class="comment"># explicit 则表示默认不收集，要显式收集，必须使用gather_facts: Ture</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#在使用 facts 缓存时设置为smart</span></span><br><span class="line">gathering = smart</span><br><span class="line">fact_caching_timeout = 86400</span><br><span class="line">fact_caching = redis</span><br><span class="line">fact_caching_connection = 172.16.1.41:6379:1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 若 redis 设置了密码</span></span><br><span class="line"><span class="comment"># fact_caching_connection =172.16.1.41:6379:1:passwd  1 库</span></span><br><span class="line"><span class="comment"># 整体性能可以提升二到三倍以上</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>Playbook使用</title>
    <url>/c3cdc4c2.html</url>
    <content><![CDATA[<h2 id="Playbook入门"><a href="#Playbook入门" class="headerlink" title="Playbook入门"></a><code>Playbook</code>入门</h2><h3 id="Playbook简介"><a href="#Playbook简介" class="headerlink" title="Playbook简介"></a>Playbook简介</h3><span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">playbook 是一个由 yml 语法编写的文本文件，它由 play 和 task 两部分组成</span><br><span class="line">play:主要定义要操作主机或者主机组</span><br><span class="line">task:主要定义对主机或主机组具体执行的任务，可以是一个任务，也可以是多个任务（模块）</span><br><span class="line"></span><br><span class="line">总结: playbook 是由一个或多个 play 组成，一个play 可以包含多个 task 任务，</span><br><span class="line">可以理解为: 使用多个不同的模块来共同完成一件事情</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20220106100622359.png" alt="image-20220106100622359"></p>
<h3 id="Playbook与Ad-hoc"><a href="#Playbook与Ad-hoc" class="headerlink" title="Playbook与Ad-hoc"></a><code>Playbook</code>与<code>Ad-hoc</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1) playbook 是对 AD-Hoc 的一种编排方式</span><br><span class="line">2) playbook 可以持久运行，而 Ad-Hoc 只能临时运行</span><br><span class="line">3) playbook 适合复杂的任务，而 Ad-Hoc 适合做快速简单的任务</span><br><span class="line">4) playbook 能控制任务执行的先后顺序</span><br></pre></td></tr></table></figure>

<h3 id="Playbook格式"><a href="#Playbook格式" class="headerlink" title="Playbook格式"></a><code>Playbook</code>格式</h3><p>playbook 是由 yml 语法书写，结构清晰，可读性强， 所以必须掌握 yml 语法</p>
<table>
<thead>
<tr>
<th>语法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>缩 进</td>
<td>YAML使用固定的缩进风格表示层级结构,每个缩进由两个空格组成, 不能使用tab</td>
</tr>
<tr>
<td>冒 号</td>
<td>以冒号结尾的除外，其他所有冒号后面所有必须 有空格</td>
</tr>
<tr>
<td>短 横 线</td>
<td>表示列表项，使用一个短横杠加一个空格，多个项使用同样的缩进级别作为同一列表</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">host: 对哪些主机进行操作</span><br><span class="line">remote_user: 我要使用什么用户执行</span><br><span class="line">tasks: 具体执行什么任务</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示playbook执行时间</span></span><br><span class="line">ansible2.0以上的版本需要在ansible.cfg中加入</span><br><span class="line">callback_whitelist = profile_tasks</span><br></pre></td></tr></table></figure>
<p>安装nginx的playbook，install-nginx.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">all</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Nginx</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">yum:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Systemd</span> <span class="string">Nginx</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">systemd:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">started</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>

<h3 id="执行方式"><a href="#执行方式" class="headerlink" title="执行方式"></a>执行方式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible-playbook --syntax-check install-nginx.yml   <span class="comment"># 检查语法</span></span><br><span class="line">ansible-playbook -C install-nginx.yml         <span class="comment"># 模拟执行</span></span><br><span class="line">ansible-playbook install-nginx.yml            <span class="comment"># 真实执行</span></span><br><span class="line"></span><br><span class="line">执行playbook，注意观察执行返回的状态颜色:</span><br><span class="line">红色：表示有task执行失败，通常都会提示错误信息</span><br><span class="line">黄色：表示远程主机按照编排的任务执行且进行了改变</span><br><span class="line">绿色：表示该主机已经是描述后的状态，无需在次运行</span><br></pre></td></tr></table></figure>

<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><h4 id="部署NFS"><a href="#部署NFS" class="headerlink" title="部署NFS"></a>部署<code>NFS</code></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat exports.j2</span><br><span class="line">/ansible_test (rw,all_squash,anonuid=7777,anongid=7777)</span><br></pre></td></tr></table></figure>

<p><code>install-yaml</code>文件内容:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">nfs-server</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="number">1.</span><span class="string">Install</span> <span class="string">NFS</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">yum:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nfs-utils</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="number">2.</span><span class="string">Configure</span> <span class="string">NFS</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">copy:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">./exports.j2</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/etc/exports</span></span><br><span class="line">      <span class="comment"># 定义触发器</span></span><br><span class="line">      <span class="attr">notify:</span> <span class="string">Restart</span> <span class="string">NFS</span> <span class="string">Server</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="number">3.</span><span class="string">Created</span> <span class="string">Group</span></span><br><span class="line">      <span class="attr">group:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">bbb</span></span><br><span class="line">        <span class="attr">gid:</span> <span class="number">7777</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="number">4.</span><span class="string">Created</span> <span class="string">User</span></span><br><span class="line">      <span class="attr">user:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">bbb</span></span><br><span class="line">        <span class="attr">uid:</span> <span class="number">7777</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">bbb</span></span><br><span class="line">        <span class="attr">shell:</span> <span class="string">/sbin/nologin</span></span><br><span class="line">        <span class="attr">create_home:</span> <span class="literal">no</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="number">5.</span><span class="string">Init</span> <span class="string">Create</span>  <span class="string">Directory</span></span><br><span class="line">      <span class="attr">file:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/ansible_test</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">directory</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">bbb</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">bbb</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="string">&quot;0755&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="number">6.</span><span class="string">Started</span> <span class="string">NFS</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">systemd:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nfs</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">started</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">handlers:</span></span><br><span class="line">    <span class="comment"># 激活触发器,进行重启nfs，因为nfs服务如果在启动状态的话就不会再启动</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restart</span> <span class="string">NFS</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">systemd:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nfs</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure>

<h4 id="部署Rsync"><a href="#部署Rsync" class="headerlink" title="部署Rsync"></a>部署<code>Rsync</code></h4><p><code>rsyncd.conf.j2</code>文件内容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uid = ansible_www</span><br><span class="line">gid = ansible_www</span><br><span class="line">port = 873</span><br><span class="line">fake super = yes</span><br><span class="line">use chroot = no</span><br><span class="line">max connections = 200</span><br><span class="line">timeout = 600</span><br><span class="line"><span class="comment">#ignore errors</span></span><br><span class="line"><span class="built_in">read</span> only = <span class="literal">false</span></span><br><span class="line">list = <span class="literal">false</span></span><br><span class="line">auth users = rsync_backup</span><br><span class="line">secrets file = /etc/rsync.passwd</span><br><span class="line"><span class="built_in">log</span> file = /var/<span class="built_in">log</span>/rsyncd.log</span><br><span class="line"><span class="comment">#####################################</span></span><br><span class="line">[backup]</span><br><span class="line">path = /backup=</span><br></pre></td></tr></table></figure>

<p><code>install-rsync.yml</code>文件内容</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">rsync-server</span></span><br><span class="line">  <span class="attr">tasks:</span> </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Rsync</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">yum:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">rsync</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">        </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configure</span> <span class="string">Rsync</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">copy:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">./rsyncd.conf.j2</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/etc/rsyncd.conf</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="number">0644</span></span><br><span class="line">      <span class="attr">notify:</span> <span class="string">Restart</span> <span class="string">Rsync</span> <span class="string">Server</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Init</span> <span class="string">Group</span></span><br><span class="line">      <span class="attr">group:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">ansible_www</span></span><br><span class="line">        <span class="attr">gid:</span> <span class="number">8888</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Init</span> <span class="string">User</span></span><br><span class="line">      <span class="attr">user:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">ansible_www</span></span><br><span class="line">        <span class="attr">uid:</span> <span class="number">8888</span></span><br><span class="line">        <span class="attr">shell:</span> <span class="string">/sbin/nologin</span></span><br><span class="line">        <span class="attr">create_home:</span> <span class="literal">no</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Init</span> <span class="string">Create</span> <span class="string">Directory</span></span><br><span class="line">      <span class="attr">file:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/backup</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">ansible_www</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">ansible_www</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="number">0755</span></span><br><span class="line">        <span class="attr">recurse:</span> <span class="literal">yes</span></span><br><span class="line">        </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Init</span> <span class="string">Rsync</span> <span class="string">Server</span> <span class="string">Virtual</span> <span class="string">User</span> <span class="string">Passwd</span> <span class="string">file</span></span><br><span class="line">      <span class="attr">copy:</span></span><br><span class="line">        <span class="attr">content:</span> <span class="string">&quot;rsync_backup:123456&quot;</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/etc/rsync.passwd</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="number">0600</span></span><br><span class="line">      <span class="attr">notify:</span> <span class="string">Restart</span> <span class="string">Rsync</span> <span class="string">Server</span></span><br><span class="line">  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Started</span> <span class="string">Rsync</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">systemd:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">rsyncd</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">started</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">yes</span></span><br><span class="line"> </span><br><span class="line">  <span class="attr">handlers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restart</span> <span class="string">Rsync</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">systemd:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">rsyncd</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure>

<p>测试是否成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync -avz exports.j2 rsync_backup@192.168.0.12::backup</span><br></pre></td></tr></table></figure>

<h4 id="部署Redis"><a href="#部署Redis" class="headerlink" title="部署Redis"></a>部署<code>Redis</code></h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">redis</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line">  </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Redis</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">yum:</span> </span><br><span class="line">        <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line">        </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configure</span> <span class="string">Redis</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">copy:</span> </span><br><span class="line">        <span class="attr">src:</span> <span class="string">./files/redis.conf.j2</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/etc/redis.conf</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">redis</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="number">0640</span></span><br><span class="line">      <span class="attr">notify:</span> <span class="string">Restart</span> <span class="string">Redis</span> <span class="string">Server</span></span><br><span class="line">      </span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Systemd</span> <span class="string">Redis</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">systemd:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">redis</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">started</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">yes</span></span><br><span class="line">        </span><br><span class="line">  <span class="attr">handlers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restart</span> <span class="string">Redis</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">systemd:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">Redis</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure>

<h4 id="部署Nginx-PHP"><a href="#部署Nginx-PHP" class="headerlink" title="部署Nginx+PHP"></a>部署<code>Nginx+PHP</code></h4><p><code>PHP</code>源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible web -m shell -a <span class="string">&quot;rpm -Uvh https://mirror.webtatic.com/yum/el7/epel-release.rpm&quot;</span></span><br><span class="line">ansible web -m shell -a <span class="string">&quot;rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm&quot;</span></span><br><span class="line">ansible web -m shell -a <span class="string">&quot;yum makecache&quot;</span></span><br></pre></td></tr></table></figure>

<p><code>nginx+php</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">hosts:</span> <span class="string">webservers</span></span><br><span class="line">  <span class="attr">tasks:</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Installed</span> <span class="string">Nginx</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">yum:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">present</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Installed</span> <span class="string">PHP</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">yum:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">&quot;<span class="template-variable">&#123;&#123; pack &#125;&#125;</span>&quot;</span></span><br><span class="line">      <span class="attr">vars:</span></span><br><span class="line">        <span class="attr">pack:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">php71w-fpm</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">php71w-gd</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">php71w-mbstring</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">php71w-mcrypt</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">php71w-mysqlnd</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">php71w-opcache</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">php71w-pdo</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">php71w-pear</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">php71w-pecl-igbinary</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">php71w-pecl-memcached</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">mod_php71w</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">php71w-pecl-mongodb</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">php71w-pecl-redis</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">php71w-cli</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">php71w-process</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">php71w-common</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">php71w-xml</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">php71w-devel</span></span><br><span class="line">          <span class="bullet">-</span> <span class="string">php71w-embedded</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># nginx</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Configure</span> <span class="string">Nginx</span> <span class="string">nginx.conf</span></span><br><span class="line">      <span class="attr">copy:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">files/nginx.conf.j2</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/etc/nginx/nginx.conf</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="number">0644</span></span><br><span class="line">      <span class="attr">notify:</span> <span class="string">Restart</span> <span class="string">Nginx</span> <span class="string">Server</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Create</span> <span class="string">Group</span> <span class="string">www</span></span><br><span class="line">      <span class="attr">group:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">        <span class="attr">gid:</span> <span class="number">666</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Create</span> <span class="string">User</span> <span class="string">www</span></span><br><span class="line">      <span class="attr">user:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">www</span></span><br><span class="line">        <span class="attr">uid:</span> <span class="number">666</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">www</span></span><br><span class="line">        <span class="attr">create_home:</span> <span class="literal">no</span></span><br><span class="line">        <span class="attr">shell:</span> <span class="string">/sbin/nologin</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Started</span> <span class="string">Nginx</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">systemd:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">started</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># php</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Confgiure</span> <span class="string">PHP</span> <span class="string">Server</span> <span class="string">php.ini</span></span><br><span class="line">      <span class="attr">copy:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">./files/php.ini.j2</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/etc/php.ini</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="number">0644</span></span><br><span class="line">      <span class="attr">notify:</span> <span class="string">Restart</span> <span class="string">PHP</span> <span class="string">Server</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Confgiure</span> <span class="string">PHP</span> <span class="string">Server</span> <span class="string">php-fpm.d/www.conf</span></span><br><span class="line">      <span class="attr">copy:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">./files/php-fpm.www.conf.j2</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/etc/php-fpm.d/www.conf</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="number">0644</span></span><br><span class="line">      <span class="attr">notify:</span> <span class="string">Restart</span> <span class="string">PHP</span> <span class="string">Server</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Started</span> <span class="string">PHP</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">systemd:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">php-fpm</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">started</span></span><br><span class="line">        <span class="attr">enabled:</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># code</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Copy</span> <span class="string">Nginx</span> <span class="string">Virtual</span> <span class="string">Site</span> </span><br><span class="line">      <span class="attr">copy:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">./files/ansible.oldxu.net.conf.j2</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/etc/nginx/conf.d/ansible.oldxu.net.conf</span></span><br><span class="line">      <span class="attr">notify:</span> <span class="string">Restart</span> <span class="string">Nginx</span> <span class="string">Server</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Create</span> <span class="string">Ansible</span> <span class="string">Directory</span></span><br><span class="line">      <span class="attr">file:</span></span><br><span class="line">        <span class="attr">path:</span> <span class="string">/ansible</span></span><br><span class="line">        <span class="attr">owner:</span> <span class="string">www</span></span><br><span class="line">        <span class="attr">group:</span> <span class="string">www</span></span><br><span class="line">        <span class="attr">mode:</span> <span class="number">0755</span></span><br><span class="line">        <span class="attr">recurse:</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Unarchive</span> <span class="string">PHP</span> <span class="string">Code</span></span><br><span class="line">      <span class="attr">unarchive:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">files/phpMyAdmin-5.1.1-all-languages.zip</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/ansible/</span></span><br><span class="line">        <span class="attr">creates:</span> <span class="string">/ansible/phpMyAdmin-5.1.1-all-languages/config.inc.php</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Create</span> <span class="string">Link</span></span><br><span class="line">      <span class="attr">file:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">/ansible/phpMyAdmin-5.1.1-all-languages/</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/ansible/phpmyadmin</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">link</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Change</span> <span class="string">phpmyadmin</span> <span class="string">Configure</span> </span><br><span class="line">      <span class="attr">copy:</span></span><br><span class="line">        <span class="attr">src:</span> <span class="string">./files/config.inc.php.j2</span></span><br><span class="line">        <span class="attr">dest:</span> <span class="string">/ansible/phpmyadmin/config.inc.php</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">handlers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restart</span> <span class="string">Nginx</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">systemd:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">restarted</span></span><br><span class="line"></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Restart</span> <span class="string">PHP</span> <span class="string">Server</span></span><br><span class="line">      <span class="attr">systemd:</span></span><br><span class="line">        <span class="attr">name:</span> <span class="string">php-fpm</span></span><br><span class="line">        <span class="attr">state:</span> <span class="string">restarted</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible常用模块</title>
    <url>/6beab3d3.html</url>
    <content><![CDATA[<h2 id="ad-hoc与常用模块"><a href="#ad-hoc与常用模块" class="headerlink" title="ad-hoc与常用模块"></a><code>ad-hoc</code>与常用模块</h2><p><code>ad-hoc</code>就是临时命令，执行完成即结束，并不会保存</p>
<p>可以查看多台节点是的进程是否存在</p>
<p>拷贝指定文件至本地</p>
<span id="more"></span>
<h3 id="使用范例"><a href="#使用范例" class="headerlink" title="使用范例"></a>使用范例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ansible &#x27;groups&#x27; -m command -a &quot;df -h&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20220103175305795.png" alt="image-20220103175305795"></p>
<h3 id="ad-hoc执行过程"><a href="#ad-hoc执行过程" class="headerlink" title="ad-hoc执行过程"></a><code>ad-hoc</code>执行过程</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.加载配置文件，默认 /etc/ansible/ansible.cfg</span><br><span class="line">2.读取inventory</span><br><span class="line">3.操作对应的目标主机组；如果组不存在则报错</span><br><span class="line">4.构建对应的py文件，推送到远程目标主机</span><br><span class="line">5.远程主机执行该文件</span><br><span class="line">6.执行完成后，删除对应的py文件</span><br><span class="line">7.像服务端返回最终执行结果</span><br></pre></td></tr></table></figure>

<h3 id="执行状态"><a href="#执行状态" class="headerlink" title="执行状态"></a>执行状态</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">返回结果的颜色说明</span><br><span class="line">绿色: 代表被管理端主机没有被修改</span><br><span class="line">黄色: 代表被管理端主机发现变更</span><br><span class="line">红色: 代表出现了故障，注意查看提示</span><br></pre></td></tr></table></figure>

<h3 id="单独项目使用ansible"><a href="#单独项目使用ansible" class="headerlink" title="单独项目使用ansible"></a>单独项目使用<code>ansible</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建项目</span></span><br><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">mkdir project1</span><br><span class="line"><span class="built_in">cd</span> project1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目配置文件和主机文件</span></span><br><span class="line">cp /etc/ansible/ansible.cfg .</span><br><span class="line">cp /etc/ansible/hosts  hosts_group</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line">vim ansible.cfg</span><br><span class="line">...</span><br><span class="line">inventory      = ./hosts_group</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看读取的配置文件</span></span><br><span class="line">ansible --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行</span></span><br><span class="line">ansible all -m ping</span><br></pre></td></tr></table></figure>

<h2 id="Ansible常用模块"><a href="#Ansible常用模块" class="headerlink" title="Ansible常用模块"></a><code>Ansible</code>常用模块</h2><p>常用模块较多，可以使用<code>ansible-doc  模块名</code>查看帮助</p>
<h3 id="command模块"><a href="#command模块" class="headerlink" title="command模块"></a>command模块</h3><p>功能：在远程主机执行shell命令，是一个默认模块，可以忽略参数 <code>-m</code>，但是不支持管道命令 <code>|</code></p>
<table>
<thead>
<tr>
<th>参数</th>
<th>选项</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>chdir</td>
<td>chdir /opt</td>
<td>执行ansible时，切换到指定的目录</td>
</tr>
<tr>
<td>creates</td>
<td>creates /data/file</td>
<td>如果文件在，则跳过执行</td>
</tr>
<tr>
<td>removes</td>
<td>removes /data/file</td>
<td>如果文件存在，则执行</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当 /data/opt 不存在时，就会执行 ifconfig eth0 命令</span></span><br><span class="line">ansible all -m <span class="built_in">command</span> -a <span class="string">&quot;creates=/data/opt ifconfig eth0&quot;</span></span><br><span class="line"><span class="comment"># 备份: 如果备份的文件存在，则不执行备份的命令；如果文件不存在，则执行备份的命令</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 /data/opt 存在时，就会执行 ifconfig eth0 命令</span></span><br><span class="line">ansible all -m <span class="built_in">command</span> -a <span class="string">&quot;removes=/data/opt ifconfig eth0&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="shell模块"><a href="#shell模块" class="headerlink" title="shell模块"></a><code>shell</code>模块</h3><p>command支持在这个模块一样能执行，被控端已有的<code>shell</code>命令都可以执行，且支持管道</p>
<h3 id="yum模块"><a href="#yum模块" class="headerlink" title="yum模块"></a><code>yum</code>模块</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name:  <span class="comment"># 软件包名称</span></span><br><span class="line">  state: <span class="comment"># 状态</span></span><br><span class="line">		present <span class="comment"># 安装</span></span><br><span class="line">		absent <span class="comment"># 删除</span></span><br><span class="line">		latest <span class="comment"># 最新版</span></span><br><span class="line">		</span><br><span class="line">enablerepo  <span class="comment"># 通过哪个仓库获取</span></span><br><span class="line">disablerepo  <span class="comment"># 不使用哪些仓库的包</span></span><br><span class="line">excludekernel  <span class="comment"># kernel排除</span></span><br></pre></td></tr></table></figure>

<p>使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.安装vsftpd软件包</span></span><br><span class="line">ansible all -m yum -a <span class="string">&#x27;name=vsftpd state=present&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.删除vsftpd</span></span><br><span class="line">ansible all -m yum -a <span class="string">&#x27;name=vsftpd state=absent&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.安装httpd服务，必须从epel仓库中安装(所有的被控都有这个epel仓库)</span></span><br><span class="line">ansible all -m yum -a <span class="string">&#x27;name=httpd state=present enablerepo=epel&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.更新所有的软件包，唯独kernel程序不更新</span></span><br><span class="line">ansible all -m yum -a <span class="string">&#x27;name=* state=present exclude=&quot;kernel*&quot;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="copy模块"><a href="#copy模块" class="headerlink" title="copy模块"></a><code>copy</code>模块</h3><p>控制端的文件，拷贝到被控端，实现替换</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">src:      控制端的源文件路径</span><br><span class="line">dest:     被控端的文件路径</span><br><span class="line">owner:    属主</span><br><span class="line">group:    属组</span><br><span class="line">mode:     权限</span><br><span class="line">backup：   备份</span><br><span class="line">validate： 验证</span><br><span class="line">content:   往一个文件写入内容</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.更新nfs配置，将控制端的 exports.j2 文件同步到被控端的 /etc/exports </span></span><br><span class="line">ansible all -m copy -a <span class="string">&#x27;src=./exports.j2 dest=/etc/exports owner=root group=root mode=0644 backup=yes&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.往一个文件中写入内容，如果文件不存在则创建</span></span><br><span class="line">ansible all -m copy -a <span class="string">&#x27;content=&quot;123&quot; dest=/data/test.txt owner=root group=root mode=&quot;0600&quot; backup=yes&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.验证sudo配置是否正确(adhoc测试失败)：</span></span><br><span class="line">cat tt.yaml </span><br><span class="line">- hosts: all</span><br><span class="line">  tasks:</span><br><span class="line">  - name: Copy a <span class="string">&quot;sudoers&quot;</span> file on the remote machine <span class="keyword">for</span> editing</span><br><span class="line">    copy:</span><br><span class="line">      src: ./sudoers</span><br><span class="line">      dest: /etc/sudoers</span><br><span class="line">      validate: /usr/sbin/visudo -csf %s</span><br><span class="line"></span><br><span class="line">ansible-ploybook tt.yamy</span><br></pre></td></tr></table></figure>

<h3 id="systemd模块"><a href="#systemd模块" class="headerlink" title="systemd模块"></a><code>systemd</code>模块</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name                <span class="comment"># 服务名称</span></span><br><span class="line">state               <span class="comment"># 服务状态</span></span><br><span class="line">  started           <span class="comment"># 启动</span></span><br><span class="line">  stopped           <span class="comment"># 停止</span></span><br><span class="line">  restarted         <span class="comment"># 重启</span></span><br><span class="line">  reloaded          <span class="comment"># 重载</span></span><br><span class="line">enabled              <span class="comment"># 开启自启动</span></span><br><span class="line">daemon_reload: yes  <span class="comment"># 重新刷新daemon-reload</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动nfs并设置开机自启</span></span><br><span class="line">ansible all -m systemd -a <span class="string">&quot;name=nfs state=started enabled=yes&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止nfs并关闭开机自启动</span></span><br><span class="line">ansible all -m systemd -a <span class="string">&quot;name=nfs state=stopped enabled=no&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="file模块"><a href="#file模块" class="headerlink" title="file模块"></a><code>file</code>模块</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建文件、创建目录、授权</span></span><br><span class="line">  file:</span><br><span class="line">    path: 		在被控端创建的路径</span><br><span class="line">    owner: 		属主</span><br><span class="line">    group: 		属组</span><br><span class="line">    mode: 		权限</span><br><span class="line">	state: 		  类型</span><br><span class="line">		touch:    文件</span><br><span class="line">		directory： 目录</span><br><span class="line">		link: 软链接</span><br><span class="line">		hard：硬链接</span><br><span class="line">	recurse： yes 递归授权</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line"><span class="comment"># 被控端需要有 www 用户</span></span><br><span class="line">gropuadd -g 888 www</span><br><span class="line">useradd -u 888 -g 888 www</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个/data/www 目录，授权为 www 身份</span></span><br><span class="line">ansible webservers -m file -a <span class="string">&#x27;path=/data/www owner=www group=www mode=&quot;0755&quot; state=directory recurse=yes&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在 /data/www/ 目录中创建一个文件</span></span><br><span class="line">ansible webservers -m file -a <span class="string">&#x27;path=/data/www/books.html owner=www group=www mode=&quot;0644&quot; state=touch&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="group模块"><a href="#group模块" class="headerlink" title="group模块"></a><code>group</code>模块</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name: 指定组名称</span><br><span class="line">  gid： 指定gid</span><br><span class="line">	state:</span><br><span class="line">		present：创建  默认</span><br><span class="line">		absent：删除</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line"><span class="comment"># 指定 gid 为 666 创建 www 组</span></span><br><span class="line">ansible webservers -m group -a <span class="string">&#x27;name=www gid=666 state=present&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 mysqldb 组为系统的 gid</span></span><br><span class="line">ansible webservers -m group -a <span class="string">&#x27;name=mysqldb system=yes state=present&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="user模块"><a href="#user模块" class="headerlink" title="user模块"></a><code>user</code>模块</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user:</span><br><span class="line">  name: 				创建的名称</span><br><span class="line">  uid: 				  指定uid</span><br><span class="line">  group: 				指定基本组</span><br><span class="line">  shell: 				登录shell类型默认/bin/bash</span><br><span class="line">  create_home		是否创建家目录</span><br><span class="line">	password			设定对应的密码，必须是加密后的字符串才行，否则不生效；</span><br><span class="line">	system				系统用户</span><br><span class="line"></span><br><span class="line">	groups: admins,dev  附加组</span><br><span class="line">	append: yes			追加</span><br><span class="line"></span><br><span class="line">  state: absent		删除</span><br><span class="line">  remove: yes			家目录一起结束</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 www 用户，指定 uid 666，基本组 www ，不创建家目录</span></span><br><span class="line">ansible webservers -m user -a <span class="string">&#x27;name=www uid=666 group=www shell=/sbin/nologin create_home=no&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建db用户，基本组是root，附加组，adm，sys</span></span><br><span class="line">ansible webservers -m user -a <span class="string">&#x27;name=db group=root groups=adm,sys append=yes shell=/bin/bash create_home=yes&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个ddd用户，密码123，需要正常登录系统</span></span><br><span class="line"><span class="comment"># 生成密码</span></span><br><span class="line">ansible localhost -m debug -a <span class="string">&quot;msg=&#123;&#123; &#x27;123&#x27; | password_hash(&#x27;sha512&#x27;,&#x27;salt&#x27;)&#125;&#125;&quot;</span></span><br><span class="line"></span><br><span class="line">ansible webservers -m user -a <span class="string">&#x27;name=ddd password=$6$salt$jkHSO0tOjmLW0S1NFlw5veSIDRAVsiQQMTrkOKy4xdCCLPNIsHhZkIRlzfzIvKyXeGdOfCBoW1wJZPLyQ9Qx/1 shell=/bin/bash create_home=yes&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个dev用户，并为其生成对应的秘钥</span></span><br><span class="line">ansible webservers -m user -a <span class="string">&#x27;name=dev generate_ssh_key=yes ssh_key_bits=2048 ssh_key_file=.ssh/id_rsa&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="mount模块"><a href="#mount模块" class="headerlink" title="mount模块"></a><code>mount</code>模块</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">src: 源设备路径，或网络地址；</span><br><span class="line">  path: 挂载至本地哪个路径下；</span><br><span class="line">  fstype: 设备类型； nfs</span><br><span class="line">  opts:   挂载的选项</span><br><span class="line">  state:  挂载还是卸载</span><br><span class="line">    present			永久挂载，但没有立即生效</span><br><span class="line">    absent			卸载，临时挂载+永久挂载</span><br><span class="line">    mounted			临时(fstab)挂载</span><br><span class="line">    unmounted		临时卸载</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 172.16.1.7 的 /data 目录挂载到 172.16.1.8 /mnt 目录</span></span><br><span class="line">ansible 172.16.1.8 -m mount -a <span class="string">&#x27;src=172.16.1.7:/data path=/opt fstype=nfs opts=defaults state=mounted&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="cron模块"><a href="#cron模块" class="headerlink" title="cron模块"></a><code>cron</code>模块</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">name: 		 描述信息，描述脚本的作用</span><br><span class="line">minute: 	 分钟</span><br><span class="line">hour:		   小时</span><br><span class="line">weekday:	 周</span><br><span class="line">user:		   该任务由哪个用户取运行；默认root</span><br><span class="line">job: 		   任务</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 每天凌晨3点执行 /bin/bash /scripts/client_push_data_server.sh &amp;&gt;/dev/null</span></span><br><span class="line">ansible webservers -m cron -a <span class="string">&#x27;name=&quot;backups app data scripts&quot; hour=03 minute=00 job=&quot;/bin/bash /scripts/client_push_data_server.sh &amp;&gt;/dev/null&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除 backups app data script  执行</span></span><br><span class="line">ansible webservers -m cron -a <span class="string">&#x27;name=&quot;backups app data scripts&quot; hour=03 minute=00 job=&quot;/bin/bash /scripts/client_push_data_server.sh &amp;&gt;/dev/null&quot; state=absent&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 注释 backups app data script  执行</span></span><br><span class="line">ansible webservers -m cron -a <span class="string">&#x27;name=&quot;backups app data scripts&quot; hour=03 minute=00 job=&quot;/bin/bash /scripts/client_push_data_server.sh &amp;&gt;/dev/null&quot; disabled=yes&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="get-url"><a href="#get-url" class="headerlink" title="get_url"></a><code>get_url</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">get_url:</span><br><span class="line">  url: 下载地址</span><br><span class="line">  dest: 下载到本地的路径；</span><br><span class="line">  mode: 权限；</span><br><span class="line">  checksum：对资源做校验；</span><br><span class="line"></span><br><span class="line"><span class="comment"># 下载一个资源到本地/tmp目录；</span></span><br><span class="line">ansible webservers -m get_url -a <span class="string">&#x27;url=http://nginx.org/download/nginx-1.20.2.tar.gz dest=/tmp mode=0666&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对下载的资源做验证：</span></span><br><span class="line">ansible webservers -m get_url -a <span class="string">&#x27;url=http://nginx.org/download/nginx-1.20.2.tar.gz dest=/opt mode=0666 checksum=md5:3bcc5ccdc052c35d0d3c5557cf56c7d2&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="unarchive模块"><a href="#unarchive模块" class="headerlink" title="unarchive模块"></a><code>unarchive</code>模块</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># unarchive解压</span></span><br><span class="line">unarchive:</span><br><span class="line">  src: 			  控制端的源文件</span><br><span class="line">  dest: 			解压到被控端的路径</span><br><span class="line">remote_src: yes	源文本是否在被控端，yes则在，no则不在</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将控制端的压缩包，解压到被控端 remote_src: no</span></span><br><span class="line">ansible webservers -m unarchive -a <span class="string">&#x27;src=./test.tar.gz dest=/mnt&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将被控端的压缩包解压到被控端  remote_src: yes   config_vpn_new.zip</span></span><br><span class="line">ansible webservers -m unarchive -a <span class="string">&#x27;src=/tmp/test.tar.gz dest=/mnt remote_src=yes&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># archive 压缩</span></span><br><span class="line"><span class="comment"># 将被控端的/opt 打包到 /mnt 目录下，并命名为 opt.tar.gz </span></span><br><span class="line">ansible webservers -m archive -a <span class="string">&#x27;path=/opt dest=/mnt/opt.tar.gz format=gz&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="selinux模块"><a href="#selinux模块" class="headerlink" title="selinux模块"></a><code>selinux</code>模块</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">selinux 防火墙模块：</span><br><span class="line">ansible webservers -m selinux -a <span class="string">&#x27;state=disabled&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="firewalld模块"><a href="#firewalld模块" class="headerlink" title="firewalld模块"></a><code>firewalld</code>模块</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">zone：		要操作的区域  默认public</span><br><span class="line">	<span class="built_in">source</span>：	来源地址</span><br><span class="line">    service: 	 服务名称 http,https,sshd,......</span><br><span class="line">	port:		端口</span><br><span class="line">    permanent:	永久生效，但不会立即生效</span><br><span class="line">	immediate：	临时生效；</span><br><span class="line">    state: 		启用和关闭；</span><br><span class="line">		disabled</span><br><span class="line">		enabled</span><br><span class="line"></span><br><span class="line"><span class="comment"># 让被控端都放行80端口；</span></span><br><span class="line">ansible webservers -m systemd -a <span class="string">&#x27;name=firewalld state=started&#x27;</span></span><br><span class="line">ansible webservers -m firewalld -a <span class="string">&#x27;port=80/tcp immediate=yes state=present&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 让被控端都放行https端口；</span></span><br><span class="line">ansible webservers -m systemd -a <span class="string">&#x27;name=firewalld state=started&#x27;</span></span><br><span class="line">ansible webservers -m firewalld -a <span class="string">&#x27;service=https immediate=yes state=present&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="iptables"><a href="#iptables" class="headerlink" title="iptables"></a><code>iptables</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables:</span><br><span class="line">	table: 					  表</span><br><span class="line">    chain: 					链</span><br><span class="line">    <span class="built_in">source</span>: 				来源IP</span><br><span class="line">	destination				目标IP</span><br><span class="line">	destination_port  目标端口</span><br><span class="line">	protocol	协议</span><br><span class="line">    jump: DROP	动作</span><br><span class="line">	action		如何添加规则</span><br><span class="line">		insert：插入</span><br><span class="line">		append：追加</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 来源IP是192.168.1.1 目标地址 1.1.1.1 目标端口 80  协议 tcp  则拒绝； 规则要写入第一行；</span></span><br><span class="line">ansible webservers -m iptables -a <span class="string">&#x27;table=filter chain=INPUT source=192.168.1.1/32 destination=1.1.1.1 destination_port=80 protocol=tcp jump=DROP action=insert&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># NAT：SNAT和DNAT：</span></span><br><span class="line">	DNAT： 如果请求1.1.1:80端口，则DNAT到2.2.2.2:8800</span><br><span class="line">	ansible webservers -m iptables -a <span class="string">&#x27;table=nat chain=PREROUTING protocol=tcp destination=1.1.1.1 destination_port=80 jump=DNAT to_destination=&quot;2.2.2.2:8800&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line">	DNAT： 如果请求1.1.1:81端口，则DNAT到3.3.3.3:8800</span><br><span class="line">	ansible webservers -m iptables -a <span class="string">&#x27;table=nat chain=PREROUTING protocol=tcp destination=1.1.1.1 destination_port=81 jump=DNAT to_destination=&quot;3.3.3.3:8800&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line">SNAT:  </span><br><span class="line">	POSTROUTING</span><br><span class="line">	iptables -t nat -I POSTROUTING -s 172.16.1.0/24 -j SNAT --to-source 5.5.5.5</span><br><span class="line"></span><br><span class="line">ansible webservers -m iptables -a <span class="string">&#x27;table=nat chain=POSTROUTING source=172.16.2.0/24 jump=SNAT to_source=6.6.6.6&#x27;</span></span><br><span class="line">ansible webservers -m iptables -a <span class="string">&#x27;table=nat chain=POSTROUTING source=172.16.3.0/24 jump=SNAT to_source=7.7.7.7 action=insert&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="yum-repo"><a href="#yum-repo" class="headerlink" title="yum_repo"></a><code>yum_repo</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum_repository</span><br><span class="line">	name				  名称,文件名称</span><br><span class="line">	description	  描述，必填</span><br><span class="line">	baseurl				仓库的地址</span><br><span class="line">	gpgcheck			验证开启</span><br><span class="line">	gpgkey</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ansible webservers -m yum_repository -a <span class="string">&#x27;name=ansible_nginx description=xxx baseurl=&quot;http://nginx.org/packages/centos/$releasever/$basearch/&quot; gpgcheck=yes gpgkey=&quot;https://nginx.org/keys/nginx_signing.key&quot;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="hostname"><a href="#hostname" class="headerlink" title="hostname"></a><code>hostname</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hostname 修改主机名称：</span><br><span class="line">    name: 	修改后的主机名称；</span><br><span class="line"></span><br><span class="line">ansible webservers -m hostname -a <span class="string">&#x27;name=web_cluster&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="sysctl"><a href="#sysctl" class="headerlink" title="sysctl"></a><code>sysctl</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sysctl	修改内核参数模块</span><br><span class="line">- sysctl:</span><br><span class="line">    name: vm.swappiness</span><br><span class="line">    value: <span class="string">&#x27;5&#x27;</span></span><br><span class="line">    state: present</span><br><span class="line"></span><br><span class="line">ansible webservers -m sysctl -a <span class="string">&#x27;name=net.ipv4.ip_forward value=1 state=present&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="lineinfile"><a href="#lineinfile" class="headerlink" title="lineinfile"></a><code>lineinfile</code></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">lineinfile	替换|追加|删除</span><br><span class="line">    path: 					      被控端的路径</span><br><span class="line">    regexp: <span class="string">&#x27;^Listen &#x27;</span>		正则匹配语法格式</span><br><span class="line">    line: Listen 8080			填充的内容</span><br><span class="line">	state: absent					  删除</span><br><span class="line">	insertafter: <span class="string">&#x27;^#Listen &#x27;</span></span><br><span class="line">	insertbefore: <span class="string">&#x27;^www.*80/tcp&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换httpd.conf文件中， ^Listen   为  Linsten 8080</span></span><br><span class="line">ansible webservers -m lineinfile -a <span class="string">&#x27;path=/etc/httpd/conf/httpd.conf regexp=&quot;^Listen&quot; line=&quot;Listen 8080&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给主机增加一个网关</span></span><br><span class="line">ansible webservers -m lineinfile -a <span class="string">&#x27;path=/etc/sysconfig/network-scripts/ifcfg-eth1 line=&quot;GATEWAY=172.16.1.200&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除主机的网关</span></span><br><span class="line">ansible webservers -m lineinfile -a <span class="string">&#x27;path=/etc/sysconfig/network-scripts/ifcfg-eth1 regexp=&quot;^GATEWAY&quot; state=absent&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给主机增加一个网关，但需要增加到ONBOOT下面</span></span><br><span class="line">ansible webservers -m lineinfile -a <span class="string">&#x27;path=/etc/sysconfig/network-scripts/ifcfg-eth1 insertafter=&quot;ONBOOT=yes&quot; line=&quot;GATEWAY=172.16.1.200&quot;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给主机增加一个网关，但需要增加到ONBOOT上面</span></span><br><span class="line">ansible webservers -m lineinfile -a <span class="string">&#x27;path=/etc/sysconfig/network-scripts/ifcfg-eth1 insertbefore=&quot;ONBOOT=yes&quot; line=&quot;test=172.16.1.200&quot;&#x27;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>Ansible简介、安装</title>
    <url>/1452b361.html</url>
    <content><![CDATA[<h2 id="Ansible介绍"><a href="#Ansible介绍" class="headerlink" title="Ansible介绍"></a><code>Ansible</code>介绍</h2><h3 id="简-介"><a href="#简-介" class="headerlink" title="简 介"></a>简 介</h3><p>ansible是自动化运维工具，基于Python开发，集合了众多运维工具（puppet、cfengine、chef、func、fabric）的优点，实现了批量系统配置、批量程序部署、批量运行命令等</p>
<span id="more"></span>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li><p>优势</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.ansible不需要单独安装客户端，也不需要启动任何服务</span><br><span class="line">2.ansible是python中的一套完整的自动化执行任务模块</span><br><span class="line">3.ansible playbook，采用yaml配置，对于自动化任务执行一目了然</span><br><span class="line">4.ansible 模块较多，对于自动化的场景支持较丰富</span><br></pre></td></tr></table></figure></li>
<li><p>劣势</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.幂等性，每次的描述一种状态后，服务器会按照你所期望的状态去运行；出了问题无法回退，需要重新在描述一次状态，然后执行，以实现回退的效果</span><br><span class="line"></span><br><span class="line">2.效率，如果连接的主机较多，执行的速度会比较的慢，速度相对比saltstack慢</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="基础架构"><a href="#基础架构" class="headerlink" title="基础架构"></a>基础架构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.连接插件connectior plugins用于连接主机 用来连接被管理端</span><br><span class="line">2.核心模块 core modules 连接主机实现操作， 它依赖于具体的模块来做具体的事情</span><br><span class="line">3.自定义模块 custom modules，根据自己的需求编写具体的模块</span><br><span class="line">4.插件 plugins，完成模块功能的补充</span><br><span class="line">5.剧本 playbooks，ansible的配置文件,将多个任务定义在剧本中，由ansible自动执行</span><br><span class="line">6.主机清单 inventor，定义ansible需要操作主机的范围</span><br><span class="line">最重要的一点是 ansible是模块化的 它所有的操作都依赖于模块</span><br></pre></td></tr></table></figure>



<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20220103130441938.png" alt="image-20220103130441938"></p>
<h2 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h2><h3 id="包管理方式-yum"><a href="#包管理方式-yum" class="headerlink" title="包管理方式(yum)"></a>包管理方式(<code>yum</code>)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># centos需要有epel源</span></span><br><span class="line">curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接安装</span></span><br><span class="line">yum install ansible -y</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看版本</span></span><br><span class="line">ansible --version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单使用</span></span><br><span class="line">ansible localhost -m ping</span><br></pre></td></tr></table></figure>

<h3 id="pip安装"><a href="#pip安装" class="headerlink" title="pip安装"></a><code>pip</code>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装python3</span></span><br><span class="line">yum -y install python3 python3-devel python3-pip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级pip3</span></span><br><span class="line">pip3 install --upgrade pip -i https://pypi.douban.com/simple/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装ansible</span></span><br><span class="line">pip3 install ansible -i https://pypi.douban.com/simple/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看ansible安装位置</span></span><br><span class="line"><span class="built_in">which</span> ansible</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看ansible版本</span></span><br><span class="line">/usr/<span class="built_in">local</span>/bin/ansible --version</span><br></pre></td></tr></table></figure>

<h2 id="配置文件说明"><a href="#配置文件说明" class="headerlink" title="配置文件说明"></a>配置文件说明</h2><h3 id="默认配置文件"><a href="#默认配置文件" class="headerlink" title="默认配置文件"></a>默认配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看默认配置文件路径</span></span><br><span class="line">rpm -qc ansible</span><br><span class="line">/etc/ansible/ansible.cfg  <span class="comment"># 主配置文件</span></span><br><span class="line">/etc/ansible/hosts				<span class="comment"># 主机清单文件 inventory</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># /etc/ansible/ansible.cfg 部分说明</span></span><br><span class="line"><span class="comment">#inventory      = /etc/ansible/hosts			    # 默认主机清单路径</span></span><br><span class="line"><span class="comment">#library        = /usr/share/my_modules/      # 模块存放路径</span></span><br><span class="line"><span class="comment">#module_utils   = /usr/share/my_module_utils/ # 模块存放路径</span></span><br><span class="line"><span class="comment">#remote_tmp     = ~/.ansible/tmp              # 将模块推送到被控端的临时位置</span></span><br><span class="line"><span class="comment">#local_tmp      = ~/.ansible/tmp              # 本地模块临时存放位置</span></span><br><span class="line"><span class="comment">#forks          = 5											      #	默认并行的主机数量  可以使用参数 -f 单独指定</span></span><br><span class="line"><span class="comment">#poll_interval  = 15</span></span><br><span class="line"><span class="comment">#sudo_user      = root</span></span><br><span class="line"><span class="comment">#ask_sudo_pass = True</span></span><br><span class="line"><span class="comment">#ask_pass      = True</span></span><br><span class="line"><span class="comment">#remote_port    = 22</span></span><br><span class="line"><span class="comment">#host_key_checking = False								    # 第一次连接主机的 yes 需要打开注释</span></span><br><span class="line"><span class="comment">#roles_path    = /etc/ansible/roles           # 默认角色路径</span></span><br></pre></td></tr></table></figure>

<h3 id="配置文件优先级"><a href="#配置文件优先级" class="headerlink" title="配置文件优先级"></a>配置文件优先级</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置文件加载顺序</span></span><br><span class="line">第一步读取：ANSIBLE_CONFIG</span><br><span class="line">第二步读取：当前项目目录下的ansible.cfg</span><br><span class="line">第三步读取：当前用户家目录下的 .ansible.cfg </span><br><span class="line">第四步读取: /etc/ansible/ansible.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境变量</span></span><br><span class="line"><span class="built_in">export</span> ANSIBLE_CONFIG=/tmp/ansible.cfg  <span class="comment"># 定义</span></span><br><span class="line">touch /tmp/ansible.cfg</span><br><span class="line">ansible --version     <span class="comment"># 可以看到配置文件位置是 /tmp/ansible.cfg</span></span><br><span class="line"><span class="built_in">unset</span> ANSIBLE_CONFIG  <span class="comment"># 取消定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为项目单独定义配置文件，非常的重要</span></span><br><span class="line">mkdir project1</span><br><span class="line"><span class="built_in">cd</span> project1/</span><br><span class="line">touch ansible.cfg</span><br><span class="line">ansible --version  <span class="comment"># 此时加载的配置文件位置就是 /root/project1/ansible.cfg</span></span><br><span class="line"><span class="comment"># 退出当前目录就变成默认的配置文件了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 为当前执行的用户家目录植入一个配置文件；</span></span><br><span class="line">touch ~/.ansible.cfg</span><br><span class="line">ansible --version  <span class="comment"># 此时加载的配置文件位置就是 ~/.ansible.cfg</span></span><br><span class="line">rm -f ~/.ansible.cfg</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认的配置文件加载路径，优先级是最低的</span></span><br><span class="line">ansible --version</span><br></pre></td></tr></table></figure>

<h2 id="Inventory"><a href="#Inventory" class="headerlink" title="Inventory"></a><code>Inventory</code></h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">主要用来填写被管理主机及主机组信息(逻辑定义)</span><br><span class="line">默认Inventory文件为/etc/ansible/hosts</span><br><span class="line">也可以自定义一个我看，使用ansible命令 -i 参数指定Inventory文件位置</span><br></pre></td></tr></table></figure>

<h3 id="主机清单定义方式"><a href="#主机清单定义方式" class="headerlink" title="主机清单定义方式"></a>主机清单定义方式</h3><h4 id="用户密码"><a href="#用户密码" class="headerlink" title="用户密码"></a>用户密码</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接写主机IP</span></span><br><span class="line">[server1]</span><br><span class="line">192.168.0.11 ansible_ssh_port=22 ansible_ssh_user=root ansible_ssh_pass=<span class="string">&#x27;123456&#x27;</span></span><br><span class="line">192.168.0.12 ansible_ssh_port=22 ansible_ssh_user=root ansible_ssh_pass=<span class="string">&#x27;123456&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将密码改成变量，等同于上面</span></span><br><span class="line">[server1]</span><br><span class="line">192.168.0.11</span><br><span class="line">192.168.0.11</span><br><span class="line"></span><br><span class="line">[server1:vars]</span><br><span class="line">ansible_ssh_port=22</span><br><span class="line">ansible_ssh_user=root</span><br><span class="line">ansible_ssh_pass=<span class="string">&#x27;123456&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多台机器时</span></span><br><span class="line">[server1]</span><br><span class="line">192.168.0.[11:100] ansible_ssh_port=22 ansible_ssh_user=root ansible_ssh_pass=<span class="string">&#x27;123456&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以通过域名简写(前提在 hosts 文件中解析)</span></span><br><span class="line">[server1]</span><br><span class="line">server[1:2].test.com ansible_ssh_port=22 ansible_ssh_user=root ansible_ssh_pass=<span class="string">&#x27;123456&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="免密"><a href="#免密" class="headerlink" title="免密"></a>免密</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 免交互生成秘钥对</span></span><br><span class="line">ssh-keygen -f ~/.ssh/id_rsa  -P <span class="string">&#x27;&#x27;</span> -q</span><br><span class="line"></span><br><span class="line">yum install sshpass</span><br><span class="line"></span><br><span class="line">sshpass -p123456 ssh-copy-id -f -i ~/.ssh/id_rsa.pub <span class="string">&quot;-o StrictHostKeyChecking=no&quot;</span> root@10.0.0.100 &gt;/dev/null 2&gt;&amp;1</span><br><span class="line"><span class="comment"># 可以依据上述编写批量免密推送脚本</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主机清单</span></span><br><span class="line"><span class="comment"># 方式一</span></span><br><span class="line">[server1]</span><br><span class="line">192.168.0.11</span><br><span class="line">192.168.0.12</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line">[db]</span><br><span class="line">192.168.0.[100:110]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式三</span></span><br><span class="line">[server1]</span><br><span class="line">server[1:100]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 server 主机组内有多少机器，两种方式通用</span></span><br><span class="line">ansible server  --list-hosts</span><br></pre></td></tr></table></figure>

<h3 id="匹配主机组的方式"><a href="#匹配主机组的方式" class="headerlink" title="匹配主机组的方式"></a>匹配主机组的方式</h3><p><code>ansible</code>命令格式</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ansible &lt;host-pattern&gt; [-m module_name] [-a args]</span><br></pre></td></tr></table></figure>

<p><code>host-pattern</code>的使用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 指定所有组</span></span><br><span class="line">ansible all -m ping</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通配符</span></span><br><span class="line">ansible <span class="string">&quot;server*&quot;</span> -m ping</span><br><span class="line">ansible 192.168.0.* -m ping</span><br><span class="line"></span><br><span class="line"><span class="comment"># 与: 在server1组，并且在db1组中的主机</span></span><br><span class="line">ansible <span class="string">&quot;server1:&amp;db1&quot;</span> -m ping</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或: 在server1组，或者在db1组中的主机</span></span><br><span class="line">ansible <span class="string">&quot;server1:db1&quot;</span> -m ping</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非: 在server1组，或者在db1组中的主机</span></span><br><span class="line">ansible <span class="string">&quot;server1:!db1&quot;</span> -m ping</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式</span></span><br><span class="line">ansible <span class="string">&quot;~(web|db).*&quot;</span> -m ping </span><br></pre></td></tr></table></figure>

<h3 id="使用普通用户管理被控端"><a href="#使用普通用户管理被控端" class="headerlink" title="使用普通用户管理被控端"></a>使用普通用户管理被控端</h3><p><code>ansible</code>使用<code>test</code>普通用户统一管理所有被控端节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有主机都创建 test 普通用户</span></span><br><span class="line">useradd <span class="built_in">test</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;123&#x27;</span> |passwd --stdin <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 管理机推送秘钥到被控端</span></span><br><span class="line">su - <span class="built_in">test</span></span><br><span class="line">ssh-keygen -f ~/.ssh/id_rsa  -P <span class="string">&#x27;&#x27;</span> -q</span><br><span class="line">sshpass -p123 ssh-copy-id -f -i ~/.ssh/id_rsa.pub <span class="string">&quot;-o StrictHostKeyChecking=no&quot;</span> <span class="built_in">test</span>@192.168.0.12 &gt;/dev/null 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启所有主机的sudo权限</span></span><br><span class="line">visudo</span><br><span class="line"><span class="built_in">test</span> ALL=(ALL) NOPASSWD: ALL</span><br><span class="line"></span><br><span class="line"><span class="comment"># 控制端配置文件中配置普通用户提权</span></span><br><span class="line">[privilege_escalation]</span><br><span class="line">become=True</span><br><span class="line">become_method=sudo</span><br><span class="line">become_user=root</span><br><span class="line">become_ask_pass=False</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不配置上述参数可以使用 -b -K 输入密码即可</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Ansible</category>
      </categories>
      <tags>
        <tag>Ansible</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB监控</title>
    <url>/8ba5944d.html</url>
    <content><![CDATA[<h3 id="常用监控工具手段"><a href="#常用监控工具手段" class="headerlink" title="常用监控工具手段"></a>常用监控工具手段</h3><span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MongoDB Ops Manager</span><br><span class="line">Percona</span><br><span class="line">通用监控平台</span><br><span class="line">程序脚本</span><br></pre></td></tr></table></figure>

<h3 id="获取监控数据"><a href="#获取监控数据" class="headerlink" title="获取监控数据"></a>获取监控数据</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">监控信息的来源</span><br><span class="line">1.db.serverStatus()（主要）</span><br><span class="line">2.db.isMaster()（次要）</span><br><span class="line">3.mongostats 命令行工具（只有部分信息）</span><br><span class="line"></span><br><span class="line">注意：db.serverStatus() 包含的监控信息是从上次开机到现在为止的累计数据，因此不能简单使用。</span><br></pre></td></tr></table></figure>

<h3 id="serverStatus-主要信息"><a href="#serverStatus-主要信息" class="headerlink" title="serverStatus() 主要信息"></a><code>serverStatus()</code> 主要信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">connections: 关于连接数的信息</span><br><span class="line">locks: 关于 MongoDB 使用的锁情况</span><br><span class="line">network: 网络使用情况统计</span><br><span class="line">opcounters: CRUD 的执行次数统计</span><br><span class="line">repl: 复制集配置信息</span><br><span class="line">wiredTiger: 包含大量 WirdTiger 执行情况的信息</span><br><span class="line">    block-manager: WT 数据块的读写情况</span><br><span class="line">    session: session 使用数量</span><br><span class="line">    concurrentTransactions: Ticket 使用情况</span><br><span class="line">mem: 内存使用情况</span><br><span class="line">metrics: 一系列性能指标统计信息</span><br></pre></td></tr></table></figure>

<h3 id="监控报警的考量"><a href="#监控报警的考量" class="headerlink" title="监控报警的考量"></a>监控报警的考量</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">具备一定的容错机制以减少误报的发生</span><br><span class="line">总结应用各指标峰值</span><br><span class="line">适时调整报警阈值</span><br><span class="line">留出足够的处理时间</span><br></pre></td></tr></table></figure>

<h3 id="建议监控指标"><a href="#建议监控指标" class="headerlink" title="建议监控指标"></a>建议监控指标</h3><table>
<thead>
<tr>
<th>指标</th>
<th>功能</th>
<th>采集方法</th>
</tr>
</thead>
<tbody><tr>
<td>opcounters（操作计数 器）</td>
<td>查询、更新、插入、删除、getmore 和其 他命令的的数量</td>
<td>db.serverStatus().opcounters</td>
</tr>
<tr>
<td>tickets（令牌）</td>
<td>对 WiredTiger 存储引擎的读/写令牌数量 。令牌数量表示了可以进入存储引擎的并 发操作数量。</td>
<td>db.serverStatus().wiredTiger.c oncurrentTransactions</td>
</tr>
<tr>
<td>replication lag（复制 延迟）</td>
<td>这个指标代表了写操作到达从结点所需要 的最小时间。过高的 replication lag 会 减小从结点的价值并且不利于配置了写关 注 w&gt;1 的那些操作。</td>
<td>db.adminCommand({‘replSet GetStatus’: 1})</td>
</tr>
<tr>
<td>oplog window （复制时间窗）</td>
<td>这个指标代表oplog可以容纳多长时间的写 操作。它表示了一个从结点可以离线多长时 间仍能够追上主节点。通常建议该值应大于 24小时为佳。</td>
<td>db.oplog.rs.find().sort({$natura l: -1}).limit(1).next().ts - db.oplog.rs.find().sort({$natura l: 1}).limit(1).next().ts</td>
</tr>
<tr>
<td>connections（连接数）</td>
<td>连接数应作为监控指标的一部分，因为每个 连接都将消耗资源。应该计算低峰/正常/高 峰时间的连接数，并制定合理的报警阈值范 围。</td>
<td>db.serverStatus().connections</td>
</tr>
<tr>
<td>Query targeting （查询专注度）</td>
<td>索引键/文档扫描数量比返回的文档数量， 按秒平均。如果该值比较高表示查询系需要 进行很多低效的扫描来满足查询。这个情况 通常代表了索引不当或缺少索引来支持查询 。</td>
<td>var status = db.serverStatus() status.metrics.queryExecutor.scanned / status.metrics.document.returned status.metrics.queryExecutor.scannedO bjects / status.metrics.document.returned</td>
</tr>
<tr>
<td>Scan and Order（扫描 和排序）</td>
<td>每秒内内存排序操作所占的平均比例。内存 排序可能会十分昂贵，因为它们通常要求缓 冲大量数据。如果有适当索引的情况下，内 存排序是可以避免的。</td>
<td>var status = db.serverStatus() status.metrics.operation.scanA ndOrder / status.opcounters.query</td>
</tr>
<tr>
<td>节点状态</td>
<td>每个节点的运行状态。如果节点状态不是 PRIMARY、SECONDARY、ARBITER 中的 一个，或无法执行上述命令则报警</td>
<td>db.runCommand(“isMaster”)</td>
</tr>
<tr>
<td>dataSize（数据大小）</td>
<td>整个实例数据总量（压缩前）</td>
<td>每个 DB 执行 db.stats()；</td>
</tr>
<tr>
<td>StorageSize（磁盘空间 大小）</td>
<td>已使用的磁盘空间占总空间的百分比。</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB备份与恢复迁移</title>
    <url>/d4437f91.html</url>
    <content><![CDATA[<h3 id="备份工具"><a href="#备份工具" class="headerlink" title="备份工具"></a>备份工具</h3><span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.mongoexport/mongoimport</span><br><span class="line">2.mongodump/mongorestore</span><br><span class="line"></span><br><span class="line"><span class="comment"># 区别</span></span><br><span class="line">mongoexport/mongoimport  导入/导出的是JSON格式或者CSV格式</span><br><span class="line">mongodump/mongorestore   导入/导出的是BSON格式</span><br><span class="line"></span><br><span class="line"><span class="comment"># 应用场景</span></span><br><span class="line">mongoexport/mongoimport:json csv </span><br><span class="line">1.异构平台迁移      mysql  &lt;---&gt; mongodb</span><br><span class="line">2.同平台,跨大版本   mongodb2  ----&gt; mongodb3</span><br><span class="line"></span><br><span class="line">mongodump/mongorestore</span><br><span class="line">日常备份恢复时使用</span><br></pre></td></tr></table></figure>

<h3 id="mongoexport导出"><a href="#mongoexport导出" class="headerlink" title="mongoexport导出"></a><code>mongoexport</code>导出</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">-h   指明数据库宿主机的IP</span><br><span class="line">-u   指明数据库的用户名</span><br><span class="line">-p   指明数据库的密码</span><br><span class="line">-d   指明数据库的名字</span><br><span class="line">-c   指明collection的名字</span><br><span class="line">-f   指明要导出那些列</span><br><span class="line">-o   指明到要导出的文件名</span><br><span class="line">-q   指明导出数据的过滤条件</span><br><span class="line">--authenticationDatabase admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据准备</span></span><br><span class="line">use <span class="built_in">test</span></span><br><span class="line"><span class="keyword">for</span>(i=0;i&lt;10000;i++)&#123; db.log.insert(&#123;<span class="string">&quot;uid&quot;</span>:i,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;mongodb&quot;</span>,<span class="string">&quot;age&quot;</span>:6,<span class="string">&quot;date&quot;</span>:new Date()&#125;);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单表备份至json格式</span></span><br><span class="line">mongoexport -uroot -proot123 --port 27017 --authenticationDatabase admin -d <span class="built_in">test</span> -c <span class="built_in">log</span> -o /mongodb/log.json</span><br><span class="line"><span class="comment">## 备份文件的名字可以自定义，默认导出了JSON格式的数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  单表备份至csv格式</span></span><br><span class="line"><span class="comment">## 如果我们需要导出CSV格式的数据，则需要使用----type=csv参数</span></span><br><span class="line">mongoexport -uroot -proot123 --port 27017 --authenticationDatabase admin -d <span class="built_in">test</span> -c <span class="built_in">log</span> --<span class="built_in">type</span>=csv -f uid,name,age,date  -o /mongodb/log.csv</span><br></pre></td></tr></table></figure>

<h3 id="mongoimport-导入"><a href="#mongoimport-导入" class="headerlink" title="mongoimport 导入"></a><code>mongoimport</code> 导入</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">-h  指明数据库宿主机的IP</span><br><span class="line">-u  指明数据库的用户名</span><br><span class="line">-p  指明数据库的密码</span><br><span class="line">-d  指明数据库的名字</span><br><span class="line">-c  指明collection的名字</span><br><span class="line">-f  指明要导入那些列</span><br><span class="line">-j  并发数</span><br><span class="line"></span><br><span class="line">//并行</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据恢复</span></span><br><span class="line"><span class="comment"># 恢复json格式表数据到log1 ( --drop 就可以删除之前的表导入或者换个表，如导入到这边的 log1 )</span></span><br><span class="line">mongoimport -uroot -proot123 --port 27017 --authenticationDatabase admin -d <span class="built_in">test</span> -c log1 /mongodb/log.json</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复csv格式的文件到log2</span></span><br><span class="line">上面演示的是导入JSON格式的文件中的内容，如果要导入CSV格式文件中的内容，则需要通过--<span class="built_in">type</span>参数指定导入格式，具体如下所示：</span><br><span class="line">错误的恢复</span><br><span class="line"></span><br><span class="line"><span class="comment"># csv格式的文件头行，有列名字</span></span><br><span class="line">mongoimport   -uroot -proot123 --port 27017 --authenticationDatabase admin -d <span class="built_in">test</span> -c log2 --<span class="built_in">type</span>=csv --headerline --file  /mongodb/log.csv</span><br><span class="line"><span class="comment"># --headerline 指明第一行是列名，不需要导入</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># csv格式的文件头行，没有列名字</span></span><br><span class="line">mongoimport   -uroot -proot123 --port 27017 --authenticationDatabase admin -d <span class="built_in">test</span> -c log3 -j 4 --<span class="built_in">type</span>=csv -f id,name,age,date --file  /mongodb/log.csv</span><br></pre></td></tr></table></figure>

<h3 id="异构平台迁移"><a href="#异构平台迁移" class="headerlink" title="异构平台迁移"></a>异构平台迁移</h3><h4 id="MySQL到MongoDB"><a href="#MySQL到MongoDB" class="headerlink" title="MySQL到MongoDB"></a><code>MySQL</code>到<code>MongoDB</code></h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql ---&gt; mongodb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备mysql数据库，略</span></span><br><span class="line"><span class="comment"># 添加配置文件，导出文件存放位置</span></span><br><span class="line">vim /etc/my.cnf</span><br><span class="line">...</span><br><span class="line">secure-file-priv=/data/bak</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">chown -R mysql.mysql /data/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入一个world库，下载地址: https://dev.mysql.com/doc/index-other.html</span></span><br><span class="line">mysql -uroot -p123 &lt; world.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># sql导出city表为csv格式</span></span><br><span class="line">use world;</span><br><span class="line">select * from city into outfile <span class="string">&#x27;/data/bak/city.csv&#x27;</span> fields terminated by <span class="string">&#x27;,&#x27;</span> enclosed by <span class="string">&#x27;&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导出的格式缺少mongodb的头信息，可以用desc 查看补齐</span></span><br><span class="line">desc world.city;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者用下列语句查看</span></span><br><span class="line">select table_name,group_concat(column_name) from information_schema.columns <span class="built_in">where</span> table_schema=<span class="string">&#x27;world&#x27;</span> group by table_name;</span><br><span class="line"><span class="comment"># 得到 Name,CountryCode,District,Population,ID</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># mongodb 导入</span></span><br><span class="line">mongoimport -uroot -proot123 --port 27017 --authenticationDatabase admin -d world -c city --<span class="built_in">type</span>=csv -f Name,CountryCode,District,Population,ID --file /data/bak/city.csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查</span></span><br><span class="line">mongo -uroot -proot123 --port 27017 admin</span><br><span class="line">use world</span><br><span class="line">show collections  // show tables</span><br><span class="line">db.city.count()</span><br><span class="line">db.city.find().pretty()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="大量数据批量迁移"><a href="#大量数据批量迁移" class="headerlink" title="大量数据批量迁移"></a>大量数据批量迁移</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模拟大量数据</span></span><br><span class="line">wget https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/sql/100w.sql.zip </span><br><span class="line">unzip 100w.sql.zip</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入到mysql </span></span><br><span class="line">use world;</span><br><span class="line"><span class="built_in">source</span> /root/100w.sql;</span><br><span class="line">create table t1 like t100w;</span><br><span class="line">insert into t1 select * from t100w;</span><br><span class="line">create table t2 like t100w;</span><br><span class="line">insert into t2 select * from t100w;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将数据批量导出，world库的数据</span></span><br><span class="line">mysqldump --fields-terminated-by <span class="string">&#x27;,&#x27;</span> --fields-enclosed-by <span class="string">&#x27;&quot;&#x27;</span> world -T /data/bak/</span><br><span class="line">rm -f /data/bak/*.sql</span><br><span class="line">find ./ -name <span class="string">&quot;*.txt&quot;</span>|awk -F <span class="string">&quot;.&quot;</span> <span class="string">&#x27;&#123;print $2&#125;&#x27;</span> |xargs -i -t mv ./&#123;&#125;.txt ./&#123;&#125;.csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 mysql 的SQL语句，拼接批量导入mongodb的语句</span></span><br><span class="line">select concat(<span class="string">&quot;mongoimport -uroot -proot123 --port 27017 --authenticationDatabase admin -d &quot;</span>,table_schema,<span class="string">&quot; -c &quot;</span>,table_name,<span class="string">&quot; --type=csv -f &quot;</span>,group_concat(column_name),<span class="string">&quot; --file /data/bak/&quot;</span>, table_name,<span class="string">&quot;.csv&quot;</span>) from information_schema.columns <span class="built_in">where</span> table_schema=<span class="string">&#x27;world&#x27;</span> group by table_name into outfile <span class="string">&#x27;/data/bak/import-mongodb.sh&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看批量导入语句</span></span><br><span class="line">cat /data/bak/import-mongodb.sh</span><br><span class="line">chmod +x /data/bak/import-mongodb.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除之前的数据</span></span><br><span class="line">su - mongod</span><br><span class="line"> mongo -uroot -proot123 --port 27017 admin</span><br><span class="line"> use world</span><br><span class="line"> db.dropDatabase();</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用脚本批量导入数据</span></span><br><span class="line">su - mongod</span><br><span class="line">bash /data/bak/import-mongodb.sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查数据</span></span><br></pre></td></tr></table></figure>

<h3 id="mongodump备份"><a href="#mongodump备份" class="headerlink" title="mongodump备份"></a><code>mongodump</code>备份</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongodump能够在Mongodb运行时进行备份，它的工作原理是对运行的Mongodb做查询，然后将所有查到的文档写入磁盘,</span><br><span class="line">但是存在的问题时使用mongodump产生的备份不一定是数据库的实时快照，如果我们在备份时对数据库进行了写入操作,</span><br><span class="line">则备份出来的文件可能不完全和Mongodb实时数据相等。另外在备份时可能会对其它客户端性能产生不利的影响,</span><br></pre></td></tr></table></figure>

<h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">-h  指明数据库宿主机的IP</span><br><span class="line">-u  指明数据库的用户名</span><br><span class="line">-p  指明数据库的密码</span><br><span class="line">-d  指明数据库的名字</span><br><span class="line">-c  指明collection的名字</span><br><span class="line">-o  指明到要导出的文件名</span><br><span class="line">-q  指明导出数据的过滤条件</span><br><span class="line">-j  指定并发数</span><br><span class="line">--oplog  备份的同时备份oplog</span><br></pre></td></tr></table></figure>

<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全库备份</span></span><br><span class="line">mkdir /mongodb/backup</span><br><span class="line">mongodump -uroot -proot123 --port 27017 --authenticationDatabase admin -o /mongodb/backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份world库</span></span><br><span class="line">mongodump -uroot -proot123 --port 27017 --authenticationDatabase admin -d world -o /mongodb/backup/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份world库下的city集合</span></span><br><span class="line">mongodump -uroot -proot123 --port 27017 --authenticationDatabase admin -d world -c city -o /mongodb/backup/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 压缩备份</span></span><br><span class="line">mongodump   -uroot -proot123 --port 27017 --authenticationDatabase admin -o /mongodb/backup/ --gzip</span><br><span class="line">mongodump   -uroot -proot123 --port 27017 --authenticationDatabase admin -d world -o /mongodb/backup/ --gzip</span><br><span class="line">mongodump   -uroot -proot123 --port 27017 --authenticationDatabase admin -d world -c city -o /mongodb/backup/ --gzip</span><br></pre></td></tr></table></figure>

<h3 id="mongorestore恢复"><a href="#mongorestore恢复" class="headerlink" title="mongorestore恢复"></a><code>mongorestore</code>恢复</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全库恢复</span></span><br><span class="line">mongorestore   -uroot -proot123 --port 27017 --authenticationDatabase admin /mongodb/backup/ --gzip </span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复world库</span></span><br><span class="line">mongorestore   -uroot -proot123 --port 27017 --authenticationDatabase admin -d world1  /mongodb/backup/world</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复world库下的t1集合</span></span><br><span class="line">mongorestore   -uroot -proot123 --port 27017 --authenticationDatabase admin -d world -c t1  --gzip /mongodb/backup.bak/oldboy/log1.bson.gz </span><br><span class="line"></span><br><span class="line"><span class="comment"># --drop 表示恢复的时候把之前的集合删除再导入</span></span><br><span class="line">mongorestore  -uroot -proot123 --port 27017 --authenticationDatabase admin -d world --drop  /mongodb/backup/world</span><br></pre></td></tr></table></figure>

<h3 id="oplog"><a href="#oplog" class="headerlink" title="oplog"></a><code>oplog</code></h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">这是replica <span class="built_in">set</span>或者master/slave模式专用</span><br><span class="line">在replica <span class="built_in">set</span>中oplog是一个定容集合(capped collection),它的默认大小是磁盘空间的5%(可以通过--oplogSizeMB参数修改),位于<span class="built_in">local</span>库的db.oplog.rs</span><br><span class="line">其中记录的是整个mongod实例一段时间内数据库的所有变更（插入/更新/删除）操作,当空间用完时新记录自动覆盖最老的记录</span><br><span class="line">其覆盖范围被称作oplog时间窗口。需要注意的是，因为oplog是一个定容集合，所以时间窗口能覆盖的范围会因为你单位时间内的更新次数不同而变化</span><br><span class="line"></span><br><span class="line">想要查看当前的oplog时间窗口预计值，可以使用以下命令:</span><br><span class="line"> use <span class="built_in">local</span> </span><br><span class="line"> db.oplog.rs.find().pretty()</span><br><span class="line"></span><br><span class="line">rs.printReplicationInfo()</span><br><span class="line">configured oplog size:   1561.5615234375MB      //&lt;--集合大小</span><br><span class="line"><span class="built_in">log</span> length start to end: 423849secs (117.74hrs) //&lt;--预计窗口覆盖时间</span><br></pre></td></tr></table></figure>

<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 实现热备，在备份时使用 --oplog 选项</span></span><br><span class="line"><span class="comment"># 搭建复制集，略</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试数据</span></span><br><span class="line">mongo --port 28018</span><br><span class="line">use <span class="built_in">test</span></span><br><span class="line"><span class="keyword">for</span>(var i = 1 ;i &lt; 100; i++) &#123;</span><br><span class="line">    db.foo.insert(&#123;a:i&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">db.oplog.rs.find(&#123;<span class="string">&quot;op&quot;</span>:<span class="string">&quot;i&quot;</span>&#125;).pretty()</span><br><span class="line"></span><br><span class="line"><span class="comment"># oplog 配合mongodump实现热备</span></span><br><span class="line">mongodump --port 28018 --oplog -o /mongodb/backup</span><br><span class="line"><span class="comment"># 作用介绍：--oplog 会记录备份过程中的数据变化。会以oplog.bson保存下来</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复</span></span><br><span class="line">mongorestore  --port 28018 --oplogReplay /mongodb/backup</span><br></pre></td></tr></table></figure>

<h4 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">背景：每天0点全备，oplog恢复窗口为48小时。某天，上午10点world.city 业务表被误删除</span><br><span class="line">恢复思路：</span><br><span class="line">    0、停应用</span><br><span class="line">    2、找测试库</span><br><span class="line">    3、恢复昨天晚上全备</span><br><span class="line">    4、截取全备之后到world.city误删除时间点的oplog，并恢复到测试库</span><br><span class="line">    5、将误删除表导出，恢复到生产库</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复步骤如下</span></span><br><span class="line"><span class="comment"># 全备数据库</span></span><br><span class="line">    <span class="comment"># 模拟原始数据</span></span><br><span class="line">    mongo --port 28017</span><br><span class="line">    use wo</span><br><span class="line">    <span class="keyword">for</span>(var i = 1 ;i &lt; 20; i++) &#123;</span><br><span class="line">        db.ci.insert(&#123;a: i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 全备</span></span><br><span class="line">    rm -rf /mongodb/backup/*</span><br><span class="line">    mongodump --port 28018 --oplog -o /mongodb/backup</span><br><span class="line">   <span class="comment">#  --oplog功能:在备份同时,将备份过程中产生的日志进行备份，文件必须存放在/mongodb/backup下,自动命令为oplog.bson</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 再次模拟数据</span></span><br><span class="line">    db.ci1.insert(&#123;id:1&#125;)</span><br><span class="line">    db.ci2.insert(&#123;id:2&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上午10点：删除wo库下的ci表，10:00时刻,误删除</span></span><br><span class="line">db.ci.drop()</span><br><span class="line">show tables;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 备份现有的oplog.rs表</span></span><br><span class="line">mongodump --port 28018 -d <span class="built_in">local</span> -c oplog.rs  -o /mongodb/backup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取oplog并恢复到drop之前的位置，更合理的方法：登陆到原数据库</span></span><br><span class="line">mongo --port 28018</span><br><span class="line">use <span class="built_in">local</span></span><br><span class="line">db.oplog.rs.find(&#123;op:<span class="string">&quot;c&quot;</span>&#125;).pretty();</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;ts&quot;</span> : Timestamp(1553659908, 1),</span><br><span class="line">    <span class="string">&quot;t&quot;</span> : NumberLong(2),</span><br><span class="line">    <span class="string">&quot;h&quot;</span> : NumberLong(<span class="string">&quot;-7439981700218302504&quot;</span>),</span><br><span class="line">    <span class="string">&quot;v&quot;</span> : 2,</span><br><span class="line">    <span class="string">&quot;op&quot;</span> : <span class="string">&quot;c&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ns&quot;</span> : <span class="string">&quot;wo.<span class="variable">$cmd</span>&quot;</span>,</span><br><span class="line">    <span class="string">&quot;ui&quot;</span> : UUID(<span class="string">&quot;db70fa45-edde-4945-ade3-747224745725&quot;</span>),</span><br><span class="line">    <span class="string">&quot;wall&quot;</span> : ISODate(<span class="string">&quot;2019-03-27T04:11:48.890Z&quot;</span>),</span><br><span class="line">    <span class="string">&quot;o&quot;</span> : &#123;</span><br><span class="line">        <span class="string">&quot;drop&quot;</span> : <span class="string">&quot;ci&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取到oplog误删除时间点位置</span></span><br><span class="line"><span class="string">&quot;ts&quot;</span> : Timestamp(1553659908, 1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复备份+应用oplog</span></span><br><span class="line"><span class="built_in">cd</span> /mongodb/backup/<span class="built_in">local</span>/</span><br><span class="line">ls</span><br><span class="line">oplog.rs.bson  oplog.rs.metadata.json</span><br><span class="line"></span><br><span class="line">cp oplog.rs.bson ../oplog.bson </span><br><span class="line">rm -rf /mongodb/backup/<span class="built_in">local</span>/</span><br><span class="line"></span><br><span class="line">mongorestore --port 38021  --oplogReplay --oplogLimit <span class="string">&quot;1553659908:1&quot;</span>  --drop   /mongodb/backup/</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB全球多写</title>
    <url>/2a426223.html</url>
    <content><![CDATA[<h3 id="全球多写-Zone-Sharding"><a href="#全球多写-Zone-Sharding" class="headerlink" title="全球多写(Zone Sharding)"></a>全球多写(<code>Zone Sharding</code>)</h3><span id="more"></span>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20220104181800463.png" alt="image-20220104181800463"></p>
<h3 id="db1复制集配置"><a href="#db1复制集配置" class="headerlink" title="db1复制集配置"></a><code>db1</code>复制集配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /mongodb/&#123;20001..20003&#125;/&#123;conf,data,<span class="built_in">log</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line">cat &gt;  /mongodb/20001/conf/mongodb.conf  &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">systemLog:</span></span><br><span class="line"><span class="string">  destination: file</span></span><br><span class="line"><span class="string">  path: /mongodb/20001/log/mongodb.log   </span></span><br><span class="line"><span class="string">  logAppend: true</span></span><br><span class="line"><span class="string">storage:</span></span><br><span class="line"><span class="string">  journal:</span></span><br><span class="line"><span class="string">    enabled: true</span></span><br><span class="line"><span class="string">  dbPath: /mongodb/20001/data</span></span><br><span class="line"><span class="string">  directoryPerDB: true</span></span><br><span class="line"><span class="string">  #engine: wiredTiger</span></span><br><span class="line"><span class="string">  wiredTiger:</span></span><br><span class="line"><span class="string">    engineConfig:</span></span><br><span class="line"><span class="string">      cacheSizeGB: 1</span></span><br><span class="line"><span class="string">      directoryForIndexes: true</span></span><br><span class="line"><span class="string">    collectionConfig:</span></span><br><span class="line"><span class="string">      blockCompressor: zlib</span></span><br><span class="line"><span class="string">    indexConfig:</span></span><br><span class="line"><span class="string">      prefixCompression: true</span></span><br><span class="line"><span class="string">net:</span></span><br><span class="line"><span class="string">  bindIpAll: true</span></span><br><span class="line"><span class="string">  port: 20001</span></span><br><span class="line"><span class="string">replication:</span></span><br><span class="line"><span class="string">  oplogSizeMB: 2048</span></span><br><span class="line"><span class="string">  replSetName: CN_sh</span></span><br><span class="line"><span class="string">sharding:</span></span><br><span class="line"><span class="string">  clusterRole: shardsvr</span></span><br><span class="line"><span class="string">processManagement: </span></span><br><span class="line"><span class="string">  fork: true</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cp /mongodb/20001/conf/mongodb.conf  /mongodb/20002/conf</span><br><span class="line">cp /mongodb/20001/conf/mongodb.conf  /mongodb/20003/conf</span><br><span class="line">sed -i <span class="string">&#x27;s#20001#20002#g&#x27;</span> /mongodb/20002/conf/mongodb.conf</span><br><span class="line">sed -i <span class="string">&#x27;s#20001#20003#g&#x27;</span> /mongodb/20003/conf/mongodb.conf</span><br><span class="line">sed -i <span class="string">&#x27;s#CN_sh#US_sh#g&#x27;</span> /mongodb/20003/conf/mongodb.conf</span><br><span class="line"></span><br><span class="line">chown -R mongod:mongod /mongodb</span><br><span class="line">su - mongod</span><br><span class="line">mongod -f /mongodb/20001/conf/mongodb.conf</span><br><span class="line">mongod -f /mongodb/20002/conf/mongodb.conf</span><br><span class="line">mongod -f /mongodb/20003/conf/mongodb.conf</span><br></pre></td></tr></table></figure>

<h3 id="db2复制集配置"><a href="#db2复制集配置" class="headerlink" title="db2复制集配置"></a><code>db2</code>复制集配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /mongodb/&#123;20001..20003&#125;/&#123;conf,data,<span class="built_in">log</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line">cat &gt;  /mongodb/20001/conf/mongodb.conf  &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">systemLog:</span></span><br><span class="line"><span class="string">  destination: file</span></span><br><span class="line"><span class="string">  path: /mongodb/20001/log/mongodb.log   </span></span><br><span class="line"><span class="string">  logAppend: true</span></span><br><span class="line"><span class="string">storage:</span></span><br><span class="line"><span class="string">  journal:</span></span><br><span class="line"><span class="string">    enabled: true</span></span><br><span class="line"><span class="string">  dbPath: /mongodb/20001/data</span></span><br><span class="line"><span class="string">  directoryPerDB: true</span></span><br><span class="line"><span class="string">  #engine: wiredTiger</span></span><br><span class="line"><span class="string">  wiredTiger:</span></span><br><span class="line"><span class="string">    engineConfig:</span></span><br><span class="line"><span class="string">      cacheSizeGB: 1</span></span><br><span class="line"><span class="string">      directoryForIndexes: true</span></span><br><span class="line"><span class="string">    collectionConfig:</span></span><br><span class="line"><span class="string">      blockCompressor: zlib</span></span><br><span class="line"><span class="string">    indexConfig:</span></span><br><span class="line"><span class="string">      prefixCompression: true</span></span><br><span class="line"><span class="string">net:</span></span><br><span class="line"><span class="string">  bindIpAll: true</span></span><br><span class="line"><span class="string">  port: 20001</span></span><br><span class="line"><span class="string">replication:</span></span><br><span class="line"><span class="string">  oplogSizeMB: 2048</span></span><br><span class="line"><span class="string">  replSetName: US_sh</span></span><br><span class="line"><span class="string">sharding:</span></span><br><span class="line"><span class="string">  clusterRole: shardsvr</span></span><br><span class="line"><span class="string">processManagement: </span></span><br><span class="line"><span class="string">  fork: true</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cp /mongodb/20001/conf/mongodb.conf  /mongodb/20002/conf</span><br><span class="line">cp /mongodb/20001/conf/mongodb.conf  /mongodb/20003/conf</span><br><span class="line">sed -i <span class="string">&#x27;s#20001#20002#g&#x27;</span> /mongodb/20002/conf/mongodb.conf</span><br><span class="line">sed -i <span class="string">&#x27;s#20001#20003#g&#x27;</span> /mongodb/20003/conf/mongodb.conf</span><br><span class="line">sed -i <span class="string">&#x27;s#US_sh#CN_sh#g&#x27;</span> /mongodb/20003/conf/mongodb.conf</span><br><span class="line"></span><br><span class="line">chown -R mongod:mongod /mongodb</span><br><span class="line">su - mongod</span><br><span class="line">mongod -f /mongodb/20001/conf/mongodb.conf</span><br><span class="line">mongod -f /mongodb/20002/conf/mongodb.conf</span><br><span class="line">mongod -f /mongodb/20003/conf/mongodb.conf</span><br></pre></td></tr></table></figure>

<h3 id="db1上config节点"><a href="#db1上config节点" class="headerlink" title="db1上config节点"></a><code>db1</code>上<code>config</code>节点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /mongodb/&#123;20004..20006&#125;/&#123;conf,data,<span class="built_in">log</span>&#125;</span><br><span class="line"></span><br><span class="line">cat &gt; /mongodb/20004/conf/mongodb.conf  &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">systemLog:</span></span><br><span class="line"><span class="string">  destination: file</span></span><br><span class="line"><span class="string">  path: /mongodb/20004/log/mongodb.log</span></span><br><span class="line"><span class="string">  logAppend: true</span></span><br><span class="line"><span class="string">storage:</span></span><br><span class="line"><span class="string">  journal:</span></span><br><span class="line"><span class="string">    enabled: true</span></span><br><span class="line"><span class="string">  dbPath: /mongodb/20004/data/</span></span><br><span class="line"><span class="string">  directoryPerDB: true</span></span><br><span class="line"><span class="string">  #engine: wiredTiger</span></span><br><span class="line"><span class="string">  wiredTiger:</span></span><br><span class="line"><span class="string">    engineConfig:</span></span><br><span class="line"><span class="string">      cacheSizeGB: 1</span></span><br><span class="line"><span class="string">      directoryForIndexes: true</span></span><br><span class="line"><span class="string">    collectionConfig:</span></span><br><span class="line"><span class="string">      blockCompressor: zlib</span></span><br><span class="line"><span class="string">    indexConfig:</span></span><br><span class="line"><span class="string">      prefixCompression: true</span></span><br><span class="line"><span class="string">net:</span></span><br><span class="line"><span class="string">  bindIpAll: true</span></span><br><span class="line"><span class="string">  port: 20004</span></span><br><span class="line"><span class="string">replication:</span></span><br><span class="line"><span class="string">  oplogSizeMB: 2048</span></span><br><span class="line"><span class="string">  replSetName: configReplSet</span></span><br><span class="line"><span class="string">sharding:</span></span><br><span class="line"><span class="string">  clusterRole: configsvr</span></span><br><span class="line"><span class="string">processManagement: </span></span><br><span class="line"><span class="string">  fork: true</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cp /mongodb/20004/conf/mongodb.conf  /mongodb/20005/conf</span><br><span class="line">cp /mongodb/20004/conf/mongodb.conf  /mongodb/20006/conf</span><br><span class="line">sed -i <span class="string">&#x27;s#20004#20005#g&#x27;</span> /mongodb/20005/conf/mongodb.conf</span><br><span class="line">sed -i <span class="string">&#x27;s#20004#20006#g&#x27;</span> /mongodb/20006/conf/mongodb.conf</span><br><span class="line"></span><br><span class="line">chown -R mongod:mongod /mongodb</span><br><span class="line">su - mongod</span><br><span class="line">mongod -f /mongodb/20004/conf/mongodb.conf</span><br><span class="line">mongod -f /mongodb/20005/conf/mongodb.conf</span><br><span class="line">mongod -f /mongodb/20006/conf/mongodb.conf</span><br></pre></td></tr></table></figure>

<h3 id="复制集配置"><a href="#复制集配置" class="headerlink" title="复制集配置"></a>复制集配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 设置复制集1</span></span><br><span class="line">mongo 192.168.0.11:20001/admin</span><br><span class="line">use  admin</span><br><span class="line">config = &#123;_id: <span class="string">&#x27;CN_sh&#x27;</span>, members: [</span><br><span class="line">                        &#123;_id: 0, host: <span class="string">&#x27;192.168.0.11:20001&#x27;</span>&#125;,</span><br><span class="line">                        &#123;_id: 1, host: <span class="string">&#x27;192.168.0.11:20002&#x27;</span>&#125;,</span><br><span class="line">                        &#123;_id: 2, host: <span class="string">&#x27;192.168.0.12:20003&#x27;</span>&#125;]</span><br><span class="line">         &#125;</span><br><span class="line">rs.initiate(config)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置复制集2</span></span><br><span class="line">mongo 192.168.0.12:20001/admin</span><br><span class="line">use  admin</span><br><span class="line">config = &#123;_id: <span class="string">&#x27;US_sh&#x27;</span>, members: [</span><br><span class="line">                        &#123;_id: 0, host: <span class="string">&#x27;192.168.0.12:20001&#x27;</span>&#125;,</span><br><span class="line">                        &#123;_id: 1, host: <span class="string">&#x27;192.168.0.12:20002&#x27;</span>&#125;,</span><br><span class="line">                        &#123;_id: 2, host: <span class="string">&#x27;192.168.0.11:20003&#x27;</span>&#125;]</span><br><span class="line">         &#125;</span><br><span class="line">rs.initiate(config)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置config节点，db1节点</span></span><br><span class="line">mongo --port 20004 admin</span><br><span class="line">use  admin</span><br><span class="line">config = &#123;_id: <span class="string">&#x27;configReplSet&#x27;</span>, members: [</span><br><span class="line">                        &#123;_id: 0, host: <span class="string">&#x27;192.168.0.11:20004&#x27;</span>&#125;,</span><br><span class="line">                        &#123;_id: 1, host: <span class="string">&#x27;192.168.0.11:20005&#x27;</span>&#125;,</span><br><span class="line">                        &#123;_id: 2, host: <span class="string">&#x27;192.168.0.11:20006&#x27;</span>&#125;]</span><br><span class="line">         &#125;</span><br><span class="line">rs.initiate(config)  </span><br></pre></td></tr></table></figure>

<h3 id="mongos配置"><a href="#mongos配置" class="headerlink" title="mongos配置"></a><code>mongos</code>配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># db1上操作</span></span><br><span class="line">mkdir -p /mongodb/20010/&#123;conf,<span class="built_in">log</span>&#125;</span><br><span class="line"></span><br><span class="line">cat &gt; /mongodb/20010/conf/mongos.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">systemLog:</span></span><br><span class="line"><span class="string">  destination: file</span></span><br><span class="line"><span class="string">  path: /mongodb/20010/log/mongos.log</span></span><br><span class="line"><span class="string">  logAppend: true</span></span><br><span class="line"><span class="string">net:</span></span><br><span class="line"><span class="string">  bindIpAll: true </span></span><br><span class="line"><span class="string">  port: 20010</span></span><br><span class="line"><span class="string">sharding:</span></span><br><span class="line"><span class="string">  configDB: configReplSet/192.168.0.11:20004,192.168.0.11:20005,192.168.0.11:20006</span></span><br><span class="line"><span class="string">processManagement: </span></span><br><span class="line"><span class="string">  fork: true</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">mongos -f /mongodb/20010/conf/mongos.conf </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># db2上操作</span></span><br><span class="line">mkdir -p /mongodb/20011/&#123;conf,<span class="built_in">log</span>&#125;</span><br><span class="line"></span><br><span class="line">cat &gt; /mongodb/20011/conf/mongos.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">systemLog:</span></span><br><span class="line"><span class="string">  destination: file</span></span><br><span class="line"><span class="string">  path: /mongodb/20011/log/mongos.log</span></span><br><span class="line"><span class="string">  logAppend: true</span></span><br><span class="line"><span class="string">net:</span></span><br><span class="line"><span class="string">  bindIpAll: true </span></span><br><span class="line"><span class="string">  port: 20011</span></span><br><span class="line"><span class="string">sharding:</span></span><br><span class="line"><span class="string">  configDB: configReplSet/192.168.0.11:20004,192.168.0.11:20005,192.168.0.11:20006</span></span><br><span class="line"><span class="string">processManagement: </span></span><br><span class="line"><span class="string">  fork: true</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mongos -f /mongodb/20011/conf/mongos.conf </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 在db1上操作(随便一台都行)</span></span><br><span class="line"><span class="comment"># 连接到mongs的admin数据库</span></span><br><span class="line">su - mongod</span><br><span class="line">mongo 192.168.0.11:20010/admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加分片</span></span><br><span class="line">db.runCommand( &#123; addshard : <span class="string">&quot;CN_sh/192.168.0.11:20001,192.168.0.11:20002,192.168.0.12:20003&quot;</span>,name:<span class="string">&quot;CN_sh&quot;</span>&#125; )</span><br><span class="line">db.runCommand( &#123; addshard : <span class="string">&quot;US_sh/192.168.0.12:20001,192.168.0.12:20002,192.168.0.11:20003&quot;</span>,name:<span class="string">&quot;US_sh&quot;</span>&#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出分片</span></span><br><span class="line">db.runCommand( &#123; listshards : 1 &#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整体状态查看</span></span><br><span class="line">sh.status()</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录 mongos 操作</span></span><br><span class="line">mongo 192.168.0.11:20010/admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对shard添加标记</span></span><br><span class="line">use config</span><br><span class="line">sh.addShardTag(<span class="string">&quot;CN_sh&quot;</span>,<span class="string">&quot;ASIA&quot;</span>)</span><br><span class="line">sh.addShardTag(<span class="string">&quot;US_sh&quot;</span>,<span class="string">&quot;AMERICA&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启crm库的功能</span></span><br><span class="line">use admin</span><br><span class="line">db.runCommand( &#123; enablesharding : <span class="string">&quot;crm&quot;</span> &#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启路由规则</span></span><br><span class="line">use config</span><br><span class="line">sh.addTagRange( <span class="string">&quot;crm.orders&quot;</span>,</span><br><span class="line">&#123; <span class="string">&quot;locationCode&quot;</span> : <span class="string">&quot;CN&quot;</span>, <span class="string">&quot;order_id&quot;</span> : MinKey &#125;,</span><br><span class="line">&#123; <span class="string">&quot;locationCode&quot;</span> : <span class="string">&quot;CN&quot;</span>, <span class="string">&quot;order_id&quot;</span> : MaxKey &#125;,</span><br><span class="line"><span class="string">&quot;ASIA&quot;</span>)</span><br><span class="line"></span><br><span class="line">sh.addTagRange( <span class="string">&quot;crm.orders&quot;</span>,</span><br><span class="line">&#123; <span class="string">&quot;locationCode&quot;</span> : <span class="string">&quot;US&quot;</span>, <span class="string">&quot;order_id&quot;</span> : MinKey &#125;,</span><br><span class="line">&#123; <span class="string">&quot;locationCode&quot;</span> : <span class="string">&quot;US&quot;</span>, <span class="string">&quot;order_id&quot;</span> : MaxKey &#125;,</span><br><span class="line"><span class="string">&quot;AMERICA&quot;</span>)</span><br><span class="line"></span><br><span class="line">sh.addTagRange( <span class="string">&quot;crm.orders&quot;</span>,</span><br><span class="line">&#123; <span class="string">&quot;locationCode&quot;</span> : <span class="string">&quot;CA&quot;</span>, <span class="string">&quot;order_id&quot;</span> : MinKey &#125;,</span><br><span class="line">&#123; <span class="string">&quot;locationCode&quot;</span> : <span class="string">&quot;CA&quot;</span>, <span class="string">&quot;order_id&quot;</span> : MaxKey &#125;,</span><br><span class="line"><span class="string">&quot;AMERICA&quot;</span>)</span><br><span class="line"></span><br><span class="line">sh.status()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB两地三中心部署</title>
    <url>/ec5ee46f.html</url>
    <content><![CDATA[<h3 id="容灾级别"><a href="#容灾级别" class="headerlink" title="容灾级别"></a>容灾级别</h3><span id="more"></span>
<table>
<thead>
<tr>
<th>级别</th>
<th>方式</th>
<th>RPO</th>
<th>RTO</th>
</tr>
</thead>
<tbody><tr>
<td>L0</td>
<td>无备源中心 : 没有灾难恢复能力，只在本地进行数据备份</td>
<td>24小时</td>
<td>4小时</td>
</tr>
<tr>
<td>L1</td>
<td>本地备份+异地保存: 本地将关键数据备份，然后送到异地保存。 灾难发生后，按预定数据恢复程序恢复系统和数据</td>
<td>24小时</td>
<td>8小时</td>
</tr>
<tr>
<td>L2</td>
<td>双中心主备模式:  在异地建立一个热备份点，通过网络进行数据备份。 当出现灾难时，备份站点接替主站点的业务，维护业务连续性</td>
<td>秒</td>
<td>数分钟到半小时</td>
</tr>
<tr>
<td>L3</td>
<td>双中心双活: 在相隔较远的地方分别建立两个数据中心，进行相互数据备份。 当某个数据中心发生灾难时，另一个数据中心接替其工作任务</td>
<td>秒</td>
<td>秒</td>
</tr>
<tr>
<td>L4</td>
<td>双中心双活 + 异地热备 = 两地三中心:  在同城分别建立两个数据中心，进行相互数据备份。 当该城市的2个中心同时不可用（地震/大面积停电/网络等），快速切换到异地 L4 秒</td>
<td>秒</td>
<td>分钟</td>
</tr>
</tbody></table>
<h3 id="简单架构"><a href="#简单架构" class="headerlink" title="简单架构"></a>简单架构</h3><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20220104155254690.png" alt="image-20220104155254690"></p>
<h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><table>
<thead>
<tr>
<th>配置</th>
<th>IP</th>
<th>角色</th>
</tr>
</thead>
<tbody><tr>
<td>2c4g</td>
<td>192.168.0.11(db1)</td>
<td>Primary(10011)、Secondary(10002)</td>
</tr>
<tr>
<td>2c4g</td>
<td>192.168.0.12(db2)</td>
<td>Secondary(10003)、Secondary(10004)</td>
</tr>
<tr>
<td>2c4g</td>
<td>192.168.0.13(db3)</td>
<td>Secondary(10005)</td>
</tr>
</tbody></table>
<h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><h4 id="db1配置"><a href="#db1配置" class="headerlink" title="db1配置"></a>db1配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /mongodb/&#123;10001..10002&#125;/&#123;conf,data,<span class="built_in">log</span>&#125;</span><br><span class="line">tree -L 2 /mongodb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line">cat &gt; /mongodb/10001/conf/mongodb.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">systemLog:</span></span><br><span class="line"><span class="string">  destination: file</span></span><br><span class="line"><span class="string">  path: /mongodb/10001/log/mongodb.log</span></span><br><span class="line"><span class="string">  logAppend: true</span></span><br><span class="line"><span class="string">storage:</span></span><br><span class="line"><span class="string">  journal:</span></span><br><span class="line"><span class="string">    enabled: true</span></span><br><span class="line"><span class="string">  dbPath: /mongodb/10001/data</span></span><br><span class="line"><span class="string">  directoryPerDB: true</span></span><br><span class="line"><span class="string">  #engine: wiredTiger</span></span><br><span class="line"><span class="string">  wiredTiger:</span></span><br><span class="line"><span class="string">    engineConfig:</span></span><br><span class="line"><span class="string">      cacheSizeGB: 1</span></span><br><span class="line"><span class="string">      directoryForIndexes: true</span></span><br><span class="line"><span class="string">    collectionConfig:</span></span><br><span class="line"><span class="string">      blockCompressor: zlib</span></span><br><span class="line"><span class="string">    indexConfig:</span></span><br><span class="line"><span class="string">      prefixCompression: true</span></span><br><span class="line"><span class="string">processManagement:</span></span><br><span class="line"><span class="string">  fork: true</span></span><br><span class="line"><span class="string">net:</span></span><br><span class="line"><span class="string">  bindIpAll: true</span></span><br><span class="line"><span class="string">  port: 10001</span></span><br><span class="line"><span class="string">replication:</span></span><br><span class="line"><span class="string">  oplogSizeMB: 2048</span></span><br><span class="line"><span class="string">  replSetName: my_repl</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cp /mongodb/10001/conf/mongodb.conf  /mongodb/10002/conf</span><br><span class="line">sed -i <span class="string">&#x27;s#10001#10002#g&#x27;</span> /mongodb/10002/conf/mongodb.conf</span><br><span class="line"></span><br><span class="line">chown -R mongod:mongod /mongodb</span><br><span class="line">su - mongod</span><br><span class="line">mongod -f /mongodb/10001/conf/mongodb.conf</span><br><span class="line">mongod -f /mongodb/10002/conf/mongodb.conf</span><br></pre></td></tr></table></figure>

<h4 id="db2配置"><a href="#db2配置" class="headerlink" title="db2配置"></a>db2配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /mongodb/&#123;10003..10004&#125;/&#123;conf,data,<span class="built_in">log</span>&#125;</span><br><span class="line">tree -L 2 /mongodb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line">cat &gt; /mongodb/10003/conf/mongodb.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">systemLog:</span></span><br><span class="line"><span class="string">  destination: file</span></span><br><span class="line"><span class="string">  path: /mongodb/10003/log/mongodb.log</span></span><br><span class="line"><span class="string">  logAppend: true</span></span><br><span class="line"><span class="string">storage:</span></span><br><span class="line"><span class="string">  journal:</span></span><br><span class="line"><span class="string">    enabled: true</span></span><br><span class="line"><span class="string">  dbPath: /mongodb/10003/data</span></span><br><span class="line"><span class="string">  directoryPerDB: true</span></span><br><span class="line"><span class="string">  #engine: wiredTiger</span></span><br><span class="line"><span class="string">  wiredTiger:</span></span><br><span class="line"><span class="string">    engineConfig:</span></span><br><span class="line"><span class="string">      cacheSizeGB: 1</span></span><br><span class="line"><span class="string">      directoryForIndexes: true</span></span><br><span class="line"><span class="string">    collectionConfig:</span></span><br><span class="line"><span class="string">      blockCompressor: zlib</span></span><br><span class="line"><span class="string">    indexConfig:</span></span><br><span class="line"><span class="string">      prefixCompression: true</span></span><br><span class="line"><span class="string">processManagement:</span></span><br><span class="line"><span class="string">  fork: true</span></span><br><span class="line"><span class="string">net:</span></span><br><span class="line"><span class="string">  bindIpAll: true</span></span><br><span class="line"><span class="string">  port: 10003</span></span><br><span class="line"><span class="string">replication:</span></span><br><span class="line"><span class="string">  oplogSizeMB: 2048</span></span><br><span class="line"><span class="string">  replSetName: my_repl</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cp /mongodb/10003/conf/mongodb.conf  /mongodb/10004/conf</span><br><span class="line">sed -i <span class="string">&#x27;s#10003#10004#g&#x27;</span> /mongodb/10004/conf/mongodb.conf</span><br><span class="line"> </span><br><span class="line">chown -R mongod:mongod /mongodb</span><br><span class="line">su - mongod</span><br><span class="line">mongod -f /mongodb/10003/conf/mongodb.conf</span><br><span class="line">mongod -f /mongodb/10004/conf/mongodb.conf</span><br></pre></td></tr></table></figure>

<h4 id="db3配置"><a href="#db3配置" class="headerlink" title="db3配置"></a>db3配置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /mongodb/10005/&#123;conf,data,<span class="built_in">log</span>&#125;</span><br><span class="line">tree -L 2 /mongodb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line">cat &gt; /mongodb/10005/conf/mongodb.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">systemLog:</span></span><br><span class="line"><span class="string">  destination: file</span></span><br><span class="line"><span class="string">  path: /mongodb/10005/log/mongodb.log</span></span><br><span class="line"><span class="string">  logAppend: true</span></span><br><span class="line"><span class="string">storage:</span></span><br><span class="line"><span class="string">  journal:</span></span><br><span class="line"><span class="string">    enabled: true</span></span><br><span class="line"><span class="string">  dbPath: /mongodb/10005/data</span></span><br><span class="line"><span class="string">  directoryPerDB: true</span></span><br><span class="line"><span class="string">  #engine: wiredTiger</span></span><br><span class="line"><span class="string">  wiredTiger:</span></span><br><span class="line"><span class="string">    engineConfig:</span></span><br><span class="line"><span class="string">      cacheSizeGB: 1</span></span><br><span class="line"><span class="string">      directoryForIndexes: true</span></span><br><span class="line"><span class="string">    collectionConfig:</span></span><br><span class="line"><span class="string">      blockCompressor: zlib</span></span><br><span class="line"><span class="string">    indexConfig:</span></span><br><span class="line"><span class="string">      prefixCompression: true</span></span><br><span class="line"><span class="string">processManagement:</span></span><br><span class="line"><span class="string">  fork: true</span></span><br><span class="line"><span class="string">net:</span></span><br><span class="line"><span class="string">  bindIpAll: true</span></span><br><span class="line"><span class="string">  port: 10005</span></span><br><span class="line"><span class="string">replication:</span></span><br><span class="line"><span class="string">  oplogSizeMB: 2048</span></span><br><span class="line"><span class="string">  replSetName: my_repl</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">chown -R mongod:mongod /mongodb</span><br><span class="line">su - mongod</span><br><span class="line">mongod -f /mongodb/10005/conf/mongodb.conf</span><br></pre></td></tr></table></figure>

<h4 id="配置复制集和权重"><a href="#配置复制集和权重" class="headerlink" title="配置复制集和权重"></a>配置复制集和权重</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongo --port 10001 admin</span><br><span class="line">config = &#123;_id: <span class="string">&#x27;my_repl&#x27;</span>, members: [</span><br><span class="line">                          &#123;_id: 0, host: <span class="string">&#x27;192.168.0.11:10001&#x27;</span>&#125;,</span><br><span class="line">                          &#123;_id: 1, host: <span class="string">&#x27;192.168.0.11:10002&#x27;</span>&#125;,</span><br><span class="line">                          &#123;_id: 2, host: <span class="string">&#x27;192.168.0.12:10003&#x27;</span>&#125;,</span><br><span class="line">                          &#123;_id: 3, host: <span class="string">&#x27;192.168.0.12:10004&#x27;</span>&#125;,</span><br><span class="line">                          &#123;_id: 4, host: <span class="string">&#x27;192.168.0.13:10005&#x27;</span>&#125;]</span><br><span class="line">          &#125;                   </span><br><span class="line">rs.initiate(config) </span><br><span class="line">rs.status()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 权重配置</span></span><br><span class="line">cfg = rs.conf()</span><br><span class="line">cfg.members[0].priority = 5</span><br><span class="line">cfg.members[1].priority = 10</span><br><span class="line">rs.reconfig(cfg)</span><br></pre></td></tr></table></figure>

<h4 id="复制集安全加固"><a href="#复制集安全加固" class="headerlink" title="复制集安全加固"></a>复制集安全加固</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl rand -base64 756 &gt; /mongodb/10001/conf/keyfile</span><br><span class="line">chmod 600 /mongodb/10001/conf/keyfile</span><br><span class="line">cp -a /mongodb/10001/conf/keyfile /mongodb/10002/conf</span><br><span class="line">scp -rp /mongodb/10001/conf/keyfile db2:/mongodb/10003/conf</span><br><span class="line">scp -rp /mongodb/10001/conf/keyfile db2:/mongodb/10004/conf</span><br><span class="line">scp -rp /mongodb/10001/conf/keyfile db3:/mongodb/10005/conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat &gt;&gt; /mongodb/10001/conf/mongodb.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">security:</span></span><br><span class="line"><span class="string">  keyFile: /mongodb/10001/conf/keyfile</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cat &gt;&gt; /mongodb/10002/conf/mongodb.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">security:</span></span><br><span class="line"><span class="string">  keyFile: /mongodb/10002/conf/keyfile</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cat &gt;&gt; /mongodb/10003/conf/mongodb.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">security:</span></span><br><span class="line"><span class="string">  keyFile: /mongodb/10003/conf/keyfile</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cat &gt;&gt; /mongodb/10004/conf/mongodb.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">security:</span></span><br><span class="line"><span class="string">  keyFile: /mongodb/10004/conf/keyfile</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cat &gt;&gt; /mongodb/10005/conf/mongodb.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">security:</span></span><br><span class="line"><span class="string">  keyFile: /mongodb/10005/conf/keyfile</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭的时候最后关闭主节点</span></span><br><span class="line">su - mongod</span><br><span class="line">mongod -f /mongodb/10001/conf/mongodb.conf --shutdown</span><br><span class="line">mongod -f /mongodb/10002/conf/mongodb.conf --shutdown</span><br><span class="line">mongod -f /mongodb/10003/conf/mongodb.conf --shutdown</span><br><span class="line">mongod -f /mongodb/10004/conf/mongodb.conf --shutdown</span><br><span class="line">mongod -f /mongodb/10005/conf/mongodb.conf --shutdown</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">mongod -f /mongodb/10001/conf/mongodb.conf</span><br><span class="line">mongod -f /mongodb/10002/conf/mongodb.conf</span><br><span class="line">mongod -f /mongodb/10003/conf/mongodb.conf</span><br><span class="line">mongod -f /mongodb/10004/conf/mongodb.conf</span><br><span class="line">mongod -f /mongodb/10005/conf/mongodb.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在主节点上添加用户密码</span></span><br><span class="line">mongo --port 10001 admin</span><br><span class="line">use admin</span><br><span class="line">db.createUser(</span><br><span class="line">&#123;</span><br><span class="line">    user: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">    <span class="built_in">pwd</span>: <span class="string">&quot;root123&quot;</span>,</span><br><span class="line">    roles: [ &#123; role: <span class="string">&quot;root&quot;</span>, db: <span class="string">&quot;admin&quot;</span> &#125; ]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交互式输入密码</span></span><br><span class="line">use admin</span><br><span class="line">db.createUser(</span><br><span class="line">&#123;</span><br><span class="line">    user: <span class="string">&quot;root1&quot;</span>,</span><br><span class="line">    <span class="built_in">pwd</span>: passwordPrompt(),</span><br><span class="line">    roles: [ &#123; role: <span class="string">&quot;root&quot;</span>, db: <span class="string">&quot;admin&quot;</span> &#125; ]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 交互式验证</span></span><br><span class="line">use admin</span><br><span class="line">db.auth(<span class="string">&quot;root1&quot;</span>,passwordPrompt())</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB分片集群搭建及扩容</title>
    <url>/d8bf061a.html</url>
    <content><![CDATA[<h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><p>测试机器没有那么多，所以采用三台机器多实例的办法，应该一台机器一个实例</p>
<span id="more"></span>
<table>
<thead>
<tr>
<th>配置</th>
<th>IP</th>
<th>角色</th>
</tr>
</thead>
<tbody><tr>
<td>4c8g</td>
<td>192.168.0.11(db1)</td>
<td>shard1(node1(28017))、shard2(node1(28018))、config(node1(28019))、mongos(28021)</td>
</tr>
<tr>
<td>4c8g</td>
<td>192.168.0.12(db2)</td>
<td>shard1(node2(28017))、shard2(node2(28018))、config(node1(28019))</td>
</tr>
<tr>
<td>4c8g</td>
<td>192.168.0.13(db3)</td>
<td>shard1(node3(27017))、shard2(node3(28018))、config(node1(28019))</td>
</tr>
</tbody></table>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20211231194820648.png" alt="image-20211231194820648"></p>
<h3 id="配置分片集群"><a href="#配置分片集群" class="headerlink" title="配置分片集群"></a>配置分片集群</h3><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全部机器操作，软件按照上述安装部署</span></span><br><span class="line"><span class="comment"># hosts解析</span></span><br><span class="line">cat &gt;&gt; /etc/hosts &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">192.168.0.11 db1</span></span><br><span class="line"><span class="string">192.168.0.12 db2</span></span><br><span class="line"><span class="string">192.168.0.13 db3</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建集群目录</span></span><br><span class="line">mkdir -p /mongodb/&#123;28017..28019&#125;/&#123;conf,data,<span class="built_in">log</span>&#125;</span><br><span class="line">chown -R mongod.mongod /mongodb</span><br><span class="line"></span><br><span class="line">su - mongod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制集一配置文件</span></span><br><span class="line">cat &gt;  /mongodb/28017/conf/mongodb.conf  &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">systemLog:</span></span><br><span class="line"><span class="string">  destination: file</span></span><br><span class="line"><span class="string">  path: /mongodb/28017/log/mongodb.log   </span></span><br><span class="line"><span class="string">  logAppend: true</span></span><br><span class="line"><span class="string">storage:</span></span><br><span class="line"><span class="string">  journal:</span></span><br><span class="line"><span class="string">    enabled: true</span></span><br><span class="line"><span class="string">  dbPath: /mongodb/28017/data</span></span><br><span class="line"><span class="string">  directoryPerDB: true</span></span><br><span class="line"><span class="string">  #engine: wiredTiger</span></span><br><span class="line"><span class="string">  wiredTiger:</span></span><br><span class="line"><span class="string">    engineConfig:</span></span><br><span class="line"><span class="string">      cacheSizeGB: 1</span></span><br><span class="line"><span class="string">      directoryForIndexes: true</span></span><br><span class="line"><span class="string">    collectionConfig:</span></span><br><span class="line"><span class="string">      blockCompressor: zlib</span></span><br><span class="line"><span class="string">    indexConfig:</span></span><br><span class="line"><span class="string">      prefixCompression: true</span></span><br><span class="line"><span class="string">net:</span></span><br><span class="line"><span class="string">  bindIpAll: true</span></span><br><span class="line"><span class="string">  port: 28017</span></span><br><span class="line"><span class="string">replication:</span></span><br><span class="line"><span class="string">  oplogSizeMB: 2048</span></span><br><span class="line"><span class="string">  replSetName: sh1</span></span><br><span class="line"><span class="string">sharding:</span></span><br><span class="line"><span class="string">  clusterRole: shardsvr</span></span><br><span class="line"><span class="string">processManagement: </span></span><br><span class="line"><span class="string">  fork: true</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制集二配置文件</span></span><br><span class="line">cat &gt;  /mongodb/28018/conf/mongodb.conf  &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">systemLog:</span></span><br><span class="line"><span class="string">  destination: file</span></span><br><span class="line"><span class="string">  path: /mongodb/28018/log/mongodb.log   </span></span><br><span class="line"><span class="string">  logAppend: true</span></span><br><span class="line"><span class="string">storage:</span></span><br><span class="line"><span class="string">  journal:</span></span><br><span class="line"><span class="string">    enabled: true</span></span><br><span class="line"><span class="string">  dbPath: /mongodb/28018/data</span></span><br><span class="line"><span class="string">  directoryPerDB: true</span></span><br><span class="line"><span class="string">  #engine: wiredTiger</span></span><br><span class="line"><span class="string">  wiredTiger:</span></span><br><span class="line"><span class="string">    engineConfig:</span></span><br><span class="line"><span class="string">      cacheSizeGB: 1</span></span><br><span class="line"><span class="string">      directoryForIndexes: true</span></span><br><span class="line"><span class="string">    collectionConfig:</span></span><br><span class="line"><span class="string">      blockCompressor: zlib</span></span><br><span class="line"><span class="string">    indexConfig:</span></span><br><span class="line"><span class="string">      prefixCompression: true</span></span><br><span class="line"><span class="string">net:</span></span><br><span class="line"><span class="string">  bindIpAll: true</span></span><br><span class="line"><span class="string">  port: 28018</span></span><br><span class="line"><span class="string">replication:</span></span><br><span class="line"><span class="string">  oplogSizeMB: 2048</span></span><br><span class="line"><span class="string">  replSetName: sh2</span></span><br><span class="line"><span class="string">sharding:</span></span><br><span class="line"><span class="string">  clusterRole: shardsvr</span></span><br><span class="line"><span class="string">processManagement: </span></span><br><span class="line"><span class="string">  fork: true</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># config集群配置文件</span></span><br><span class="line">cat &gt; /mongodb/28019/conf/mongodb.conf  &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">systemLog:</span></span><br><span class="line"><span class="string">  destination: file</span></span><br><span class="line"><span class="string">  path: /mongodb/28019/log/mongodb.log</span></span><br><span class="line"><span class="string">  logAppend: true</span></span><br><span class="line"><span class="string">storage:</span></span><br><span class="line"><span class="string">  journal:</span></span><br><span class="line"><span class="string">    enabled: true</span></span><br><span class="line"><span class="string">  dbPath: /mongodb/28019/data/</span></span><br><span class="line"><span class="string">  directoryPerDB: true</span></span><br><span class="line"><span class="string">  #engine: wiredTiger</span></span><br><span class="line"><span class="string">  wiredTiger:</span></span><br><span class="line"><span class="string">    engineConfig:</span></span><br><span class="line"><span class="string">      cacheSizeGB: 1</span></span><br><span class="line"><span class="string">      directoryForIndexes: true</span></span><br><span class="line"><span class="string">    collectionConfig:</span></span><br><span class="line"><span class="string">      blockCompressor: zlib</span></span><br><span class="line"><span class="string">    indexConfig:</span></span><br><span class="line"><span class="string">      prefixCompression: true</span></span><br><span class="line"><span class="string">net:</span></span><br><span class="line"><span class="string">  bindIpAll: true</span></span><br><span class="line"><span class="string">  port: 28019</span></span><br><span class="line"><span class="string">replication:</span></span><br><span class="line"><span class="string">  oplogSizeMB: 2048</span></span><br><span class="line"><span class="string">  replSetName: configReplSet</span></span><br><span class="line"><span class="string">sharding:</span></span><br><span class="line"><span class="string">  clusterRole: configsvr</span></span><br><span class="line"><span class="string">processManagement: </span></span><br><span class="line"><span class="string">  fork: true</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>

<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 所有机器</span></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">mongod -f /mongodb/28017/conf/mongodb.conf</span><br><span class="line">mongod -f /mongodb/28018/conf/mongodb.conf      </span><br><span class="line">mongod -f /mongodb/28019/conf/mongodb.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭</span></span><br><span class="line">mongod -f /mongodb/28017/conf/mongodb.conf  --shutdown</span><br><span class="line">mongod -f /mongodb/28018/conf/mongodb.conf  --shutdown     </span><br><span class="line">mongod -f /mongodb/28019/conf/mongodb.conf  --shutdown</span><br></pre></td></tr></table></figure>

<h4 id="配置复制集"><a href="#配置复制集" class="headerlink" title="配置复制集"></a>配置复制集</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在db1上操作即可</span></span><br><span class="line">su - mongod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制集1</span></span><br><span class="line">mongo --port 28017 admin</span><br><span class="line">use admin</span><br><span class="line">config = &#123;_id: <span class="string">&#x27;sh1&#x27;</span>, members: [</span><br><span class="line">                          &#123;_id: 0, host: <span class="string">&#x27;192.168.0.11:28017&#x27;</span>&#125;,</span><br><span class="line">                          &#123;_id: 1, host: <span class="string">&#x27;192.168.0.12:28017&#x27;</span>&#125;,</span><br><span class="line">                          &#123;_id: 2, host: <span class="string">&#x27;192.168.0.13:28017&#x27;</span>&#125;]</span><br><span class="line">           &#125;</span><br><span class="line">rs.initiate(config)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制集2</span></span><br><span class="line">mongo --port 28018 admin </span><br><span class="line">use admin</span><br><span class="line">config = &#123;_id: <span class="string">&#x27;sh2&#x27;</span>, members: [</span><br><span class="line">                        &#123;_id: 0, host: <span class="string">&#x27;192.168.0.11:28018&#x27;</span>&#125;,</span><br><span class="line">                        &#123;_id: 1, host: <span class="string">&#x27;192.168.0.12:28018&#x27;</span>&#125;,</span><br><span class="line">                        &#123;_id: 2, host: <span class="string">&#x27;192.168.0.13:28018&#x27;</span>&#125;]</span><br><span class="line">         &#125;</span><br><span class="line">rs.initiate(config)</span><br></pre></td></tr></table></figure>

<h4 id="配置config节点"><a href="#配置config节点" class="headerlink" title="配置config节点"></a>配置<code>config</code>节点</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongo --port 28019 admin</span><br><span class="line">use  admin</span><br><span class="line">config = &#123;_id: <span class="string">&#x27;configReplSet&#x27;</span>, members: [</span><br><span class="line">                        &#123;_id: 0, host: <span class="string">&#x27;192.168.0.11:28019&#x27;</span>&#125;,</span><br><span class="line">                        &#123;_id: 1, host: <span class="string">&#x27;192.168.0.12:28019&#x27;</span>&#125;,</span><br><span class="line">                        &#123;_id: 2, host: <span class="string">&#x27;192.168.0.13:28019&#x27;</span>&#125;]</span><br><span class="line">         &#125;</span><br><span class="line">rs.initiate(config)  </span><br><span class="line">  </span><br><span class="line">注：configserver 可以是一个节点，官方建议复制集。configserver不能有arbiter</span><br><span class="line">新版本中，要求必须是复制集</span><br><span class="line">注：mongodb 3.4之后，虽然要求config server为replica <span class="built_in">set</span>，但是不支持arbiter</span><br></pre></td></tr></table></figure>

<h4 id="配置mongos节点"><a href="#配置mongos节点" class="headerlink" title="配置mongos节点"></a>配置<code>mongos</code>节点</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># db1单独配置</span></span><br><span class="line">mkdir -p /mongodb/28020/&#123;conf,<span class="built_in">log</span>&#125;</span><br><span class="line">cat &gt; /mongodb/28020/conf/mongos.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">systemLog:</span></span><br><span class="line"><span class="string">  destination: file</span></span><br><span class="line"><span class="string">  path: /mongodb/28020/log/mongos.log</span></span><br><span class="line"><span class="string">  logAppend: true</span></span><br><span class="line"><span class="string">net:</span></span><br><span class="line"><span class="string">  bindIpAll: true </span></span><br><span class="line"><span class="string">  port: 28020</span></span><br><span class="line"><span class="string">sharding:</span></span><br><span class="line"><span class="string">  configDB: configReplSet/192.168.0.11:28019,192.168.0.12:28019,192.168.0.13:28019</span></span><br><span class="line"><span class="string">processManagement: </span></span><br><span class="line"><span class="string">  fork: true</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 mongos 命令有差别</span></span><br><span class="line">mongos -f /mongodb/28020/conf/mongos.conf </span><br></pre></td></tr></table></figure>

<h4 id="mongos添加分片集群"><a href="#mongos添加分片集群" class="headerlink" title="mongos添加分片集群"></a>mongos添加分片集群</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在db1上操作(随便一台都行)</span></span><br><span class="line"><span class="comment"># 连接到mongs的admin数据库</span></span><br><span class="line">su - mongod</span><br><span class="line">mongo 192.168.0.11:28020/admin</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加分片</span></span><br><span class="line">db.runCommand( &#123; addshard : <span class="string">&quot;sh1/192.168.0.11:28017,192.168.0.12:28017,192.168.0.13:28017&quot;</span>,name:<span class="string">&quot;shard1&quot;</span>&#125; )</span><br><span class="line">db.runCommand( &#123; addshard : <span class="string">&quot;sh2/192.168.0.11:28018,192.168.0.12:28018,192.168.0.13:28018&quot;</span>,name:<span class="string">&quot;shard2&quot;</span>&#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出分片</span></span><br><span class="line">db.runCommand( &#123; listshards : 1 &#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整体状态查看</span></span><br><span class="line">sh.status()</span><br></pre></td></tr></table></figure>

<h3 id="使用分片"><a href="#使用分片" class="headerlink" title="使用分片"></a>使用分片</h3><h4 id="RANGE分片配置及测试"><a href="#RANGE分片配置及测试" class="headerlink" title="RANGE分片配置及测试"></a><code>RANGE</code>分片配置及测试</h4><h5 id="激活数据库分片功能"><a href="#激活数据库分片功能" class="headerlink" title="激活数据库分片功能"></a>激活数据库分片功能</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">db.runCommand( &#123; enablesharding : <span class="string">&quot;数据库名称&quot;</span> &#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 例如激活test库分片功能，先登录 mongos </span></span><br><span class="line">mongo 192.168.0.11:28020/admin</span><br><span class="line">db.runCommand( &#123; enablesharding : <span class="string">&quot;test&quot;</span> &#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整体状态查看</span></span><br><span class="line">sh.status()</span><br></pre></td></tr></table></figure>

<h5 id="指定分片键对集合分片"><a href="#指定分片键对集合分片" class="headerlink" title="指定分片键对集合分片"></a>指定分片键对集合分片</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建索引</span></span><br><span class="line">use <span class="built_in">test</span></span><br><span class="line">db.vast.ensureIndex( &#123; id: 1 &#125; )</span><br><span class="line">show tables;</span><br><span class="line">db.vest.find()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启分片</span></span><br><span class="line">use admin</span><br><span class="line">db.runCommand( &#123; shardcollection : <span class="string">&quot;test.vast&quot;</span>,key : &#123;id: 1&#125; &#125; )</span><br><span class="line">sh.status()</span><br></pre></td></tr></table></figure>

<h5 id="集合分片验证"><a href="#集合分片验证" class="headerlink" title="集合分片验证"></a>集合分片验证</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">use <span class="built_in">test</span></span><br><span class="line"><span class="keyword">for</span>(i=1;i&lt;1000000;i++)&#123; db.vast.insert(&#123;<span class="string">&quot;id&quot;</span>:i,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;shenzheng&quot;</span>,<span class="string">&quot;age&quot;</span>:70,<span class="string">&quot;date&quot;</span>:new Date()&#125;); &#125;</span><br><span class="line">db.vast.stats()</span><br></pre></td></tr></table></figure>

<h5 id="分片结果测试"><a href="#分片结果测试" class="headerlink" title="分片结果测试"></a>分片结果测试</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复制集1</span></span><br><span class="line">mongo --port 28017</span><br><span class="line">use <span class="built_in">test</span></span><br><span class="line">db.vast.count();</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制集2</span></span><br><span class="line">mongo --port 28018</span><br><span class="line">use <span class="built_in">test</span></span><br><span class="line">db.vast.count();</span><br></pre></td></tr></table></figure>

<h4 id="Hash分片"><a href="#Hash分片" class="headerlink" title="Hash分片"></a><code>Hash</code>分片</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对test1库下的vast大表进行hash</span></span><br><span class="line"><span class="comment"># 创建哈希索引</span></span><br><span class="line"><span class="comment"># 对于test1开启分片功能，连接到mongos</span></span><br><span class="line">mongo 192.168.0.11:28020/admin</span><br><span class="line"></span><br><span class="line">use admin</span><br><span class="line">db.runCommand( &#123; enablesharding : <span class="string">&quot;test1&quot;</span> &#125; )</span><br><span class="line">sh.status()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对于test1库下的vast表建立hash索引</span></span><br><span class="line">use test1</span><br><span class="line">db.vast.ensureIndex( &#123; id: <span class="string">&quot;hashed&quot;</span> &#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开启分片 </span></span><br><span class="line">use admin</span><br><span class="line">sh.shardCollection( <span class="string">&quot;test1.vast&quot;</span>, &#123; id: <span class="string">&quot;hashed&quot;</span> &#125; )</span><br><span class="line">sh.status()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 录入10w行数据测试</span></span><br><span class="line">use test1</span><br><span class="line"><span class="keyword">for</span>(i=1;i&lt;100000;i++)&#123; db.vast.insert(&#123;<span class="string">&quot;id&quot;</span>:i,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;shenzheng&quot;</span>,<span class="string">&quot;age&quot;</span>:70,<span class="string">&quot;date&quot;</span>:new Date()&#125;); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># hash分片结果测试</span></span><br><span class="line"><span class="comment"># 复制集1</span></span><br><span class="line">mongo --port 28017</span><br><span class="line">use test1</span><br><span class="line">db.vast.count();</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复制集2</span></span><br><span class="line">mongo --port 28018</span><br><span class="line">use test1</span><br><span class="line">db.vast.count();</span><br></pre></td></tr></table></figure>

<h3 id="分片集群查询及管理"><a href="#分片集群查询及管理" class="headerlink" title="分片集群查询及管理"></a>分片集群查询及管理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断是否Shard集群</span></span><br><span class="line">db.runCommand(&#123; isdbgrid : 1&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有分片信息</span></span><br><span class="line">db.runCommand(&#123; listshards : 1&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出开启分片的数据库</span></span><br><span class="line">use config</span><br><span class="line">db.databases.find( &#123; <span class="string">&quot;partitioned&quot;</span>: <span class="literal">true</span> &#125; )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看分片的片键</span></span><br><span class="line">db.collections.find().pretty()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看分片的详细信息</span></span><br><span class="line">sh.status()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除分片节点(谨慎)</span></span><br><span class="line">    <span class="comment"># 确认blance是否在工作</span></span><br><span class="line">    sh.getBalancerState()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 删除shard2节点(谨慎)</span></span><br><span class="line">    db.runCommand( &#123; removeShard: <span class="string">&quot;shard2&quot;</span> &#125; )</span><br><span class="line">    <span class="comment"># 注意：删除操作一定会立即触发blancer</span></span><br></pre></td></tr></table></figure>

<h3 id="balancer操作"><a href="#balancer操作" class="headerlink" title="balancer操作"></a>balancer操作</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongos的一个重要功能，自动巡查所有shard节点上的chunk的情况，自动做chunk迁移，什么时候工作？</span><br><span class="line">1、自动运行，会检测系统不繁忙的时候做迁移</span><br><span class="line">2、在做节点删除的时候，立即开始迁移工作</span><br><span class="line">3、balancer只能在预设定的时间窗口内运行</span><br><span class="line"></span><br><span class="line">有需要时可以关闭和开启blancer（备份的时候）</span><br><span class="line">sh.stopBalancer()</span><br><span class="line">sh.startBalancer()</span><br></pre></td></tr></table></figure>

<h4 id="自动平衡时间段"><a href="#自动平衡时间段" class="headerlink" title="自动平衡时间段"></a>自动平衡时间段</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 官方文档: https://docs.mongodb.com/manual/tutorial/manage-sharded-cluster-balancer/#schedule-the-balancing-window</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到mongos</span></span><br><span class="line">use config</span><br><span class="line">sh.setBalancerState( <span class="literal">true</span> )</span><br><span class="line">db.settings.update(&#123; _id : <span class="string">&quot;balancer&quot;</span> &#125;, &#123; <span class="variable">$set</span> : &#123; activeWindow : &#123; start : <span class="string">&quot;3:00&quot;</span>, stop : <span class="string">&quot;5:00&quot;</span> &#125; &#125; &#125;, <span class="literal">true</span> )</span><br><span class="line"></span><br><span class="line">sh.getBalancerWindow()</span><br><span class="line">sh.status()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关于集合的balancer</span></span><br><span class="line">    <span class="comment"># 关闭某个集合的balance</span></span><br><span class="line">    sh.disableBalancing(<span class="string">&quot;students.grades&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打开某个集合的balancer</span></span><br><span class="line">    sh.enableBalancing(<span class="string">&quot;students.grades&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 确定某个集合的balance是开启或者关闭</span></span><br><span class="line">    db.getSiblingDB(<span class="string">&quot;config&quot;</span>).collections.findOne(&#123;_id : <span class="string">&quot;students.grades&quot;</span>&#125;).noBalance</span><br></pre></td></tr></table></figure>

<h3 id="分片集群设计"><a href="#分片集群设计" class="headerlink" title="分片集群设计"></a>分片集群设计</h3><h4 id="分片的基本标准"><a href="#分片的基本标准" class="headerlink" title="分片的基本标准"></a>分片的基本标准</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.关于数据：数据量不超过3TB，尽可能保持在2TB一个片</span><br><span class="line">2.关于索引：常用索引必须容纳进内存</span><br><span class="line">3.按照以上标准初步确定分片后，还需要考虑业务压力，随着压力增大，CPU、RAM、磁盘中的任何一项出现瓶颈时，都可以通过添加更多分片来解决</span><br></pre></td></tr></table></figure>

<h4 id="需求多少分片"><a href="#需求多少分片" class="headerlink" title="需求多少分片"></a>需求多少分片</h4><table>
<thead>
<tr>
<th>条件</th>
<th>分片个数</th>
</tr>
</thead>
<tbody><tr>
<td>A = 所需存储总量 / 单服务器可挂载容量</td>
<td>8TB / 2TB = 4</td>
</tr>
<tr>
<td>B = 工作集大小 / 单服务器内存容量</td>
<td>400GB / （256G * 0.6） = 3</td>
</tr>
<tr>
<td>C = 并发量总数 / （单服务器并发量 * 0.7）</td>
<td>30000 / (9000*0.7) = 6</td>
</tr>
<tr>
<td>额外开销</td>
<td></td>
</tr>
</tbody></table>
<h4 id="其他需求"><a href="#其他需求" class="headerlink" title="其他需求"></a>其他需求</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">考虑分片的分布：</span><br><span class="line">1.是否需要跨机房分布分片</span><br><span class="line">2.是否需要容灾</span><br><span class="line">3.高可用的要求如何</span><br></pre></td></tr></table></figure>

<h4 id="正确的姿势"><a href="#正确的姿势" class="headerlink" title="正确的姿势"></a>正确的姿势</h4><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20220104111409719.png" alt="image-20220104111409719"></p>
<h5 id="选择合适的片键"><a href="#选择合适的片键" class="headerlink" title="选择合适的片键"></a>选择合适的片键</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">影响片键效率的主要因素:</span><br><span class="line">1.取值基数(Cardinality)</span><br><span class="line">2.取值分布</span><br><span class="line">3.分散写，集中读</span><br><span class="line">4.被尽可能多的业务场景用到</span><br><span class="line">5.避免单调递增或递减的片键</span><br></pre></td></tr></table></figure>

<h5 id="选择基数大的片键"><a href="#选择基数大的片键" class="headerlink" title="选择基数大的片键"></a>选择基数大的片键</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">对于小基数的片键:</span><br><span class="line">1.因为备选值有限，那么块的总数量就有限</span><br><span class="line">2.随着数据增多，块的大小会越来越大</span><br><span class="line">3.水平扩展时移动块会非常困难</span><br><span class="line"></span><br><span class="line">例如：存储一个高中的师生数据，以年龄（假设年龄范围为15~65岁）作为片键，那么:</span><br><span class="line">1.15&lt;=年龄&lt;=65，且只为整数</span><br><span class="line">2.最多只会有51个 chunk</span><br><span class="line">结论：取值基数要大</span><br></pre></td></tr></table></figure>

<h5 id="选择分布均匀的片键"><a href="#选择分布均匀的片键" class="headerlink" title="选择分布均匀的片键"></a>选择分布均匀的片键</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">对于分布不均匀的片键</span><br><span class="line">1.造成某些块的数据量急剧增大</span><br><span class="line">2.这些块压力随之增大</span><br><span class="line">3.数据均衡以 chunk 为单位，所以系统无能为力</span><br><span class="line"></span><br><span class="line">例如：存储一个学校的师生数据，以年龄（假设年龄范围为15~65岁）作为片键，那么：</span><br><span class="line">1.15&lt;=年龄&lt;=65，且只为整数</span><br><span class="line">2.大部分人的年龄范围为15~18岁（学生）</span><br><span class="line">3.15、16、17、18四个 chunk 的数据量、访问压力远大于其他 chunk</span><br><span class="line">结论：取值分布应尽可能均匀</span><br></pre></td></tr></table></figure>

<h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  _id: ObjectId(),</span><br><span class="line">  user: <span class="number">123</span>,</span><br><span class="line">  time: Date(),</span><br><span class="line">  subject: “...”,</span><br><span class="line">  recipients: [],</span><br><span class="line">  body: “...”,</span><br><span class="line">  attachments: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="片键-id-1"><a href="#片键-id-1" class="headerlink" title="片键: { _id: 1}"></a>片键: { _id: 1}</h6><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20220104114356075.png" alt="image-20220104114356075"></p>
<h6 id="片键：-id-”hashed”"><a href="#片键：-id-”hashed”" class="headerlink" title="片键： { _id: ”hashed”}"></a>片键： { _id: ”hashed”}</h6><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20220104114436035.png" alt="image-20220104114436035"></p>
<h6 id="片键：-user-id-1"><a href="#片键：-user-id-1" class="headerlink" title="片键： { user_id: 1 }"></a>片键： { user_id: 1 }</h6><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20220104114502342.png" alt="image-20220104114502342"></p>
<h6 id="片键：-user-id-1-time-1"><a href="#片键：-user-id-1-time-1" class="headerlink" title="片键： { user_id: 1, time:1 }"></a>片键： { user_id: 1, time:1 }</h6><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20220104114530321.png" alt="image-20220104114530321"></p>
<h5 id="硬件规划"><a href="#硬件规划" class="headerlink" title="硬件规划"></a>硬件规划</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongos 与 config 通常消耗很少的资源，可以选择低规格虚拟机，资源的重点在于 shard 服务器:</span><br><span class="line">  1.需要足以容纳热数据索引的内存</span><br><span class="line">  2.正确创建索引后 CPU 通常不会成为瓶颈，除非涉及非常多的计算</span><br><span class="line">  3.磁盘尽量选用 SSD</span><br><span class="line">  4.最后，实际测试是最好的检验，来看你的资源配置是否完备</span><br><span class="line"></span><br><span class="line">即使项目初期已经具备了足够的资源，仍然需要考虑在合适的时候扩展。建议监控各项资源使用情况，无论哪一项达到60%以上，则开始考虑扩展，因为：</span><br><span class="line">  1.扩展需要新的资源，申请新资源需要时间</span><br><span class="line">  2.扩展后数据需要均衡，均衡需要时间。应保证新数据入库速度慢于均衡速度</span><br><span class="line">  3.均衡需要资源，如果资源即将或已经耗尽，均衡也是会很低效的</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB复制集</title>
    <url>/37db6981.html</url>
    <content><![CDATA[<h3 id="复制集的作用"><a href="#复制集的作用" class="headerlink" title="复制集的作用"></a>复制集的作用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MongoDB 复制集的主要意义在于实现服务高可用，它的现实依赖于两个方面的功能</span><br><span class="line">1.数据写入时将数据迅速复制到另一个独立节点上</span><br><span class="line">2.在接受写入的节点发生故障时自动选举出一个新的替代节点</span><br><span class="line"></span><br><span class="line">在实现高可用的同时，复制集实现了其他几个附加作用</span><br><span class="line">1.数据分发：将数据从一个区域复制到另一个区域，减少另一个区域的读延迟</span><br><span class="line">2.读写分离：不同类型的压力分别在不同的节点上执行</span><br><span class="line">3.异地容灾：在数据中心故障时候快速切换到异地</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="典型复制集结构"><a href="#典型复制集结构" class="headerlink" title="典型复制集结构"></a>典型复制集结构</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">一个典型的复制集由3个以上具有投票权的节点组成</span><br><span class="line">1.一个主节点（PRIMARY）：接受写入操作和选举时投票</span><br><span class="line">2.两个（或多个）从节点（SECONDARY）：复制主节点上的新数据和选举时投票</span><br><span class="line">3.不推荐使用 Arbiter（投票节点）</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/B6n7ov.png" alt="B6n7ov"></p>
<h3 id="数据是如何复制的"><a href="#数据是如何复制的" class="headerlink" title="数据是如何复制的"></a>数据是如何复制的</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.当一个修改操作，无论是插入、更新或删除，到达主节点时，它对数据的操作将被记录下来（经过一些必要的转换），这些记录称为 oplog (是一张表)</span><br><span class="line">2.从节点通过在主节点上打开一个 tailable 游标不断获取新进入主节点的 oplog，并在自己的数据上回放，以此保持跟主节点的数据一致</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/cTeuoL.png" alt="cTeuoL"></p>
<h3 id="通过选举完成故障恢复"><a href="#通过选举完成故障恢复" class="headerlink" title="通过选举完成故障恢复"></a>通过选举完成故障恢复</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.具有投票权的节点之间两两互相发送心跳</span><br><span class="line">2.当5次心跳未收到时判断为节点失联</span><br><span class="line">3.如果失联的是主节点，从节点会发起选举，选出新的主节点</span><br><span class="line">4.如果失联的是从节点则不会产生新的选举</span><br><span class="line">5.选举基于 RAFT一致性算法 实现，选举成功的必要条件是大多数投票节点存活</span><br><span class="line">6.复制集中最多可以有50个节点，但具有投票权的节点最多7个</span><br></pre></td></tr></table></figure>

<h3 id="影响选举的因素"><a href="#影响选举的因素" class="headerlink" title="影响选举的因素"></a>影响选举的因素</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">整个集群必须有大多数节点存活，被选举为主节点的节点必须</span><br><span class="line">  1.能够与多数节点建立连接</span><br><span class="line">  2.具有较新的 oplog</span><br><span class="line">  3.具有较高的优先级（如果有配置）</span><br></pre></td></tr></table></figure>

<h3 id="常见选项"><a href="#常见选项" class="headerlink" title="常见选项"></a>常见选项</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">复制集节点有以下常见的选配项</span><br><span class="line">1.是否具有投票权（v 参数）：有则参与投票</span><br><span class="line">2.优先级（priority 参数）：优先级越高的节点越优先成为主节点。优先级为0的节点无法成为主节点</span><br><span class="line">3.隐藏（hidden 参数）：复制数据，但对应用不可见。隐藏节点可以具有投票仅，但优先级必须为0</span><br><span class="line">4.延迟（slaveDelay 参数）：复制 n 秒之前的数据，保持与主节点的时间差</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/3QYZEh.png" alt="3QYZEh"></p>
<h3 id="复制集注意事项"><a href="#复制集注意事项" class="headerlink" title="复制集注意事项"></a>复制集注意事项</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">关于硬件:</span><br><span class="line">1.因为正常的复制集节点都有可能成为主节点，它们的地位是一样的，因此硬件配置上必须一致</span><br><span class="line">2.为了保证节点不会同时宕机，各节点使用的硬件必须具有独立性</span><br><span class="line"></span><br><span class="line">关于软件:</span><br><span class="line">1.复制集各节点软件版本必须一致，以避免出现不可预知的问题。</span><br><span class="line"> </span><br><span class="line">增加节点不会增加系统写性能</span><br></pre></td></tr></table></figure>

<h3 id="搭建复制集"><a href="#搭建复制集" class="headerlink" title="搭建复制集"></a>搭建复制集</h3><h4 id="多实例配置启动"><a href="#多实例配置启动" class="headerlink" title="多实例配置启动"></a>多实例配置启动</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 三个以上的mongodb节点（或多实例）</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 采用多实例的端口规划</span></span><br><span class="line">28017、28018、28019、28020</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建相关目录</span></span><br><span class="line">mkdir -p /mongodb/&#123;28017..28020&#125;/&#123;conf,data,<span class="built_in">log</span>&#125;</span><br><span class="line">tree -L 2 /mongodb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line">cat &gt; /mongodb/28017/conf/mongod.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">systemLog:</span></span><br><span class="line"><span class="string">  destination: file</span></span><br><span class="line"><span class="string">  path: /mongodb/28017/log/mongodb.log</span></span><br><span class="line"><span class="string">  logAppend: true</span></span><br><span class="line"><span class="string">storage:</span></span><br><span class="line"><span class="string">  journal:</span></span><br><span class="line"><span class="string">    enabled: true</span></span><br><span class="line"><span class="string">  dbPath: /mongodb/28017/data</span></span><br><span class="line"><span class="string">  directoryPerDB: true</span></span><br><span class="line"><span class="string">  #engine: wiredTiger</span></span><br><span class="line"><span class="string">  wiredTiger:</span></span><br><span class="line"><span class="string">    engineConfig:</span></span><br><span class="line"><span class="string">      cacheSizeGB: 1</span></span><br><span class="line"><span class="string">      directoryForIndexes: true</span></span><br><span class="line"><span class="string">    collectionConfig:</span></span><br><span class="line"><span class="string">      blockCompressor: zlib</span></span><br><span class="line"><span class="string">    indexConfig:</span></span><br><span class="line"><span class="string">      prefixCompression: true</span></span><br><span class="line"><span class="string">processManagement:</span></span><br><span class="line"><span class="string">  fork: true</span></span><br><span class="line"><span class="string">net:</span></span><br><span class="line"><span class="string">  bindIpAll: true</span></span><br><span class="line"><span class="string">  port: 28017</span></span><br><span class="line"><span class="string">replication:</span></span><br><span class="line"><span class="string">  oplogSizeMB: 2048</span></span><br><span class="line"><span class="string">  replSetName: my_repl</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件说明</span></span><br><span class="line">engine: wiredTiger   <span class="comment"># 存储引擎，默认就是wiredTiger</span></span><br><span class="line">cacheSizeGB: 1       <span class="comment"># 类似缓冲区大小</span></span><br><span class="line">oplogSizeMB: 2048    <span class="comment"># 设置  oplog 大小</span></span><br><span class="line">replSetName: my_repl <span class="comment"># 设置 oplog 名字，要和配置复制内的名称一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 多配置文件复制</span></span><br><span class="line">cp  /mongodb/28017/conf/mongod.conf  /mongodb/28018/conf/</span><br><span class="line">cp  /mongodb/28017/conf/mongod.conf  /mongodb/28019/conf/</span><br><span class="line">cp  /mongodb/28017/conf/mongod.conf  /mongodb/28020/conf/</span><br><span class="line"></span><br><span class="line">sed -i <span class="string">&#x27;s#28017#28018#g&#x27;</span> /mongodb/28018/conf/mongod.conf</span><br><span class="line">sed -i <span class="string">&#x27;s#28017#28019#g&#x27;</span> /mongodb/28019/conf/mongod.conf</span><br><span class="line">sed -i <span class="string">&#x27;s#28017#28020#g&#x27;</span> /mongodb/28020/conf/mongod.conf</span><br><span class="line"></span><br><span class="line">chown -R mongod:mongod /mongodb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">su - mongod</span><br><span class="line">mongod -f /mongodb/28017/conf/mongod.conf</span><br><span class="line">mongod -f /mongodb/28018/conf/mongod.conf</span><br><span class="line">mongod -f /mongodb/28019/conf/mongod.conf</span><br><span class="line">mongod -f /mongodb/28020/conf/mongod.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查</span></span><br><span class="line">netstat -lntp |grep 280</span><br></pre></td></tr></table></figure>

<h4 id="配置复制集"><a href="#配置复制集" class="headerlink" title="配置复制集"></a>配置复制集</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1主2从，从库普通从库 PSS</span></span><br><span class="line">mongo --port 28017 admin</span><br><span class="line"></span><br><span class="line">config = &#123;_id: <span class="string">&#x27;my_repl&#x27;</span>, members: [</span><br><span class="line">                          &#123;_id: 0, host: <span class="string">&#x27;192.168.0.11:28017&#x27;</span>&#125;,</span><br><span class="line">                          &#123;_id: 1, host: <span class="string">&#x27;192.168.0.11:28018&#x27;</span>&#125;,</span><br><span class="line">                          &#123;_id: 2, host: <span class="string">&#x27;192.168.0.11:28019&#x27;</span>&#125;]</span><br><span class="line">          &#125;                   </span><br><span class="line">rs.initiate(config) </span><br><span class="line">rs.status();  //查询复制集状态</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1主1从1个arbiter PSA</span></span><br><span class="line">mongo -port 28017 admin</span><br><span class="line">config = &#123;_id: <span class="string">&#x27;my_repl&#x27;</span>, members: [</span><br><span class="line">                          &#123;_id: 0, host: <span class="string">&#x27;192.168.0.11:28017&#x27;</span>&#125;,</span><br><span class="line">                          &#123;_id: 1, host: <span class="string">&#x27;192.168.0.11:28018&#x27;</span>&#125;,</span><br><span class="line">                          &#123;_id: 2, host: <span class="string">&#x27;192.168.0.11:28019&#x27;</span>,<span class="string">&quot;arbiterOnly&quot;</span>:<span class="literal">true</span>&#125;]</span><br><span class="line">          &#125;                </span><br><span class="line">rs.initiate(config) </span><br></pre></td></tr></table></figure>

<h3 id="复制集测试"><a href="#复制集测试" class="headerlink" title="复制集测试"></a>复制集测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主库插入数据</span></span><br><span class="line">mongo --port 28017 admin</span><br><span class="line">use <span class="built_in">test</span></span><br><span class="line">db.movies.insert([&#123; <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Jaws&quot;</span>,<span class="string">&quot;year&quot;</span>:1975 ,<span class="string">&quot;imdb_rating&quot;</span>:8.1&#125;,</span><br><span class="line">                  &#123; <span class="string">&quot;title&quot;</span>: <span class="string">&quot;Batman&quot;</span>,<span class="string">&quot;year&quot;</span>:1989,<span class="string">&quot;imdb_rating&quot;</span>:7.6&#125;]);</span><br><span class="line">                  </span><br><span class="line">db.movies.find().pretty()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从库查看</span></span><br><span class="line">mongo --port 28018 admin</span><br><span class="line">use <span class="built_in">test</span></span><br><span class="line">db.movies.find().pretty()  //默认情况下从库不允许读写</span><br><span class="line">rs.slaveOk()               //当前版本4.4还可以用，提示后续会弃用，use secondaryOk() instead</span><br><span class="line">db.movies.find().pretty()  //此时就可以查看到数据了</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭主库查看从库接管情况</span></span><br><span class="line">mongod -f /mongodb/28017/conf/mongod.conf --shutdown</span><br></pre></td></tr></table></figure>

<h3 id="复制集管理"><a href="#复制集管理" class="headerlink" title="复制集管理"></a>复制集管理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看状态</span></span><br><span class="line">rs.status();    //查看整体复制集状态</span><br><span class="line">rs.isMaster();  // 查看当前是否是主节点</span><br><span class="line">rs.conf()；     //查看复制集配置信息</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加和删除节点命令</span></span><br><span class="line">rs.add(<span class="string">&quot;ip:port&quot;</span>); // 新增从节点</span><br><span class="line">rs.remove(<span class="string">&quot;ip:port&quot;</span>); // 删除一个节点</span><br><span class="line">rs.addArb(<span class="string">&quot;ip:port&quot;</span>); // 新增仲裁节点</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接到主节点(shell命令)</span></span><br><span class="line">mongo --port 28017 admin </span><br><span class="line"></span><br><span class="line"><span class="comment"># 新增从节点</span></span><br><span class="line">rs.add(<span class="string">&quot;192.168.0.11:28020&quot;</span>)</span><br><span class="line">rs.status();</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除一个节点</span></span><br><span class="line">rs.remove(<span class="string">&quot;192.168.0.11:28020&quot;</span>);</span><br><span class="line">rs.status();</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加 arbiter节点</span></span><br><span class="line">rs.addArb(<span class="string">&quot;192.168.0.11:28020&quot;</span>)</span><br><span class="line">rs.status();</span><br><span class="line"></span><br><span class="line">从其他集群踢出的节点不能直接加入新的集群，强行加入也会被踢出，需要先清空这个节点的数据再加入</span><br></pre></td></tr></table></figure>

<h3 id="特殊从节点"><a href="#特殊从节点" class="headerlink" title="特殊从节点"></a>特殊从节点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">priority (0-1000): 优先级越高的节点越优先成为主节点，优先级为0的节点无法成为主节点</span><br><span class="line">hidden 参数: 复制数据，但对应用不可见，隐藏节点可以具有投票仅，但优先级必须为0</span><br><span class="line">slaveDelay 参数: 复制 n 秒之前的数据，保持与主节点的时间差</span><br><span class="line"></span><br><span class="line"><span class="comment"># 节点种类</span></span><br><span class="line">arbiter节点: 主要负责选主过程中的投票，但是不存储任何数据，也不提供任何服务</span><br><span class="line">hidden节点: 隐藏节点，不参与选主，也不对外提供服务</span><br><span class="line">delay节点: 延时节点，数据落后于主库一段时间，因为数据是延时的，也不应该提供服务或参与选主，所以通常会配合hidden（隐藏）</span><br><span class="line">一般情况下会将delay+hidden一起配置使用</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看副本集的配置信息</span></span><br><span class="line">rs.<span class="function"><span class="title">conf</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;_id&quot;</span> : <span class="string">&quot;my_repl&quot;</span>,</span><br><span class="line">	<span class="string">&quot;version&quot;</span> : 2,</span><br><span class="line">	<span class="string">&quot;protocolVersion&quot;</span> : NumberLong(1),</span><br><span class="line">	<span class="string">&quot;writeConcernMajorityJournalDefault&quot;</span> : <span class="literal">true</span>,</span><br><span class="line">	<span class="string">&quot;members&quot;</span> : [</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="string">&quot;_id&quot;</span> : 0,</span><br><span class="line">			<span class="string">&quot;host&quot;</span> : <span class="string">&quot;192.168.0.11:28017&quot;</span>,  // 主机和端口</span><br><span class="line">			<span class="string">&quot;arbiterOnly&quot;</span> : <span class="literal">false</span>,  //是不是arbiter节点</span><br><span class="line">			<span class="string">&quot;buildIndexes&quot;</span> : <span class="literal">true</span>, </span><br><span class="line">			<span class="string">&quot;hidden&quot;</span> : <span class="literal">false</span>,  //隐藏节点</span><br><span class="line">			<span class="string">&quot;priority&quot;</span> : 1,  //权重</span><br><span class="line">			<span class="string">&quot;tags&quot;</span> : &#123;</span><br><span class="line"></span><br><span class="line">			&#125;,</span><br><span class="line">			<span class="string">&quot;slaveDelay&quot;</span> : NumberLong(0),</span><br><span class="line">			<span class="string">&quot;votes&quot;</span> : 1  //参与节点投票</span><br><span class="line">		&#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置延时节点（一般延时节点也配置成hidden）</span></span><br><span class="line"><span class="comment"># MongoDB数据库内配置</span></span><br><span class="line">rs.conf()  //查看当前配置</span><br><span class="line">cfg=rs.conf() </span><br><span class="line">//members[num]中，num是从0开始依次往下数的节点数字，不是根据 _id 数字，因为后续添加删除之后这个数字容易混乱</span><br><span class="line">cfg.members[3].priority=0  //不能成为主节点</span><br><span class="line">cfg.members[3].hidden=<span class="literal">true</span>  //隐藏节点</span><br><span class="line">cfg.members[3].slaveDelay=120  //延时2小时同步</span><br><span class="line">cfg.members[3].votes=0  //不参与投票</span><br><span class="line">rs.reconfig(cfg)  //生效</span><br><span class="line">rs.conf()  //再次查看</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消以上配置,恢复</span></span><br><span class="line">cfg=rs.conf() </span><br><span class="line">cfg.members[3].priority=1</span><br><span class="line">cfg.members[3].hidden=<span class="literal">false</span></span><br><span class="line">cfg.members[3].slaveDelay=0</span><br><span class="line">cfg.members[3].votes=1</span><br><span class="line">rs.reconfig(cfg)    </span><br><span class="line">rs.conf();</span><br></pre></td></tr></table></figure>

<h3 id="其他命令操作"><a href="#其他命令操作" class="headerlink" title="其他命令操作"></a>其他命令操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看副本集各成员的状态</span></span><br><span class="line">rs.status()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 副本集角色切换（不要人为随便操作）</span></span><br><span class="line">rs.stepDown()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 锁定从，使其不会转变成主库</span></span><br><span class="line">rs.freeze(300)</span><br><span class="line">//freeze()和stepDown单位都是秒</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置副本节点可读：在副本节点执行</span></span><br><span class="line">rs.slaveOk()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看副本节点（监控主从延时）</span></span><br><span class="line">rs.printSlaveReplicationInfo()</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB聚合框架</title>
    <url>/3bf43096.html</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">MongoDB 聚合框架（Aggregation Framework）是一个计算框架</span><br><span class="line">1.作用在一个或几个集合上</span><br><span class="line">2.对集合中的数据进行的一系列运算</span><br><span class="line">3.将这些数据转化为期望的形式</span><br><span class="line"></span><br><span class="line">从效果而言，聚合框架相当于 SQL 查询里的 GROUP BY，LEFT OUTER JOIN， AS等</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="管道和步骤"><a href="#管道和步骤" class="headerlink" title="管道和步骤"></a>管道和步骤</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">整个聚合运算过程称为管道（Pipeline），它是由多个步骤（Stage）组成的，每个管道：</span><br><span class="line">接受一系列文档（原始数据）</span><br><span class="line">每个步骤对这些文档进行一系列运算</span><br><span class="line">结果文档输出给下一个步骤</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/6CZpmp.png" alt="6CZpmp"></p>
<h3 id="聚合运算的基本格式"><a href="#聚合运算的基本格式" class="headerlink" title="聚合运算的基本格式"></a>聚合运算的基本格式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pipeline = [<span class="variable">$stage1</span>, <span class="variable">$stage2</span>, ...<span class="variable">$stageN</span>];</span><br><span class="line"></span><br><span class="line">db.&lt;COLLECTION&gt;.aggregate(</span><br><span class="line">pipeline,</span><br><span class="line">&#123; options &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/qtz4v5.png" alt="qtz4v5"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/OiAelr.png" alt="OiAelr"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/hn9SKU.png" alt="hn9SKU"></p>
<h3 id="MQL常用步骤与SQL对比"><a href="#MQL常用步骤与SQL对比" class="headerlink" title="MQL常用步骤与SQL对比"></a>MQL常用步骤与SQL对比</h3><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/jOXO8p.png" alt="jOXO8p"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/5Gmlwo.png" alt="5Gmlwo"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/6yyGxc.png" alt="6yyGxc"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/TEfb3m.png" alt="TEfb3m"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/ozaeeI.png" alt="ozaeeI"></p>
<h3 id="运算实例"><a href="#运算实例" class="headerlink" title="运算实例"></a>运算实例</h3><p>测试数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wget https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/sql/dump.tar.gz</span></span><br><span class="line">curl -O -k https://raw.githubusercontent.com/tapdata/geektimemongodb-course/master/aggregation/dump.tar.gz</span><br><span class="line">tar xf dump.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果按照上述修改了用户和密码如下导入</span></span><br><span class="line">mongorestore -uroot -proot123 --port 27017 --authenticationDatabase admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入数据库查看</span></span><br><span class="line">mongo -uroot -proot123 admin</span><br><span class="line"></span><br><span class="line">show dbs</span><br><span class="line">use mock</span><br><span class="line">show collections  //查看集合</span><br><span class="line">db.orders.findOne()  //查看数据</span><br></pre></td></tr></table></figure>

<p>计算</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 计算到目前为止的所有订单总销售额</span></span><br><span class="line">db.orders.aggregate([</span><br><span class="line">	&#123;<span class="variable">$group</span>:</span><br><span class="line">		&#123;</span><br><span class="line">			_id:null,  //将整个表做汇总</span><br><span class="line">			total: &#123;<span class="variable">$sum</span>: <span class="string">&quot;<span class="variable">$total</span>&quot;</span>&#125;  //total自定义的，<span class="string">&quot;<span class="variable">$total</span>&quot;</span>才是数据的字段</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">])</span><br><span class="line">// 结果 &#123; <span class="string">&quot;_id&quot;</span> : null, <span class="string">&quot;total&quot;</span> : NumberDecimal(<span class="string">&quot;44019609&quot;</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询2019年第一季度（1月1日~3月31日）已完成订单（completed）的订单总金额和订单总数</span></span><br><span class="line"></span><br><span class="line">db.orders.aggregate([</span><br><span class="line">// 步骤1：匹配条件</span><br><span class="line">&#123; <span class="variable">$match</span>: &#123; status: <span class="string">&quot;completed&quot;</span>, orderDate: &#123;</span><br><span class="line">		<span class="variable">$gte</span>: ISODate(<span class="string">&quot;2019-01-01&quot;</span>),</span><br><span class="line">		<span class="variable">$lt</span>: ISODate(<span class="string">&quot;2019-04-01&quot;</span>) &#125; &#125; &#125;,</span><br><span class="line"></span><br><span class="line">// 步骤二：聚合订单总金额、总运费、总数量</span><br><span class="line">&#123; <span class="variable">$group</span>: &#123;</span><br><span class="line">_id: null,</span><br><span class="line">total: &#123; <span class="variable">$sum</span>: <span class="string">&quot;<span class="variable">$total</span>&quot;</span> &#125;,</span><br><span class="line">shippingFee: &#123; <span class="variable">$sum</span>: <span class="string">&quot;<span class="variable">$shippingFee</span>&quot;</span> &#125;,</span><br><span class="line">count: &#123; <span class="variable">$sum</span>: 1 &#125; &#125; &#125;,</span><br><span class="line"></span><br><span class="line">&#123; <span class="variable">$project</span>: &#123;</span><br><span class="line">// 计算总金额</span><br><span class="line">grandTotal: &#123; <span class="variable">$add</span>: [<span class="string">&quot;<span class="variable">$total</span>&quot;</span>, <span class="string">&quot;<span class="variable">$shippingFee</span>&quot;</span>] &#125;,</span><br><span class="line">count: 1,</span><br><span class="line">_id: 0 &#125; &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line">// 结果：</span><br><span class="line">// &#123; <span class="string">&quot;count&quot;</span> : 5875, <span class="string">&quot;grandTotal&quot;</span> : NumberDecimal(<span class="string">&quot;2636376.00&quot;</span>) &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="compass使用聚合"><a href="#compass使用聚合" class="headerlink" title="compass使用聚合"></a>compass使用聚合</h3><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/I01uEx.png" alt="I01uEx"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/ZuMRhx.png" alt="ZuMRhx"></p>
<p>语句导出不同的开发语言</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/XT5Uxr.png" alt="XT5Uxr"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/UpX1kj.png" alt="UpX1kj"></p>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB基本的CRUD</title>
    <url>/cb1bd433.html</url>
    <content><![CDATA[<h3 id="通用方法和获取帮助"><a href="#通用方法和获取帮助" class="headerlink" title="通用方法和获取帮助"></a>通用方法和获取帮助</h3><span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取帮助</span></span><br><span class="line"><span class="built_in">help</span></span><br><span class="line"><span class="built_in">help</span></span><br><span class="line">db.help()</span><br><span class="line">db.t1.help()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 常用操作</span></span><br><span class="line">//查看当前db版本</span><br><span class="line">db.version()</span><br><span class="line"></span><br><span class="line">//显示当前数据库</span><br><span class="line">db</span><br><span class="line">db.getName()</span><br><span class="line"></span><br><span class="line">// 查询所有数据库</span><br><span class="line">show dbs</span><br><span class="line"></span><br><span class="line">//切换数据库</span><br><span class="line">use <span class="built_in">local</span></span><br><span class="line"></span><br><span class="line">// 显示当前数据库状态</span><br><span class="line">  //查看<span class="built_in">local</span>数据</span><br><span class="line">  use <span class="built_in">local</span></span><br><span class="line">  db.stats()</span><br><span class="line"></span><br><span class="line">//查看当前数据库的连接机器地址</span><br><span class="line">db.getMongo()</span><br><span class="line"></span><br><span class="line">// 指定数据库进行连接：（默认连接本机<span class="built_in">test</span>数据库）</span><br><span class="line"><span class="comment"># mongo 192.168.0.11/admin</span></span><br><span class="line">[mongod@mongodb ~]$ mongo 192.168.0.11/admin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 库和表的操作 </span></span><br><span class="line">// 建库 </span><br><span class="line">use <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">// 删除</span><br><span class="line">db.<span class="function"><span class="title">dropDatabase</span></span>()</span><br><span class="line">&#123; <span class="string">&quot;dropped&quot;</span> : <span class="string">&quot;test&quot;</span>, <span class="string">&quot;ok&quot;</span> : 1 &#125;</span><br><span class="line"></span><br><span class="line">// 创建集合(表)</span><br><span class="line">//方法1</span><br><span class="line">use app</span><br><span class="line">db.createCollection(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">db.createCollection(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">//方法2：当插入一个文档的时候，一个集合就会自动创建</span><br><span class="line">use app</span><br><span class="line">db.c.insert(&#123;username:<span class="string">&quot;mongodb&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line">//查看当前全部集合</span><br><span class="line">show collections</span><br><span class="line"></span><br><span class="line">//查看指定集合</span><br><span class="line">db.c.<span class="function"><span class="title">find</span></span>()</span><br><span class="line">&#123; <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5743c9a9bf72d9f7b524713d&quot;</span>), <span class="string">&quot;username&quot;</span> : <span class="string">&quot;mongodb&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line">// 删除集合</span><br><span class="line">use app</span><br><span class="line">db.a.drop()</span><br><span class="line"></span><br><span class="line">// 重命名集合</span><br><span class="line">app&gt; db.log.renameCollection(<span class="string">&quot;log1&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="使用insert完成插入操作"><a href="#使用insert完成插入操作" class="headerlink" title="使用insert完成插入操作"></a>使用<code>insert</code>完成插入操作</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 操作格式</span></span><br><span class="line">db.&lt;集合&gt;.insertOne(&lt;JSON对象&gt;)</span><br><span class="line">db.&lt;集合&gt;.insertMany([&lt;JSON 1&gt;, &lt;JSON 2&gt;, …&lt;JSON n&gt;])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">db.fruit.insertOne(&#123;name: <span class="string">&quot;apple&quot;</span>&#125;)</span><br><span class="line">db.fruit.insertMany([</span><br><span class="line">&#123;name: <span class="string">&quot;apple&quot;</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">&quot;pear&quot;</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">&quot;orange&quot;</span>&#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量插入数据</span></span><br><span class="line"><span class="keyword">for</span>(i=0;i&lt;1000;i++)&#123; db.test.insert(&#123;<span class="string">&quot;uid&quot;</span>:i,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;mongodb&quot;</span>,<span class="string">&quot;age&quot;</span>:6,<span class="string">&quot;date&quot;</span>:new Date()&#125;);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时区问题，中国当前时间需要解决</span></span><br></pre></td></tr></table></figure>

<h3 id="使用find查询文档"><a href="#使用find查询文档" class="headerlink" title="使用find查询文档"></a>使用<code>find</code>查询文档</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关于 find:</span></span><br><span class="line">find 是 MongoDB 中查询数据的基本指令，相当于 SQL 中的 SELECT</span><br><span class="line">find 返回的是游标</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">db.movies.find( &#123; <span class="string">&quot;year&quot;</span> : 1975 &#125; ) //单条件查询</span><br><span class="line">db.movies.find( &#123; <span class="string">&quot;year&quot;</span> : 1989, <span class="string">&quot;title&quot;</span> : <span class="string">&quot;Batman&quot;</span> &#125; ) //多条件and查询</span><br><span class="line">db.movies.find( &#123; <span class="variable">$and</span> : [ &#123;<span class="string">&quot;title&quot;</span> : <span class="string">&quot;Batman&quot;</span>&#125;, &#123; <span class="string">&quot;category&quot;</span> : <span class="string">&quot;action&quot;</span> &#125;] &#125; ) // and的另一种形式</span><br><span class="line">db.movies.find( &#123; <span class="variable">$or</span>: [&#123;<span class="string">&quot;year&quot;</span> : 1989&#125;, &#123;<span class="string">&quot;title&quot;</span> : <span class="string">&quot;Batman&quot;</span>&#125;] &#125; ) //多条件or查询</span><br><span class="line">db.movies.find( &#123; <span class="string">&quot;title&quot;</span> : /^B/&#125; ) //按正则表达式查找</span><br></pre></td></tr></table></figure>

<h3 id="查询条件对照表"><a href="#查询条件对照表" class="headerlink" title="查询条件对照表"></a>查询条件对照表</h3><table>
<thead>
<tr>
<th>SQL</th>
<th>MSQL</th>
</tr>
</thead>
<tbody><tr>
<td>a = 1</td>
<td>{a:1}</td>
</tr>
<tr>
<td>a &lt;&gt; 1</td>
<td>{a:{$ne:1}}</td>
</tr>
<tr>
<td>a &gt; 1</td>
<td>{a:{$gt:1}}</td>
</tr>
<tr>
<td>a &gt;= 1</td>
<td>{a:{$gte:1}}</td>
</tr>
<tr>
<td>a &lt; 1</td>
<td>{a:{$lt:1}}</td>
</tr>
<tr>
<td>a &lt;= 1</td>
<td>{a:{$lte:1}}</td>
</tr>
</tbody></table>
<h3 id="查询逻辑对照表"><a href="#查询逻辑对照表" class="headerlink" title="查询逻辑对照表"></a>查询逻辑对照表</h3><table>
<thead>
<tr>
<th>SQL</th>
<th>MSQL</th>
</tr>
</thead>
<tbody><tr>
<td>a = 1 AND  b= 1</td>
<td>{a:1,b:1}或者{$and:[{a:1},{b:1}]}</td>
</tr>
<tr>
<td>a = 1 OR b = 1</td>
<td>{$or:[{$a:1},{$b:1}]}</td>
</tr>
<tr>
<td>a IS NULL</td>
<td>{a:{$exists:false}}</td>
</tr>
<tr>
<td>a IN (1,2,3)</td>
<td>{a:{$in:[1,2,3]}}</td>
</tr>
</tbody></table>
<h3 id="逻辑查询运算符"><a href="#逻辑查询运算符" class="headerlink" title="逻辑查询运算符"></a>逻辑查询运算符</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$lt</span>: 存在并小于</span><br><span class="line"><span class="variable">$lte</span>: 存在并小于等于</span><br><span class="line"><span class="variable">$gt</span>: 存在并大于</span><br><span class="line"><span class="variable">$gte</span>: 存在并大于等于</span><br><span class="line"><span class="variable">$ne</span>: 不存在或存在但不等于</span><br><span class="line"><span class="variable">$in</span>: 存在并在指定数组中</span><br><span class="line"><span class="variable">$nin</span>: 不存在或不在指定数组中</span><br><span class="line"><span class="variable">$or</span>: 匹配两个或多个条件中的一个</span><br><span class="line"><span class="variable">$and</span>: 匹配全部条件</span><br></pre></td></tr></table></figure>

<h3 id="使用find搜索子文档"><a href="#使用find搜索子文档" class="headerlink" title="使用find搜索子文档"></a>使用<code>find</code>搜索子文档</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># find 支持使用“field.sub_field”的形式查询子文档。假设有一个文档：</span></span><br><span class="line">db.fruit.insertOne(&#123;</span><br><span class="line">name: <span class="string">&quot;apple&quot;</span>,</span><br><span class="line">from: &#123;</span><br><span class="line">country: <span class="string">&quot;China&quot;</span>,</span><br><span class="line">province: <span class="string">&quot;Guangdong&quot;</span> &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确写法</span></span><br><span class="line">db.fruit.find( &#123; <span class="string">&quot;from.country&quot;</span> : <span class="string">&quot;China&quot;</span> &#125; )</span><br></pre></td></tr></table></figure>

<h3 id="使用-find-搜索数组"><a href="#使用-find-搜索数组" class="headerlink" title="使用 find 搜索数组"></a>使用 find 搜索数组</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># find 支持对数组中的元素进行搜索。假设有一个文档：</span></span><br><span class="line">db.fruit.insert([</span><br><span class="line">&#123; <span class="string">&quot;name&quot;</span> : <span class="string">&quot;Apple&quot;</span>, color: [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;green&quot;</span> ] &#125;,</span><br><span class="line">&#123; <span class="string">&quot;name&quot;</span> : <span class="string">&quot;Mango&quot;</span>, color: [<span class="string">&quot;yellow&quot;</span>, <span class="string">&quot;green&quot;</span>] &#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看单个条件</span></span><br><span class="line">db.fruit.find(&#123;color: <span class="string">&quot;red&quot;</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询多个条件</span></span><br><span class="line">db.fruit.find(&#123;<span class="variable">$or</span>: [&#123;color: <span class="string">&quot;red&quot;</span>&#125;, &#123;color: <span class="string">&quot;yellow&quot;</span>&#125;]&#125; )</span><br></pre></td></tr></table></figure>

<h3 id="使用-find-搜索数组中的对象"><a href="#使用-find-搜索数组中的对象" class="headerlink" title="使用 find 搜索数组中的对象"></a>使用 find 搜索数组中的对象</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">考虑以下文档，在其中搜索</span><br><span class="line">db.movies.insertOne( &#123;</span><br><span class="line"><span class="string">&quot;title&quot;</span> : <span class="string">&quot;Raiders of the Lost Ark&quot;</span>,</span><br><span class="line"><span class="string">&quot;filming_locations&quot;</span> : [ </span><br><span class="line">&#123; <span class="string">&quot;city&quot;</span> : <span class="string">&quot;Los Angeles&quot;</span>, <span class="string">&quot;state&quot;</span> : <span class="string">&quot;CA&quot;</span>, <span class="string">&quot;country&quot;</span> : <span class="string">&quot;USA&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;city&quot;</span> : <span class="string">&quot;Rome&quot;</span>, <span class="string">&quot;state&quot;</span> : <span class="string">&quot;Lazio&quot;</span>, <span class="string">&quot;country&quot;</span> : <span class="string">&quot;Italy&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;city&quot;</span> : <span class="string">&quot;Florence&quot;</span>, <span class="string">&quot;state&quot;</span> : <span class="string">&quot;SC&quot;</span>, <span class="string">&quot;country&quot;</span> : <span class="string">&quot;USA&quot;</span> &#125;</span><br><span class="line">] </span><br><span class="line">&#125;)</span><br><span class="line">// 查找城市是 Rome 的记录</span><br><span class="line">db.movies.find(&#123;<span class="string">&quot;filming_locations.city&quot;</span>: <span class="string">&quot;Rome&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用-find-搜索数组中的对象-1"><a href="#使用-find-搜索数组中的对象-1" class="headerlink" title="使用 find 搜索数组中的对象"></a>使用 find 搜索数组中的对象</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在数组中搜索子对象的多个字段时，如果使用 $elemMatch，它表示必须是同一个子对象满足多个条件，考虑以下两个查询</span></span><br><span class="line">db.getCollection(<span class="string">&#x27;movies&#x27;</span>).find(&#123;</span><br><span class="line"><span class="string">&quot;filming_locations.city&quot;</span>: <span class="string">&quot;Rome&quot;</span>,</span><br><span class="line"><span class="string">&quot;filming_locations.country&quot;</span>: <span class="string">&quot;USA&quot;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">db.movies.insertOne( &#123;</span><br><span class="line"><span class="string">&quot;title&quot;</span> : <span class="string">&quot;11111&quot;</span>,</span><br><span class="line"><span class="string">&quot;filming_locations&quot;</span> : [ </span><br><span class="line">&#123; <span class="string">&quot;city&quot;</span> : <span class="string">&quot;bj&quot;</span>, <span class="string">&quot;state&quot;</span> : <span class="string">&quot;CA&quot;</span>, <span class="string">&quot;country&quot;</span> : <span class="string">&quot;CHN&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;city&quot;</span> : <span class="string">&quot;Rome&quot;</span>, <span class="string">&quot;state&quot;</span> : <span class="string">&quot;Lazio&quot;</span>, <span class="string">&quot;country&quot;</span> : <span class="string">&quot;Italy&quot;</span> &#125;,</span><br><span class="line">&#123; <span class="string">&quot;city&quot;</span> : <span class="string">&quot;tlp&quot;</span>, <span class="string">&quot;state&quot;</span> : <span class="string">&quot;SC&quot;</span>, <span class="string">&quot;country&quot;</span> : <span class="string">&quot;USA&quot;</span> &#125;</span><br><span class="line">] </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">db.getCollection(<span class="string">&#x27;movies&#x27;</span>).find(&#123;</span><br><span class="line"><span class="string">&quot;filming_locations&quot;</span>: &#123;</span><br><span class="line"><span class="variable">$elemMatch</span>:&#123;<span class="string">&quot;city&quot;</span>:<span class="string">&quot;bj&quot;</span>, <span class="string">&quot;country&quot;</span>: <span class="string">&quot;CHN&quot;</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="控制-find-返回的字段"><a href="#控制-find-返回的字段" class="headerlink" title="控制 find 返回的字段"></a>控制 find 返回的字段</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># find 可以指定只返回指定的字段</span></span><br><span class="line">_id字段必须明确指明不返回，否则默认返回</span><br><span class="line">在 MongoDB 中我们称这为投影(projection)</span><br><span class="line"></span><br><span class="line">db.movies.find(&#123;<span class="string">&quot;category&quot;</span>: <span class="string">&quot;action&quot;</span>&#125;,&#123;<span class="string">&quot;_id&quot;</span>:0, title:1&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用remove删除文档"><a href="#使用remove删除文档" class="headerlink" title="使用remove删除文档"></a>使用remove删除文档</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">remove 命令需要配合查询条件使用</span><br><span class="line">匹配查询条件的的文档会被删除</span><br><span class="line">指定一个空文档条件会删除所有文档</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以下示例</span></span><br><span class="line">db.testcol.remove( &#123; a : 1 &#125; ) // 删除a 等于1的记录</span><br><span class="line">db.testcol.remove( &#123; a : &#123; <span class="variable">$lt</span> : 5 &#125; &#125; ) // 删除a 小于5的记录</span><br><span class="line">db.testcol.remove( &#123; &#125; ) // 删除所有记录</span><br></pre></td></tr></table></figure>

<h3 id="使用-update-更新文档"><a href="#使用-update-更新文档" class="headerlink" title="使用 update 更新文档"></a>使用 update 更新文档</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Update 操作执行格式: db.&lt;集合&gt;.update(&lt;查询条件&gt;, &lt;更新字段&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以以下数据为例</span></span><br><span class="line"><span class="comment"># 插入数据</span></span><br><span class="line">db.fruit.insertMany([</span><br><span class="line">&#123;name: <span class="string">&quot;apple&quot;</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">&quot;pear&quot;</span>&#125;,</span><br><span class="line">&#123;name: <span class="string">&quot;orange&quot;</span>&#125;</span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新数据</span></span><br><span class="line">db.fruit.updateOne(&#123;name: <span class="string">&quot;apple&quot;</span>&#125;, &#123;<span class="variable">$set</span>: &#123;from: <span class="string">&quot;China&quot;</span>&#125;&#125;) //有就更新，没有就行添加</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用规则</span></span><br><span class="line">使用 updateOne 表示无论条件匹配多少条记录，始终只更新第一条</span><br><span class="line">使用 updateMany 表示条件匹配多少条就更新多少条</span><br><span class="line">updateOne/updateMany 方法要求更新条件部分必须具有以下之一，否则将报错</span><br><span class="line">    <span class="variable">$set</span>/<span class="variable">$unset</span></span><br><span class="line">    <span class="variable">$push</span>/<span class="variable">$pushAll</span>/<span class="variable">$pop</span></span><br><span class="line">    <span class="variable">$pull</span>/<span class="variable">$pullAll</span></span><br><span class="line">    <span class="variable">$addToSet</span></span><br><span class="line">// 报错</span><br><span class="line">db.fruit.updateOne(&#123;name: <span class="string">&quot;apple&quot;</span>&#125;, &#123;from: <span class="string">&quot;China&quot;</span>&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="使用-update-更新数组"><a href="#使用-update-更新数组" class="headerlink" title="使用 update 更新数组"></a>使用 update 更新数组</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$push</span>: 增加一个对象到数组底部</span><br><span class="line"><span class="variable">$pushAll</span>: 增加多个对象到数组底部</span><br><span class="line"><span class="variable">$pop</span>: 从数组底部删除一个对象</span><br><span class="line"><span class="variable">$pull</span>: 如果匹配指定的值，从数组中删除相应的对象</span><br><span class="line"><span class="variable">$pullAll</span>: 如果匹配任意的值，从数据中删除相应的对象</span><br><span class="line"><span class="variable">$addToSet</span>: 如果不存在则增加一个值到数组</span><br></pre></td></tr></table></figure>

<h3 id="使用-drop-删除集合"><a href="#使用-drop-删除集合" class="headerlink" title="使用 drop 删除集合"></a>使用 drop 删除集合</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">使用 db.&lt;集合&gt;.drop() 来删除一个集合</span><br><span class="line">集合中的全部文档都会被删除</span><br><span class="line">集合相关的索引也会被删除</span><br><span class="line"></span><br><span class="line">db.colToBeDropped.drop()</span><br></pre></td></tr></table></figure>

<h3 id="使用-dropDatabase-删除数据库"><a href="#使用-dropDatabase-删除数据库" class="headerlink" title="使用 dropDatabase 删除数据库"></a>使用 dropDatabase 删除数据库</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">使用 db.dropDatabase() 来删除数据库</span><br><span class="line">数据库相应文件也会被删除，磁盘空间将被释放</span><br><span class="line"></span><br><span class="line">use tempDB</span><br><span class="line">db.dropDatabase()</span><br><span class="line">show collections // No collections</span><br><span class="line">show dbs // The db is gone</span><br></pre></td></tr></table></figure>

<h3 id="Python操作MongoDB"><a href="#Python操作MongoDB" class="headerlink" title="Python操作MongoDB"></a>Python操作MongoDB</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 环境准备</span></span><br><span class="line"><span class="comment"># Centos安装python3</span></span><br><span class="line">yum install python3</span><br><span class="line">pip3 install pymongo</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查</span></span><br><span class="line">在 python 交互模式下导入 pymongo，检查驱动是否已正确安装</span><br><span class="line">import pymongo </span><br><span class="line">pymongo.version</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 确定 MongoDB 连接串</span></span><br><span class="line">使用驱动连接到 MongoDB 集群只需要指定 MongoDB 连接字符串即可。其基本格式可以参考文档: Connection String URI Format </span><br><span class="line">最简单的形式是mongodb://数据库服务器主机地址：端口号</span><br><span class="line">如：mongodb://127.0.0.1:27017</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化数据库连接以下操作在python终端操作就行</span></span><br><span class="line">from pymongo import MongoClient </span><br><span class="line">uri = <span class="string">&quot;mongodb://root:root123@db1:27017&quot;</span></span><br><span class="line">client = MongoClient(uri) </span><br><span class="line">client</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入数据</span></span><br><span class="line"><span class="comment"># 初始化数据库和集合</span></span><br><span class="line">db = client[<span class="string">&quot;eshop&quot;</span>]</span><br><span class="line">user_coll = db[<span class="string">&quot;users&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 插入一条新的用户数据</span></span><br><span class="line">new_user = &#123;<span class="string">&quot;username&quot;</span>: <span class="string">&quot;nina&quot;</span>, <span class="string">&quot;password&quot;</span>: <span class="string">&quot;xxxx&quot;</span>, <span class="string">&quot;email&quot;</span>: </span><br><span class="line"><span class="string">&quot;123456@qq.com &quot;</span>&#125;</span><br><span class="line">result = user_coll.insert_one(new_user)  <span class="comment"># 这条执行之后MongoDB才会有数据</span></span><br><span class="line">result</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB远程连接方式</title>
    <url>/3358d614.html</url>
    <content><![CDATA[<h3 id="图形化工具"><a href="#图形化工具" class="headerlink" title="图形化工具"></a>图形化工具</h3><h4 id="compass"><a href="#compass" class="headerlink" title="compass"></a><code>compass</code></h4><span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载地址，直安装即可</span></span><br><span class="line">https://www.mongodb.com/try/download/compass</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一的连接方法</span></span><br><span class="line">mongodb://root:root123@db1:27017/admin</span><br><span class="line"></span><br><span class="line">root          用户名</span><br><span class="line">root123       密码</span><br><span class="line">db1:27017     主机地址+端口</span><br><span class="line">admin         验证库</span><br></pre></td></tr></table></figure>

<p>方式一</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/6gLJgx.png" alt="6gLJgx"></p>
<p>方式二，在下图位置填入相应信息</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20211230160335813.png" alt="image-20211230160335813"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20211230160400469.png" alt="image-20211230160400469"></p>
<h4 id="Navicat"><a href="#Navicat" class="headerlink" title="Navicat"></a><code>Navicat</code></h4><p>不做演示了</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/Vd8uLU.png" alt="Vd8uLU"></p>
<h3 id="命令远程"><a href="#命令远程" class="headerlink" title="命令远程"></a>命令远程</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongo --host 192.168.0.11 --port 27017 -uroot -proot123 admin</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB用户管理</title>
    <url>/ff4ef26d.html</url>
    <content><![CDATA[<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">验证库，建立用户时use到的库，在使用用户时，要加上验证库才能登陆</span><br><span class="line">对于管理员用户,必须在admin下创建</span><br><span class="line">1. 建用户时,use到的库,就是此用户的验证库</span><br><span class="line">2. 登录时,必须明确指定验证库才能登录</span><br><span class="line">3. 通常,管理员用的验证库是admin,普通用户的验证库一般是所管理的库设置为验证库</span><br><span class="line">4. 如果直接登录到数据库,不进行use,默认的验证库是test,不是我们生产建议的</span><br></pre></td></tr></table></figure>

<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mongo 10.0.0.151/admin</span><br><span class="line">use admin </span><br><span class="line"></span><br><span class="line">db.createUser</span><br><span class="line">&#123;</span><br><span class="line">    user: <span class="string">&quot;&lt;name&gt;&quot;</span>,</span><br><span class="line">    <span class="built_in">pwd</span>: <span class="string">&quot;&lt;cleartext password&gt;&quot;</span>,</span><br><span class="line">    roles: [</span><br><span class="line">       &#123; role: <span class="string">&quot;&lt;role&gt;&quot;</span>,</span><br><span class="line">     db: <span class="string">&quot;&lt;database&gt;&quot;</span> &#125; | <span class="string">&quot;&lt;role&gt;&quot;</span>,</span><br><span class="line">    ...</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基本语法</span></span><br><span class="line">user:用户名</span><br><span class="line"><span class="built_in">pwd</span>:密码</span><br><span class="line">roles:</span><br><span class="line">    role:角色名</span><br><span class="line">    db:作用对象 </span><br><span class="line">role：root, readWrite,<span class="built_in">read</span>   </span><br><span class="line"></span><br><span class="line">验证数据库：</span><br><span class="line">mongo -u <span class="built_in">test</span> -p 123 10.0.0.21/<span class="built_in">test</span></span><br></pre></td></tr></table></figure>

<h3 id="用法实例"><a href="#用法实例" class="headerlink" title="用法实例"></a>用法实例</h3><h4 id="管理员用户"><a href="#管理员用户" class="headerlink" title="管理员用户"></a>管理员用户</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建超级管理员 管理所有数据库（必须use admin再去创建）</span></span><br><span class="line">$ mongo  <span class="comment"># 命令行输入mongo进入数据库</span></span><br><span class="line">use admin</span><br><span class="line">db.createUser(</span><br><span class="line">&#123;</span><br><span class="line">    user: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">    <span class="built_in">pwd</span>: <span class="string">&quot;root123&quot;</span>,</span><br><span class="line">    roles: [ &#123; role: <span class="string">&quot;root&quot;</span>, db: <span class="string">&quot;admin&quot;</span> &#125; ]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证用户</span></span><br><span class="line">db.auth(<span class="string">&#x27;root&#x27;</span>,<span class="string">&#x27;root123&#x27;</span>)  <span class="comment"># 结果为1代表成功</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置文件中，加入以下配置</span></span><br><span class="line">vim /mongodb/conf/mongodb.conf</span><br><span class="line">security:</span><br><span class="line">  authorization: enabled</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启mongodb</span></span><br><span class="line">mongod -f /mongodb/conf/mongodb.conf --shutdown</span><br><span class="line">mongod -f /mongodb/conf/mongodb.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录验证</span></span><br><span class="line">mongo -uroot -proot123  admin</span><br><span class="line">mongo -uroot -proot123  192.168.0.11/admin</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 或者</span></span><br><span class="line">  mongo</span><br><span class="line">  use admin</span><br><span class="line">  db.auth(<span class="string">&#x27;root&#x27;</span>,<span class="string">&#x27;root123&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看用户</span></span><br><span class="line">use admin</span><br><span class="line">db.system.users.find().pretty()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建库管理用户</span></span><br><span class="line">mongo -uroot -proot123  admin</span><br><span class="line"></span><br><span class="line">use app</span><br><span class="line">db.createUser(</span><br><span class="line">&#123;</span><br><span class="line">user: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line"><span class="built_in">pwd</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">roles: [ &#123; role: <span class="string">&quot;dbAdmin&quot;</span>, db: <span class="string">&quot;app&quot;</span> &#125; ]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">db.auth(<span class="string">&#x27;admin&#x27;</span>,<span class="string">&#x27;admin&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录测试</span></span><br><span class="line">mongo -uadmin -padmin app</span><br></pre></td></tr></table></figure>

<h4 id="普通用户"><a href="#普通用户" class="headerlink" title="普通用户"></a>普通用户</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建对app数据库，读、写权限的用户app01：</span></span><br><span class="line">    <span class="comment"># 超级管理员用户登陆</span></span><br><span class="line">    mongo -uroot -proot123 admin</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 选择一个验证库</span></span><br><span class="line">    use app</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建用户</span></span><br><span class="line">    db.createUser(</span><br><span class="line">        &#123;</span><br><span class="line">            user: <span class="string">&quot;app01&quot;</span>,</span><br><span class="line">            <span class="built_in">pwd</span>: <span class="string">&quot;app01&quot;</span>,</span><br><span class="line">            roles: [ &#123; role: <span class="string">&quot;readWrite&quot;</span> , db: <span class="string">&quot;app&quot;</span> &#125; ]</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 验证</span></span><br><span class="line">    mongo  -uapp01 -papp01 app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建app数据库读写权限的用户并对test数据库具有读权限</span></span><br><span class="line">mongo -uroot -proot123 admin</span><br><span class="line"></span><br><span class="line">use app</span><br><span class="line">db.createUser(</span><br><span class="line">&#123;</span><br><span class="line">user: <span class="string">&quot;app03&quot;</span>,</span><br><span class="line"><span class="built_in">pwd</span>: <span class="string">&quot;app03&quot;</span>,</span><br><span class="line">roles: [ &#123; role: <span class="string">&quot;readWrite&quot;</span>, db: <span class="string">&quot;app&quot;</span> &#125;,</span><br><span class="line">&#123; role: <span class="string">&quot;read&quot;</span>, db: <span class="string">&quot;test&quot;</span> &#125;</span><br><span class="line">]</span><br><span class="line">&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询mongodb中的用户信息</span></span><br><span class="line">mongo -uroot -proot123 admin</span><br><span class="line">db.system.users.find().pretty()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除用户（root身份登录，use到验证库）</span></span><br><span class="line">mongo -uroot -proot123 admin</span><br><span class="line">use app</span><br><span class="line">db.dropUser(<span class="string">&quot;admin&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="角色关系"><a href="#角色关系" class="headerlink" title="角色关系"></a>角色关系</h3><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/VX8Kie.png" alt="VX8Kie"></p>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB安装部署</title>
    <url>/55c06d78.html</url>
    <content><![CDATA[<h3 id="获取安装包"><a href="#获取安装包" class="headerlink" title="获取安装包"></a>获取安装包</h3><span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载地址</span></span><br><span class="line">https://www.mongodb.com/try/download/community</span><br><span class="line"></span><br><span class="line"><span class="comment"># centos7下载</span></span><br><span class="line">wget https://fastdl.mongodb.org/linux/mongodb-linux-x86_64-rhel70-4.2.17.tgz</span><br></pre></td></tr></table></figure>

<h3 id="安装MongoDB"><a href="#安装MongoDB" class="headerlink" title="安装MongoDB"></a>安装MongoDB</h3><h4 id="关闭THP"><a href="#关闭THP" class="headerlink" title="关闭THP"></a>关闭THP</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭THP</span></span><br><span class="line"><span class="comment"># root用户下</span></span><br><span class="line"><span class="comment"># 在 /etc/rc.local 最后添加如下代码</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -f /sys/kernel/mm/transparent_hugepage/enabled; <span class="keyword">then</span></span><br><span class="line">  <span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">test</span> -f /sys/kernel/mm/transparent_hugepage/defrag; <span class="keyword">then</span></span><br><span class="line">   <span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/defrag</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/enabled        </span><br><span class="line"><span class="built_in">echo</span> never &gt; /sys/kernel/mm/transparent_hugepage/defrag </span><br><span class="line"></span><br><span class="line"><span class="comment">#其他系统关闭参照官方文档</span></span><br><span class="line">https://docs.mongodb.com/manual/tutorial/transparent-huge-pages/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 为什么要关闭</span></span><br><span class="line">Transparent Huge Pages (THP) is a Linux memory management system </span><br><span class="line">that reduces the overhead of Translation Lookaside Buffer (TLB) </span><br><span class="line">lookups on machines with large amounts of memory by using larger memory pages.</span><br><span class="line">However, database workloads often perform poorly with THP, </span><br><span class="line">because they tend to have sparse rather than contiguous memory access patterns. </span><br><span class="line">You should <span class="built_in">disable</span> THP on Linux machines to ensure best performance with MongoDB.</span><br></pre></td></tr></table></figure>

<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar xf mongodb-linux-x86_64-rhel70-4.2.17.tgz</span><br><span class="line">mv mongodb-linux-x86_64-rhel70-4.2.17 /usr/<span class="built_in">local</span>/mongodb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建用户</span></span><br><span class="line">useradd mongod</span><br><span class="line">passwd mongod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建相关目录</span></span><br><span class="line">mkdir -p /mongodb/&#123;data,conf,<span class="built_in">log</span>&#125;</span><br><span class="line">chown -R mongod:mongod /mongodb</span><br><span class="line">chown -R mongod:mongod /usr/<span class="built_in">local</span>/mongodb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 环境变量配置</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=/usr/local/mongodb/bin:$PATH&#x27;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br></pre></td></tr></table></figure>

<h4 id="初始化数据库"><a href="#初始化数据库" class="headerlink" title="初始化数据库"></a>初始化数据库</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 切换用户</span></span><br><span class="line">su - mongod</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化mongodb</span></span><br><span class="line">mongod --dbpath=/mongodb/data --logpath=/mongodb/<span class="built_in">log</span>/mongodb.log --port=27017 --logappend --fork</span><br><span class="line"></span><br><span class="line"><span class="comment"># 登录mongodb数据库</span></span><br><span class="line">mongo</span><br></pre></td></tr></table></figure>

<h3 id="普通配置文件"><a href="#普通配置文件" class="headerlink" title="普通配置文件"></a>普通配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 普通配置文件</span></span><br><span class="line">cat &gt; /mongodb/conf/mongodb.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">logpath=/mongodb/log/mongodb.log</span></span><br><span class="line"><span class="string">dbpath=/mongodb/data </span></span><br><span class="line"><span class="string">port=27017</span></span><br><span class="line"><span class="string">logappend=true</span></span><br><span class="line"><span class="string">fork=true</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭mongodb</span></span><br><span class="line">mongod -f /mongodb/conf/mongodb.conf --shutdown</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动mongodb</span></span><br><span class="line">mongod -f /mongodb/conf/mongodb.conf</span><br></pre></td></tr></table></figure>

<h3 id="YAML格式配置文件"><a href="#YAML格式配置文件" class="headerlink" title="YAML格式配置文件"></a>YAML格式配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置文件解释</span></span><br><span class="line">--系统日志有关  </span><br><span class="line">systemLog:</span><br><span class="line">   destination: file        </span><br><span class="line">   path: <span class="string">&quot;/mongodb/log/mongodb.log&quot;</span>    --日志位置</span><br><span class="line">   logAppend: <span class="literal">true</span>                     --日志以追加模式记录</span><br><span class="line"></span><br><span class="line">--数据存储有关   </span><br><span class="line">storage:</span><br><span class="line">   journal:</span><br><span class="line">      enabled: <span class="literal">true</span></span><br><span class="line">   dbPath: <span class="string">&quot;/mongodb/data&quot;</span>            --数据路径的位置</span><br><span class="line"></span><br><span class="line">-- 进程控制  </span><br><span class="line">processManagement:</span><br><span class="line">   fork: <span class="literal">true</span>                         --后台守护进程</span><br><span class="line">   pidFilePath: &lt;string&gt;              --pid文件的位置，一般不用配置，可以去掉这行，自动生成到data中</span><br><span class="line"></span><br><span class="line">--网络配置有关   </span><br><span class="line">net:            </span><br><span class="line">   bindIp: &lt;ip&gt;                       -- 监听地址</span><br><span class="line">   bindIpAll: <span class="literal">true</span>                    -- 开启所有端口</span><br><span class="line">   port: &lt;port&gt;                       -- 端口号,默认不配置端口号，是27017</span><br><span class="line"></span><br><span class="line">-- 安全验证有关配置      </span><br><span class="line">security:</span><br><span class="line">  authorization: enabled              --是否打开用户名密码验证，授权完成之后再开启</span><br><span class="line"></span><br><span class="line">------------------以下是复制集与分片集群有关----------------------  </span><br><span class="line"></span><br><span class="line">replication:</span><br><span class="line"> oplogSizeMB: &lt;NUM&gt;</span><br><span class="line"> replSetName: <span class="string">&quot;&lt;REPSETNAME&gt;&quot;</span></span><br><span class="line"> secondaryIndexPrefetch: <span class="string">&quot;all&quot;</span></span><br><span class="line"></span><br><span class="line">sharding:</span><br><span class="line">   clusterRole: &lt;string&gt;</span><br><span class="line">   archiveMovedChunks: &lt;boolean&gt;</span><br><span class="line"></span><br><span class="line">---<span class="keyword">for</span> mongos only</span><br><span class="line">replication:</span><br><span class="line">   localPingThresholdMs: &lt;int&gt;</span><br><span class="line"></span><br><span class="line">sharding:</span><br><span class="line">   configDB: &lt;string&gt;</span><br><span class="line">---</span><br><span class="line">------------------------------------  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># YAML例子</span></span><br><span class="line">cat &gt;  /mongodb/conf/mongodb.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">systemLog:</span></span><br><span class="line"><span class="string">  destination: file</span></span><br><span class="line"><span class="string">  path: &quot;/mongodb/log/mongodb.log&quot;</span></span><br><span class="line"><span class="string">  logAppend: true</span></span><br><span class="line"><span class="string">storage:</span></span><br><span class="line"><span class="string">  journal:</span></span><br><span class="line"><span class="string">    enabled: true</span></span><br><span class="line"><span class="string">  dbPath: &quot;/mongodb/data/&quot;</span></span><br><span class="line"><span class="string">processManagement:</span></span><br><span class="line"><span class="string">  fork: true</span></span><br><span class="line"><span class="string">net:</span></span><br><span class="line"><span class="string">  port: 27017</span></span><br><span class="line"><span class="string">  bindIpAll: true</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭和启动</span></span><br><span class="line">mongod -f /mongodb/conf/mongodb.conf --shutdown</span><br><span class="line">mongod -f /mongodb/conf/mongodb.conf</span><br></pre></td></tr></table></figure>

<h3 id="优化启动警告"><a href="#优化启动警告" class="headerlink" title="优化启动警告"></a>优化启动警告</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">** WARNING: Using the XFS filesystem is strongly recommended with the WiredTiger storage engine</span><br><span class="line">建议使用xfs文件系统，但不影响使用</span><br><span class="line"></span><br><span class="line">** WARNING: Access control is not enabled <span class="keyword">for</span> the database.</span><br><span class="line">配置密码之后开启安全</span><br><span class="line"></span><br><span class="line">** WARNING: This server is bound to localhost.</span><br><span class="line">配置文件中绑定IP就可以解决</span><br><span class="line"></span><br><span class="line">** WARNING: /sys/kernel/mm/transparent_hugepage/enabled is <span class="string">&#x27;always&#x27;</span>.</span><br><span class="line">** WARNING: /sys/kernel/mm/transparent_hugepage/defrag is <span class="string">&#x27;always&#x27;</span>.</span><br><span class="line">这两条参考上面关闭THP即可</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">** WARNING: soft rlimits too low. rlimits <span class="built_in">set</span> to 31192 processes, 100001 files. Number of processes....</span><br><span class="line">vim /etc/security/limits.conf</span><br><span class="line"><span class="comment"># end of file</span></span><br><span class="line">mongod soft nofile 64000</span><br><span class="line">mongod hard nofile 64000</span><br><span class="line">mongod soft nproc 32000</span><br><span class="line">mongod hard nproc 32000</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>MongoDB简介</title>
    <url>/99ace97a.html</url>
    <content><![CDATA[<h3 id="简单认识"><a href="#简单认识" class="headerlink" title="简单认识"></a>简单认识</h3><table>
<thead>
<tr>
<th>Q</th>
<th>A</th>
</tr>
</thead>
<tbody><tr>
<td>什么是MongoDB</td>
<td>一个以JSON为数据模型的文档数据库</td>
</tr>
<tr>
<td>文档数据库</td>
<td>文档来自于’JSON Document’，并非PDF，Word等</td>
</tr>
<tr>
<td>主要用途</td>
<td>OLTP/OLAP 数据库，类似于Oracle，MySQL海量数据处理，数据平台</td>
</tr>
<tr>
<td>主要特点</td>
<td>无模式或可选，友好的JSON数据模型，开发方便</td>
</tr>
<tr>
<td>版本</td>
<td>企业版和社区版</td>
</tr>
</tbody></table>
<span id="more"></span>
<h3 id="版本变迁"><a href="#版本变迁" class="headerlink" title="版本变迁"></a>版本变迁</h3><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20211229213159423.png" alt="image-20211229213159423"></p>
<h3 id="与RDBMS比较"><a href="#与RDBMS比较" class="headerlink" title="与RDBMS比较"></a>与RDBMS比较</h3><table>
<thead>
<tr>
<th>功能</th>
<th>MongoDB</th>
<th>RDBMS</th>
</tr>
</thead>
<tbody><tr>
<td>数据模型</td>
<td>JSON</td>
<td>Relational</td>
</tr>
<tr>
<td>数据库类型</td>
<td>OLTP/OLAP</td>
<td>OLTP/OLAP</td>
</tr>
<tr>
<td>CRUD操作</td>
<td>MQL/SQL</td>
<td>SQL/SQLX</td>
</tr>
<tr>
<td>高可用</td>
<td>原生Replica-Set</td>
<td>Cluster、中间件</td>
</tr>
<tr>
<td>横向扩展能力</td>
<td>原生MSC</td>
<td>分片、中间件</td>
</tr>
<tr>
<td>索引支持</td>
<td>B-Tree、F-text、GIS、multikey、HASH、TTL</td>
<td>B-Tree</td>
</tr>
<tr>
<td>开发难度</td>
<td>简单</td>
<td>难</td>
</tr>
<tr>
<td>数据容量</td>
<td>无理论上限</td>
<td>千万、亿</td>
</tr>
<tr>
<td>扩展方式</td>
<td>垂直扩展+水平扩展</td>
<td>垂直扩展</td>
</tr>
</tbody></table>
<h3 id="逻辑结构对比"><a href="#逻辑结构对比" class="headerlink" title="逻辑结构对比"></a>逻辑结构对比</h3><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20211229213216469.png" alt="image-20211229213216469"></p>
<h3 id="MongoDB优势"><a href="#MongoDB优势" class="headerlink" title="MongoDB优势"></a>MongoDB优势</h3><ul>
<li><p>简单直观</p>
<p>以自然的方式来建模，以直观的方式来与数据库交互</p>
</li>
<li><p>结构灵活</p>
<p>弹性模式从容响应需求的频繁变化</p>
</li>
<li><p>快速开发</p>
<p>做更多的事情，写更少的代码</p>
</li>
</ul>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20211229213046722.png" alt="image-20211229213046722"></p>
]]></content>
      <categories>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>NFS搭建使用</title>
    <url>/e15f268d.html</url>
    <content><![CDATA[<h1 id="NFS-网络存储"><a href="#NFS-网络存储" class="headerlink" title="NFS 网络存储"></a>NFS 网络存储</h1><h2 id="NFS简介"><a href="#NFS简介" class="headerlink" title="NFS简介"></a>NFS简介</h2><span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">NFS : 共享存储，文件服务器</span><br><span class="line"></span><br><span class="line">基本概述：</span><br><span class="line">   1.NFS是Network File System的缩写及网络文件系统。NFS主要功能是通过局域网络让不同的主机系统之间可以共享文件或目录。</span><br><span class="line"></span><br><span class="line">   2.NFS系统和Windows网络共享、网络驱动器类似, 只不过windows用于局域网, NFS用于企业集群架构中, 如果是大型网站, 会用到更复杂的分布式文件系统FastDFS，glusterfs，HDFS，ceph</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">为何使用NFS：</span><br><span class="line">  1.实现多台服务器之间数据共享</span><br><span class="line">  2.实现多台服务器之间数据一致</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/2251663-20210419213338770-1524770891.png" alt="2251663-20210419213338770-1524770891"></p>
<h2 id="NFS应用"><a href="#NFS应用" class="headerlink" title="NFS应用"></a>NFS应用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.用户访问NFS客户端，将请求转化为函数</span><br><span class="line">2.NFS通过TCP/IP连接服务端</span><br><span class="line">3.NFS服务端接收请求，会先调用portmap进程进行端口映射</span><br><span class="line">4.Rpc.nfsd进程用于判断NFS客户端能否连接服务端；</span><br><span class="line">5.Rpc.mount进程用于判断客户端对服务端的操作权限</span><br><span class="line">6.如果通过权限验证，可以对服务端进行操作，修改或读取</span><br></pre></td></tr></table></figure>

<p>nfs运行原理</p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/nfs%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86-1024x640.png" alt="nfs运行原理-1024x640"></p>
<h2 id="NFS实践"><a href="#NFS实践" class="headerlink" title="NFS实践"></a>NFS实践</h2><ul>
<li>为了实现文件共享</li>
<li>为了多台服务器之间数据一致</li>
</ul>
<p>nfs原理</p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/nfs%E5%8E%9F%E7%90%86-1024x754.png" alt="nfs原理-1024x754"></p>
<h4 id="1、服务端"><a href="#1、服务端" class="headerlink" title="1、服务端"></a>1、服务端</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、安装NFS和rpcbind</span><br><span class="line">[root@nfs ~]<span class="comment"># yum install nfs-utils rpcbind -y</span></span><br><span class="line"></span><br><span class="line">2、创建挂载点</span><br><span class="line">[root@nfs ~]<span class="comment"># mkdir -p /web/nfs&#123;1..9&#125;</span></span><br><span class="line"></span><br><span class="line">3、配置挂载点</span><br><span class="line">[root@nfs ~]<span class="comment"># vim /etc/exports</span></span><br><span class="line">格式：</span><br><span class="line">[挂载点] [可以访问的IP]([权限])<span class="comment">#NFS配置详解参考下方</span></span><br><span class="line">/web/nfs1  172.16.1.0/20(rw,sync,all_squash)</span><br><span class="line"></span><br><span class="line">4、关闭selinux和防火墙</span><br><span class="line">[root@nfs ~]<span class="comment"># setenforce 0</span></span><br><span class="line">[root@nfs ~]<span class="comment"># systemctl disable --now firewalld</span></span><br><span class="line"></span><br><span class="line">5、启动nfs和rpcbind服务</span><br><span class="line">[root@nfs ~]<span class="comment"># systemctl start nfs-server </span></span><br><span class="line">[root@nfs ~]<span class="comment"># systemctl start rpcbind</span></span><br><span class="line"></span><br><span class="line">6、检查服务端是否正常</span><br><span class="line">[root@nfs ~]<span class="comment"># showmount -e [服务端的地址，默认是本机地址]</span></span><br><span class="line"></span><br><span class="line">[root@nfs ~]<span class="comment"># showmount -e</span></span><br><span class="line">Export list <span class="keyword">for</span> nfs:</span><br><span class="line">/web/nfsv1 172.16.1.0/20</span><br><span class="line">[root@nfs ~]<span class="comment"># showmount -e 172.16.1.31</span></span><br><span class="line">Export list <span class="keyword">for</span> 172.16.1.31:</span><br><span class="line">/web/nfsv1 172.16.1.0/20</span><br><span class="line"></span><br><span class="line">[root@nfs ~]<span class="comment"># cat /var/lib/nfs/etab</span></span><br><span class="line"></span><br><span class="line">7、给挂载点授权</span><br><span class="line">[root@nfs ~]<span class="comment"># chown -R nfsnobody.nfsnobody /web</span></span><br></pre></td></tr></table></figure>

<h4 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、安装NFS</span><br><span class="line">[root@web01 opt]<span class="comment"># yum install -y nfs-utils</span></span><br><span class="line"></span><br><span class="line">2、创建目录</span><br><span class="line">[root@web01 opt]<span class="comment"># mkdir /opt/nfs/</span></span><br><span class="line"></span><br><span class="line">3、挂载NFS</span><br><span class="line">[root@web01 opt]<span class="comment"># mount -t nfs 172.16.1.31:/web/nfs1  /opt/nfs/</span></span><br><span class="line"></span><br><span class="line">4、测试NFS文件同步功能</span><br><span class="line">[root@web opt]<span class="comment"># touch nfs/&#123;1..9&#125;.txt</span></span><br><span class="line">[root@web opt]<span class="comment"># ll nfs/</span></span><br><span class="line"> 总用量 0</span><br><span class="line"> -rw-r--r-- 1 nfsnobody nfsnobody 0 12月 30 2021 1.txt</span><br><span class="line"> -rw-r--r-- 1 nfsnobody nfsnobody 0 12月 30 2021 2.txt</span><br><span class="line"> -rw-r--r-- 1 nfsnobody nfsnobody 0 12月 30 2021 3.txt</span><br><span class="line"> -rw-r--r-- 1 nfsnobody nfsnobody 0 12月 30 2021 4.txt</span><br><span class="line"> -rw-r--r-- 1 nfsnobody nfsnobody 0 12月 30 2021 5.txt</span><br><span class="line"> -rw-r--r-- 1 nfsnobody nfsnobody 0 12月 30 2021 6.txt</span><br><span class="line"> -rw-r--r-- 1 nfsnobody nfsnobody 0 12月 30 2021 7.txt</span><br><span class="line"> -rw-r--r-- 1 nfsnobody nfsnobody 0 12月 30 2021 8.txt</span><br><span class="line"> -rw-r--r-- 1 nfsnobody nfsnobody 0 12月 30 2021 9.txt</span><br><span class="line"></span><br><span class="line"><span class="comment">########################################################</span></span><br><span class="line"> <span class="comment"># 切换到服务端nfs服务器上查看 </span></span><br><span class="line">[root@nfs ~]<span class="comment"># ll /web/nfs1 #发现已经同步过来了</span></span><br><span class="line"> 总用量 0</span><br><span class="line"> -rw-r--r-- 1 nfsnobody nfsnobody 0 12月 30 22:02 1.txt</span><br><span class="line"> -rw-r--r-- 1 nfsnobody nfsnobody 0 12月 30 22:02 2.txt</span><br><span class="line"> -rw-r--r-- 1 nfsnobody nfsnobody 0 12月 30 22:02 3.txt</span><br><span class="line"> -rw-r--r-- 1 nfsnobody nfsnobody 0 12月 30 22:02 4.txt</span><br><span class="line"> -rw-r--r-- 1 nfsnobody nfsnobody 0 12月 30 22:02 5.txt</span><br><span class="line"> -rw-r--r-- 1 nfsnobody nfsnobody 0 12月 30 22:02 6.txt</span><br><span class="line"> -rw-r--r-- 1 nfsnobody nfsnobody 0 12月 30 22:02 7.txt</span><br><span class="line"> -rw-r--r-- 1 nfsnobody nfsnobody 0 12月 30 22:02 8.txt</span><br><span class="line"> -rw-r--r-- 1 nfsnobody nfsnobody 0 12月 30 22:02 9.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="NFS配置详解"><a href="#NFS配置详解" class="headerlink" title="NFS配置详解"></a>NFS配置详解</h2><table>
<thead>
<tr>
<th>nfs共享参数</th>
<th>参数作用</th>
</tr>
</thead>
<tbody><tr>
<td>rw</td>
<td>读写权限 (常用)</td>
</tr>
<tr>
<td>ro</td>
<td>只读权限 (不常用)</td>
</tr>
<tr>
<td>root_squash</td>
<td>当NFS客户端以root管理员访问时，映射为NFS服务器的匿名用户 (不常用)</td>
</tr>
<tr>
<td>no_root_squash</td>
<td>当NFS客户端以root管理员访问时，映射为NFS服务器的root管理员 (不常用)</td>
</tr>
<tr>
<td>all_squash</td>
<td>无论NFS客户端使用什么账户访问，均映射为NFS服务器的匿名用户 (常用)</td>
</tr>
<tr>
<td>no_all_squash</td>
<td>无论NFS客户端使用什么账户访问，都不进行压缩 (不常用)</td>
</tr>
<tr>
<td>sync</td>
<td>同时将数据写入到内存与硬盘中，保证不丢失数据 (常用)</td>
</tr>
<tr>
<td>async</td>
<td>优先将数据保存到内存，然后再写入硬盘；这样效率更高，但可能会丢失数据 (不常用)</td>
</tr>
<tr>
<td>anonuid</td>
<td>配置all_squash使用,指定NFS的用户UID,必须存在系统 (常用)</td>
</tr>
<tr>
<td>anongid</td>
<td>配置all_squash使用,指定NFS的用户GID,必须存在系统 (常用)</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、控制读写</span><br><span class="line">  rw  <span class="comment">#可读可写</span></span><br><span class="line">  ro  <span class="comment">#只读</span></span><br><span class="line"></span><br><span class="line">2、控制文件权限</span><br><span class="line">root_squash  </span><br><span class="line">no_root_squash</span><br><span class="line">all_squash</span><br><span class="line">no_all_squash</span><br><span class="line"></span><br><span class="line">3、控制写模式</span><br><span class="line">sync  <span class="comment">#同步写</span></span><br><span class="line">async <span class="comment">#异步写</span></span><br><span class="line"></span><br><span class="line">4、控制用户</span><br><span class="line">anonuid</span><br><span class="line">anongid</span><br><span class="line"></span><br><span class="line">统一用户：</span><br><span class="line"></span><br><span class="line">1、创建用户</span><br><span class="line">[root@nfs nfs1]<span class="comment"># groupadd www -g 666</span></span><br><span class="line">[root@nfs nfs1]<span class="comment"># useradd www -u 666 -g 666 -M -r -s /sbin/nologin </span></span><br><span class="line"></span><br><span class="line">2、修改配置挂载点</span><br><span class="line">[root@nfs nfs1]<span class="comment"># vim /etc/exports</span></span><br><span class="line"> /web/nfs1  172.16.1.0/20(rw,sync,all_squash，anonuid=666，anongid=666)</span><br><span class="line"><span class="comment"># 修改后重启</span></span><br><span class="line">[root@nfs nfs1]<span class="comment"># systemctl restart nfs-server rpcbind</span></span><br><span class="line"> </span><br><span class="line">3、修改挂载点权限</span><br><span class="line">[root@nfs nfs1]<span class="comment"># chown -R www.www /web/</span></span><br><span class="line"></span><br><span class="line">3、使用</span><br><span class="line"><span class="comment"># 先卸载再重新挂载</span></span><br><span class="line">[root@nfs nfs1]<span class="comment">#umount /opt/nfs/</span></span><br><span class="line">[root@nfs nfs1]<span class="comment">#mount -t nfs 172.16.1.31:/web/nfs1 /opt/nfs/</span></span><br><span class="line"><span class="comment"># 写入文件</span></span><br><span class="line">[root@nfs nfs1]<span class="comment"># touch nfs/10.txt</span></span><br><span class="line"><span class="comment"># 查看</span></span><br><span class="line">[root@nfs nfs1]<span class="comment"># ll nfs/</span></span><br></pre></td></tr></table></figure>

<h2 id="搭建考试系统"><a href="#搭建考试系统" class="headerlink" title="搭建考试系统"></a>搭建考试系统</h2><h4 id="1、搭建WEB服务"><a href="#1、搭建WEB服务" class="headerlink" title="1、搭建WEB服务"></a>1、搭建WEB服务</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、安装web软件</span><br><span class="line">[root@web01 opt]<span class="comment"># yum install httpd php php-devel -y</span></span><br><span class="line"></span><br><span class="line">2、将代码放置于网站的根目录</span><br><span class="line">[root@web01 opt]<span class="comment"># cd /var/www/html/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传代码</span></span><br><span class="line"></span><br><span class="line">3、授权</span><br><span class="line">[root@web01 html]<span class="comment"># chown -R www.www /var/www/html</span></span><br><span class="line"></span><br><span class="line">4、关闭selinux和防火墙</span><br><span class="line">[root@nfs ~]<span class="comment"># setenforce 0</span></span><br><span class="line">[root@nfs ~]<span class="comment"># systemctl disable --now firewalld</span></span><br><span class="line"></span><br><span class="line">5、修改web软件的用户</span><br><span class="line">[root@web01 html]<span class="comment"># vim /etc/httpd/conf/httpd.conf</span></span><br><span class="line">User www</span><br><span class="line">Group www</span><br><span class="line"></span><br><span class="line">6、启动web软件</span><br><span class="line">[root@web01 html]<span class="comment"># systemctl start httpd</span></span><br><span class="line"></span><br><span class="line">7、测试</span><br><span class="line"></span><br><span class="line">	1、上传</span><br><span class="line">	</span><br><span class="line">	2、访问</span><br><span class="line">    http://172.16.1.7/upload/1_linux.jpg</span><br></pre></td></tr></table></figure>

<h4 id="2、配合NFS实现文件共享"><a href="#2、配合NFS实现文件共享" class="headerlink" title="2、配合NFS实现文件共享"></a>2、配合NFS实现文件共享</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、修改NFS配置文件</span><br><span class="line">[root@nfs nfs1]<span class="comment"># vim /etc/exports</span></span><br><span class="line">/web/upload  172.16.1.0/20(rw,sync,all_squash,anonuid=666,anongid=666)</span><br><span class="line"></span><br><span class="line">2、创建挂载点</span><br><span class="line">[root@nfs nfs1]<span class="comment"># mkdir /web/upload</span></span><br><span class="line">[root@nfs nfs1]<span class="comment"># chown www.www /web/upload</span></span><br><span class="line"></span><br><span class="line">3、重启NFS</span><br><span class="line">[root@nfs nfs1]<span class="comment"># systemctl restart nfs-server rpcbind</span></span><br><span class="line"></span><br><span class="line">4、客户端安装NFS软件</span><br><span class="line">[root@web01 html]<span class="comment"># yum install nfs-utils -y</span></span><br><span class="line">[root@web02 html]<span class="comment"># yum install nfs-utils -y</span></span><br><span class="line">[root@web03 html]<span class="comment"># yum install nfs-utils -y</span></span><br><span class="line"></span><br><span class="line">5、挂载</span><br><span class="line">[root@web01 html]<span class="comment"># mount -t nfs 172.16.1.31:/web/upload /var/www/html/upload</span></span><br><span class="line">[root@web02 html]<span class="comment"># mount -t nfs 172.16.1.31:/web/upload /var/www/html/upload</span></span><br><span class="line">[root@web03 html]<span class="comment"># mount -t nfs 172.16.1.31:/web/upload /var/www/html/upload</span></span><br><span class="line"></span><br><span class="line">6、测试</span><br><span class="line"><span class="comment"># 用web2上传，web3查看</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">sed -i <span class="string">&#x27;s/.100/$1/g&#x27;</span> /etc/sysconfig/network-scripts/ifcfg-eth[10]</span><br><span class="line">hostnamectl set-hostname <span class="variable">$2</span></span><br><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Rsync使用</title>
    <url>/340a13f1.html</url>
    <content><![CDATA[<h1 id="rsync同步工具"><a href="#rsync同步工具" class="headerlink" title="rsync同步工具"></a>rsync同步工具</h1><ul>
<li>rsync (remote synchronizetion) 一款开源的快速的，多功能的，可实现全量及增量（差异化备份）的本地或远程数据备份的优秀工具<span id="more"></span>
<img src="https://gitee.com/gengff/blogimage/raw/master/images/v2-6f26d816c7a3d517e75d8f4187d2c5b5_1440w.jpg" alt="v2-6f26d816c7a3d517e75d8f4187d2c5b5_1440w"></li>
</ul>
<h2 id="rsync介绍"><a href="#rsync介绍" class="headerlink" title="rsync介绍"></a>rsync介绍</h2><ul>
<li>rsync，从软件的名称就可以看出来，rsync具有可使本地和远程两台主机之间的数据快速复制同步镜像、远程备份的功能，这个功能类似于ssh带的scp命令，但是又优于scp命令的功能，scp每次都是全量拷贝，而rsync可以增量拷贝。当然，rsync还可以在本地主机的不同分区或目录之间全量及增量的复制数据，这又类似cp命令。但是同样也优于cp命令，cp每次都是全量拷贝，而rsync可以增量拷贝。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync官方地址：https://rsync.samba.org/</span><br><span class="line">rsync监听端口：873</span><br><span class="line">rsync运行模式：C/S   client/server</span><br><span class="line"></span><br><span class="line">rsync简称叫做远程同步，可以实现不同主机之间的数据同步，还支持全量和增量</span><br></pre></td></tr></table></figure>

<h2 id="rsync特性"><a href="#rsync特性" class="headerlink" title="rsync特性"></a>rsync特性</h2><ul>
<li>1)支持拷贝特殊文件，如链接文件、设备等。</li>
<li>2)可以有排除指定文件或目录同步的功能，相当于打包命令tar的排除功能。</li>
<li>3)可以做到保持原文件或目录的权限、时间、软硬链接、属主、组等所有属性均不改变 –p。</li>
<li>4)可以实现增量同步，既只同步发生变化的数据，因此数据传输效率很高（tar-N）。</li>
<li>5)可以使用rcp、rsh、ssh等方式来配合传输文件（rsync本身不对数据加密）。</li>
<li>6)可以通过socket（进程方式）传输文件和数据（服务端和客户端）。</li>
<li>7)支持匿名的活认证（无需系统用户）的进程模式传输，可以实现方便安全的进行数据备份和镜像。</li>
</ul>
<h2 id="rsync应用场景"><a href="#rsync应用场景" class="headerlink" title="rsync应用场景"></a>rsync应用场景</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">全量备份</span><br><span class="line">增量备份</span><br><span class="line"></span><br><span class="line">两台服务器之间数据同步。</span><br><span class="line">把所有客户服务器数据同步到备份服务器，生产场景集群架构服务器备份方案。</span><br><span class="line">rsync结合inotify的功能做实时的数据同步。</span><br></pre></td></tr></table></figure>

<h2 id="rsync的传输方式"><a href="#rsync的传输方式" class="headerlink" title="rsync的传输方式"></a>rsync的传输方式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">push 推：</span><br><span class="line">  客户端将数据从本地推送至服务端(rsync服务器主动推送数据给其他主机。服务器开销大，适合后端服务器少的情况)</span><br><span class="line"> </span><br><span class="line">pull 拉：</span><br><span class="line">  客户端将数据从服务端拉取到本地(客户端主动向rsync服务器拉取数据)</span><br></pre></td></tr></table></figure>

<h2 id="rsync传输模式"><a href="#rsync传输模式" class="headerlink" title="rsync传输模式"></a>rsync传输模式</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.本地方式（类似于cp，不支持推送和拉取，只是单纯的复制）</span><br><span class="line">2.远程方式（类似于scp，又不同于scp），scp只支持全量备份，rsync支持增量备份和差异备份</span><br><span class="line">3.守护进程（socket）方式（客户端和服务端）</span><br></pre></td></tr></table></figure>

<h2 id="rsync使用"><a href="#rsync使用" class="headerlink" title="rsync使用"></a>rsync使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-a   <span class="comment">#归档模式传输, 等于-tropgDl    -t -r -o -p -g -D -l</span></span><br><span class="line">-v   <span class="comment">#详细模式输出, 打印速率, 文件数量等</span></span><br><span class="line">	[root@m01 ~]<span class="comment"># rsync -v ./2.txt  root@172.16.1.41:/opt/</span></span><br><span class="line">-z   <span class="comment">#传输时进行压缩以提高效率</span></span><br><span class="line">	[root@m01 ~]<span class="comment"># rsync -vz ./2.txt  root@172.16.1.41:/opt/</span></span><br><span class="line">-r   <span class="comment">#递归传输目录及子目录，即目录下得所有目录都同样传输。</span></span><br><span class="line">	[root@m01 ~]<span class="comment"># rsync -vzr ./a  root@172.16.1.41:/opt/</span></span><br><span class="line">-t   <span class="comment">#保持文件时间信息</span></span><br><span class="line">	[root@m01 ~]<span class="comment"># rsync -vzrt ./a/b/c/2.txt  root@172.16.1.41:/opt/</span></span><br><span class="line">-o   <span class="comment">#保持文件属主信息</span></span><br><span class="line">-g   <span class="comment">#保持文件属组信息</span></span><br><span class="line">	[root@m01 ~]<span class="comment"># rsync -vzrtgo  ./a/b/c/2.txt  root@172.16.1.41:/opt/</span></span><br><span class="line">-p   <span class="comment">#保持文件权限</span></span><br><span class="line">	[root@m01 ~]<span class="comment"># rsync -vzrtgop  ./a/b/c/2.txt  root@172.16.1.41:/opt/</span></span><br><span class="line">-l   <span class="comment">#保留软连接</span></span><br><span class="line">	[root@m01 ~]<span class="comment"># rsync -vzrtgopl  ./*  root@172.16.1.41:/opt/</span></span><br><span class="line">-P   <span class="comment">#显示同步的过程及传输时的进度等信息</span></span><br><span class="line">	[root@m01 ~]<span class="comment"># rsync -vzrtgoplP  ./*  root@172.16.1.41:/opt/</span></span><br><span class="line">-D   <span class="comment">#保持设备文件信息</span></span><br><span class="line">	[root@m01 dev]<span class="comment"># rsync -vzrtgDopl /dev/tty1   root@172.16.1.41:/opt/</span></span><br><span class="line">-L   <span class="comment">#保留软连接指向的目标文件</span></span><br><span class="line">-e   <span class="comment">#使用的信道协议,指定替代rsh的shell程序</span></span><br><span class="line"></span><br><span class="line">--append          <span class="comment"># 指定文件接着上次传输中断处继续传输</span></span><br><span class="line">--append-verify   <span class="comment"># 使用参数续传（在断点续传之后，验证一下文件，如果不同，修复文件）</span></span><br><span class="line"></span><br><span class="line">--exclude=PATTERN   <span class="comment"># 指定排除不需要传输的文件</span></span><br><span class="line">	[root@m01 ~]<span class="comment"># rsync -avzP --append-verify --exclude=2.txt  ./* root@172.16.1.41:/opt/</span></span><br><span class="line"></span><br><span class="line">--exclude-from=file <span class="comment"># 按照文件指定内容排除</span></span><br><span class="line">	[root@m01 ~]<span class="comment"># rsync -avzP --append-verify --exclude-from=/tmp/exclude.txt  ./* root@172.16.1.41:/opt/</span></span><br><span class="line"></span><br><span class="line">--bwlimit=100       <span class="comment"># 限速传输（单位：MB）</span></span><br><span class="line">	[root@m01 ~]<span class="comment"># rsync -avzP --append-verify --bwlimit=10  ./* root@172.16.1.41:/opt/</span></span><br><span class="line"></span><br><span class="line">--delete            <span class="comment"># 让目标目录和源目录数据保持一致</span></span><br><span class="line"></span><br><span class="line">--password-file=xxx <span class="comment"># 使用密码文件</span></span><br><span class="line"></span><br><span class="line">--port              <span class="comment"># 指定端口传输</span></span><br></pre></td></tr></table></figure>

<h2 id="rsync守护进程模式"><a href="#rsync守护进程模式" class="headerlink" title="rsync守护进程模式"></a>rsync守护进程模式</h2><h4 id="1、服务端"><a href="#1、服务端" class="headerlink" title="1、服务端"></a>1、服务端</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、安装</span><br><span class="line"> [root@backup ~]<span class="comment"># yum install -y rsync</span></span><br><span class="line"></span><br><span class="line">2、修改配置文件</span><br><span class="line"> [root@m01 ~]<span class="comment"># vim /etc/rsyncd.conf </span></span><br><span class="line">  uid = rsync</span><br><span class="line">  gid = rsync</span><br><span class="line">  port = 873</span><br><span class="line">  fake super = yes</span><br><span class="line">  use chroot = no</span><br><span class="line">  max connections = 200</span><br><span class="line">  timeout = 600</span><br><span class="line">  ignore errors</span><br><span class="line">  <span class="built_in">read</span> only = <span class="literal">false</span></span><br><span class="line">  list = <span class="literal">false</span></span><br><span class="line">  auth users = rsync_backup</span><br><span class="line">  secrets file = /etc/rsync.passwd</span><br><span class="line">  <span class="built_in">log</span> file = /var/<span class="built_in">log</span>/rsyncd.log</span><br><span class="line">  <span class="comment">#####################################</span></span><br><span class="line">  [backup]</span><br><span class="line">  comment = welcome to backup!</span><br><span class="line">  path = /backup</span><br><span class="line">  [linux]</span><br><span class="line">  comment = welcome to linux!</span><br><span class="line">  path=/tmp/linux</span><br><span class="line"></span><br><span class="line">3、创建系统用户</span><br><span class="line"> [root@backup opt]<span class="comment"># groupadd rsync -g 666</span></span><br><span class="line"> [root@backup opt]<span class="comment"># useradd rsync -u 666 -g 666 -M -s /sbin/nologin -r</span></span><br><span class="line"></span><br><span class="line">4、创建密码文件</span><br><span class="line"> [root@backup opt]<span class="comment"># echo &quot;rsync_backup:123456&quot; &gt; /etc/rsync.passwd</span></span><br><span class="line"></span><br><span class="line">5、授权（必须授权为600）</span><br><span class="line"> [root@backup opt]<span class="comment"># chmod 600 /etc/rsync.passwd</span></span><br><span class="line"></span><br><span class="line">6、创建备份目录</span><br><span class="line"> [root@backup opt]<span class="comment"># mkdir /backup</span></span><br><span class="line"> [root@backup opt]<span class="comment"># mkdir /tmp/linux</span></span><br><span class="line"></span><br><span class="line">7、目录授权</span><br><span class="line"> [root@backup opt]<span class="comment"># chown rsync.rsync /backup/</span></span><br><span class="line"> [root@backup opt]<span class="comment"># chown rsync.rsync /tmp/linux/</span></span><br><span class="line"></span><br><span class="line">8、关闭防火墙和selinux</span><br><span class="line"> [root@backup opt]<span class="comment"># systemctl disabel --now firewalld</span></span><br><span class="line"> [root@backup opt]<span class="comment"># setenforce 0</span></span><br><span class="line"></span><br><span class="line">9、启动rsyncd服务</span><br><span class="line"> [root@backup opt]<span class="comment"># systemctl start rsyncd</span></span><br></pre></td></tr></table></figure>

<h4 id="2、客户端"><a href="#2、客户端" class="headerlink" title="2、客户端"></a>2、客户端</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">方法一：自己输入密码</span><br><span class="line">  [root@m01 ~]<span class="comment"># rsync -avzP ./* rsync_backup@172.16.1.41::backup</span></span><br><span class="line">	</span><br><span class="line">   rsync_backup ： 虚拟用户，只在数据传输时使用</span><br><span class="line">   172.16.1.41  ： backup服务端的IP</span><br><span class="line">   backup       ： 模块名称</span><br><span class="line">	</span><br><span class="line">方法二：设置密码文件，运行时读取</span><br><span class="line"></span><br><span class="line">	1、编写密码文件</span><br><span class="line">   [root@backup opt]<span class="comment"># echo &quot;123456&quot; &gt; /etc/rsync.passwd</span></span><br><span class="line"></span><br><span class="line">	2、授权</span><br><span class="line">   [root@m01 ~]<span class="comment"># chmod 600 /etc/rsync.passwd</span></span><br><span class="line"></span><br><span class="line">	3、连接</span><br><span class="line">   [root@m01 ~]<span class="comment"># rsync -avzP --password-file=/etc/rsync.passwd  ./* rsync_backup@172.16.1.41::linux</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">方法三：添加环境变量</span><br><span class="line">	1、定义环境变量</span><br><span class="line">   <span class="built_in">export</span> RSYNC_PASSWORD=123456</span><br><span class="line">	</span><br><span class="line">	2、同步</span><br><span class="line">   [root@m01 ~]<span class="comment"># rsync -avzP  ./* rsync_backup@172.16.1.41::linux</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="rsync实时同步"><a href="#rsync实时同步" class="headerlink" title="rsync实时同步"></a>rsync实时同步</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rsync是不支持实时同步的，通常我们借助于inotify这个软件来实时监控文件变化，一旦inotify监控到文件变，则立即调用rsync进行同步。</span><br><span class="line"></span><br><span class="line">1、安装inotify(装在客户端)</span><br><span class="line">[root@web01 ~]<span class="comment"># yum -y install inotify-tools</span></span><br><span class="line"></span><br><span class="line">2、inotify参数介绍</span><br><span class="line">-m 持续监控</span><br><span class="line">-r 递归</span><br><span class="line">-q 静默，仅打印时间信息</span><br><span class="line">--timefmt 指定输出时间格式</span><br><span class="line">--format 指定事件输出格式</span><br><span class="line">    %Xe 事件</span><br><span class="line">    %w 目录</span><br><span class="line">    %f 文件</span><br><span class="line">-e 指定监控的事件</span><br><span class="line">    access 访问</span><br><span class="line">    modify 内容修改</span><br><span class="line">    attrib 属性修改</span><br><span class="line">    close_write 修改真实文件内容</span><br><span class="line">    open 打开</span><br><span class="line">    create 创建</span><br><span class="line">    delete 删除</span><br><span class="line">    umount 卸载</span><br><span class="line">    </span><br><span class="line">3、开始监控</span><br><span class="line">[root@m01 ~]<span class="comment"># /usr/bin/inotifywait  -mrq  --format &#x27;%Xe  %w  %f&#x27; -e create,modify,delete,attrib,close_write  /root</span></span><br><span class="line"></span><br><span class="line">4、实时监控并同步</span><br><span class="line">[root@m01 ~]<span class="comment"># /usr/bin/inotifywait  -mrq  --format &#x27;%Xe  %w  %f&#x27; -e create,modify,delete,attrib,close_write  /root | while read line;do</span></span><br><span class="line">  <span class="built_in">cd</span>  /root</span><br><span class="line">  rsync -avzP --delete --password-file=/etc/rsyncd.passwd ./* rsync_backup@172.16.1.41::backup</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux防火墙iptables</title>
    <url>/2efe136b.html</url>
    <content><![CDATA[<h1 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h1><span id="more"></span>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84.png" alt="项目架构"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/6581640856451_.pic_%E5%89%AF%E6%9C%AC.jpg" alt="6581640856451_.pic_副本"></p>
<h1 id="防火墙种类及使用说明"><a href="#防火墙种类及使用说明" class="headerlink" title="防火墙种类及使用说明"></a>防火墙种类及使用说明</h1><p><img src="https://gitee.com/gengff/blogimage/raw/master/images/2615753-20211226235009781-222102770.webp" alt="2615753-20211226235009781-222102770"></p>
<ul>
<li><p>什么是防火墙</p>
<ul>
<li>防火墙一直被认为是保护敏感信息的第一道防线。他们在安全与受控内部网络之间建立了一道屏障，提供低级保护，以及重要的日志记录和审计功能。它能监视传入和传出的流量，并根据一组以定义的安全规则决定是允许还是阻止特定流量。</li>
</ul>
</li>
<li><p>防火墙种类</p>
<ul>
<li>硬件防火墙（主机防火墙）<ul>
<li>三层路由： 华为 H3C(华三)</li>
<li>深信服</li>
</ul>
</li>
<li>软件防火墙（网络防火墙）<ul>
<li>iptables</li>
<li>firewalld</li>
</ul>
</li>
<li>云防火墙<ul>
<li>阿里云:安全组（默认的是白名单 防火墙默认规则是拒绝）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="Iptables"><a href="#Iptables" class="headerlink" title="Iptables"></a>Iptables</h1><p>Netfilter/Iptables（以下简称Iptables）是unix/linux自带的一款优秀且开放源代码的完全自由的基于包过滤的防火墙工具，它的功能十分强大，使用非常灵活，可以对流入和流出服务器的数据包进行很精细的控制。在早期的Linux系统中，默认使用的是iptables防火墙管理服务来配置防火墙。尽管新型的firewalld防火墙管理服务已经被投入使用多年，但是大量的企业在生产环境中依然出于各种原因而继续使用iptables。</p>
<ul>
<li>iptables是linux2.4及2.6内核中集成的服务。</li>
<li>iptables主要工作在OSI七层的二、三、四层，如果重新编译内核，iptables也可以支持7层控制</li>
</ul>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/image-20210823223210395.png" alt="image-20210823223210395"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">用户  ---&gt;  调用iptables  ---&gt;  ip_tables内核模块  ---&gt;  Netfilter（系统安全框架） ---&gt;  过滤请求</span><br></pre></td></tr></table></figure>



<h3 id="iptables防火墙网路安全前言介绍"><a href="#iptables防火墙网路安全前言介绍" class="headerlink" title="iptables防火墙网路安全前言介绍"></a>iptables防火墙网路安全前言介绍</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">学好iptables的基础：</span><br><span class="line">  1、OSI7层模型以及不同层对应哪些协议？</span><br><span class="line">  2、TCP/IP三次握手，四次断开的过程，TCP HEADER，状态转换</span><br><span class="line">  3、常用的服务端口要非常清楚了解。</span><br><span class="line">  4、常用服务协议原理http协议，icmp协议。</span><br><span class="line"></span><br><span class="line">企业中安全配置原则：</span><br><span class="line">  1、尽可能不给服务器配置外网IP，可以通过代理转发或者通过防火墙映射。</span><br><span class="line">  2、并发不是特别大情况有外网IP，可以开启防火墙服务。</span><br><span class="line">  3、大并发的情况，不能开iptables，影响性能，利用硬件防火墙提升架构安全。Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h3 id="包过滤防火墙"><a href="#包过滤防火墙" class="headerlink" title="包过滤防火墙"></a>包过滤防火墙</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、什么是包</span><br><span class="line">	在数据传输过程，并不是一次性传输完成的；而是将数据分成若干个数据包，一点一点的传输。</span><br><span class="line"></span><br><span class="line">2、 什么是包过滤防火墙</span><br><span class="line">	过滤数据包的防火墙。</span><br><span class="line"></span><br><span class="line">4、包过滤防火墙如何实现</span><br><span class="line">  通过系统安全框架，过滤数据包。</span><br><span class="line">  </span><br><span class="line">5、防火墙使用时名词概念理解  </span><br><span class="line">容器：装东西的器皿，docker容器技术，将镜像装在了一个系统中，这个系统就称为容器</span><br><span class="line">iptables称为一个容器---装着防火墙的表</span><br><span class="line">防火墙的表又是一个容器---装着防火墙的链</span><br><span class="line">防火墙的链也是一个容器---装着防火墙的规则</span><br><span class="line">iptables---表---链---规则</span><br><span class="line">  </span><br><span class="line">规则：防火墙一条一条安全策略</span><br><span class="line">防火墙匹配规则流程：</span><br><span class="line">  1. 防火墙是层层过滤的，实际是按照配置规则的顺序从上到下，从前到后进行过滤的。</span><br><span class="line">  2. 如果匹配上规则，即明确表示是阻止还是通过，数据包就不再向下匹配新的规则。</span><br><span class="line">  3. 如果规则中没有明确表明是阻止还是通过的，也就是没有匹配规则，向下进行匹配，直到匹配默认规则得到明确的阻止还是通过。</span><br><span class="line">  4. 防火墙的默认规则是所有规则执行完才执行的。Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<h2 id="4表5链"><a href="#4表5链" class="headerlink" title="4表5链"></a>4表5链</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、四个表，有哪些作用</span><br><span class="line">   具备某种功能的集合叫做表。</span><br><span class="line"></span><br><span class="line">   filter：负责做过滤功能呢	  INPUT、OUTPUT、FORWARD</span><br><span class="line">   nat：	  网络地址转换	     PREROUTING、INPUT、OUTPUT、POSTROUTING</span><br><span class="line">   mangle：负责修改数据包内容  PREROUTING、INPUT、OUTPUT、POSTROUTING、FORWARD</span><br><span class="line">   raw：   负责数据包跟踪      PREROUTING、OUTPUT</span><br><span class="line"></span><br><span class="line">2、五条链，运行在那些地方</span><br><span class="line"></span><br><span class="line">   PREROUTING、INPUT、OUTPUT、FORWARD、POSTROUTING</span><br><span class="line"></span><br><span class="line">  1）PREROUTING: 主机外报文进入位置，允许的表mangle, nat（目标地址转换，把本机地址转换为真正的目标机地址，通常指响应报文）</span><br><span class="line">  2）INPUT：报文进入本机用户空间位置，允许的表filter, mangle</span><br><span class="line">  3）OUTPUT：报文从本机用户空间出去的位置，允许filter, mangle, nat</span><br><span class="line">  4）FOWARD：报文经过路由并且发觉不是本机决定转发但还不知道从哪个网卡出去，允许filter, mangle</span><br><span class="line">  5）POSTROUTING：报文经过路由被转发出去，允许mangle，nat（源地址转换，把原始地址转换为转发主机出口网卡地址）</span><br><span class="line"></span><br><span class="line">   流入本机：PREROUTING  --&gt;  INPUT  --&gt; PROCESS(进程)</span><br><span class="line">   流出本机：PROCESS(进程) --&gt;  OUTPUT --&gt; POSTROUTING</span><br><span class="line">   经过本机：PREROUTING  --&gt; FORWARD --&gt; POSTROUTING</span><br></pre></td></tr></table></figure>



<h4 id="流入本机"><a href="#流入本机" class="headerlink" title="流入本机"></a>流入本机</h4><ul>
<li>当外部的数据进入时通过网卡进入本机后，在网络层时会经过PREROUTING（主机外报文进入位置）链继续前进到达用户层之前会经过INPUT链。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据进入（通过网线）---&gt; 链接网卡设备 ---&gt; 网络接口层 ---&gt; netfilter ---&gt;</span><br><span class="line">在网络层时会经过PREROUTING（主机外报文进入的位置）链 ---&gt; TCP UDP协议 ---&gt;</span><br><span class="line">进入用户层之前（INPUT）---&gt; 到达用户层</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/2615753-20211227000852784-704163914.png" alt="2615753-20211227000852784-704163914"></p>
<h4 id="流出本机"><a href="#流出本机" class="headerlink" title="流出本机"></a>流出本机</h4><ul>
<li>当用户从用户层发出数据之后，会先经过OUTPUT链，在经过了OUTPUT链到达Netfilter防火墙，在经过防火墙到达设备驱动之前，会经过POSTROUTING链，之后在发送出去。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户操作命令工具(iptables) --&gt; OUTPUT链 --&gt; ip_tables内核模块 --&gt;</span><br><span class="line">Netfilter(防火墙) --&gt; 网络层 --&gt; 网络接口层 --&gt; POSTROUTING链</span><br><span class="line">-- 设备驱动 --&gt; 网络传输出</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/2615753-20211227002046380-1487109655.png" alt="2615753-20211227002046380-1487109655"></p>
<h4 id="经过本机"><a href="#经过本机" class="headerlink" title="经过本机"></a>经过本机</h4><ul>
<li>报文经过路由并且发觉目的并不是本机,在经过PREROUTING链进入本机发现最终目的并不是本机时被转到FORWORD链后经过POSTROUING链转发出去。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据进入 --&gt; PREROUTING --&gt; FORWARD --&gt; POSTROUTING --&gt; 出去</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/2615753-20211227002203426-1208905019-20211230171628792.png" alt="2615753-20211227002203426-1208905019"></p>
<h2 id="Iptables流程图"><a href="#Iptables流程图" class="headerlink" title="Iptables流程图"></a>Iptables流程图</h2><p><img src="https://gitee.com/gengff/blogimage/raw/master/images/1.jpeg" alt="1"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">流入本机： A  ---&gt;  PREROUTING  ---&gt;  INPUT ---&gt; B</span><br><span class="line">流出本机：OUTPUT  ---&gt;  POSTROUTING  ---&gt; B</span><br><span class="line">经过本机： A ---&gt; OUTPUT ---&gt; POSTROUTING | ---&gt; PREROUTING ---&gt; FORWARD  ---&gt; POSTROUTING ---&gt; C ---&gt; PREROUTING  ---&gt; INPUT ---&gt; B</span><br><span class="line"></span><br><span class="line">filter :  INPUT 、FORWARD、 OUTPUT </span><br><span class="line">nat : PREROUTING 、 INPUT、 OUTPUT、 POSTROUTING</span><br><span class="line">raw : PREROUTING、 OUTPUT</span><br><span class="line">mangle : PREROUTING INPUT FORWARD OUTPUT POSTROUTING</span><br></pre></td></tr></table></figure>







<h2 id="Iptables的使用"><a href="#Iptables的使用" class="headerlink" title="Iptables的使用"></a>Iptables的使用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、安装Iptables</span><br><span class="line">	[root@m01 ~]<span class="comment"># yum install iptables*</span></span><br><span class="line"></span><br><span class="line">2、启动Iptables</span><br><span class="line">	[root@m01 ~]<span class="comment"># systemctl start iptables</span></span><br><span class="line"></span><br><span class="line">3、关闭firewalld</span><br><span class="line">	[root@m01 ~]<span class="comment"># systemctl disable --now firewalld</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">格式：iptables -t 表名 选项 链名称 条件  动作</span><br><span class="line"></span><br><span class="line">-t            <span class="comment">#指定操作的表</span></span><br><span class="line">-L, --list    <span class="comment">#以列表形式显示当前的规则</span></span><br><span class="line">-v            <span class="comment">#显示数据包和数据包大小</span></span><br><span class="line">-n            <span class="comment">#不反解地址</span></span><br><span class="line">-A, --append  <span class="comment">#追加一条规则到指定链中</span></span><br><span class="line">-I, --insert  <span class="comment">#插入一条规则，插入到顶部</span></span><br><span class="line">-F, --flush   <span class="comment">#清除防火墙默认规则</span></span><br><span class="line">-Z, --zero    <span class="comment">#清空计数器（包数量 、包大小）</span></span><br><span class="line">-D, --delete  <span class="comment">#删除链中的规则</span></span><br><span class="line">-R, --replace <span class="comment">#修改</span></span><br><span class="line">-S, --list-rules   <span class="comment">#列出所有的规则</span></span><br><span class="line">-N, --new-chain    <span class="comment">#创建一个自定义 链</span></span><br><span class="line">-X, --delete-chain <span class="comment">#删除防火墙自定义链</span></span><br><span class="line">-P, --policy       <span class="comment">#指定链的默认策略  </span></span><br></pre></td></tr></table></figure>

<h4 id="iptables动作"><a href="#iptables动作" class="headerlink" title="iptables动作"></a>iptables动作</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ACCEPT   <span class="comment">#将数据包放行，进行完此处理动作后，将不再比对其它规则，直接跳往下一个规则链。</span></span><br><span class="line">REJECT   <span class="comment">#拦阻该数据包，并传送数据包通知对方。</span></span><br><span class="line">DROP     <span class="comment">#丢弃包不予处理，进行完此处理动作后，将不再比对其它规则，直接中断过滤程序。</span></span><br><span class="line">REDIRECT <span class="comment">#将包重新导向到另一个端口，进行完此处理动作后，将会继续比对其它规则。</span></span><br></pre></td></tr></table></figure>

<h4 id="Iptables基本的条件匹配"><a href="#Iptables基本的条件匹配" class="headerlink" title="Iptables基本的条件匹配"></a>Iptables基本的条件匹配</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TCP(http)</span><br><span class="line">UDP</span><br><span class="line">ICMP(ping)</span><br><span class="line">ALL</span><br></pre></td></tr></table></figure>

<h4 id="s、-d-源地址、目标地址"><a href="#s、-d-源地址、目标地址" class="headerlink" title="-s、-d  源地址、目标地址"></a>-s、-d  源地址、目标地址</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-s  <span class="comment">#源地址：发送请求的地址（指定匹配的源地址网段信息，或者匹配的主机信息）</span></span><br><span class="line"></span><br><span class="line">-d  <span class="comment">#目标地址：访问的地址（指定匹配的目标地址网段信息，或者匹配的主机信息）</span></span><br></pre></td></tr></table></figure>

<h4 id="–sport源端口、–dport-目标端口"><a href="#–sport源端口、–dport-目标端口" class="headerlink" title="–sport源端口、–dport 目标端口"></a>–sport源端口、–dport 目标端口</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">--sport  <span class="comment">#源端口：发送请求的端口（表示指定源端口号信息）</span></span><br><span class="line"></span><br><span class="line">--dport  <span class="comment">#目标端口：访问的端口（表示指定目标端口信息）</span></span><br></pre></td></tr></table></figure>

<h4 id="i、-o、-m、-j-动作"><a href="#i、-o、-m、-j-动作" class="headerlink" title="-i、-o、-m、-j  动作"></a>-i、-o、-m、-j  动作</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-i  <span class="comment">#进来的网卡（指定匹配的进入流量接口信息 只能配置在INPUT链上）</span></span><br><span class="line">-o  <span class="comment">#出去的网卡（指定匹配的发出流量接口信息 只能配置在OUTPUT链上）</span></span><br><span class="line">-m  <span class="comment">#指定应用扩展模块参数</span></span><br><span class="line">-p  <span class="comment">#指定相应服务协议信息（tcp udp icmp all）</span></span><br><span class="line">-j  <span class="comment">#转发动作，指定对相应匹配规则执行什么操作（ACCEPT DROP REJECT REDIRECT）</span></span><br><span class="line">    ACCEPT 允许通过</span><br><span class="line">    DROP 直接拒绝 </span><br><span class="line">    REJECT 委婉拒绝</span><br><span class="line">    REDIRECT 重定向</span><br><span class="line">    MASQUERADE 地址伪装</span><br><span class="line">    SNAT 如果内网主机访问外网而经过路由时，源IP会发生改变，这种变更行为就是SNAT</span><br><span class="line">    DNAT 当外网的数据经过路由发往内网主机时，数据包中的目的IP (路由器上的公网IP) 将修改为内网IP，这种变更行为就是DNAT</span><br></pre></td></tr></table></figure>

<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">案例1：只允许22端口可以访问，其他端口全部无法访问。 </span><br><span class="line">iptables -t filter -A INPUT -p TCP --dport 22  -j ACCEPT</span><br><span class="line">iptables -t filter -A INPUT -p TCP -j DROP</span><br><span class="line"></span><br><span class="line">案例2：只允许22，80，443端口可以访问，其他端口全部无法访问。 </span><br><span class="line">iptables -t filter -A INPUT -p TCP --dport 22  -j ACCEPT</span><br><span class="line">iptables -t filter -A INPUT -p TCP --dport 80  -j ACCEPT</span><br><span class="line">iptables -t filter -A INPUT -p TCP --dport 443  -j ACCEPT</span><br><span class="line">iptables -t filter -A INPUT -p TCP -j DROP</span><br><span class="line"></span><br><span class="line">案例3：只允许22，80，443端口可以访问，其他端口全部无法访问，但是本机可以访问百度。 </span><br><span class="line"></span><br><span class="line">案例4：要求使用192.168.15.81能够通过22端口链接，但是其他的不行</span><br><span class="line">iptables -t filter -A INPUT -p TCP -d 192.168.15.81 --dport 22  -j ACCEPT</span><br><span class="line">iptables -t filter -A INPUT -p TCP -j DROP</span><br><span class="line"></span><br><span class="line">案例5：只允许192.168.15.71能够通过22端口链接，其他的不行。</span><br><span class="line">iptables -t filter -A INPUT -p  TCP -s 192.168.15.71  -d 192.168.15.81 --dport 22 -j ACCEPT</span><br><span class="line">iptables -t filter -A INPUT -p TCP -j DROP</span><br><span class="line"></span><br><span class="line">案例6：要求192.168.15.71对外部不可见</span><br><span class="line">iptables -t filter -A INPUT -p TCP -d 192.168.15.71 -j DROP</span><br><span class="line"></span><br><span class="line">案例7：要求使用eth0网卡的所有请求全部拒绝</span><br><span class="line">iptables -t filter -A INPUT -p TCP -i etho -j DROP</span><br><span class="line"></span><br><span class="line">使用172.16.1.71登录进来的窗口，不允许访问百度。</span><br><span class="line">iptables -t filter -I OUTPUT -p TCP -o eth1 -j DROP</span><br><span class="line"></span><br><span class="line">案例8：要求访问服务器的8080端口转发至80端口</span><br><span class="line">iptables -t nat -A PREROUTING -p TCP --dport 8080 -j REDIRECT --to-port 80</span><br><span class="line"></span><br><span class="line">案例9：要求只允许windows通过ssh连接192.168.15.81，其他的拒绝</span><br><span class="line">iptables -t filter -I INPUT -p TCP -s 192.168.15.1 -d 192.168.15.81 --dport 22 -j ACCEPT</span><br><span class="line">iptables -t filter -I INPUT -p TCP --dport 22 -j DROP</span><br><span class="line"></span><br><span class="line">知识储备：</span><br><span class="line">	查看本机端口占用的命令：	</span><br><span class="line">		netstat -nutlp</span><br></pre></td></tr></table></figure>

<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">拓展iptables的功能的。</span><br><span class="line"></span><br><span class="line">-m : 指定模块</span><br><span class="line"></span><br><span class="line">1、连续匹配多个端口（multiport）</span><br><span class="line"></span><br><span class="line">	--dports  : 指定多个端口(不同端口之间以逗号分割，连续的端口使用冒号分割)。</span><br><span class="line">	</span><br><span class="line">2、指定一段连续的ip地址范围(iprange)</span><br><span class="line">    --src-range from[-to]:	源地址范围</span><br><span class="line">    --dst-range from[-to]	目标地址范围</span><br><span class="line"></span><br><span class="line">3、匹配指定字符串(string)</span><br><span class="line">    --string pattern	<span class="comment"># 指定要匹配的字符串</span></span><br><span class="line">    --algo &#123;bm|kmp&#125;		<span class="comment"># 匹配的查询算法</span></span><br><span class="line">    </span><br><span class="line">4、根据时间段匹配报文(time)</span><br><span class="line">    --timestart hh:mm[:ss]		<span class="comment"># 开始时间</span></span><br><span class="line">    --timestop hh:mm[:ss]		<span class="comment"># 结束时间</span></span><br><span class="line">    --monthdays day[,day...]	<span class="comment"># 指定一个月的某一天</span></span><br><span class="line">    --weekdays day[,day...]		<span class="comment"># 指定周 还是  周天 </span></span><br><span class="line"></span><br><span class="line">5、禁ping, 默认本机无法ping别人 、别人无法ping自己</span><br><span class="line">	--icmp-type &#123;<span class="built_in">type</span>[/code]|typename&#125;</span><br><span class="line">		echo-request  (8) 请求 </span><br><span class="line">		echo-reply    (0) 回应</span><br><span class="line"></span><br><span class="line">6、限制链接数，并发连接数（connlimit）</span><br><span class="line">    --connlimit-upto n		<span class="comment">#  如果现有连接数小于或等于  n  则 匹配</span></span><br><span class="line">    --connlimit-above n		<span class="comment">#  如果现有连接数大于n 则匹配</span></span><br><span class="line"></span><br><span class="line">7、针对 报文速率 进行限制。 秒、分钟、小时、天。</span><br><span class="line"></span><br><span class="line">	--<span class="built_in">limit</span> rate[/second|/minute|/hour|/day] <span class="comment"># 报文数量 </span></span><br><span class="line">     --limit-burst number  <span class="comment"># 报文数量（默认：5）</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="案例-1"><a href="#案例-1" class="headerlink" title="案例"></a>案例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、要求将22,80,443以及30000-50000之间所有的端口向外暴露，其他端口拒绝</span><br><span class="line"></span><br><span class="line">	iptables -t filter -A INPUT -p TCP -m multiport --dports 22,80,443,30000:50000 -j ACCEPT</span><br><span class="line">	iptables -f filter -A INPUT -p TCP -j DROP</span><br><span class="line"></span><br><span class="line">2、要求访问数据包中包含HelloWorld的数据不允许通过。</span><br><span class="line">	iptables -t filter -A INPUT -p TCP -m string --string <span class="string">&quot;HelloWorld&quot;</span> --algo kmp -j DROP</span><br><span class="line"></span><br><span class="line">3、要求192.168.15.1 - 192.168.15.10之间的所有IP能够连接192.168.15.81，其他拒绝</span><br><span class="line">	iptables -t filter -A INPUT -p TCP -m iprange --src-range 192.168.15.1-192.168.15.10 -j ACCEPT </span><br><span class="line">	iptables -f filter -A INPUT -p TCP -j DROP</span><br><span class="line"></span><br><span class="line">4、要求每天的12到13之间，不允许访问</span><br><span class="line">	iptables -t filter -A INPUT -p TCP -m time  --timestart 4:00   --timestop 5:00 -j DROP</span><br><span class="line">	</span><br><span class="line">	必须使用UTC时间</span><br><span class="line"></span><br><span class="line">5、要求别人不能ping本机，但是本机可以ping别人</span><br><span class="line">	iptables -t filter -A INPUT -p TCP -m icmp --icmp-type <span class="string">&quot;echo-request&quot;</span> -j DROP</span><br><span class="line">	</span><br><span class="line">6、要求主机连接最多有2个</span><br><span class="line">	iptables -t filter -A INPUT -p TCP --dport 22 -m connlimit --connlimit-above 2 -j DROP</span><br><span class="line">	</span><br><span class="line">7、要求限制速率在500k/s左右</span><br><span class="line">	iptables -t filter -A INPUT -p TCP -m <span class="built_in">limit</span> 333/s -j ACCEPT</span><br><span class="line">	iptables -t filter -A INPUT -p TCP -j DROP</span><br><span class="line">	</span><br><span class="line">8、只允许windows连接本机的iptables规则</span><br><span class="line">iptables -t filter -A INPUT -p tcp -s 192.168.15.1 --dport 22 -j ACCEPT</span><br><span class="line">iptables -t filter -A INPUT -p tcp --dport 22 -j DROP</span><br><span class="line"></span><br><span class="line">9、只允许192.168.15.0网段的IP连接本机，用两种方式实现。</span><br><span class="line">iptables -t filter -A INPUT -p tcp -m iprange  --src-range 192.168.15.1-192.168.15.254 -j ACCEPT</span><br><span class="line">iptables -t filter -A INPUT -p tcp --dport 22 -j DROP</span><br><span class="line"></span><br><span class="line">iptables -t filter -A INPUT -p tcp -i eth0 --dport 22 -j ACCEPT</span><br><span class="line">iptables -t filter -A INPUT -p tcp --dport 22 -j DROP</span><br><span class="line"></span><br><span class="line">10、要求本机流出的数据中包含“元旦快乐”</span><br><span class="line">iptables -t filter -A OUTPUT -p tcp --dport 80 -m string  --string <span class="string">&quot;元旦快乐&quot;</span> --algo kmp -j ACCEPT</span><br><span class="line">iptables -t filter -A OUTPUT -p tcp --dport 80 -j DROP</span><br><span class="line"></span><br><span class="line">11、要求每天的九点到17点之间可以正常访问</span><br><span class="line">iptables -t filetr -A INPUT -p tcp -m time  --timestart 1:00 --timestop 9:00 -j ACCEPT</span><br><span class="line">iptables -t filter -A INPUT -p tcp -j DROP</span><br></pre></td></tr></table></figure>























]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>VPN搭建使用</title>
    <url>/7efc43b.html</url>
    <content><![CDATA[<h1 id="虚拟专用网络"><a href="#虚拟专用网络" class="headerlink" title="虚拟专用网络"></a>虚拟专用网络</h1><p>VPN(全称：Virtual Private Network)虚拟专用网络，是依靠ISP和其他的NSP，在公共网络中建立专用的数据通信的网络技术，可以为企业之间或者个人与企业之间提供安全的数据传输隧道服务。在VPN中任意两点之间的链接并没有传统专网所需的端到端的物理链路，而是利用公共网络资源动态组成的，可以理解为通过私有的隧道技术在公共数据网络上模拟出来的和专网有同样功能的点到点的专线技术，所谓虚拟是指不需要去拉实际的长途物理线路，而是借用了公共Internet网络实现的。</p>
<span id="more"></span>
<h2 id="VPN的作用"><a href="#VPN的作用" class="headerlink" title="VPN的作用"></a>VPN的作用</h2><p>VPN的功能是帮助公司里的远程用户（出差，在家）、公司的分支机构、商业合作伙伴及供应商等公司和自己的公司内部网络之间建立可信的安全连接或者是局域网连接，确保数据的加密安全传输和业务访问，对于运维工程师来说，还可以连接不同的机房为局域网来处理相关事宜。</p>
<h2 id="VPN的分类"><a href="#VPN的分类" class="headerlink" title="VPN的分类"></a>VPN的分类</h2><ul>
<li>根据常用的使用场景来分类。</li>
</ul>
<h4 id="远程访问VPN服务"><a href="#远程访问VPN服务" class="headerlink" title="远程访问VPN服务"></a>远程访问VPN服务</h4><ul>
<li><p>通过个人电脑远程拨号到企业办公网络。</p>
<p>1、一般为企业内部员工出差、休假或特殊情况下载原理办公室的时候，又有需求访问公司的内部网络获取相关资源，就可以通过VPN拨号到公司内部。此时远程拨号的员工和办公室内的员工以及其他拨号的员工之间都相当于在一个局域网内。例如：访问内部的域控、文件服务器、OA系统等局域网应用。</p>
<p>2、对于运维人员来说就是需要个人电脑远程拨号到企业网站的服务器机房，远程维护机房中的（无外网IP的）服务器。</p>
<p>这种形式的VPN一般在运维人员在工作中会经常遇到。</p>
</li>
</ul>
<h4 id="企业内部网络互联"><a href="#企业内部网络互联" class="headerlink" title="企业内部网络互联"></a>企业内部网络互联</h4><ul>
<li>一般是建立一个网络隧道，多个机房之间互联。</li>
</ul>
<p>在公司的分支机构的局域网和公司总部LAN之间的VPN链接。通过公网Internet建立VPN将公司在各地的分支机构的LAN链接到公司总部的LAN。例如：各大银行之间的资金结算业务。</p>
<p>这是由于各个地域的原因产生的VPN的需求，通过VPN让不同地域的机器可以实现内网互联。例如远程协同办公，机房互联数据同步及业务访问。</p>
<h4 id="互联网各地域机房之间的互联"><a href="#互联网各地域机房之间的互联" class="headerlink" title="互联网各地域机房之间的互联"></a>互联网各地域机房之间的互联</h4><ul>
<li>主要是用于不同机房之间的内网互通。</li>
</ul>
<h4 id="企业外部的VPN服务"><a href="#企业外部的VPN服务" class="headerlink" title="企业外部的VPN服务"></a>企业外部的VPN服务</h4><ul>
<li>主要是提供给合作伙伴共享企业内网数据的VPN服务。</li>
</ul>
<h2 id="常见的隧道协议"><a href="#常见的隧道协议" class="headerlink" title="常见的隧道协议"></a>常见的隧道协议</h2><ul>
<li>这里列举常见的隧道协议</li>
</ul>
<h4 id="PPTP"><a href="#PPTP" class="headerlink" title="PPTP"></a>PPTP</h4><p>点对点协议（PPTP）是由包括微软和3Com等公司组成的PPTP论坛开发的一种点对点隧道协议，基于拨号使用的PPP协议，使用PAP或CHAP之类的加密算法，或者使用Microsoft的点对点加密算法MPPE。其通过跨越基于TCP/IP的数据网络创建VPN实现了从远程客户端到专用企业服务器之间数据的安全传输。PPTP支持通过公共网络建立按需的、多协议的、虚拟专用网络。PPTP允许加密IP通讯，然后在跨域公司IP网络或公共IP网络发送的IP头中对其进行封装。典型的Linux平台的开源软件为PPTP。PPTP属于点对点应用，比较合适远程的企业用户拨号到企业进行办公等应用。</p>
<h4 id="L2TP"><a href="#L2TP" class="headerlink" title="L2TP"></a>L2TP</h4><p>L2TP第2等隧道协议（L2TP）是IETF基于L2F（Cisco的第二层转发协议）开的的PPTP的后续版本。是一种工业标准Internet隧道协议，其可以为跨越面向数据包的媒体发送点到点的协议（PPP）框架提供封装。PPTP和L2TP都使用PPP协议对数据进行封装，然后添加附加爆头用于数据在互联网上传输。PPTP只能在两端点间建立单一隧道。L2TP支持在两端点间使用多隧道，用户可以针对不同的服务质量创建不同隧道。L2TP可以提供隧道验证，而PPTP则不支持隧道验证。但是当L2TP或PPTP与IPSEC共同使用时，可以由IPSEC提供隧道验证，不需要在第二层协议上验证隧道使用L2TP。PPTP要求互联网络为IP网络。L2TP只要求隧道媒介提供面向数据包的点对点的链接，L2TP可以在IP（使用UDP），祯中继续永久虚拟电路（PVCs）,X.25虚拟电路（VCs）或ATM VCS网络上使用。</p>
<h4 id="IPSec"><a href="#IPSec" class="headerlink" title="IPSec"></a>IPSec</h4><p>IP安全协议实际上是一套协议包而不是一个单独的协议。从1995年开始IPSec的研究以来，IETF IPSec工作组在它的主页上发布了几十个Internet草案文献和12个RFC文件。其中比较重要的有RFC2409IKE（互联网秘钥交换）、RFC2401 IPSec协议、RFC2402AH验证包头、RFC2406ESP加密数据等文件。</p>
<p>IPSec隧道模式隧道是封装、路由与解封的整个过程。隧道将原始数据包隐藏（或封装）在新的数据包内部。该新的数据包可能会有新的寻址与路由信息，从而使其能够通过网络传输。隧道与数据保密性结合使用时，在网络上窃听通讯的人将无法获取原始数据包数据（以及原始的源和目标）。封装的数据包到达目的地后，会删除封装，原始数据包头用于将数据包路由到最终目的地。</p>
<p>隧道本身是封装数据经过的逻辑数据路径，对原始的源和目的的端，隧道是不可见的，而只能看到网络路径中的点对点连接。将隧道和数据保密性结合使用时，可用于提供VPN。</p>
<p>封装的数据包在网络中的隧道内部传输。再次示例中，该网络是Internet。网关可以是外部Internet与专用网络之间的周边网关。周界网关可以是路由器、防火墙、代理服务器或其他安全网关。另外，在专用网络内部可以使用两个网关来保护网络中不信任的通讯。</p>
<p>当以隧道模式使用IPSEC时，其只为IP通讯提供封装。使用IPSec隧道模式主要是为了与其他不支持IPSec上的L2TP或PPTP VPN隧道技术的路由器、网关或终端系统之间的相互操作。</p>
<h4 id="SSL-VPN"><a href="#SSL-VPN" class="headerlink" title="SSL VPN"></a>SSL VPN</h4><p>SSL协议提供了数据私密性、端点验证、信息完整性等特性。SSL协议由许多子协议组成，其中两个主要的子协议是握手协议和记录协议。握手协议允许服务器和客户端在应用协议传输第一个数据字节以前，彼此确认，协商一种加密算法和密码钥匙。在数据传输期间，记录协议利用握手协议生成的秘钥加密和解密后来交换的数据。</p>
<p>SSL独立应用，因此任何一个应用程序都可以享受它的安全性而不必理会执行细节。SSL置身于网络结构体系的传输层和应用层之间。此外，SSL本身就被几乎所有的WEB浏览器支持。这意味着客户端不需要为了支持SSL链接安装额外的软件。这两个特征就是SSL能应用于VPN的关键点。</p>
<p>典型的SSL VPN应用：Open VPN，这是一个比较好的开源软件。Open VPN允许参与建立VPN的单点使用预设的私钥，第三方证书，或者用户名/密码来进行身份验证。它大量使用了OpenSSL加密库，以及SSLv3/TLSv1协议。OpenVPN能在Linux、xBSD、MacOS 上运行。它并不是一个基于Web的VPN软件，也不能与IPSec及其他VPN软件包兼容。</p>
<h2 id="常见的VPN软件"><a href="#常见的VPN软件" class="headerlink" title="常见的VPN软件"></a>常见的VPN软件</h2><h4 id="PPTP-VPN"><a href="#PPTP-VPN" class="headerlink" title="PPTP VPN"></a>PPTP VPN</h4><p>使用PPTP VPN的最大优势在于，无需在Windows客户端独立安装客户端软件，Windows默认就知道PPTP VPN拨号连接功能。另外，PPTP VPN属于点对点方式的应用，比较适合远程的企业用户拨号到企业进行办公等应用。</p>
<h4 id="SSL-VPN-1"><a href="#SSL-VPN-1" class="headerlink" title="SSL VPN"></a>SSL VPN</h4><p>PPTP主要为那些经常外出移动办公或家庭办公的用户考虑，而OpenVPN不但使用于PPTP的应用场景，还适合针对企业异地两地总分公司之间的VPN不间断按需链接，例如：OA，及时通讯工具等在企业中的应用。</p>
<h4 id="IPSec-VPN"><a href="#IPSec-VPN" class="headerlink" title="IPSec VPN"></a>IPSec VPN</h4><p>IPSecVPN也适用针对企业异地办公或多个IDC机房之间VPN不间断按需链接，并且在部署使用上更简单方便。</p>
<h1 id="OpenVPN"><a href="#OpenVPN" class="headerlink" title="OpenVPN"></a>OpenVPN</h1><h2 id="OpenVPN介绍"><a href="#OpenVPN介绍" class="headerlink" title="OpenVPN介绍"></a>OpenVPN介绍</h2><p>专用网：专用网就是在两个网络（例如，北京和广州）之间架设一条专用线路，但是它并不需要真正地去铺设光缆之类的物理线路。虽然没有亲自去铺设，但是需要向电信运营商申请租用专线，在这条专用的线路上只传输自己的信息,所以安全稳定,同时也费用高昂</p>
<p>在众多的VPN产品中，OpenVPN无疑是Linux下开源VPN的经典产品，他提供了良好的访问性能和友好的用户GUI。</p>
<p>Open VPN是一个用于创建虚拟专用网络加密通道的软件包，最早由James Yonan编写。一个实现VPN的开源软件，OpenVPN 是一个健壮的、高度灵活的 VPN 守护进程。它支持SSL/TLS 安全、Ethernet bridging、经由代理的 TCP 或 UDP 隧道和 NAT。另外，它也支持动态 IP 地址以及DHCP，可伸缩性足以支持数百或数千用户的使用场景，同时可移植至大多数主流操作系统平台上。</p>
<p>官网：<a href="https://openvpn.net/">https://openvpn.net</a></p>
<p>GitHub地址：<a href="https://github.com/OpenVPN/openvpn">https://github.com/OpenVPN/openvpn</a></p>
<h4 id="OpenVPN依赖的SSL与TLS协议介绍"><a href="#OpenVPN依赖的SSL与TLS协议介绍" class="headerlink" title="OpenVPN依赖的SSL与TLS协议介绍"></a>OpenVPN依赖的SSL与TLS协议介绍</h4><p>众所周知，真正的通信实际上是两台主机之间的进程在交换数据，而运输层作为整个网络最关键的从层次之一，扮演沿着向上层（应用层）提供通信服务的角色。想要剖析运输层的数据安全传输策略就一定无法绕开三个至关重要的协议，它们分别是HTTPS协议、SSL协议、TSL协议。SSL（Secure Sockets Layer）协议既安全套接字层协议，TLS（Transport Layer Security）协议即<code>安全传输层协议</code>。</p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/dasdasdas.jpg"></p>
<h2 id="部署OpenVPN"><a href="#部署OpenVPN" class="headerlink" title="部署OpenVPN"></a>部署OpenVPN</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">OpenVPN 分为客户端和服务端</span><br></pre></td></tr></table></figure>

<h3 id="环境规划"><a href="#环境规划" class="headerlink" title="环境规划"></a>环境规划</h3><table>
<thead>
<tr>
<th>公网IP</th>
<th>内网IP</th>
<th>主机名</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.15.110</td>
<td>172.16.1.0</td>
<td>openvpn</td>
</tr>
</tbody></table>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><h4 id="1、安装OpenVPN和证书工具，准备相关配置文件"><a href="#1、安装OpenVPN和证书工具，准备相关配置文件" class="headerlink" title="1、安装OpenVPN和证书工具，准备相关配置文件"></a>1、安装OpenVPN和证书工具，准备相关配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装openvpn和证书工具</span></span><br><span class="line">[root@m01 ~]<span class="comment"># yum -y install openvpn easy-rsa</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成服务器配置文件</span></span><br><span class="line">[root@m01 ~]<span class="comment"># cp /usr/share/doc/openvpn-2.4.11/sample/sample-config-files/server.conf /etc/openvpn/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备证书签发相关文件</span></span><br><span class="line">[root@m01 ~]<span class="comment"># cp -r /usr/share/easy-rsa/ /etc/openvpn/easy-rsa-server</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备签发证书相关变量的配置文件</span></span><br><span class="line">[root@m01 ~]<span class="comment"># cp /usr/share/doc/easy-rsa-3.0.8/vars.example /etc/openvpn/easy-rsa-server/3/vars</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#建议修改给CA和OpenVPN服务器颁发的证书的有效期,可适当加长（可忽略）</span></span><br><span class="line">[root@m01 ~]<span class="comment"># vim /etc/openvpn/easy-rsa-server/3/vars</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#CA的证书有效期默为为10年,可以适当延长,比如:36500天</span></span><br><span class="line"><span class="comment">#set_var EASYRSA_CA_EXPIRE     3650</span></span><br><span class="line">set_var EASYRSA_CA_EXPIRE      36500</span><br><span class="line"></span><br><span class="line"><span class="comment">#服务器证书默为为825天,可适当加长,比如:3650天</span></span><br><span class="line"><span class="comment">#set_var EASYRSA_CERT_EXPIRE   825 </span></span><br><span class="line"><span class="comment">#将上面行修改为下面</span></span><br><span class="line">set_var EASYRSA_CERT_EXPIRE    3650</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看配置文件目录结构</span></span><br><span class="line">[root@m01 ~]<span class="comment"># tree /etc/openvpn/</span></span><br><span class="line">/etc/openvpn/</span><br><span class="line">├── client</span><br><span class="line">├── easy-rsa-server</span><br><span class="line">│   ├── 3 -&gt; 3.0.8</span><br><span class="line">│   ├── 3.0 -&gt; 3.0.8</span><br><span class="line">│   └── 3.0.8</span><br><span class="line">│       ├── easyrsa</span><br><span class="line">│       ├── openssl-easyrsa.cnf</span><br><span class="line">│       ├── vars</span><br><span class="line">│       └── x509-types</span><br><span class="line">│           ├── ca</span><br><span class="line">│           ├── client</span><br><span class="line">│           ├── code-signing</span><br><span class="line">│           ├── COMMON</span><br><span class="line">│           ├── email</span><br><span class="line">│           ├── kdc</span><br><span class="line">│           ├── server</span><br><span class="line">│           └── serverClient</span><br><span class="line">├── server</span><br><span class="line">└── server.conf</span><br><span class="line"></span><br><span class="line">7 directories, 12 files</span><br></pre></td></tr></table></figure>

<h4 id="2、初始化PKI和CA签发机构环境"><a href="#2、初始化PKI和CA签发机构环境" class="headerlink" title="2、初始化PKI和CA签发机构环境"></a>2、初始化PKI和CA签发机构环境</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化PKI生成PKI相关目录和文件</span></span><br><span class="line">[root@m01 3]<span class="comment"># cd /etc/openvpn/easy-rsa-server/3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化数据,在当前目录下生成pki目录及相关文件</span></span><br><span class="line">[root@m01 3]<span class="comment"># ./easyrsa init-pki</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建CA机构必须在该目录下</span></span><br><span class="line">[root@m01 3]<span class="comment"># pwd</span></span><br><span class="line">/etc/openvpn/easy-rsa-server/3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建CA机构,回车</span></span><br><span class="line">[root@m01 3]<span class="comment"># ./easyrsa build-ca nopass </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证CA证书</span></span><br><span class="line">[root@m01 3]<span class="comment"># openssl x509 -in pki/ca.crt -noout -text</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建服务端证书申请</span></span><br><span class="line">[root@m01 3]<span class="comment"># ./easyrsa gen-req server nopass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 签发证书，输入yes回车</span></span><br><span class="line">[root@m01 3]<span class="comment"># ./easyrsa sign server server</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证证书，删除 BF97ECFB46EFB13E5A684AEF07DE4CD8.pem 该内容按tab键进行验证</span></span><br><span class="line">[root@m01 3]<span class="comment"># diff pki/certs_by_serial/BF97ECFB46EFB13E5A684AEF07DE4CD8.pem  pki/issued/server.crt</span></span><br><span class="line"><span class="comment"># 没有结果则为验证成功</span></span><br></pre></td></tr></table></figure>

<h4 id="3、创建-Diffie-Hellman-密钥"><a href="#3、创建-Diffie-Hellman-密钥" class="headerlink" title="3、创建 Diffie-Hellman 密钥"></a>3、创建 Diffie-Hellman 密钥</h4><p>Diffie-Hellman 密钥交换方法，由惠特菲尔德·迪菲（Bailey Whitfield Diffie）、马丁·赫尔曼（Martin Edward Hellman）于1976年发表。它是一种安全协议，让双方在完全没有对方任何预先信息的条件下通过不安全信道建立起一个密钥，这个密钥一般作为“对称加密”的密钥而被双方在后续数据传输中使用。DH数学原理是base离散对数问题。做类似功能的还有非对称加密类算法，如：RSA。其应用非常广泛，在SSH、VPN、Https等都有应用。</p>
<p>wiki参考链接: <a href="https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange">https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">方式一：</span><br><span class="line"> [root@m01 3]<span class="comment"># ./easyrsa gen-dh</span></span><br><span class="line"> <span class="comment">#查看生成的文件</span></span><br><span class="line"> [root@m01 3]<span class="comment"># ll pki/dh.pem</span></span><br><span class="line"> [root@m01 3]<span class="comment"># cat pki/dh.pem</span></span><br><span class="line"></span><br><span class="line">方式二：</span><br><span class="line"> [root@m01 3]<span class="comment"># openssl dhparam -out /etc/openvpn/dh2048.pem 2048</span></span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><h4 id="1、客户端证书环境"><a href="#1、客户端证书环境" class="headerlink" title="1、客户端证书环境"></a>1、客户端证书环境</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@m01 3]<span class="comment"># cp -r /usr/share/easy-rsa/ /etc/openvpn/easy-rsa-client</span></span><br><span class="line">[root@m01 3]<span class="comment"># cp /usr/share/doc/easy-rsa-3.0.8/vars.example /etc/openvpn/easy-rsa-client/3/vars</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到客户端目录</span></span><br><span class="line">[root@m01 3]<span class="comment"># cd /etc/openvpn/easy-rsa-client/3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化证书目录</span></span><br><span class="line">[root@m01 3]<span class="comment"># ./easyrsa init-pki</span></span><br><span class="line"></span><br><span class="line">[root@m01 3]<span class="comment"># pwd</span></span><br><span class="line">/etc/openvpn/easy-rsa-client/3</span><br><span class="line">[root@m01 3]<span class="comment"># ls</span></span><br><span class="line">easyrsa  openssl-easyrsa.cnf  varsa  x509-types</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成客户端证书，回车</span></span><br><span class="line">[root@m01 3]<span class="comment"># ./easyrsa gen-req gengfeng nopass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将客户端证书请求文件复制到CA的工作目录</span></span><br><span class="line">[root@m01 3]<span class="comment"># cd /etc/openvpn/easy-rsa-server/3</span></span><br><span class="line">[root@m01 3]<span class="comment"># ./easyrsa import-req /etc/openvpn/easy-rsa-client/3/pki/reqs/gengfeng.req gengfeng</span></span><br><span class="line"><span class="comment"># 签发客户端证书，yes</span></span><br><span class="line">[root@m01 3]<span class="comment"># pwd</span></span><br><span class="line"> /etc/openvpn/easy-rsa-server/3</span><br><span class="line">[root@m01 3]<span class="comment"># ./easyrsa sign client gengfeng </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 验证，对比一下</span></span><br><span class="line">[root@m01 3]<span class="comment"># cat pki/index.txt</span></span><br><span class="line"> V 240401022739Z  ADBFFB9F45E5CEF861E7F642BA6C447E  unknown /CN=server</span><br><span class="line"> V 240401023724Z  47765AD8225E12A13FB1EEBAC769B999  unknown /CN=gengfeng</span><br><span class="line"><span class="comment"># 查看是否和上面一致</span></span><br><span class="line">[root@m01 3]<span class="comment"># ll pki/certs_by_serial/</span></span><br><span class="line">total 16</span><br><span class="line"> -rw------- 1 root root 4438 Dec 28 10:37 47765AD8225E12A13FB1EEBAC769B999.pem</span><br><span class="line"> -rw------- 1 root root 4552 Dec 28 10:27 ADBFFB9F45E5CEF861E7F642BA6C447E.pem</span><br></pre></td></tr></table></figure>

<h4 id="2、创建链接配置文件"><a href="#2、创建链接配置文件" class="headerlink" title="2、创建链接配置文件"></a>2、创建链接配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、修改openvpn配置文件</span><br><span class="line">[root@m01 3]<span class="comment"># &gt;/etc/openvpn/server.conf  #清空文件</span></span><br><span class="line">[root@m01 3]<span class="comment"># vim /etc/openvpn/server.conf</span></span><br><span class="line"></span><br><span class="line">cat &gt; /etc/openvpn/server.conf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">port 1194</span></span><br><span class="line"><span class="string">proto tcp</span></span><br><span class="line"><span class="string">dev tun</span></span><br><span class="line"><span class="string">ca  /etc/openvpn/certs/ca.crt</span></span><br><span class="line"><span class="string">cert  /etc/openvpn/certs/server.crt</span></span><br><span class="line"><span class="string">key  /etc/openvpn/certs/server.key</span></span><br><span class="line"><span class="string">dh  /etc/openvpn/certs/dh.pem</span></span><br><span class="line"><span class="string">server 10.8.0.0 255.255.255.0</span></span><br><span class="line"><span class="string">push &quot;route 172.16.1.0 255.255.255.0&quot;  #必须更改为自己的网卡地址</span></span><br><span class="line"><span class="string">keepalive 10 120</span></span><br><span class="line"><span class="string">cipher AES-256-CBC</span></span><br><span class="line"><span class="string">compress lz4-v2</span></span><br><span class="line"><span class="string">push &quot;compress lz4-v2&quot;</span></span><br><span class="line"><span class="string">max-clients 2048</span></span><br><span class="line"><span class="string">user openvpn</span></span><br><span class="line"><span class="string">group openvpn</span></span><br><span class="line"><span class="string">status  /var/log/openvpn/openvpn-status.log</span></span><br><span class="line"><span class="string">log-append   /var/log/openvpn/openvpn.log</span></span><br><span class="line"><span class="string">verb 3</span></span><br><span class="line"><span class="string">mute 20</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建日志文件目录</span></span><br><span class="line">[root@m01 3]<span class="comment"># mkdir -p /var/log/openvpn</span></span><br><span class="line"><span class="comment"># 创建权限</span></span><br><span class="line">[root@m01 ~]<span class="comment"># chown openvpn.openvpn /var/log/openvpn</span></span><br><span class="line"><span class="comment"># 创建存放证书目录</span></span><br><span class="line">[root@m01 ~]<span class="comment"># mkdir -p /etc/openvpn/certs</span></span><br><span class="line"><span class="comment"># 复制证书</span></span><br><span class="line">[root@m01 ~]<span class="comment"># cp /etc/openvpn/easy-rsa-server/3/pki/dh.pem /etc/openvpn/certs/</span></span><br><span class="line">[root@m01 ~]<span class="comment"># cp /etc/openvpn/easy-rsa-server/3/pki/ca.crt /etc/openvpn/certs/</span></span><br><span class="line">[root@m01 ~]<span class="comment"># cp /etc/openvpn/easy-rsa-server/3/pki/private/server.key /etc/openvpn/certs/</span></span><br><span class="line">[root@m01 ~]<span class="comment"># cp /etc/openvpn/easy-rsa-server/3/pki/issued/server.crt /etc/openvpn/certs/</span></span><br><span class="line">[root@m01 ~]<span class="comment"># ll /etc/openvpn/certs/</span></span><br><span class="line">total 20</span><br><span class="line"> -rw------- 1 root root 1172 Dec 28 10:54 ca.crt</span><br><span class="line"> -rw------- 1 root root  424 Dec 28 10:54 dh.pem</span><br><span class="line"> -rw------- 1 root root 4552 Dec 28 10:54 server.crt</span><br><span class="line"> -rw------- 1 root root 1704 Dec 28 10:54 server.key</span><br><span class="line"></span><br><span class="line">2、启动OpenVPN</span><br><span class="line"><span class="comment"># 开启系统内核网络转发功能(该功能默认为关闭状态)</span></span><br><span class="line">[root@m01 ~]<span class="comment"># echo net.ipv4.ip_forward = 1 &gt;&gt; /etc/sysctl.conf</span></span><br><span class="line">[root@m01 ~]<span class="comment"># sysctl -p</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装防火墙</span></span><br><span class="line">[root@m01 ~]<span class="comment"># yum install iptables-services -y</span></span><br><span class="line">[root@m01 ~]<span class="comment"># systemctl disable --now firewalld</span></span><br><span class="line">[root@m01 ~]<span class="comment"># systemctl start iptables</span></span><br><span class="line">[root@m01 ~]<span class="comment"># iptables -F</span></span><br><span class="line">[root@m01 ~]<span class="comment"># iptables -F -t nat</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加iptables规则</span></span><br><span class="line">[root@m01 ~]<span class="comment"># iptables -t nat -A POSTROUTING -s 10.8.0.0/24 -j MASQUERADE</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 永久保存Iptables规则</span></span><br><span class="line">[root@m01 ~]<span class="comment"># service iptables save</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动OpenVPN</span></span><br><span class="line">[root@m01 ~]<span class="comment"># systemctl enable --now openvpn@server</span></span><br><span class="line"></span><br><span class="line">3、创建链接文件</span><br><span class="line"></span><br><span class="line">[root@m01 ~]<span class="comment"># mkdir -p /etc/openvpn/client/gengfeng/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备证书</span></span><br><span class="line">[root@m01 gengfeng]<span class="comment"># cp /etc/openvpn/easy-rsa-server/3/pki/ca.crt /etc/openvpn/client/gengfeng/</span></span><br><span class="line">[root@m01 gengfeng]<span class="comment"># cp /etc/openvpn/easy-rsa-server/3/pki/issued/gengfeng.crt /etc/openvpn/client/gengfeng/</span></span><br><span class="line">[root@m01 gengfeng]<span class="comment"># cp /etc/openvpn/easy-rsa-client/3/pki/private/gengfeng.key /etc/openvpn/client/gengfeng/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备链接文件</span></span><br><span class="line">[root@m01 ~]<span class="comment"># vim /etc/openvpn/client/gengfeng/client.ovpn </span></span><br><span class="line">client</span><br><span class="line">dev tun</span><br><span class="line">proto tcp</span><br><span class="line">remote 192.168.15.110 1194</span><br><span class="line">resolv-retry infinite</span><br><span class="line">nobind</span><br><span class="line">ca ca.crt</span><br><span class="line">cert gengfeng.crt</span><br><span class="line">key gengfeng.key</span><br><span class="line">remote-cert-tls server</span><br><span class="line">cipher AES-256-CBC</span><br><span class="line">verb 3</span><br><span class="line">compress lz4-v2</span><br></pre></td></tr></table></figure>

<h2 id="服务器端配置文件说明"><a href="#服务器端配置文件说明" class="headerlink" title="服务器端配置文件说明"></a>服务器端配置文件说明</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#server.conf文件中以#或;开头的行都为注释</span></span><br><span class="line">[root@instance-gvpb80ao ~]<span class="comment"># grep -Ev &quot;^#|^$&quot; /etc/openvpn/server.conf</span></span><br><span class="line">;<span class="built_in">local</span> a.b.c.d  <span class="comment">#本机监听IP,默认为本机所有IP</span></span><br><span class="line">port 1194   <span class="comment">#端口</span></span><br><span class="line">;proto tcp  <span class="comment">#协议,生产推荐使用TCP</span></span><br><span class="line">proto udp <span class="comment">#默认协议</span></span><br><span class="line">;dev tap  <span class="comment">#创建一个以太网隧道，以太网使用tap,一个tap设备允许完整的以太网帧通过Openvpn隧道，可提供非ip协议的支持，比如IPX协议和AppleTalk协议,tap等同于一个以太网设备，它操作第二层数据包如以太网数据帧。</span></span><br><span class="line">dev tun  <span class="comment">#创建一个路由IP隧道，生产推存使用tun.互联网使用tun,一个tun设备大多时候，被用于基于IP协议的通讯。tun模拟了网络层设备，操作第三层数据包比如IP数据封包。</span></span><br><span class="line">;dev-node MyTap  <span class="comment">#TAP-Win32适配器。非windows不需要配置</span></span><br><span class="line">ca ca.crt   <span class="comment">#ca证书文件</span></span><br><span class="line">cert server.crt  <span class="comment">#服务器证书文件</span></span><br><span class="line">key server.key  <span class="comment">#服务器私钥文件</span></span><br><span class="line">dh dh2048.pem   <span class="comment">#dh参数文件</span></span><br><span class="line">;topology subnet</span><br><span class="line">server 10.8.0.0 255.255.255.0 <span class="comment">#客户端连接后分配IP的地址池，服务器默认会占用第一个IP 10.8.0.1将做为客户端的网关</span></span><br><span class="line">ifconfig-pool-persist ipp.txt <span class="comment">#为客户端分配固定IP，不需要配置,建议注释</span></span><br><span class="line">;server-bridge 10.8.0.4 255.255.255.0 10.8.0.50 10.8.0.100 <span class="comment">#配置网桥模式，不需要配置,建议注释</span></span><br><span class="line">;server-bridge</span><br><span class="line">;push <span class="string">&quot;route 192.168.10.0 255.255.255.0&quot;</span> <span class="comment">#给客户端生成的到达服务器后面网段的静态路由，下一跳为openvpn服务器的10.8.0.1</span></span><br><span class="line">;push <span class="string">&quot;route 192.168.20.0 255.255.255.0&quot;</span> <span class="comment">#推送路由信息到客户端，以允许客户端能够连接到服务器背后的其它私有子网</span></span><br><span class="line">;client-config-dir ccd <span class="comment">#为指定的客户端添加路由，此路由通常是客户端后面的内网网段而不是服务端的，也不需要设置</span></span><br><span class="line">;route 192.168.40.128 255.255.255.248 </span><br><span class="line">;client-config-dir ccd </span><br><span class="line">;route 10.9.0.0 255.255.255.252</span><br><span class="line">;learn-address ./script   <span class="comment">#运行外部脚本，创建不同组的iptables规则，无需配置</span></span><br><span class="line">;push <span class="string">&quot;redirect-gateway def1 bypass-dhcp&quot;</span> <span class="comment">#启用后，客户端所有流量都将通过VPN服务器，因此生产一般无需配置此项</span></span><br><span class="line">;push <span class="string">&quot;dhcp-option DNS 208.67.222.222&quot;</span> <span class="comment">#推送DNS服务器，不需要配置</span></span><br><span class="line">;push <span class="string">&quot;dhcp-option DNS 208.67.220.220&quot;</span></span><br><span class="line">;client-to-client  <span class="comment">#允许不同的client直接通信,不安全,生产环境一般无需要配置</span></span><br><span class="line">;duplicate-cn     <span class="comment">#多个用户共用一个证书，一般用于测试环境，生产环境都是一个用户一个证书,无需开启</span></span><br><span class="line">keepalive 10 120  <span class="comment">#设置服务端检测的间隔和超时时间，默认为每10秒ping一次，如果 120 秒没有回应则认为对方已经down</span></span><br><span class="line">tls-auth ta.key 0 <span class="comment">#访止DoS等攻击的安全增强配置,可以使用以下命令来生成：openvpn --</span></span><br><span class="line">genkey --secret ta.key <span class="comment">#服务器和每个客户端都需要拥有该密钥的一个拷贝。第二个参数在服务器端应该为’0’，在客户端应该为’1’</span></span><br><span class="line">cipher AES-256-CBC <span class="comment">#加密算法</span></span><br><span class="line">;compress lz4-v2  <span class="comment">#启用Openvpn2.4.X新版压缩算法</span></span><br><span class="line">;push <span class="string">&quot;compress lz4-v2&quot;</span> <span class="comment">#推送客户端使用新版压缩算法,和下面的comp-lzo不要同时使用</span></span><br><span class="line">;comp-lzo  <span class="comment">#旧户端兼容的压缩配置，需要客户端配置开启压缩,openvpn2.4.X等新版可以不用开启</span></span><br><span class="line">;max-clients 100  <span class="comment">#最大客户端数</span></span><br><span class="line">;user nobody  <span class="comment">#运行openvpn服务的用户和组</span></span><br><span class="line">;group nobody</span><br><span class="line">persist-key  <span class="comment">#重启VPN服务时默认会重新读取key文件，开启此配置后保留使用第一次的key文件,生产环境无需开启</span></span><br><span class="line">persist-tun  <span class="comment">#启用此配置后,当重启vpn服务时，一直保持tun或者tap设备是up的，否则会先down然后再up,生产环境无需开启</span></span><br><span class="line">status openvpn-status.log <span class="comment">#openVPN状态记录文件，每分钟会记录一次</span></span><br><span class="line">;<span class="built_in">log</span>  openvpn.log  <span class="comment">#第一种日志记录方式,并指定日志路径，log会在openvpn启动的时候清空日志文件,不建议使用</span></span><br><span class="line">;log-append openvpn.log <span class="comment">#第二种日志记录方式,并指定日志路径，重启openvpn后在之前的日志后面追加新的日志,生产环境建议使用</span></span><br><span class="line">verb 3   <span class="comment">#设置日志级别，0-9，级别越高记录的内容越详细,0 表示静默运行，只记录致命错误,4 表示合理的常规用法,5 和 6 可以帮助调试连接错误。9 表示极度冗余，输出非常详细的日志信息</span></span><br><span class="line">;mute 20  <span class="comment">#相同类别的信息只有前20条会输出到日志文件中</span></span><br><span class="line">explicit-exit-notify 1  <span class="comment">#通知客户端，在服务端重启后自动重新连接，仅能用于udp模式，tcp模式不需要配置即可实现断开重新连接,且开启此项后tcp配置后将导致openvpn服务无法启动,所以tcp时必须不能开启此项</span></span><br></pre></td></tr></table></figure>

<h2 id="mac连接OpenVPN"><a href="#mac连接OpenVPN" class="headerlink" title="mac连接OpenVPN"></a>mac连接OpenVPN</h2><p>安装OpenVPN软件包</p>
<p>Windows下载：OpenVPN <a href="https://openvpn.net/">https://openvpn.net</a></p>
<p>Mac下载：Tunnelblick <a href="https://tunnelblick.en.softonic.com/mac">https://tunnelblick.en.softonic.com/mac</a></p>
<p>打开FinalShell找到/etc/openvpn/client/目标文件夹</p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/image-20211230150939829.png" alt="image-20211230150939829"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/image-20211230151130162.png" alt="image-20211230151130162"></p>
<p>必须将文件夹重新命名，以.tblk结尾，文件名字必须和之前的配置一样</p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/image-20211230151403052.png" alt="image-20211230151403052"></p>
<p>最后打开Tunnelblick连接即可</p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/image-20211230151730831.png" alt="image-20211230151730831"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/image-20211230151600943.png" alt="image-20211230151600943"></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux磁盘挂载分区</title>
    <url>/f9ef965d.html</url>
    <content><![CDATA[<h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Linux系统中磁盘管理就是将硬盘通过挂载的方式挂载到linux文件系统中。</span><br><span class="line"></span><br><span class="line">1、挂载磁盘的步骤</span><br><span class="line">	1、磁盘分区</span><br><span class="line">	2、挂载</span><br><span class="line"></span><br><span class="line">2、磁盘分区</span><br><span class="line">	fdisk：分区2TB以下的磁盘，最多可以分4个分区</span><br><span class="line">	gdisk：分区2TB以上的磁盘，最多可以分128个分区</span><br><span class="line"></span><br><span class="line">3、添加一块磁盘</span><br><span class="line">	lsblk   ： 查看本机的磁盘</span><br><span class="line">	df -h   :  查看本机的分区</span><br><span class="line"></span><br><span class="line">4、磁盘分区</span><br><span class="line">	n : 新建分区</span><br><span class="line">	p : 打印分区表</span><br><span class="line">	w : 写入磁盘保存并退出</span><br><span class="line">	q : 不保存退出</span><br><span class="line">	d : 删除分区</span><br><span class="line">	</span><br><span class="line">5、挂载磁盘分区</span><br><span class="line">	1、格式化文件系统</span><br><span class="line">		mkfs.xfs /dev/sdb1 </span><br><span class="line"></span><br><span class="line">6、总结</span><br><span class="line">	1、关机</span><br><span class="line">	2、添加硬盘</span><br><span class="line">	3、创建分区</span><br><span class="line">		fdisk /dev/sdb</span><br><span class="line">		或</span><br><span class="line">		gdisk /dev/sdb</span><br><span class="line">	4、格式化文件系统</span><br><span class="line">		mkfs.xfs /dev/sdb1 </span><br><span class="line">	5、挂载</span><br><span class="line">		mount /dev/sdb1 /mnt</span><br></pre></td></tr></table></figure>

<h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><ul>
<li>逻辑分区属于扩展分区，扩展分区属于主分区</li>
<li>主分区又叫做引导分区，是可以安装系统的分区</li>
</ul>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/mbr.jpeg" alt="mbr"></p>
<p>目前常见的磁盘分区格式有两种，MBR分区和GPT分区：</p>
<ul>
<li>MBR 分区，MBR 的意思是 “主引导记录”。MBR 最大支持 2TB 容量，在容量方面存在着极大的瓶颈。</li>
<li>GPT 分区，GPT 意为 GUID 分区表，它支持的磁盘容量比 MBR 大得多。这是一个正逐渐取代 MBR 的新标准，它是由 UEFI 辅住而形成的，将来 UEFI 用于取代老旧的 BIOS，而 GPT 则取代老旧的 MBR。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 磁盘分区工具</span></span><br><span class="line"></span><br><span class="line">fdisk 工具用于 MBR 格式</span><br><span class="line">gdisk 工具用于 GPT 格式</span><br></pre></td></tr></table></figure>

<h3 id="磁盘基本分区fdisk"><a href="#磁盘基本分区fdisk" class="headerlink" title="磁盘基本分区fdisk"></a>磁盘基本分区fdisk</h3><p><strong>1.添加一块小于2TB的磁盘进行使用，步骤如下:</strong></p>
<ul>
<li><p>1.给虚拟机添加一块新的硬盘</p>
</li>
<li><p>2.使用fdisk进行分区</p>
</li>
<li><p>3.使用mkfs进行格式化</p>
</li>
<li><p>4.使用mount进行挂载</p>
<p>PS: 生产分区建议，如无特殊需求直接使用整个磁盘即可，无需分区。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># fdisk -l</span></span><br><span class="line">[root@localhost ~]<span class="comment"># fdisk  /dev/sdb</span></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): m         <span class="comment">#输入m列出常用的命令</span></span><br><span class="line">Command action</span><br><span class="line">   a   toggle a bootable flag               <span class="comment">#切换分区启动标记</span></span><br><span class="line">   b   edit bsd disklabel                   <span class="comment">#编辑sdb磁盘标签</span></span><br><span class="line">   c   toggle the dos compatibility flag    <span class="comment">#切换dos兼容模式</span></span><br><span class="line">   d   delete a partition                   <span class="comment">#删除分区</span></span><br><span class="line">   l   list known partition types           <span class="comment">#显示分区类型</span></span><br><span class="line">   m   <span class="built_in">print</span> this menu                      <span class="comment">#显示帮助菜单</span></span><br><span class="line">   n   add a new partition                  <span class="comment">#新建分区</span></span><br><span class="line">   o   create a new empty DOS partition table   <span class="comment">#创建新的空白分区表</span></span><br><span class="line">   p   <span class="built_in">print</span> the partition table            <span class="comment">#显示分区表的信息</span></span><br><span class="line">   q   quit without saving changes          <span class="comment">#不保存退出</span></span><br><span class="line">   s   create a new empty Sun disklabel     <span class="comment">#创建新的Sun磁盘标签</span></span><br><span class="line">   t   change a partitions system id        <span class="comment">#修改分区ID,可以通过l查看id</span></span><br><span class="line">   u   change display/entry units           <span class="comment">#修改容量单位,磁柱或扇区</span></span><br><span class="line">   v   verify the partition table           <span class="comment">#检验分区表</span></span><br><span class="line">   w   write table to disk and <span class="built_in">exit</span>         <span class="comment">#保存退出</span></span><br><span class="line">   x   extra functionality (experts only)   <span class="comment">#拓展功能</span></span><br></pre></td></tr></table></figure>

<p>1). fdisk创建主分区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n</span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)  <span class="comment">#主分区</span></span><br><span class="line">   e   extended  <span class="comment">#扩展分区</span></span><br><span class="line">Select (default p): p   <span class="comment">#选择创建主分区</span></span><br><span class="line">Partition number (1-4, default 1):  <span class="comment">#默认创建第一个主分区</span></span><br><span class="line">First sector (2048-2097151, default 2048): <span class="comment">#默认扇区回车</span></span><br><span class="line">Using default value 2048</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (2048-2097151, default 2097151): +50M <span class="comment">#分配50MB</span></span><br></pre></td></tr></table></figure>

<p>2). fdisk创建扩展分区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n  <span class="comment">#新建分区</span></span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (1 primary, 0 extended, 3 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): e   <span class="comment">#创建扩展分区</span></span><br><span class="line">Partition number (2-4, default 2):</span><br><span class="line">First sector (104448-2097151, default 104448):</span><br><span class="line">Using default value 104448</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (104448-2097151, default 2097151): <span class="comment">#空间都给到扩展分区</span></span><br></pre></td></tr></table></figure>

<p>3). fdisk创建逻辑分区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): n  <span class="comment">#新建分区</span></span><br><span class="line">Partition <span class="built_in">type</span>:</span><br><span class="line">   p   primary (1 primary, 1 extended, 2 free)</span><br><span class="line">   l   logical (numbered from 5)</span><br><span class="line">Select (default p): l   <span class="comment">#创建逻辑分区</span></span><br><span class="line">Adding logical partition 5</span><br><span class="line">First sector (106496-2097151, default 106496):</span><br><span class="line">Using default value 106496</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (106496-2097151, default 2097151): +100M  <span class="comment">#分配100MB空间</span></span><br></pre></td></tr></table></figure>

<p>4). fdisk查看分区情况，并保存</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): p <span class="comment">#查看分区创建</span></span><br><span class="line">Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sdb1            2048      104447       51200   83  Linux</span><br><span class="line">/dev/sdb2          104448     2097151      996352    5  Extended</span><br><span class="line">/dev/sdb5          106496      311295      102400   83  Linux</span><br><span class="line"></span><br><span class="line"><span class="comment">#保存分区</span></span><br><span class="line">Command (m <span class="keyword">for</span> <span class="built_in">help</span>): w</span><br><span class="line">The partition table has been altered!</span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line">Syncing disks.</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查磁盘是否是MBR分区方式</span></span><br><span class="line">[root@localhost ~]<span class="comment"># fdisk /dev/sdb -l|grep type</span></span><br><span class="line">Disk label <span class="built_in">type</span>: dos</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装parted, 刷新内核立即生效,无需重启</span></span><br><span class="line">[root@localhost ~]<span class="comment"># yum -y install parted</span></span><br><span class="line">[root@localhost ~]<span class="comment"># partprobe /dev/sdb</span></span><br></pre></td></tr></table></figure>

<p><strong>2.格式化磁盘</strong></p>
<ul>
<li>mkfs格式化磁盘，实质创建文件系统，文件系统类似于将房子装修成3室一厅，还是2室一厅。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项: </span></span><br><span class="line"><span class="comment"># -b  设定数据区块占用空间大小，目前支持1024、2048、4096 bytes每个块。</span></span><br><span class="line"><span class="comment"># -t  用来指定什么类型的文件系统，可以是ext4, xfs</span></span><br><span class="line"><span class="comment"># -i  设定inode的大小</span></span><br><span class="line"><span class="comment"># -N  设定inode数量，防止Inode数量不够导致磁盘不足</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.格式化整个磁盘</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mkfs.ext4  /dev/sdb </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.格式化磁盘的某个分区</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mkfs.xfs  /dev/sdb1</span></span><br></pre></td></tr></table></figure>

<p><strong>3.使用mount挂载并使用</strong></p>
<ul>
<li>如果需要使用该磁盘的空间，需要准备一个空的目录作为挂载点，与该设备进行关联。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir /data</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mount /dev/sdb1 /data</span></span><br></pre></td></tr></table></figure>



<h3 id="磁盘的基本分区Gdisk"><a href="#磁盘的基本分区Gdisk" class="headerlink" title="磁盘的基本分区Gdisk"></a>磁盘的基本分区Gdisk</h3><p>前面我们已经了解到fdisk分区，但fdisk不支持给高于2TB的磁盘进行分区。如果有单块盘高于2TB，建议使用Gdisk进行分区。</p>
<p><strong>1.使用gdisk进行磁盘分区</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.安装gdisk分区工具</span></span><br><span class="line">[root@localhost ~]<span class="comment"># yum install gdisk -y</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.创建一个新分区，500MB大小</span></span><br><span class="line">[root@localhost ~]<span class="comment"># gdisk /dev/sdb</span></span><br><span class="line">Command (? <span class="keyword">for</span> <span class="built_in">help</span>): n     <span class="comment">#创建新分区</span></span><br><span class="line">Partition number (1-128, default 1):</span><br><span class="line">First sector (34-2097118, default = 2048) or &#123;+-&#125;size&#123;KMGTP&#125;:</span><br><span class="line">Last sector (2048-2097118, default = 2097118) or &#123;+-&#125;size&#123;KMGTP&#125;: +500M <span class="comment">#分配500M大小</span></span><br><span class="line"></span><br><span class="line">Command (? <span class="keyword">for</span> <span class="built_in">help</span>): p <span class="comment">#打印查看</span></span><br><span class="line">Number  Start (sector)    End (sector)  Size       Code  Name</span><br><span class="line">   1            2048         1026047   500.0 MiB   8300  Linux filesystem</span><br><span class="line"></span><br><span class="line">Command (? <span class="keyword">for</span> <span class="built_in">help</span>): w <span class="comment">#保存分区</span></span><br><span class="line">Do you want to proceed? (Y/N): y    <span class="comment">#确认</span></span><br><span class="line">OK; writing new GUID partition table (GPT) to /dev/sdb.</span><br><span class="line">The operation has completed successfully.</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.创建完成后，可以尝试检查磁盘是否为gpt格式</span></span><br><span class="line">[root@localhost-node1 /]<span class="comment"># fdisk /dev/sdb -l|grep type</span></span><br><span class="line">Disk label <span class="built_in">type</span>: gpt</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.安装parted, 刷新内核立即生效,无需重启</span></span><br><span class="line">[root@localhost ~]<span class="comment"># yum -y install parted</span></span><br><span class="line">[root@localhost ~]<span class="comment"># partprobe /dev/sdb</span></span><br></pre></td></tr></table></figure>

<p><strong>2.使用mkfs进行格式化磁盘。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkfs.xfs  /dev/sdb</span></span><br></pre></td></tr></table></figure>

<p><strong>3.使用mount命令将某个目录挂载该分区，进行使用。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># mkdir /data_gdisk</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mount /dev/sdb /data_gdisk</span></span><br></pre></td></tr></table></figure>

<h2 id="磁盘挂载"><a href="#磁盘挂载" class="headerlink" title="磁盘挂载"></a>磁盘挂载</h2><p>前面我们已经提到过，如果需要使用磁盘的空间，需要准备一个空的目录作为挂载点，与该设备进行关联。mount主要是为文件系统指定一个访问入口。</p>
<p><strong>1.通过mount进行挂载，但重启将会失效。我们称为临时生效。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 选项：-t指定文件系统挂载分区 -a 挂载/etc/fstab中的配置文件 -o 指定挂载参数</span></span><br><span class="line"><span class="comment"># 挂载/dev/sdb1至db1目录</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># mkdir /db1</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># mount -t xfs /dev/sdb1  /db1/ </span></span><br><span class="line"></span><br><span class="line">ps：centos7选择xfs格式作为默认文件系统，而且不再使用以前的ext，仍然支持ext4，</span><br><span class="line">xfs专为大数据产生，每个单个文件系统最大可以支持8eb，单个文件可以支持16tb，不仅数据量大，</span><br><span class="line">而且扩展性高。还可以通过xfsdump，xfsrestore来备份和恢复。</span><br></pre></td></tr></table></figure>

<p><strong>2.挂载的磁盘，如果不想使用可以使用umount进行卸载。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#选项： -l 强制卸载</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#1.卸载目录方式</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># umount /db1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.卸载设备方式</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># umount /dev/sdb1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.umount不能卸载的情况</span></span><br><span class="line"> [root@localhost db1]<span class="comment"># umount /db1  </span></span><br><span class="line">  umount: /db1: device is busy.</span><br><span class="line">          (In some cases useful info about processes that use</span><br><span class="line">          the device is found by lsof(8) or fuser(1)</span><br><span class="line"></span><br><span class="line"><span class="comment">#PS: 如上情况解决办法有两种, 1.切换至其他目录 2.使用&#x27;-l&#x27;选项强制卸载    </span></span><br><span class="line"> [root@student db1]<span class="comment"># umount -l /db1</span></span><br></pre></td></tr></table></figure>

<p><strong>3.如果需要实现永久挂载则需要将挂载信息写入/etc/fstab配置文件中实现。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.使用blkid命令获取各设备的UUID</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># blkid |grep &quot;sdb1&quot;</span></span><br><span class="line">  /dev/sdb1: UUID=<span class="string">&quot;e271b5b2-b1ba-4b18-bde5-66e394fb02d9&quot;</span> TYPE=<span class="string">&quot;xfs&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.使用UUID挂载磁盘sdb1分区至于db1， 测试挂载</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># mount UUID=&quot;e271b5b2-b1ba-4b18-bde5-66e394fb02d9&quot; /db1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.写入/etc/fstab中，实现开机自动挂载</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># tail -1 /etc/fstab    </span></span><br><span class="line">  UUID=e271b5b2-b1ba-4b18-bde5-66e394fb02d9 /db1 xfs  defaults 0  0</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.加载fstab配置文件, 同时检测语法是否有错误</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># mount –a</span></span><br></pre></td></tr></table></figure>

<p><strong>4./etc/fstab配置文件编写格式</strong></p>
<table>
<thead>
<tr>
<th align="left">要挂载的设备</th>
<th align="left">挂载点(入口)</th>
<th align="left">文件系统类型</th>
<th align="left">挂载参数</th>
<th align="left">是否备份</th>
<th align="left">是否检查</th>
</tr>
</thead>
<tbody><tr>
<td align="left">/dev/sdb1</td>
<td align="left">/db1</td>
<td align="left">xfs</td>
<td align="left">defaults</td>
<td align="left">0</td>
<td align="left">0</td>
</tr>
</tbody></table>
<p>第四列：挂载参数</p>
<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">async/sync</td>
<td align="left">是否为同步方式运行。默认async</td>
</tr>
<tr>
<td align="left">user/nouser</td>
<td align="left">是否允许普通用户使用mount命令挂载。默认nouser</td>
</tr>
<tr>
<td align="left">exec/noexe</td>
<td align="left">是否允许可执行文件执行。默认exec</td>
</tr>
<tr>
<td align="left">suid/nosuid</td>
<td align="left">是否允许存在suid属性的文件。默认suid</td>
</tr>
<tr>
<td align="left">auto/noauto</td>
<td align="left">执行mount -a 命令时，此文件系统是否被主动挂载。默认auto</td>
</tr>
<tr>
<td align="left">rw/ro</td>
<td align="left">是否以只读或者读写模式进行挂载。默认rw</td>
</tr>
<tr>
<td align="left">default</td>
<td align="left">具有rw,suid,dev,exec,auto,nouser,async等默认参数的设定</td>
</tr>
</tbody></table>
<p>第五列：是否进行备份。参数的值为0或者1</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">代表不做备份</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">代表要每天进行备份操作</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">代表不定日期的进行备份操作</td>
</tr>
</tbody></table>
<p>第六列：是否检验扇区：开机的过程中，系统默认会以fsck检验我们系统是否为完整</p>
<table>
<thead>
<tr>
<th align="left">选项</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">不要检验磁盘是否有坏道</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">检验</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">校验 (当1级别检验完成之后进行2级别检验)</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL优化</title>
    <url>/2c9a5c07.html</url>
    <content><![CDATA[<h3 id="优化风险"><a href="#优化风险" class="headerlink" title="优化风险"></a>优化风险</h3><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">优化不总是对一个单纯的环境进行！还很可能是一个复杂的已投产的系统。</span><br><span class="line">优化手段本来就有很大的风险，只不过你没能力意识到和预见到！</span><br><span class="line">任何的技术可以解决一个问题，但必然存在带来一个问题的风险！</span><br><span class="line">对于优化来说解决问题而带来的问题控制在可接受的范围内才是有成果。</span><br><span class="line">保持现状或出现更差的情况都是失败！</span><br><span class="line"></span><br><span class="line">稳定性和业务可持续性通常比性能更重要！</span><br><span class="line">优化不可避免涉及到变更，变更就有风险！</span><br><span class="line">优化使性能变好，维持和变差是等概率事件！</span><br><span class="line">优化不能只是数据库管理员担当风险，但会所有的人分享优化成果！</span><br><span class="line">所以优化工作是由业务需要驱使的！！！</span><br><span class="line"></span><br><span class="line">不应该一个人独自参与优化，风险要和参与人员一起承担</span><br></pre></td></tr></table></figure>

<h3 id="优化方向"><a href="#优化方向" class="headerlink" title="优化方向"></a>优化方向</h3> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">安全优化（业务持续性）</span><br><span class="line">性能优化（业务高效性）</span><br></pre></td></tr></table></figure>

<h3 id="优化范围和思路"><a href="#优化范围和思路" class="headerlink" title="优化范围和思路"></a>优化范围和思路</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存储、主机和操作系统:</span><br><span class="line">    主机架构稳定性</span><br><span class="line">    I/O规划及配置</span><br><span class="line">    Swap</span><br><span class="line">    OS内核参数</span><br><span class="line">        网络问题</span><br><span class="line">        </span><br><span class="line">应用程序:（Index，lock，session）</span><br><span class="line">        应用程序稳定性和性能</span><br><span class="line">        SQL语句性能</span><br><span class="line">    串行访问资源</span><br><span class="line">    性能欠佳会话管理</span><br><span class="line">    </span><br><span class="line">数据库优化:（内存、数据库设计、参数）</span><br><span class="line">    内存</span><br><span class="line">    数据库结构(物理&amp;逻辑)</span><br><span class="line">    实例配置</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/KqOaeJ.jpg" alt="KqOaeJ"></p>
<h3 id="数据库优化工具"><a href="#数据库优化工具" class="headerlink" title="数据库优化工具"></a>数据库优化工具</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show status  </span><br><span class="line">show variables </span><br><span class="line">show index  </span><br><span class="line">show processlist </span><br><span class="line">show slave status</span><br><span class="line">show engine innodb status </span><br><span class="line">desc/explain </span><br><span class="line">     slowlog</span><br><span class="line"></span><br><span class="line">扩展类深度优化:</span><br><span class="line">pt系列</span><br><span class="line">mysqlslap </span><br><span class="line">sysbench </span><br><span class="line">information_schema </span><br><span class="line">performance_schema</span><br><span class="line">sys</span><br></pre></td></tr></table></figure>

<h3 id="参数优化"><a href="#参数优化" class="headerlink" title="参数优化"></a>参数优化</h3><h4 id="参数优化前压力测试"><a href="#参数优化前压力测试" class="headerlink" title="参数优化前压力测试"></a>参数优化前压力测试</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 模拟数据库数据</span><br><span class="line">create database test charset utf8mb4 collate utf8mb4_bin;</span><br><span class="line">use test;</span><br><span class="line">create table t_100w (id int,num int,k1 char(2),k2 char(4),dt timestamp);</span><br><span class="line"></span><br><span class="line">delimiter //</span><br><span class="line">create  procedure rand_data(in num int)</span><br><span class="line">begin</span><br><span class="line">declare str char(62) default &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;;</span><br><span class="line">declare str2 char(2);</span><br><span class="line">declare str4 char(4);</span><br><span class="line">declare i int default 0;</span><br><span class="line">while i&lt;num do</span><br><span class="line">set str2=concat(substring(str,1+floor(rand()*61),1),substring(str,1+floor(rand()*61),1));</span><br><span class="line">set str4=concat(substring(str,1+floor(rand()*61),2),substring(str,1+floor(rand()*61),2));</span><br><span class="line">set i=i+1;</span><br><span class="line">insert into t_100w values (i,floor(rand()*num),str2,str4,now());</span><br><span class="line">end while;</span><br><span class="line">end;</span><br><span class="line">//</span><br><span class="line">delimiter ;</span><br><span class="line"></span><br><span class="line"># 插入100w条数据</span><br><span class="line">call rand_data(10000000);</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line"># 压力测试</span><br><span class="line">mysqlslap --defaults-file=/etc/my.cnf \</span><br><span class="line">--concurrency=100 --iterations=1 --create-schema=&#x27;test&#x27; \</span><br><span class="line">--query=&quot;select * from test.t_100w where k2=&#x27;FGCD&#x27;&quot; engine=innodb \</span><br><span class="line">--number-of-queries=200 -uroot -p123 -verbose</span><br></pre></td></tr></table></figure>

<h4 id="优化参数说明"><a href="#优化参数说明" class="headerlink" title="优化参数说明"></a>优化参数说明</h4><ul>
<li><p><code>Max_connections(*)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 简介</span><br><span class="line">Mysql的最大连接数，如果服务器的并发请求量比较大，可以调高这个值，当然这是要建立在机器能够支撑的情况下，因为如果连接数越来越多，mysql会为每个连接提供缓冲区，就会开销的越多的内存，所以需要适当的调整该值，不能随便去提高设值</span><br><span class="line"></span><br><span class="line"># 判断依据</span><br><span class="line">show variables like &#x27;max_connections&#x27;;</span><br><span class="line">    +-----------------+-------+</span><br><span class="line">    | Variable_name   | Value |</span><br><span class="line">    +-----------------+-------+</span><br><span class="line">    | max_connections | 151   |</span><br><span class="line">    +-----------------+-------+</span><br><span class="line">show status like &#x27;Max_used_connections&#x27;;</span><br><span class="line">    +----------------------+-------+</span><br><span class="line">    | Variable_name        | Value |</span><br><span class="line">    +----------------------+-------+</span><br><span class="line">    | Max_used_connections | 101   |</span><br><span class="line">    +----------------------+-------+</span><br><span class="line"></span><br><span class="line"># 修改方式</span><br><span class="line">vim /etc/my.cnf </span><br><span class="line">Max_connections=1024</span><br><span class="line"></span><br><span class="line"># 补充</span><br><span class="line">1.开启数据库时,我们可以临时设置一个比较大的测试值</span><br><span class="line">2.观察show status like &#x27;Max_used_connections&#x27;;变化</span><br><span class="line">3.如果max_used_connections跟max_connections相同</span><br><span class="line">    那么就是max_connections设置过低或者超过服务器的负载上限了</span><br><span class="line">    低于10%则设置过大</span><br></pre></td></tr></table></figure></li>
<li><p><code>back_log</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 简介</span><br><span class="line">mysql能暂存的连接数量，当主要mysql线程在一个很短时间内得到非常多的连接请求时候它就会起作用，如果mysql的连接数据达到max_connections时候，新来的请求将会被存在堆栈中，等待某一连接释放资源，该推栈的数量及back_log,如果等待连接的数量超过back_log，将不被授予连接资源。</span><br><span class="line">back_log值指出在mysql暂时停止回答新请求之前的短时间内有多少个请求可以被存在推栈中，只有如果期望在一个短时间内有很多连接的时候需要增加它</span><br><span class="line"></span><br><span class="line"># 判断依据</span><br><span class="line">show full processlist</span><br><span class="line">发现大量的待连接进程时，就需要加大back_log或者加大max_connections的值</span><br><span class="line"></span><br><span class="line"># 修改方式举例</span><br><span class="line">vim /etc/my.cnf</span><br><span class="line">back_log=1024</span><br></pre></td></tr></table></figure></li>
<li><p><code>wait_timeout和interactive_timeout</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 简介</span><br><span class="line">wait_timeout：指的是mysql在关闭一个非交互的连接之前所要等待的秒数</span><br><span class="line">interactive_timeout：指的是mysql在关闭一个交互的连接之前所需要等待的秒数，比如我们在终端上进行mysql管理，使用的即使交互的连接，这时候，如果没有操作的时间超过了interactive_time设置的时间就会自动的断开，默认的是28800，可调优为7200。</span><br><span class="line">wait_timeout:如果设置太小，那么连接关闭的就很快，从而使一些持久的连接不起作用</span><br><span class="line"></span><br><span class="line"># 设置建议</span><br><span class="line">如果设置太大，容易造成连接打开时间过长，在show processlist时候，能看到很多的连接 ，一般希望wait_timeout尽可能低</span><br><span class="line"></span><br><span class="line"># 修改方式举例</span><br><span class="line">wait_timeout=60</span><br><span class="line">interactive_timeout=1200</span><br><span class="line">长连接的应用，为了不去反复的回收和分配资源，降低额外的开销</span><br><span class="line">一般我们会将wait_timeout设定比较小，interactive_timeout要和应用开发人员沟通长链接的应用是否很多。如果他需要长链接，那么这个值可以不需要调整。</span><br><span class="line">另外还可以使用类外的参数弥补。</span><br></pre></td></tr></table></figure></li>
<li><p><code>key_buffer_size(*)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 简介</span><br><span class="line">key_buffer_size指定索引缓冲区的大小，它决定索引处理的速度，尤其是索引读的速度</span><br><span class="line">1.此参数与myisam表的索引有关</span><br><span class="line">2.临时表的创建有关（多表链接、子查询中、union）</span><br><span class="line">     在有以上查询语句出现的时候，需要创建临时表，用完之后会被丢弃</span><br><span class="line">     临时表有两种创建方式：</span><br><span class="line">                        内存中-------&gt;key_buffer_size</span><br><span class="line">                        磁盘上-------&gt;ibdata1(5.6)</span><br><span class="line">                                      ibtmp1 (5.7）</span><br><span class="line"># 设置依据</span><br><span class="line">通过key_read_requests和key_reads可以直到key_baffer_size设置是否合理</span><br><span class="line">mysql&gt; show variables like &quot;key_buffer_size%&quot;;</span><br><span class="line">+-----------------+---------+</span><br><span class="line">| Variable_name   | Value   |</span><br><span class="line">+-----------------+---------+</span><br><span class="line">| key_buffer_size | 8388608 |</span><br><span class="line">+-----------------+---------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; show status like &quot;key_read%&quot;;</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Variable_name     | Value |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Key_read_requests | 10    |</span><br><span class="line">| Key_reads         | 2     |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">一共有10个索引读取请求，有2个请求在内存中没有找到直接从硬盘中读取索引</span><br><span class="line">控制在 5%以内</span><br><span class="line">注：key_buffer_size只对myisam表起作用，即使不使用myisam表，但是内部的临时磁盘表是myisam表，也要使用该值。</span><br><span class="line">可以使用检查状态值created_tmp_disk_tables得知：</span><br><span class="line"></span><br><span class="line">mysql&gt; show status like &quot;created_tmp%&quot;;</span><br><span class="line">+-------------------------+-------+</span><br><span class="line">| Variable_name           | Value |</span><br><span class="line">+-------------------------+-------+</span><br><span class="line">| Created_tmp_disk_tables | 0     |</span><br><span class="line">| Created_tmp_files       | 6     |</span><br><span class="line">| Created_tmp_tables      | 1     |</span><br><span class="line">+-------------------------+-------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">通常地，我们习惯以 Created_tmp_tables/(Created_tmp_disk_tables + Created_tmp_tables) </span><br><span class="line">Created_tmp_disk_tables/(Created_tmp_disk_tables + Created_tmp_tables) </span><br><span class="line"></span><br><span class="line">或者已各自的一个时段内的差额计算，来判断基于内存的临时表利用率。所以，我们会比较关注 Created_tmp_disk_tables 是否过多，从而认定当前服务器运行状况的优劣。</span><br><span class="line">Created_tmp_disk_tables/(Created_tmp_disk_tables + Created_tmp_tables) </span><br><span class="line">控制在5%-10%以内</span><br><span class="line">看以下例子：</span><br><span class="line">在调用mysqldump备份数据时，大概执行步骤如下：</span><br><span class="line">180322 17:39:33       7 Connect     root@localhost on</span><br><span class="line">7 Query       /*!40100 SET @@SQL_MODE=&#x27;&#x27; */</span><br><span class="line">7 Init DB     guo</span><br><span class="line">7 Query       SHOW TABLES LIKE &#x27;guo&#x27;</span><br><span class="line">7 Query       LOCK TABLES `guo` READ /*!32311 LOCAL */</span><br><span class="line">7 Query       SET OPTION SQL_QUOTE_SHOW_CREATE=1</span><br><span class="line">7 Query       show create table `guo`</span><br><span class="line">7 Query       show fields from `guo`</span><br><span class="line">7 Query       show table status like &#x27;guo&#x27;</span><br><span class="line">7 Query       SELECT /*!40001 SQL_NO_CACHE */ * FROM `guo`</span><br><span class="line">7 Query       UNLOCK TABLES</span><br><span class="line">7 Quit</span><br><span class="line"></span><br><span class="line">其中，有一步是：show fields from `guo`。从slow query记录的执行计划中，可以知道它也产生了 Tmp_table_on_disk。</span><br><span class="line">所以说，以上公式并不能真正反映到mysql里临时表的利用率，有些情况下产生的 Tmp_table_on_disk 我们完全不用担心，因此没必要过分关注 Created_tmp_disk_tables，但如果它的值大的离谱的话，那就好好查一下，你的服务器到底都在执行什么查询了</span><br><span class="line"># 配置方法</span><br><span class="line">key_buffer_size=64M</span><br></pre></td></tr></table></figure></li>
<li><p><code>query_cache_size</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 简介</span></span><br><span class="line">查询缓存简称QC，使用查询缓冲，mysql将查询结果存放在缓冲区中，今后对于同样的select语句（区分大小写）,将直接从缓冲区中读取结果。</span><br><span class="line"></span><br><span class="line">SQL层：</span><br><span class="line">select * from t1 <span class="built_in">where</span> name=:NAME;</span><br><span class="line">select * from t1 <span class="built_in">where</span> name=:NAME;</span><br><span class="line"></span><br><span class="line">1、查询完结果之后，会对SQL语句进行<span class="built_in">hash</span>运算，得出<span class="built_in">hash</span>值,我们把他称之为SQL_ID</span><br><span class="line">2、会将存储引擎返回的结果+SQL_ID存储到缓存中。</span><br><span class="line"></span><br><span class="line">存储方式：</span><br><span class="line">例子：select * from t1  <span class="built_in">where</span> id=10;      100次</span><br><span class="line"></span><br><span class="line">1、将select * from t1  <span class="built_in">where</span> id=10; 进行<span class="built_in">hash</span>运算计算出一串<span class="built_in">hash</span>值，我们把它称之为“SQL_ID<span class="string">&quot;</span></span><br><span class="line"><span class="string">2、将存储引擎返回上来的表的内容+SQLID存储到查询缓存中</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">使用方式：</span></span><br><span class="line"><span class="string">1、一条SQL执行时，进行hash运算，得出SQLID，去找query cache</span></span><br><span class="line"><span class="string">2、如果cache中有，则直接返回数据行，如果没有，就走原有的SQL执行流程</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">一个sql查询如果以select开头，那么mysql服务器将尝试对其使用查询缓存。</span></span><br><span class="line"><span class="string">注：两个sql语句，只要想差哪怕是一个字符（列如大小写不一样；多一个空格等）,那么这两个sql将使用不同的一个cache。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 判断依据</span></span><br><span class="line"><span class="string">mysql&gt; show status like &quot;</span>%Qcache%<span class="string">&quot;;</span></span><br><span class="line"><span class="string">+-------------------------+---------+</span></span><br><span class="line"><span class="string">| Variable_name           | Value   |</span></span><br><span class="line"><span class="string">+-------------------------+---------+</span></span><br><span class="line"><span class="string">| Qcache_free_blocks      | 1       |</span></span><br><span class="line"><span class="string">| Qcache_free_memory      | 1031360 |</span></span><br><span class="line"><span class="string">| Qcache_hits             | 0       |</span></span><br><span class="line"><span class="string">| Qcache_inserts          | 0       |</span></span><br><span class="line"><span class="string">| Qcache_lowmem_prunes    | 0       |</span></span><br><span class="line"><span class="string">| Qcache_not_cached       | 2002    |</span></span><br><span class="line"><span class="string">| Qcache_queries_in_cache | 0       |</span></span><br><span class="line"><span class="string">| Qcache_total_blocks     | 1       |</span></span><br><span class="line"><span class="string">+-------------------------+---------+</span></span><br><span class="line"><span class="string">8 rows in set (0.00 sec)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">---------------------状态说明--------------------</span></span><br><span class="line"><span class="string">Qcache_free_blocks：缓存中相邻内存块的个数。</span></span><br><span class="line"><span class="string">如果该值显示较大，则说明Query Cache 中的内存碎片较多了，FLUSH QUERY CACHE会对缓存中的碎片进行整理，从而得到一个空闲块。</span></span><br><span class="line"><span class="string">注：当一个表被更新之后，和它相关的cache </span></span><br><span class="line"><span class="string">blocks将被free。但是这个block依然可能存在队列中，除非是在队列的尾部。可以用FLUSH QUERY CACHE语句来清空free blocks</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Qcache_free_memory：Query Cache 中目前剩余的内存大小。通过这个参数我们可以较为准确的观察出当前系统中的Query Cache 内存大小是否足够，是需要增加还是过多了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Qcache_hits：表示有多少次命中缓存。我们主要可以通过该值来验证我们的查询缓存的效果。数字越大，缓存效果越理想。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Qcache_inserts：表示多少次未命中然后插入，意思是新来的SQL请求在缓存中未找到，不得不执行查询处理，执行查询处理后把结果insert到查询缓存中。这样的情况的次数越多，表示查询缓存应用到的比较少，效果也就不理想。当然系统刚启动后，查询缓存是空的，这很正常。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Qcache_lowmem_prunes：</span></span><br><span class="line"><span class="string">多少条Query因为内存不足而被清除出QueryCache。通过“Qcache_lowmem_prunes”和“Qcache_free_memory”相互结合，能够更清楚的了解到我们系统中Query Cache 的内存大小是否真的足够，是否非常频繁的出现因为内存不足而有Query 被换出。这个数字最好长时间来看；如果这个数字在不断增长，就表示可能碎片非常严重，或者内存很少。（上面的free_blocks和free_memory可以告诉您属于哪种情况）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Qcache_not_cached：不适合进行缓存的查询的数量，通常是由于这些查询不是 SELECT 语句或者用了now()之类的函数。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Qcache_queries_in_cache：当前Query Cache 中cache 的Query 数量；</span></span><br><span class="line"><span class="string">Qcache_total_blocks：当前Query Cache 中的block 数量；。</span></span><br><span class="line"><span class="string">Qcache_hits / (Qcache_inserts+Qcache_not_cached+Qcache_hits) </span></span><br><span class="line"><span class="string">    90/         10000             0             90</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">如果出现hits比例过低，其实就可以关闭查询缓存了。使用redis专门缓存数据库</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Qcache_free_blocks    来判断碎片</span></span><br><span class="line"><span class="string">Qcache_free_memory   +   Qcache_lowmem_prunes  来判断内存够不够</span></span><br><span class="line"><span class="string">Qcache_hits 多少次命中  Qcache_hits / (Qcache_inserts+Qcache_not_cached+Qcache_hits)  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 配置示例</span></span><br><span class="line"><span class="string">mysql&gt; show variables like &#x27;%query_cache%&#x27; ;</span></span><br><span class="line"><span class="string">+------------------------------+---------+</span></span><br><span class="line"><span class="string">| Variable_name                | Value   |</span></span><br><span class="line"><span class="string">+------------------------------+---------+</span></span><br><span class="line"><span class="string">| have_query_cache             | YES     |</span></span><br><span class="line"><span class="string">| query_cache_limit            | 1048576 |</span></span><br><span class="line"><span class="string">| query_cache_min_res_unit     | 4096    |</span></span><br><span class="line"><span class="string">| query_cache_size             | 1048576 |</span></span><br><span class="line"><span class="string">| query_cache_type             | OFF     |</span></span><br><span class="line"><span class="string">| query_cache_wlock_invalidate | OFF     |</span></span><br><span class="line"><span class="string">+------------------------------+---------+</span></span><br><span class="line"><span class="string">6 rows in set (0.00 sec)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">mysql&gt; </span></span><br><span class="line"><span class="string">-------------------配置说明-------------------------------</span></span><br><span class="line"><span class="string">以上信息可以看出query_cache_type为off表示不缓存任何查询</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">各字段的解释：</span></span><br><span class="line"><span class="string">query_cache_limit：超过此大小的查询将不缓存</span></span><br><span class="line"><span class="string">query_cache_min_res_unit：缓存块的最小大小，query_cache_min_res_unit的配置是一柄”双刃剑”，默认是4KB，设置值大对大数据查询有好处，但如果你的查询都是小数据查询，就容易造成内存碎片和浪费。</span></span><br><span class="line"><span class="string">query_cache_size：查询缓存大小 (注：QC存储的最小单位是1024byte，所以如果你设定了一个不是1024的倍数的值，这个值会被四舍五入到最接近当前值的等于1024的倍数的值。)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">query_cache_type：缓存类型，决定缓存什么样的查询，注意这个值不能随便设置，必须设置为数字，可选项目以及说明如下：</span></span><br><span class="line"><span class="string">如果设置为0，那么可以说，你的缓存根本就没有用，相当于禁用了。</span></span><br><span class="line"><span class="string">如果设置为1，将会缓存所有的结果，除非你的select语句使用SQL_NO_CACHE禁用了查询缓存。</span></span><br><span class="line"><span class="string">如果设置为2，则只缓存在select语句中通过SQL_CACHE指定需要缓存的查询。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">修改/etc/my.cnf,配置完后的部分文件如下：</span></span><br><span class="line"><span class="string">query_cache_size=128M</span></span><br><span class="line"><span class="string">query_cache_type=1</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>max_connect_errors</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 简介</span><br><span class="line">max_connect_errors是一个mysql中与安全有关的计数器值，它负责阻止过多尝试失败的客户端以防止暴力破解密码等情况，当超过指定次数，mysql服务器将禁止host的连接请求，直到mysql服务器重启或通过flush hosts命令清空此host的相关信息 max_connect_errors的值与性能并无太大关系</span><br><span class="line"></span><br><span class="line"># 修改方式</span><br><span class="line">/etc/my.cnf</span><br><span class="line">max_connect_errors=2000</span><br></pre></td></tr></table></figure></li>
<li><p><code>sort_buffer_size</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 简介</span><br><span class="line">每个需要进行排序的线程分配该大小的一个缓冲区。增加这值加速</span><br><span class="line">ORDER BY </span><br><span class="line">GROUP BY</span><br><span class="line">distinct</span><br><span class="line">union </span><br><span class="line"></span><br><span class="line"># 配置依据</span><br><span class="line">Sort_Buffer_Size并不是越大越好，由于是connection级的参数，过大的设置+高并发可能会耗尽系统内存资源。</span><br><span class="line">列如：500个连接将会消耗500*sort_buffer_size（2M）=1G内存</span><br><span class="line"></span><br><span class="line"># 配置方法</span><br><span class="line">/etc/my.cnf</span><br><span class="line">sort_buffer_size=1M</span><br></pre></td></tr></table></figure></li>
<li><p><code>max_allowed_packet(*)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 简介：</span><br><span class="line">mysql根据配置文件会限制，server接受的数据包大小。</span><br><span class="line"></span><br><span class="line"># 配置依据：</span><br><span class="line">有时候大的插入和更新会受max_allowed_packet参数限制，导致写入或者更新失败，更大值是1GB，必须设置1024的倍数</span><br><span class="line"></span><br><span class="line"># 配置方法：</span><br><span class="line">max_allowed_packet=32M</span><br></pre></td></tr></table></figure></li>
<li><p><code>join_buffer_size</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select a.name,b.name from a join b on a.id=b.id where xxxx</span><br><span class="line">用于表间关联缓存的大小，和sort_buffer_size一样，该参数对应的分配内存也是每个连接独享。</span><br><span class="line">尽量在SQL与方面进行优化，效果较为明显</span><br><span class="line">优化的方法：在on条件列加索引，至少应当是有MUL索引</span><br></pre></td></tr></table></figure></li>
<li><p><code>thread_cache_size(*)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 简介</span><br><span class="line">服务器线程缓存，这个值表示可以重新利用保存在缓存中线程的数量,当断开连接时,那么客户端的线程将被放到缓存中以响应下一个客户而不是销毁(前提是缓存数未达上限),如果线程重新被请求，那么请求将从缓存中读取,如果缓存中是空的或者是新的请求，那么这个线程将被重新创建,如果有很多新的线程，增加这个值可以改善系统性能.</span><br><span class="line"></span><br><span class="line"># 配置依据</span><br><span class="line">通过比较 Connections 和 Threads_created 状态的变量，可以看到这个变量的作用。</span><br><span class="line">设置规则如下：1GB 内存配置为8，2GB配置为16，3GB配置为32，4GB或更高内存，可配置更大。</span><br><span class="line">服务器处理此客户的线程将会缓存起来以响应下一个客户而不是销毁(前提是缓存数未达上限)</span><br><span class="line"></span><br><span class="line">试图连接到MySQL(不管是否连接成功)的连接数</span><br><span class="line">mysql&gt;  show status like &#x27;threads_%&#x27;;</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Variable_name     | Value |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">| Threads_cached    | 8     |</span><br><span class="line">| Threads_connected | 2     |</span><br><span class="line">| Threads_created   | 4783  |</span><br><span class="line">| Threads_running   | 1     |</span><br><span class="line">+-------------------+-------+</span><br><span class="line">4 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">Threads_cached :代表当前此时此刻线程缓存中有多少空闲线程。</span><br><span class="line">Threads_connected:代表当前已建立连接的数量，因为一个连接就需要一个线程，所以也可以看成当前被使用的线程数。</span><br><span class="line">Threads_created:代表从最近一次服务启动，已创建线程的数量，如果发现Threads_created值过大的话，表明MySQL服务器一直在创建线程，这也是比较耗cpu SYS资源，可以适当增加配置文件中thread_cache_size值。</span><br><span class="line">Threads_running :代表当前激活的（非睡眠状态）线程数。并不是代表正在使用的线程数，有时候连接已建立，但是连接处于sleep状态。</span><br><span class="line"></span><br><span class="line"># 配置方法：</span><br><span class="line">thread_cache_size=32</span><br><span class="line"></span><br><span class="line">整理：</span><br><span class="line">Threads_created  ：一般在架构设计阶段，会设置一个测试值，做压力测试。</span><br><span class="line">结合zabbix监控，看一段时间内此状态的变化。</span><br><span class="line">如果在一段时间内，Threads_created趋于平稳，说明对应参数设定是OK。</span><br><span class="line">如果一直陡峭的增长，或者出现大量峰值，那么继续增加此值的大小，在系统资源够用的情况下（内存）</span><br></pre></td></tr></table></figure></li>
<li><p><code>innodb_buffer_pool_size(*)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 简介</span><br><span class="line">对于InnoDB表来说，innodb_buffer_pool_size的作用就相当于key_buffer_size对于MyISAM表的作用一样</span><br><span class="line"></span><br><span class="line"># 配置依据：</span><br><span class="line">InnoDB使用该参数指定大小的内存来缓冲数据和索引。</span><br><span class="line">对于单独的MySQL数据库服务器，最大可以把该值设置成物理内存的80%,一般我们建议不要超过物理内存的70%</span><br><span class="line"></span><br><span class="line"># 配置方法</span><br><span class="line">innodb_buffer_pool_size=2048M</span><br></pre></td></tr></table></figure></li>
<li><p><code>innodb_flush_log_at_trx_commit(*)双一标准</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 简介</span><br><span class="line">主要控制了innodb将log buffer中的数据写入日志文件并flush磁盘的时间点，取值分别为0、1、2三个。</span><br><span class="line">0，表示当事务提交时，不做日志写入操作，而是每秒钟将log buffer中的数据写入日志文件并flush磁盘一次；</span><br><span class="line">1，</span><br><span class="line">每次事务的提交都会引起redo日志文件写入、flush磁盘的操作，确保了事务的ACID；</span><br><span class="line">2，每次事务提交引起写入日志文件的动作,但每秒钟完成一次flush磁盘操作。</span><br><span class="line"></span><br><span class="line"># 配置依据</span><br><span class="line">实际测试发现，该值对插入数据的速度影响非常大，设置为2时插入10000条记录只需要2秒，设置为0时只需要1秒，而设置为1时则需要229秒。因此，MySQL手册也建议尽量将插入操作合并成一个事务，这样可以大幅提高速度。</span><br><span class="line">根据MySQL官方文档，在允许丢失最近部分事务的危险的前提下，可以把该值设为0或2。</span><br><span class="line"></span><br><span class="line"># 配置方法</span><br><span class="line">innodb_flush_log_at_trx_commit=1</span><br><span class="line">双1标准中的一个1</span><br></pre></td></tr></table></figure></li>
<li><p><code>innodb_thread_concurrency</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 简介</span><br><span class="line">此参数用来设置innodb线程的并发数量，默认值为0表示不限制。</span><br><span class="line"></span><br><span class="line"># 配置依据</span><br><span class="line">在官方doc上，对于innodb_thread_concurrency的使用，也给出了一些建议，如下：</span><br><span class="line">如果一个工作负载中，并发用户线程的数量小于64，建议设置innodb_thread_concurrency=0；</span><br><span class="line">如果工作负载一直较为严重甚至偶尔达到顶峰，建议先设置innodb_thread_concurrency=128，</span><br><span class="line">并通过不断的降低这个参数，96, 80, 64等等，直到发现能够提供最佳性能的线程数，</span><br><span class="line">例如，假设系统通常有40到50个用户，但定期的数量增加至60，70，甚至200。你会发现，</span><br><span class="line">性能在80个并发用户设置时表现稳定，如果高于这个数，性能反而下降。在这种情况下，</span><br><span class="line">建议设置innodb_thread_concurrency参数为80，以避免影响性能。</span><br><span class="line">如果你不希望InnoDB使用的虚拟CPU数量比用户线程使用的虚拟CPU更多（比如20个虚拟CPU），</span><br><span class="line">建议通过设置innodb_thread_concurrency 参数为这个值（也可能更低，这取决于性能体现），</span><br><span class="line">如果你的目标是将MySQL与其他应用隔离，你可以l考虑绑定mysqld进程到专有的虚拟CPU。</span><br><span class="line">但是需 要注意的是，这种绑定，在myslqd进程一直不是很忙的情况下，可能会导致非最优的硬件使用率。在这种情况下，</span><br><span class="line">你可能会设置mysqld进程绑定的虚拟 CPU，允许其他应用程序使用虚拟CPU的一部分或全部。</span><br><span class="line">在某些情况下，最佳的innodb_thread_concurrency参数设置可以比虚拟CPU的数量小。</span><br><span class="line">定期检测和分析系统，负载量、用户数或者工作环境的改变可能都需要对innodb_thread_concurrency参数的设置进行调整。</span><br><span class="line"></span><br><span class="line">128   -----&gt; top  cpu  </span><br><span class="line">设置标准：</span><br><span class="line">1、当前系统cpu使用情况，均不均匀</span><br><span class="line">top</span><br><span class="line"></span><br><span class="line">2、当前的连接数，有没有达到顶峰</span><br><span class="line">show status like &#x27;threads_%&#x27;;</span><br><span class="line">show processlist;</span><br><span class="line"></span><br><span class="line"># 配置方法：</span><br><span class="line">innodb_thread_concurrency=8</span><br><span class="line">方法:</span><br><span class="line">    1. 看top ,观察每个cpu的各自的负载情况</span><br><span class="line">    2. 发现不平均,先设置参数为cpu个数,然后不断增加(一倍)这个数值</span><br><span class="line">    3. 一直观察top状态,直到达到比较均匀时,说明已经到位了.</span><br></pre></td></tr></table></figure></li>
<li><p><code>innodb_log_buffer_size</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此参数确定些日志文件所用的内存大小，以M为单位。缓冲区更大能提高性能，对于较大的事务，可以增大缓存大小。</span><br><span class="line">innodb_log_buffer_size=128M</span><br><span class="line"></span><br><span class="line">设定依据：</span><br><span class="line">1、大事务： 存储过程调用 CALL</span><br><span class="line">2、多事务</span><br></pre></td></tr></table></figure></li>
<li><p><code>innodb_log_file_size = 100M(*)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">设置 ib_logfile0  ib_logfile1 </span><br><span class="line">此参数确定数据日志文件的大小，以M为单位，更大的设置可以提高性能</span><br><span class="line"></span><br><span class="line">innodb_log_file_size = 100M</span><br></pre></td></tr></table></figure></li>
<li><p><code>innodb_log_files_in_group = 3(*)</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">为提高性能，MySQL可以以循环方式将日志文件写到多个文件。推荐设置为3</span><br></pre></td></tr></table></figure></li>
<li><p><code>read_buffer_size = 1M</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MySql读入缓冲区大小</span><br><span class="line">对表进行顺序扫描的请求将分配一个读入缓冲区，MySql会为它分配一段内存缓冲区</span><br><span class="line">如果对表的顺序扫描请求非常频繁，并且你认为频繁扫描进行得太慢，可以通过增加该变量值以及内存缓冲区大小提高其性能，和 sort_buffer_size一样，该参数对应的分配内存也是每个连接独享</span><br></pre></td></tr></table></figure></li>
<li><p><code>read_rnd_buffer_size = 1M</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MySql的随机读（查询操作）缓冲区大小</span><br><span class="line"></span><br><span class="line">当按任意顺序读取行时(例如，按照排序顺序)，将分配一个随机读缓存区。进行排序查询时，MySql会首先扫描一遍该缓冲，以避免磁盘搜索，提高查询速度，如果需要排序大量数据，可适当调高该值。但MySql会为每个客户连接发放该缓冲空间，所以应尽量适当设置该值，以避免内存开销过大</span><br><span class="line"></span><br><span class="line">注：顺序读是指根据索引的叶节点数据就能顺序地读取所需要的行数据。随机读是指一般需要根据辅助索引叶节点中的主键寻找实际行数据，而辅助索引和主键所在的数据段不同，因此访问方式是随机的。</span><br></pre></td></tr></table></figure></li>
<li><p><code>bulk_insert_buffer_size = 8M</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">批量插入数据缓存大小，可以有效提高插入效率，默认为8M</span><br><span class="line">tokuDB    percona</span><br><span class="line">myrocks   </span><br><span class="line">RocksDB</span><br><span class="line">TiDB</span><br><span class="line">MongoDB</span><br></pre></td></tr></table></figure></li>
<li><p><code>binary log(*)双一标准</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">binlog_cache_size = 2M  # 为每个session 分配的内存，在事务过程中用来存储二进制日志的缓存, 提高记录bin-log的效率。没有什么大事务，dml也不是很频繁的情况下可以设置小一点，如果事务大而且多，dml操作也频繁，则可以适当的调大一点。前者建议是--1M，后者建议是：即 2--4M</span><br><span class="line"></span><br><span class="line">max_binlog_cache_size = 8M  # 表示的是binlog 能够使用的最大cache 内存大小</span><br><span class="line"></span><br><span class="line">max_binlog_size= 512M  # 指定binlog日志文件的大小，如果当前的日志大小达到max_binlog_size，还会自动创建新的二进制日志。你不能将该变量设置为大于1GB或小于4096字节。默认值是1GB。在导入大容量的sql文件时，建议关闭sql_log_bin，否则硬盘扛不住，而且建议定期做删除。</span><br><span class="line"></span><br><span class="line">expire_logs_days = 7  # 定义了mysql清除过期日志的时间 二进制日志自动删除的天数。默认值为0,表示“没有自动删除”。</span><br><span class="line"></span><br><span class="line">log-bin=/data/mysql-bin</span><br><span class="line">binlog_format=row </span><br><span class="line">sync_binlog=1</span><br><span class="line"></span><br><span class="line">双1标准(基于安全的控制)</span><br><span class="line">sync_binlog=1   # 时候刷新binlog到磁盘，每次事务commit</span><br><span class="line">innodb_flush_log_at_trx_commit=1</span><br><span class="line">set sql_log_bin=0;</span><br><span class="line">show status like &#x27;com_%&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p>安全参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Innodb_flush_method=(O_DIRECT, fsync) </span><br><span class="line">1、fsync    ：</span><br><span class="line">（1）在数据页需要持久化时，首先将数据写入OS buffer中，然后由os决定什么时候写入磁盘</span><br><span class="line">（2）在redo buffuer需要持久化时，首先将数据写入OS buffer中，然后由os决定什么时候写入磁盘</span><br><span class="line">但，如果innodb_flush_log_at_trx_commit=1的话，日志还是直接每次commit直接写入磁盘</span><br><span class="line">2、 Innodb_flush_method=O_DIRECT</span><br><span class="line">（1）在数据页需要持久化时，直接写入磁盘</span><br><span class="line">（2）在redo buffuer需要持久化时，首先将数据写入OS buffer中，然后由os决定什么时候写入磁盘</span><br><span class="line">但，如果innodb_flush_log_at_trx_commit=1的话，日志还是直接每次commit直接写入磁盘</span><br><span class="line"></span><br><span class="line">最安全模式：</span><br><span class="line">innodb_flush_log_at_trx_commit=1</span><br><span class="line">innodb_flush_method=O_DIRECT</span><br><span class="line">最高性能模式：</span><br><span class="line">innodb_flush_log_at_trx_commit=0</span><br><span class="line">innodb_flush_method=fsync</span><br><span class="line">        </span><br><span class="line">一般情况下，我们更偏向于安全。 </span><br><span class="line">“双一标准”</span><br><span class="line">innodb_flush_log_at_trx_commit=1 </span><br><span class="line">sync_binlog=1              </span><br><span class="line">innodb_flush_method=O_DIRECT</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="参数优化结果"><a href="#参数优化结果" class="headerlink" title="参数优化结果"></a>参数优化结果</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">basedir=/usr/local/mysql</span><br><span class="line">datadir=/data/mysql/data</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">log-error=/var/log/mysql.log</span><br><span class="line">log_bin=/data/binlog/mysql-bin</span><br><span class="line">binlog_format=row</span><br><span class="line">skip-name-resolve</span><br><span class="line">server-id=7</span><br><span class="line">autocommit=0</span><br><span class="line">gtid-mode=on</span><br><span class="line">enforce-gtid-consistency=true</span><br><span class="line">log-slave-updates=1</span><br><span class="line">relay_log_purge=0</span><br><span class="line">max_connections=1024</span><br><span class="line">back_log=128</span><br><span class="line">wait_timeout=60</span><br><span class="line">interactive_timeout=7200</span><br><span class="line">key_buffer_size=16M</span><br><span class="line">query_cache_size=64M</span><br><span class="line">query_cache_type=1</span><br><span class="line">query_cache_limit=50M</span><br><span class="line">max_connect_errors=20</span><br><span class="line">sort_buffer_size=2M</span><br><span class="line">max_allowed_packet=32M</span><br><span class="line">join_buffer_size=2M</span><br><span class="line">thread_cache_size=200</span><br><span class="line">innodb_buffer_pool_size=1024M</span><br><span class="line">innodb_flush_log_at_trx_commit=1</span><br><span class="line">innodb_log_buffer_size=32M</span><br><span class="line">innodb_log_file_size=128M</span><br><span class="line">innodb_log_files_in_group=3</span><br><span class="line">binlog_cache_size=2M</span><br><span class="line">max_binlog_cache_size=8M</span><br><span class="line">max_binlog_size=512M</span><br><span class="line">expire_logs_days=7</span><br><span class="line">read_buffer_size=2M</span><br><span class="line">read_rnd_buffer_size=2M</span><br><span class="line">bulk_insert_buffer_size=8M</span><br><span class="line">[client]</span><br><span class="line">socket=/tmp/mysql.sock  </span><br><span class="line">        </span><br><span class="line"># 再次压力测试</span><br><span class="line">mysqlslap --defaults-file=/etc/my.cnf --concurrency=100 --iterations=1 --create-schema=&#x27;test&#x27; --query=&quot;select * from test.t_100w where k2=&#x27;FGCD&#x27;&quot; engine=innodb --number-of-queries=200000 -uroot -p123 -verbose</span><br></pre></td></tr></table></figure>



<h3 id="锁的监控及处理"><a href="#锁的监控及处理" class="headerlink" title="锁的监控及处理"></a>锁的监控及处理</h3><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/8SEDRO.jpg" alt="8SEDRO"></p>
<h4 id="查看锁状态"><a href="#查看锁状态" class="headerlink" title="查看锁状态"></a>查看锁状态</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 看有没有锁等待</span><br><span class="line">show status like &#x27;innodb_row_lock%&#x27;;</span><br><span class="line"></span><br><span class="line"># 查看哪个事务在等待(被阻塞了)</span><br><span class="line">use information_schema</span><br><span class="line">select * from information_schema.INNODB_TRX where trx_state=&#x27;LOCK WAIT&#x27;;</span><br><span class="line">trx_id : 事务ID号</span><br><span class="line">trx_state : 当前事务的状态</span><br><span class="line">trx_mysql_thread_id:连接层的,连接线程ID(show processlist; ===&gt;Id或trx_id )</span><br><span class="line">trx_query : 当前被阻塞的操作(一般是要丢给开发的)</span><br></pre></td></tr></table></figure>

<h4 id="查看锁源"><a href="#查看锁源" class="headerlink" title="查看锁源"></a>查看锁源</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from sys.innodb_lock_waits;  # 被锁的和锁定它的之间关系</span><br><span class="line"></span><br><span class="line">locked_table    : 哪张表出现的等待 </span><br><span class="line">waiting_trx_id  : 等待的事务(与上个视图trx_id 对应)</span><br><span class="line">waiting_pid     : 等待的线程号(与上个视图trx_mysql_thread_id)</span><br><span class="line">blocking_trx_id : 锁源的事务ID </span><br><span class="line">blocking_pid    : 锁源的线程号</span><br></pre></td></tr></table></figure>

<h4 id="找到锁源thread-id"><a href="#找到锁源thread-id" class="headerlink" title="找到锁源thread_id"></a>找到锁源<code>thread_id</code></h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from performance_schema.threads where processlist_id=15;</span><br></pre></td></tr></table></figure>

<h4 id="找到锁源的SQL语句"><a href="#找到锁源的SQL语句" class="headerlink" title="找到锁源的SQL语句"></a>找到锁源的SQL语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 当前在执行的语句</span><br><span class="line">SELECT * FROM performance_schema.`events_statements_current` WHERE thread_id=41;</span><br><span class="line">-- 执行语句的历史</span><br><span class="line">SELECT * FROM performance_schema.`events_statements_history` WHERE thread_id=41;</span><br><span class="line"></span><br><span class="line">得出结果,丢给开发</span><br><span class="line">表信息 </span><br><span class="line">被阻塞的</span><br><span class="line">锁源SQL</span><br></pre></td></tr></table></figure>

<h4 id="死锁监控"><a href="#死锁监控" class="headerlink" title="死锁监控"></a>死锁监控</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show engine innodb status\G</span><br><span class="line">show variables like &#x27;%deadlock%&#x27;;</span><br><span class="line"></span><br><span class="line">vim /etc/my.cnf </span><br><span class="line">innodb_print_all_deadlocks = 1  </span><br></pre></td></tr></table></figure>

<h3 id="主从优化"><a href="#主从优化" class="headerlink" title="主从优化"></a>主从优化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 5.7 从库多线程MTS</span><br><span class="line">基本要求:</span><br><span class="line">5.7以上的版本(忘记小版本)</span><br><span class="line">必须开启GTID </span><br><span class="line">binlog必须是row模式  </span><br><span class="line"></span><br><span class="line">gtid_mode=ON</span><br><span class="line">enforce_gtid_consistency=ON</span><br><span class="line">log_slave_updates=ON</span><br><span class="line">slave-parallel-type=LOGICAL_CLOCK</span><br><span class="line">slave-parallel-workers=16</span><br><span class="line">master_info_repository=TABLE</span><br><span class="line">relay_log_info_repository=TABLE</span><br><span class="line">relay_log_recovery=ON</span><br><span class="line"></span><br><span class="line">5.7 :</span><br><span class="line">slave-parallel-type=LOGICAL_CLOCK</span><br><span class="line">slave-parallel-workers=8</span><br><span class="line">cpu核心数作为标准</span><br><span class="line"></span><br><span class="line">CHANGE MASTER TO</span><br><span class="line">  MASTER_HOST=&#x27;10.0.0.128&#x27;,</span><br><span class="line">  MASTER_USER=&#x27;repl&#x27;,</span><br><span class="line">  MASTER_PASSWORD=&#x27;123&#x27;,</span><br><span class="line">  MASTER_PORT=3307,</span><br><span class="line">  MASTER_AUTO_POSITION=1;</span><br><span class="line">start slave;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL主从复制</title>
    <url>/c813917a.html</url>
    <content><![CDATA[<h3 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h3><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 简介</span><br><span class="line">1.基于二进制日志复制的</span><br><span class="line">2.主库的修改操作会记录二进制日志</span><br><span class="line">3.从库会请求新的二进制日志并回放,最终达到主从数据同步</span><br><span class="line">4.主从复制核心功能:</span><br><span class="line">  辅助备份,处理物理损坏                   </span><br><span class="line">  扩展新型的架构:高可用,高性能,分布式架构等</span><br><span class="line">  </span><br><span class="line"># 前提</span><br><span class="line">1.两台以上mysql实例 ,server_id,server_uuid不同</span><br><span class="line">2.主库开启二进制日志</span><br><span class="line">3.专用的复制用户</span><br><span class="line">4.保证主从开启之前的某个时间点,从库数据是和主库一致</span><br><span class="line">5.告知从库,复制user,passwd,IP port,以及复制起点(change master to)</span><br><span class="line">6.线程(三个):Dump thread  IO thread  SQL thread 开启(start slave)</span><br></pre></td></tr></table></figure>

<h3 id="搭建主从复制"><a href="#搭建主从复制" class="headerlink" title="搭建主从复制"></a>搭建主从复制</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 环境准备</span></span><br><span class="line">cat /etc/hosts</span><br><span class="line">192.168.0.12  db2</span><br><span class="line">192.168.0.13  db3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主机角色分配</span></span><br><span class="line">db2做主库</span><br><span class="line">db3做从库</span><br><span class="line"></span><br><span class="line"><span class="comment"># 搭建数据库，两台机器参考最开始的二进制搭建，注意目录的权限</span></span><br><span class="line"><span class="comment"># 配置文件 server_id 不能相同 db2 是7 db3是8</span></span><br><span class="line">cat /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">user=mysql</span><br><span class="line">basedir=/usr/<span class="built_in">local</span>/mysql</span><br><span class="line">datadir=/data/mysql/data</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">server_id=7</span><br><span class="line">port=3306</span><br><span class="line">secure-file-priv=/tmp</span><br><span class="line">autocommit=0</span><br><span class="line">innodb_flush_method=O_DIRECT</span><br><span class="line">innodb_flush_log_at_trx_commit=1</span><br><span class="line">log_error=/data/mysql/data/mysql.log</span><br><span class="line">log_bin=/data/binlog/mysql-bin</span><br><span class="line">gtid-mode=on</span><br><span class="line">enforce-gtid-consistency=<span class="literal">true</span></span><br><span class="line">slow_query_log=1</span><br><span class="line">slow_query_log_file=/data/mysql/data/slow.log</span><br><span class="line">long_query_time=0.1</span><br><span class="line">log_queries_not_using_indexes</span><br><span class="line">[client]</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两台都启动数据库</span></span><br><span class="line">service mysqld start</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两台检查server_id</span></span><br><span class="line">select @@server_id;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两台检查二进制日志开启情况</span></span><br><span class="line">show variables like <span class="string">&#x27;%log_bin%&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主库db2创建复制用户</span></span><br><span class="line">grant replication slave on *.* to repl@<span class="string">&#x27;192.168.0.%&#x27;</span> identified by <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">select user, host from mysql.user;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主库db2模拟一点数据</span></span><br><span class="line">create database <span class="built_in">test</span> charset utf8mb4;</span><br><span class="line">use <span class="built_in">test</span>;</span><br><span class="line">create table t1 (id int);</span><br><span class="line">insert into t1 values (11),(22),(33);</span><br><span class="line">commit;</span><br><span class="line">select * from t1;</span><br><span class="line"></span><br><span class="line"><span class="comment"># db2主库进行全备</span></span><br><span class="line">mysqldump -A -R -E --master-data=2 --triggers --single-transaction &gt; /tmp/full.sql</span><br><span class="line">scp -rp /tmp/full.sql  db3:/tmp  <span class="comment"># 推送到db3从库的 /tmp 目录中</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># db3恢复主库的全备数据</span></span><br><span class="line"><span class="built_in">set</span> sql_log_bin=0;</span><br><span class="line"><span class="built_in">source</span> /tmp/full.sql;</span><br><span class="line"></span><br><span class="line"><span class="comment"># db2需要告诉从库的复制信息</span></span><br><span class="line"><span class="comment"># db2主库上查看帮助命令</span></span><br><span class="line">mysql&gt; <span class="built_in">help</span> change master to</span><br><span class="line"><span class="comment"># 得到相应模板，修改即可</span></span><br><span class="line"><span class="comment"># 需要的信息在 mysqldump 备份文件中能查看到</span></span><br><span class="line">vim /tmp/full.sql</span><br><span class="line">-- CHANGE MASTER TO MASTER_LOG_FILE=<span class="string">&#x27;mysql-bin.000001&#x27;</span>, MASTER_LOG_POS=1048;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在db3从库中执行</span></span><br><span class="line">CHANGE MASTER TO</span><br><span class="line">  MASTER_HOST=<span class="string">&#x27;192.168.0.12&#x27;</span>,</span><br><span class="line">  MASTER_USER=<span class="string">&#x27;repl&#x27;</span>,</span><br><span class="line">  MASTER_PASSWORD=<span class="string">&#x27;1&#x27;</span>,</span><br><span class="line">  MASTER_PORT=3306,</span><br><span class="line">  MASTER_LOG_FILE=<span class="string">&#x27;mysql-bin.000001&#x27;</span>,</span><br><span class="line">  MASTER_LOG_POS=1048,</span><br><span class="line">  MASTER_CONNECT_RETRY=10;</span><br><span class="line"></span><br><span class="line"><span class="comment"># db3从库启动主从线程</span></span><br><span class="line">start slave;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果上面信息错误而且执行了使用以下办法</span></span><br><span class="line">stop slve;</span><br><span class="line">reset slave all;</span><br><span class="line">change master to...</span><br><span class="line">start slave;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查主从情况 db3从库执行</span></span><br><span class="line">show slave status\G</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">               Slave_IO_State: Waiting <span class="keyword">for</span> master to send event</span><br><span class="line">                  Master_Host: 192.168.0.12</span><br><span class="line">                  Master_User: repl</span><br><span class="line">                  Master_Port: 3306</span><br><span class="line">                Connect_Retry: 10</span><br><span class="line">              Master_Log_File: mysql-bin.000001</span><br><span class="line">          Read_Master_Log_Pos: 1048</span><br><span class="line">               Relay_Log_File: db3-relay-bin.000002</span><br><span class="line">                Relay_Log_Pos: 320</span><br><span class="line">        Relay_Master_Log_File: mysql-bin.000001</span><br><span class="line">             Slave_IO_Running: Yes  <span class="comment"># 基本状态</span></span><br><span class="line">            Slave_SQL_Running: Yes  <span class="comment"># 基本状态</span></span><br><span class="line">                         ......</span><br></pre></td></tr></table></figure>

<h3 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h3><h5 id="涉及到的文件及线程"><a href="#涉及到的文件及线程" class="headerlink" title="涉及到的文件及线程"></a>涉及到的文件及线程</h5>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 文件</span><br><span class="line">主库: binlog</span><br><span class="line">从库:</span><br><span class="line">  relay-log          # 中继日志</span><br><span class="line">  master.info        # 主库信息记录日志</span><br><span class="line">  relay-log.info     # 记录中继应用情况信息</span><br><span class="line"></span><br><span class="line"># 线程</span><br><span class="line">主库:</span><br><span class="line">  binlog_dump_thread  # 二进制日志投递线程</span><br><span class="line">  show processlist;  # 可以查看到 Binlog Dump</span><br><span class="line">从库:</span><br><span class="line">  IO_Thread  # 从库IO线程，请求和接收binlog</span><br><span class="line">  SQL_Thread  # 从库SQL线程，回放日志</span><br></pre></td></tr></table></figure>

<h5 id="主从复制原理-1"><a href="#主从复制原理-1" class="headerlink" title="主从复制原理"></a>主从复制原理</h5>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. change master to 时，ip pot user password binlog position写入到master.info进行记录</span><br><span class="line">2. start slave 时，从库会启动IO线程和SQL线程</span><br><span class="line">3. IO_T，读取master.info信息，获取主库信息连接主库</span><br><span class="line">4. 主库会生成一个准备binlog DUMP线程，来响应从库</span><br><span class="line">5. IO_T根据master.info记录的binlog文件名和position号，请求主库DUMP最新日志</span><br><span class="line">6. DUMP线程检查主库的binlog日志，如果有新的，TP(传送)给从从库的IO_T</span><br><span class="line">7. IO_T将收到的日志存储到了TCP/IP 缓存，立即返回ACK给主库 ，主库工作完成</span><br><span class="line">8. IO_T将缓存中的数据，存储到relay-log日志文件,更新master.info文件binlog 文件名和postion，IO_T工作完成</span><br><span class="line">9. SQL_T读取relay-log.info文件，获取到上次执行到的relay-log的位置，作为起点，回放relay-log</span><br><span class="line">10.SQL_T回放完成之后，会更新relay-log.info文件。</span><br><span class="line">11.relay-log会有自动清理的功能。</span><br><span class="line"></span><br><span class="line">细节：</span><br><span class="line">1.主库一旦有新的日志生成，会发送“信号”给binlog dump ，IO线程再请求</span><br></pre></td></tr></table></figure>
<p>  <img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/ApDem6.jpg" alt="ApDem6"></p>
<h3 id="主从复制监控信息"><a href="#主从复制监控信息" class="headerlink" title="主从复制监控信息"></a>主从复制监控信息</h3>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 主从监控</span><br><span class="line">    # 主库</span><br><span class="line">    # 查看连接情况，每个从库都会有一行dump相关的信息</span><br><span class="line">    show processlist;</span><br><span class="line"></span><br><span class="line">		# 从库</span><br><span class="line">		show slave status \G</span><br><span class="line">	  </span><br><span class="line">	  # 详细信息说明: </span><br><span class="line">        # 主库的信息(master.info)</span><br><span class="line">        Master_Host: 192.168.0.12          # 主库的IP</span><br><span class="line">        Master_User: repl                  # 复制用户名</span><br><span class="line">        Master_Port: 3306                  # 主库的端口</span><br><span class="line">        Connect_Retry: 10                  # 断连之后的重试次数</span><br><span class="line">        Master_Log_File: mysql-bin.000001  # 已经获取到的binlog的文件名</span><br><span class="line">        Read_Master_Log_Pos: 1301          # 已经获取到的binlog的位置号</span><br><span class="line">        </span><br><span class="line">        # 从库 relay-log.info 信息</span><br><span class="line">        Relay_Log_File: db3-relay-bin.000002  # 从库已经运行过的relaylog的文件名</span><br><span class="line">        Relay_Log_Pos: 573                    # 从库已经运行过的relaylog的位置点</span><br><span class="line">        </span><br><span class="line">        # 从库复制线程工作状态</span><br><span class="line">        Slave_IO_Running: Yes</span><br><span class="line">        Slave_SQL_Running: Yes</span><br><span class="line">        </span><br><span class="line">        # 过滤复制相关的状态</span><br><span class="line">        Replicate_Do_DB:</span><br><span class="line">        Replicate_Ignore_DB:</span><br><span class="line">        Replicate_Do_Table:</span><br><span class="line">        Replicate_Ignore_Table:</span><br><span class="line">        Replicate_Wild_Do_Table:</span><br><span class="line">        Replicate_Wild_Ignore_Table:</span><br><span class="line">        </span><br><span class="line">        # 从库延时主库的时间(非人为)</span><br><span class="line">        Seconds_Behind_Master: 0  # 从库延时主库的时间(单位为秒)</span><br><span class="line">        </span><br><span class="line">        # 延时从库有关状态</span><br><span class="line">        SQL_Delay: 0              # 延时从库设定的时间</span><br><span class="line">        SQL_Remaining_Delay: NULL # 延时操作剩余时间</span><br><span class="line">        </span><br><span class="line">        # 从库线程报错详细信息</span><br><span class="line">        Last_IO_Errno: 0         # IO报错的号码</span><br><span class="line">        Last_IO_Error:           # IO报错的具体信息</span><br><span class="line">        Last_SQL_Errno: 0        # SQL报错的号码</span><br><span class="line">        Last_SQL_Error:          # SQL报错具体信息</span><br><span class="line">        </span><br><span class="line">        # GTID复制信息</span><br><span class="line">        Retrieved_Gtid_Set:      # 接收的GTID的个数</span><br><span class="line">        Executed_Gtid_Set:       # 执行的GTID的个数</span><br><span class="line">        Auto_Position: 0</span><br></pre></td></tr></table></figure>





<h3 id="主从故障分析处理"><a href="#主从故障分析处理" class="headerlink" title="主从故障分析处理"></a>主从故障分析处理</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 连接主库</span></span><br><span class="line">(1) 用户 密码  IP  port</span><br><span class="line">	Last_IO_Error: error reconnecting to master <span class="string">&#x27;repl@10.0.0.51:3307&#x27;</span> - retry-time: 10  retries: 7</span><br><span class="line">	ERROR 1045 (28000): Access denied <span class="keyword">for</span> user <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;db01&#x27;</span> (using password: YES)</span><br><span class="line">  原因:密码错误、用户错误、地址错误、端口</span><br><span class="line">		  skip_name_resolve</span><br><span class="line">		  ERROR 2003 (HY000): Can<span class="string">&#x27;t connect to MySQL server on &#x27;</span>10.0.0.52<span class="string">&#x27; (113)</span></span><br><span class="line"><span class="string">	处理方法:</span></span><br><span class="line"><span class="string">		stop  slave  </span></span><br><span class="line"><span class="string">		reset slave all </span></span><br><span class="line"><span class="string">		change master to </span></span><br><span class="line"><span class="string">		start slave</span></span><br><span class="line"><span class="string">		</span></span><br><span class="line"><span class="string">(2) 主库连接数上线,或者是主库太繁忙</span></span><br><span class="line"><span class="string">	show slave  staus \G </span></span><br><span class="line"><span class="string">	Last_IO_Errno: 1040</span></span><br><span class="line"><span class="string">  Last_IO_Error: error reconnecting to master &#x27;</span>repl@10.0.0.51:3307<span class="string">&#x27; - retry-time: 10  retries: 7</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">	处理思路:</span></span><br><span class="line"><span class="string">		拿复制用户,手工连接一下: mysql -urepl -p123 -h 10.0.0.51 -P 3307 </span></span><br><span class="line"><span class="string">		ERROR 1040 (HY000): Too many connections</span></span><br><span class="line"><span class="string">	处理方法:</span></span><br><span class="line"><span class="string">			set global max_connections=300;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(3)防火墙,网络不通</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># 请求二进制日志</span></span><br><span class="line"><span class="string">	主库缺失日志</span></span><br><span class="line"><span class="string">	从库方面,二进制日志位置点不对</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Last_IO_Error: Got fatal error 1236 from master when reading data from binary log: &#x27;</span>could not find next <span class="built_in">log</span>; the first event <span class="string">&#x27;mysql-bin.000001&#x27;</span> at 154, the last event <span class="built_in">read</span> from <span class="string">&#x27;/data/3307/data/mysql-bin.000002&#x27;</span> at 154, the last byte <span class="built_in">read</span> from <span class="string">&#x27;/data/3307/data/mysql-bin.000002&#x27;</span> at 154.<span class="string">&#x27;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">注意: 在主从复制环境中,严令禁止主库中reset master; 可以选择expire 进行定期清理主库二进制日志</span></span><br><span class="line"><span class="string">解决方案: 重新构建主从</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># SQL 线程故障</span></span><br><span class="line"><span class="string">(1)读写relay-log.info </span></span><br><span class="line"><span class="string">(2)relay-log损坏,断节,找不到</span></span><br><span class="line"><span class="string">(3)接收到的SQL无法执行</span></span><br><span class="line"><span class="string">	0. SQL_MODE影响</span></span><br><span class="line"><span class="string">	1.要创建的数据库对象,已经存在</span></span><br><span class="line"><span class="string">	2.要删除或修改的对象不存在	</span></span><br><span class="line"><span class="string">	3.DML语句不符合表定义及约束时.</span></span><br><span class="line"><span class="string">	</span></span><br><span class="line"><span class="string">归根揭底的原因都是由于从库发生了写入操作</span></span><br><span class="line"><span class="string">Last_SQL_Error: Error &#x27;</span>Can<span class="string">&#x27;t create database &#x27;</span>db<span class="string">&#x27;; database exists&#x27;</span> on query. Default database: <span class="string">&#x27;db&#x27;</span>. Query: <span class="string">&#x27;create database db&#x27;</span></span><br><span class="line"></span><br><span class="line">以下是有风险的操作:处理方法(以从库为核心的处理方案)：</span><br><span class="line">stop slave; </span><br><span class="line"><span class="built_in">set</span> global sql_slave_skip_counter = 1;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将同步指针向下移动一个，如果多次不同步，可以重复操作</span></span><br><span class="line">start slave;</span><br><span class="line"></span><br><span class="line">/etc/my.cnf</span><br><span class="line">slave-skip-errors = 1032,1062,1007</span><br><span class="line"></span><br><span class="line">1007:对象已存在</span><br><span class="line">1032:无法执行DML</span><br><span class="line">1062:主键冲突,或约束冲突</span><br><span class="line"></span><br><span class="line">但是，以上操作有时是有风险的，最安全的做法就是重新构建主从，把握一个原则,一切以主库为主</span><br><span class="line">一劳永逸的方法:可以设置从库只读</span><br><span class="line">show variables like <span class="string">&#x27;%read_only%&#x27;</span>;</span><br></pre></td></tr></table></figure>




<h3 id="主从延时原因分析"><a href="#主从延时原因分析" class="headerlink" title="主从延时原因分析"></a>主从延时原因分析</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从库延时主库的时间</span><br><span class="line">Seconds_Behind_Master: 0   # 从库延时主库的时间（秒为单位）</span><br><span class="line"></span><br><span class="line"># 主库方面：</span><br><span class="line">  1.日志写入不及时，解决参数(双一标准): sync_binlog=1;</span><br><span class="line">  2.主库并发业务较高，使用分布式架构</span><br><span class="line">  4.从库太多，使用级联主从</span><br><span class="line">  </span><br><span class="line">对于Classic Replication: 主库是有能力并发运行事务的，但是在Dump_T在传输日志的时候，是以事件为单元传输日志的，所以导致事务的传输工作是串行方式的，这时在主库TPS很高时，会产生比较大的主从延时</span><br><span class="line">解决办法: group commit</span><br><span class="line">从5.6开始加入了GTID，在复制时，可以将原来串行的传输模式变成并行的，除了GTID支持，还需要双一保证</span><br><span class="line"></span><br><span class="line"># 从库方面	</span><br><span class="line">Classic Replication</span><br><span class="line">SQL 线程只有一个，所以说只能串行执行relay的事务</span><br><span class="line">可以多加几个SQL线程</span><br><span class="line"></span><br><span class="line">在5.6中出现了database级别的多线程SQL </span><br><span class="line">只能针对不同库下的事务，才能并发</span><br><span class="line">到5.7版本加入了MTS ，真正实现了事务级别的并发SQL</span><br></pre></td></tr></table></figure>

<h3 id="延时从库"><a href="#延时从库" class="headerlink" title="延时从库"></a>延时从库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 数据损坏 </span><br><span class="line">  物理损坏</span><br><span class="line">  逻辑损坏</span><br><span class="line">  对于传统的主从复制，比较擅长处理物理损坏</span><br><span class="line">  </span><br><span class="line"># 设计理念</span><br><span class="line">  对SQL线程进行延时设置 </span><br><span class="line"></span><br><span class="line"># 延时多久合适</span><br><span class="line">  一般企业，延时3-6小时</span><br><span class="line"></span><br><span class="line"># 如何设置</span><br><span class="line">stop slave;</span><br><span class="line">CHANGE MASTER TO MASTER_DELAY = 300;</span><br><span class="line">start slave;</span><br><span class="line">show slave status \G</span><br><span class="line">  ......</span><br><span class="line">  SQL_Delay: 300</span><br><span class="line">  SQL_Remaining_Delay: NULL</span><br><span class="line">  ......</span><br><span class="line"></span><br><span class="line"># 如何使用延时从库</span><br><span class="line">  # 模拟故障</span><br><span class="line">    create database  delay charset utf8mb4;</span><br><span class="line">    use delay;</span><br><span class="line">    create table t1(id int);</span><br><span class="line">    insert into t1 values(1),(2),(3);</span><br><span class="line">    commit; </span><br><span class="line">    drop database delay;</span><br><span class="line"></span><br><span class="line">  # 问题</span><br><span class="line">  1. 停止SQL线程，停止主库业务</span><br><span class="line">  2. 模拟SQL手工恢复relaylog到drop之前的位置点</span><br><span class="line">  3. 截取relaylog日志，找到起点（relay-log.info）和终点(drop 操作)</span><br><span class="line">  4. 恢复截取的日志，验证数据可用性</span><br><span class="line"></span><br><span class="line">  # 开始处理</span><br><span class="line">  1. 停从库的SQL线程 </span><br><span class="line">  		stop slave sql_thread;</span><br><span class="line"></span><br><span class="line">  2. 找relaylog的起点和终点</span><br><span class="line">      # 起点</span><br><span class="line">      Relay_Log_File: db01-relay-bin.000002</span><br><span class="line">      Relay_Log_Pos: 476</span><br><span class="line"></span><br><span class="line">      # 终点</span><br><span class="line">      show relaylog events in &#x27;db01-relay-bin.000002&#x27;</span><br><span class="line">      | db01-relay-bin.000002 | 1149 | Query          |         7 |        2036 | drop database delay  </span><br><span class="line"></span><br><span class="line">  3. 截取日志 </span><br><span class="line">  mysqlbinlog --start-position=476 --stop-position=1149 /data/3308/data/db01-relay-bin.000002 &gt;/tmp/relay.sql</span><br><span class="line"></span><br><span class="line">  4. 恢复 </span><br><span class="line">  set sql_log_bin=0;</span><br><span class="line">  source /tmp/relay.sql</span><br></pre></td></tr></table></figure>





<h3 id="过滤复制"><a href="#过滤复制" class="headerlink" title="过滤复制"></a>过滤复制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 主库(有弊端)</span><br><span class="line">show master status;</span><br><span class="line">binlog_do_db</span><br><span class="line">binlog_ignore_db </span><br><span class="line"></span><br><span class="line"># 从库</span><br><span class="line">show slave status\G</span><br><span class="line">  # 库级别</span><br><span class="line">  Replicate_Do_DB:</span><br><span class="line">  Replicate_Ignore_DB:</span><br><span class="line"></span><br><span class="line">  # 表级别</span><br><span class="line">  Replicate_Do_Table:</span><br><span class="line">  Replicate_Ignore_Table:</span><br><span class="line"></span><br><span class="line">  # 模糊匹配</span><br><span class="line">  Replicate_Wild_Do_Table:</span><br><span class="line">  Replicate_Wild_Ignore_Table:</span><br><span class="line">  </span><br><span class="line"># 实现: 只需要复制xyz库的数据到从库</span><br><span class="line">  vim /etc/my.cnf</span><br><span class="line">  [mysqld]</span><br><span class="line">  ...</span><br><span class="line">  replicate_do_db=xyz</span><br><span class="line">  ...</span><br><span class="line">  </span><br><span class="line">  #  检查</span><br><span class="line">  show slave status\G</span><br><span class="line">  Replicate_Do_DB: xyz</span><br></pre></td></tr></table></figure>

<h3 id="半同步复制"><a href="#半同步复制" class="headerlink" title="半同步复制"></a>半同步复制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">解决主从数据一致性问题</span><br><span class="line"></span><br><span class="line"># 原理</span><br><span class="line">1. 主库执行新的事务,commit时,更新 show master  status\G ,触发一个信号给</span><br><span class="line">2. binlog dump 接收到主库的 show master status\G信息,通知从库日志更新了</span><br><span class="line">3. 从库IO线程请求新的二进制日志事件</span><br><span class="line">4. 主库会通过dump线程传送新的日志事件,给从库IO线程</span><br><span class="line">5. 从库IO线程接收到binlog日志,当日志写入到磁盘上的relaylog文件时,给主库ACK_receiver线程</span><br><span class="line">6. ACK_receiver线程触发一个事件,告诉主库commit可以成功了</span><br><span class="line">7. 如果ACK达到了我们预设值的超时时间,半同步复制会切换为原始的异步复制</span><br><span class="line"></span><br><span class="line"># 配置</span><br><span class="line"># 加载插件</span><br><span class="line">  主:</span><br><span class="line">  INSTALL PLUGIN rpl_semi_sync_master SONAME &#x27;semisync_master.so&#x27;;</span><br><span class="line">  从:</span><br><span class="line">  INSTALL PLUGIN rpl_semi_sync_slave SONAME &#x27;semisync_slave.so&#x27;;</span><br><span class="line"></span><br><span class="line"># 查看是否加载成功</span><br><span class="line">  show plugins;</span><br><span class="line"></span><br><span class="line"># 启动</span><br><span class="line">  主:</span><br><span class="line">  SET GLOBAL rpl_semi_sync_master_enabled = 1;</span><br><span class="line">  从:</span><br><span class="line">  SET GLOBAL rpl_semi_sync_slave_enabled = 1;</span><br><span class="line"></span><br><span class="line"># 重启从库上的IO线程</span><br><span class="line">  STOP SLAVE IO_THREAD;</span><br><span class="line">  START SLAVE IO_THREAD;</span><br><span class="line"></span><br><span class="line"># 查看是否在运行</span><br><span class="line">  主:</span><br><span class="line">  show status like &#x27;Rpl_semi_sync_master_status&#x27;;</span><br><span class="line">  从:</span><br><span class="line">  show status like &#x27;Rpl_semi_sync_slave_status&#x27;;</span><br></pre></td></tr></table></figure>




<h3 id="GTID复制"><a href="#GTID复制" class="headerlink" title="GTID复制"></a><code>GTID</code>复制</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># GTID介绍</span><br><span class="line">GTID(Global Transaction ID)是对于一个已提交事务的唯一编号，并且是一个全局(主从复制)唯一的编号</span><br><span class="line">它的官方定义如下：</span><br><span class="line">GTID = source_id ：transaction_id</span><br><span class="line">7E11FA47-31CA-19E1-9E56-C43AA21293967:29</span><br><span class="line">核心特性: 全局唯一,具备幂等性</span><br><span class="line"></span><br><span class="line"># 核心参数</span><br><span class="line">gtid-mode=on                        # 启用gtid类型，否则就是普通的复制架构</span><br><span class="line">enforce-gtid-consistency=true       # 强制GTID的一致性</span><br><span class="line">log-slave-updates=1                 # slave更新是否记入日志</span><br><span class="line"></span><br><span class="line"># 配置GTID复制过程</span><br><span class="line"># 主库db01配置文件</span><br><span class="line">cat &gt; /etc/my.cnf &lt;&lt;EOF</span><br><span class="line">[mysqld]</span><br><span class="line">basedir=/application/mysql/</span><br><span class="line">datadir=/data/mysql/data</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">server_id=51</span><br><span class="line">port=3306</span><br><span class="line">secure-file-priv=/tmp</span><br><span class="line">autocommit=0</span><br><span class="line">log_bin=/data/binlog/mysql-bin</span><br><span class="line">binlog_format=row</span><br><span class="line">gtid-mode=on</span><br><span class="line">enforce-gtid-consistency=true</span><br><span class="line">log-slave-updates=1</span><br><span class="line">[mysql]</span><br><span class="line">prompt=db01 [\\d]&gt;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 从库db02配置文件</span><br><span class="line">cat &gt; /etc/my.cnf &lt;&lt;EOF</span><br><span class="line">[mysqld]</span><br><span class="line">basedir=/application/mysql</span><br><span class="line">datadir=/data/mysql/data</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">server_id=52</span><br><span class="line">port=3306</span><br><span class="line">secure-file-priv=/tmp</span><br><span class="line">autocommit=0</span><br><span class="line">log_bin=/data/binlog/mysql-bin</span><br><span class="line">binlog_format=row</span><br><span class="line">gtid-mode=on</span><br><span class="line">enforce-gtid-consistency=true</span><br><span class="line">log-slave-updates=1</span><br><span class="line">[mysql]</span><br><span class="line">prompt=db02 [\\d]&gt;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 从库db03配置文件</span><br><span class="line">cat &gt; /etc/my.cnf &lt;&lt;EOF</span><br><span class="line">[mysqld]</span><br><span class="line">basedir=/application/mysql</span><br><span class="line">datadir=/data/mysql/data</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">server_id=53</span><br><span class="line">port=3306</span><br><span class="line">secure-file-priv=/tmp</span><br><span class="line">autocommit=0</span><br><span class="line">log_bin=/data/binlog/mysql-bin</span><br><span class="line">binlog_format=row</span><br><span class="line">gtid-mode=on</span><br><span class="line">enforce-gtid-consistency=true</span><br><span class="line">log-slave-updates=1</span><br><span class="line">[mysql]</span><br><span class="line">prompt=db03 [\\d]&gt;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"># 初始化数据(所有节点)</span><br><span class="line">mysqld --initialize-insecure --user=mysql --basedir=/application/mysql  --datadir=/data/mysql/data </span><br><span class="line"></span><br><span class="line"># 启动数据库</span><br><span class="line">/etc/init.d/mysqld start	</span><br><span class="line">		</span><br><span class="line"># 主库创建用户</span><br><span class="line">grant replication slave on *.* to repl@&#x27;10.0.0.%&#x27; identified by &#x27;123&#x27;;</span><br><span class="line"></span><br><span class="line"># 两个从库开启主从</span><br><span class="line">mysql -e &quot;change master to master_host=&#x27;10.0.0.51&#x27;,master_user=&#x27;repl&#x27;,master_password=&#x27;123&#x27;,MASTER_AUTO_POSITION=1;start slave;&quot;</span><br><span class="line">mysql -e &quot;show slave status \G&quot;|grep Y</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL备份恢复与迁移</title>
    <url>/2c2a11ca.html</url>
    <content><![CDATA[<h3 id="数据库备份恢复职责"><a href="#数据库备份恢复职责" class="headerlink" title="数据库备份恢复职责"></a>数据库备份恢复职责</h3><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 备份策略</span><br><span class="line">全备、增量、时间、自动</span><br><span class="line"></span><br><span class="line"># 日常备份检查</span><br><span class="line">备份存在性</span><br><span class="line">备份空间够用否</span><br><span class="line"></span><br><span class="line"># 定期恢复演练(测试库)</span><br><span class="line">一季度 或者 半年</span><br><span class="line"></span><br><span class="line"># 故障恢复</span><br><span class="line">通过现有备份,能够将数据库恢复到故障之前的时间点</span><br><span class="line"></span><br><span class="line"># 迁移</span><br><span class="line">1. 停机时间</span><br><span class="line">2. 回退方案</span><br></pre></td></tr></table></figure>

<h3 id="备份类型"><a href="#备份类型" class="headerlink" title="备份类型"></a>备份类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 热备</span><br><span class="line">在数据库正常业务时,备份数据,并且能够一致性恢复（只能是innodb）</span><br><span class="line">对业务影响非常小</span><br><span class="line"></span><br><span class="line"># 温备</span><br><span class="line">锁表备份,只能查询不能修改（myisam）</span><br><span class="line">影响到写入操作</span><br><span class="line"></span><br><span class="line"># 冷备</span><br><span class="line">关闭数据库业务,数据库没有任何变更的情况下,进行备份数据.</span><br><span class="line">业务停止</span><br></pre></td></tr></table></figure>

<h3 id="备份方式及工具"><a href="#备份方式及工具" class="headerlink" title="备份方式及工具"></a>备份方式及工具</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 逻辑备份</span><br><span class="line">基于SQL语句进行备份</span><br><span class="line">mysqldump</span><br><span class="line">mysqlbinlog</span><br><span class="line"></span><br><span class="line"># 物理备份</span><br><span class="line">基于磁盘数据文件备份</span><br><span class="line">xtrabackup(XBK) ：percona 第三方</span><br><span class="line">MySQL Enterprise Backup（MEB）</span><br><span class="line"></span><br><span class="line"># 逻辑备份与物理备份比较</span><br><span class="line">    # mysqldump</span><br><span class="line">    优点：</span><br><span class="line">    1.不需要下载安装</span><br><span class="line">    2.备份出来的是SQL，文本格式，可读性高,便于备份处理</span><br><span class="line">    3.压缩比较高，节省备份的磁盘空间</span><br><span class="line"></span><br><span class="line">    缺点：</span><br><span class="line">    4.依赖于数据库引擎，需要从磁盘把数据读出</span><br><span class="line">    然后转换成SQL进行转储，比较耗费资源，数据量大的话效率较低</span><br><span class="line">    建议：</span><br><span class="line">    100G以内的数据量级，可以使用mysqldump</span><br><span class="line">    超过TB以上，我们也可能选择的是mysqldump，配合分布式的系统</span><br><span class="line">    1EB  =1024 PB =1000000 TB</span><br><span class="line"></span><br><span class="line">    # xtrabackup</span><br><span class="line">    优点：</span><br><span class="line">    1.类似于直接cp数据文件，不需要管逻辑结构，相对来说性能较高</span><br><span class="line">    缺点：</span><br><span class="line">    2.可读性差</span><br><span class="line">    3.压缩比低，需要更多磁盘空间</span><br><span class="line">    建议：</span><br><span class="line">    &gt;100G&lt;TB</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="备份策略"><a href="#备份策略" class="headerlink" title="备份策略"></a>备份策略</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 备份方式</span><br><span class="line">全备:全库备份，备份所有数据</span><br><span class="line">增量:备份变化的数据</span><br><span class="line">逻辑备份=mysqldump+mysqlbinlog</span><br><span class="line">物理备份=xtrabackup_full+xtrabackup_incr+binlog或者xtrabackup_full+binlog</span><br><span class="line"></span><br><span class="line"># 备份周期</span><br><span class="line">根据数据量设计备份周期</span><br><span class="line">比如：周日全备，周1-周6增量</span><br><span class="line"></span><br><span class="line"># 其他: 主从复制备份</span><br></pre></td></tr></table></figure>

<h3 id="mysqldump使用"><a href="#mysqldump使用" class="headerlink" title="mysqldump使用"></a><code>mysqldump</code>使用</h3><h4 id="客户端通用命令"><a href="#客户端通用命令" class="headerlink" title="客户端通用命令"></a>客户端通用命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 和mysql通用命令</span><br><span class="line">-u  -p   -S   -h  -P    </span><br><span class="line"></span><br><span class="line"># 本地备份</span><br><span class="line">mysqldump -uroot -p  -S /tmp/mysql.sock</span><br><span class="line"></span><br><span class="line"># 远程备份</span><br><span class="line">mysqldump -uroot -p  -h 10.0.0.51 -P3306</span><br></pre></td></tr></table></figure>

<h4 id="基本备份参数"><a href="#基本备份参数" class="headerlink" title="基本备份参数"></a>基本备份参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 全库备份 -A</span><br><span class="line">    mkdir -p /data/backup</span><br><span class="line">    mysqldump -uroot -p1 -A -S /tmp/mysql.sock &gt; /data/backup/full.sql</span><br><span class="line"></span><br><span class="line"># 备份多个单库 -B</span><br><span class="line">    # 备份worldhe testdb库</span><br><span class="line">    mysqldump -uroot -p1 -B -S /tmp/mysql.sock  world testdb &gt;/data/backup/db.sql</span><br><span class="line"></span><br><span class="line"># 备份单个或多个表</span><br><span class="line">    # 备份world下的city表和country表</span><br><span class="line">    mysqldump -uroot -p1 world city country  -S /tmp/mysql.sock &gt;/backup/bak.sql</span><br><span class="line">    # 此方法只会备份建表语句和插入语句，所以恢复前需要把库建好然后 use 到库中</span><br></pre></td></tr></table></figure>

<h4 id="高级参数使用"><a href="#高级参数使用" class="headerlink" title="高级参数使用"></a>高级参数使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 必加参数</span><br><span class="line">-R                    # 在备份时，同时备份存储过程和函数，如果没有会自动忽略</span><br><span class="line">-E                    # 在备份时，同时备份EVENT，如果没有会自动忽略</span><br><span class="line">--triggers            # 在备份时，同时备份触发器，如果没有会自动忽略</span><br><span class="line"></span><br><span class="line">--master-data=2       # 记录备份开始时记录position号，可以作为将来做日志截取的起点</span><br><span class="line">    功能:</span><br><span class="line">    (1)在备份时，会自动记录，二进制日志文件名和位置号</span><br><span class="line">        参数有:</span><br><span class="line">            0 默认值</span><br><span class="line">            1  以change master to命令形式，可以用作主从复制</span><br><span class="line">            2  以注释的形式记录，备份时刻的文件名+postion号</span><br><span class="line">    (2)自动锁表</span><br><span class="line">    (3)如果配合 --single-transaction ，只对非InnoDB表进行锁表备份，InnoDB表进行“热“”备，实际上是实现快照备份</span><br><span class="line"></span><br><span class="line">--single-transaction  # 存储引擎开启热备(快照备份)功能</span><br><span class="line">		功能:</span><br><span class="line">		使用 master-data 参数时</span><br><span class="line">    (1)在不加 --single-transaction ,启动所有表的温备份,所有表都锁定</span><br><span class="line">    (2)加上 --single-transaction ,对innodb进行快照备份,对非innodb表可以实现自动锁表功能</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"># 其他参数 了解功能即可</span><br><span class="line">-F  # 在备份开始时,刷新一个新binlog日志，刷新的个数较多，一个库一个</span><br><span class="line"></span><br><span class="line">--set-gtid-purged=auto</span><br><span class="line"># 参数:</span><br><span class="line">    auto  # 默认参数</span><br><span class="line">    on</span><br><span class="line">    off</span><br><span class="line"># 使用场景</span><br><span class="line">1. --set-gtid-purged=OFF,可以使用在日常备份参数中</span><br><span class="line">mysqldump -uroot -p -A -R -E --triggers --master-data=2 --single-transaction --set-gtid-purged=OFF &gt;/data/backup/full.sql</span><br><span class="line">2. auto , on:在构建主从复制环境时需要的参数配置</span><br><span class="line">mysqldump -uroot -p -A -R -E --triggers --master-data=2 --single-transaction --set-gtid-purged=ON &gt;/data/backup/full.sql</span><br><span class="line"></span><br><span class="line">--max-allowed-packet=#  # 表特别大时设置参数避免超出大小</span><br><span class="line">mysqldump -uroot -p -A -R -E --triggers --master-data=2 --single-transaction --set-gtid-purged=OFF --max-allowed-packet=256M &gt;/data/backup/full.sql</span><br></pre></td></tr></table></figure>

<h4 id="备份及恢复"><a href="#备份及恢复" class="headerlink" title="备份及恢复"></a>备份及恢复</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 备份语句</span><br><span class="line">mysqldump -uroot -p1 -A -R -E --triggers --master-data=2 --single-transaction --set-gtid-purged=OFF &gt;/data/backup/full.sql</span><br><span class="line"></span><br><span class="line"># 恢复</span><br><span class="line">mysqldump备份的恢复方式（在生产中恢复要谨慎，恢复会删除重复的表）</span><br><span class="line">set sql_log_bin=0;</span><br><span class="line">source /backup/full_2018-06-28.sql</span><br><span class="line"></span><br><span class="line"># 压缩版</span><br><span class="line">mysqldump -uroot -p1 -A -R -E --triggers --max-allowed-packet=128M --master-data=2 --single-transaction|gzip &gt; /data/backup/full_$(date +%F-%T).sql.gz</span><br><span class="line"></span><br><span class="line">gunzip full_2021-12-27-14:19:32.sql.gz</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line">1、mysqldump在备份和恢复时都需要mysql实例启动为前提</span><br><span class="line">2、一般数据量级100G以内，大约15-45分钟可以恢复，数据量级很大很大的时候（PB、EB）</span><br><span class="line">3、mysqldump是覆盖形式恢复的方法</span><br><span class="line"></span><br><span class="line">一般我们认为，在同数据量级，物理备份要比逻辑备份速度快</span><br><span class="line">逻辑备份的优势:</span><br><span class="line">1、可读性强</span><br><span class="line">2、压缩比很高</span><br></pre></td></tr></table></figure>

<h4 id="故障案例恢复"><a href="#故障案例恢复" class="headerlink" title="故障案例恢复"></a>故障案例恢复</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 背景</span></span><br><span class="line">正在运行的网站系统，mysql-5.7.20 数据库，数据量50G，日业务增量1-5M。</span><br><span class="line">每天23:00点，计划任务调用mysqldump执行全备脚本</span><br><span class="line">年底故障演练:模拟周三上午10点误删除数据库，并进行恢复.</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复思路</span></span><br><span class="line">1、停业务，避免数据的二次伤害</span><br><span class="line">2、找一个临时库，恢复周三23：00全备</span><br><span class="line">3、截取周二23：00  --- 周三10点误删除之间的binlog，恢复到临时库</span><br><span class="line">4、测试可用性和完整性</span><br><span class="line">5、 </span><br><span class="line">    5.1 方法一：直接使用临时库顶替原生产库，前端应用割接到新库</span><br><span class="line">    5.2 方法二：将误删除的表导出，导入到原生产库</span><br><span class="line">6、开启业务</span><br><span class="line">处理结果：经过20分钟的处理，最终业务恢复正常</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟全备之前的数据</span></span><br><span class="line">create database mbp charset utf8mb4;</span><br><span class="line">use mbp;</span><br><span class="line">create table t1 (id int);</span><br><span class="line">insert into t1 values(1),(2),(3);</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 做全备</span></span><br><span class="line">mysqldump -uroot -p1 -A -R --triggers --set-gtid-purged=OFF --master-data=2 --single-transaction&gt; /data/backup/full_$(date +%F).sql</span><br><span class="line">ls /data/backup/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟增量的数据</span></span><br><span class="line">use mbp;</span><br><span class="line">insert into t1 values(11),(22),(33);</span><br><span class="line">commit;</span><br><span class="line">create table t2 (id int);</span><br><span class="line">insert into t2 values(11),(22),(33);</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟数据库损害</span></span><br><span class="line">rm -rf /data/mysql/data/*</span><br><span class="line">pkill mysql</span><br><span class="line">rm -rf /data/mysql/data/*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复数据</span></span><br><span class="line"><span class="comment"># 重新初始化数据库</span></span><br><span class="line">mysqld --initialize-insecure --user=mysql --basedir=/usr/<span class="built_in">local</span>/mysql --datadir=/data/mysql/data</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动数据库</span></span><br><span class="line">service mysqld restart</span><br><span class="line"></span><br><span class="line"><span class="comment"># 全备恢复，此时没有增量的数据</span></span><br><span class="line"><span class="built_in">set</span> sql_log_bin=0;</span><br><span class="line"><span class="built_in">source</span> /data/backup/full_2021-12-27.sql;</span><br><span class="line"><span class="built_in">set</span> sql_log_bin=1;</span><br><span class="line">flush privileges;  <span class="comment"># 刷新权限，恢复账号权限等</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复增量的数据---&gt; 全备到故障时刻的数据</span></span><br><span class="line"><span class="comment"># 找日志起点和终点</span></span><br><span class="line">vim /data/backup/full_2021-12-27.sql</span><br><span class="line">CHANGE MASTER TO MASTER_LOG_FILE=<span class="string">&#x27;mysql-bin.000005&#x27;</span>, MASTER_LOG_POS=949;  <span class="comment"># 找打全备时的 binlog 日志文件，--master-data=2 参数实现的</span></span><br><span class="line"></span><br><span class="line">show binlog events <span class="keyword">in</span> <span class="string">&#x27;mysql-bin.000005&#x27;</span>;</span><br><span class="line"><span class="comment"># 下图可以看到 GTID 号应该是11-13 就是后面增量的数据信息</span></span><br><span class="line"><span class="comment"># 截取日志</span></span><br><span class="line">mysqlbinlog --skip-gtids --include-gtids=<span class="string">&#x27;b25a4cc7-609b-11ec-afea-525400aaf73e:11-13&#x27;</span> /data/binlog/mysql-bin.000005 &gt; /data/backup/bin.sql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复增量数据</span></span><br><span class="line"><span class="built_in">set</span> sql_log_bin=0;</span><br><span class="line"><span class="built_in">source</span> /data/backup/bin.sql;</span><br><span class="line"><span class="built_in">set</span> sql_log_bin=1;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查是否恢复</span></span><br><span class="line">select * from mbp.t2;</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20211227124136331.png" alt="image-20211227124136331"></p>
<h4 id="单表的恢复"><a href="#单表的恢复" class="headerlink" title="单表的恢复"></a>单表的恢复</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 从全备中导出单表备份</span><br><span class="line"># 获取表结构</span><br><span class="line">sed -e &#x27;/./&#123;H;$!d;&#125;&#x27; -e &#x27;x;/CREATE TABLE `city`/!d;q&#x27; full.sql &gt; createtable.sql</span><br><span class="line"></span><br><span class="line"># 获取INSERT INTO语句，用于数据的恢复</span><br><span class="line">grep -i &#x27;INSERT INTO `city`&#x27; full.sql &gt; data.sql</span><br><span class="line"></span><br><span class="line"># 获取单库的备份，可以直接创建库就行</span><br><span class="line">sed -n &#x27;/^-- Current Database: `world`/,/^-- Current Database: `/p&#x27; full.sql &gt; world.sql</span><br></pre></td></tr></table></figure>

<h3 id="xtrabackup使用"><a href="#xtrabackup使用" class="headerlink" title="xtrabackup使用"></a><code>xtrabackup</code>使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下载依赖</span></span><br><span class="line">wget -O /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line">yum -y install perl perl-devel libaio libaio-devel perl-Time-HiRes perl-DBD-MySQL libev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个版本只支持8.0数据库以下的，最新版本支持8.0</span></span><br><span class="line"><span class="comment"># wget https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/sql/percona-xtrabackup-24-2.4.12-1.el7.x86_64.rpm</span></span><br><span class="line">wget https://www.percona.com/downloads/XtraBackup/Percona-XtraBackup-2.4.12/binary/redhat/7/x86_64/percona-xtrabackup-24-2.4.12-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">yum -y install percona-xtrabackup-24-2.4.4-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 版本</span></span><br><span class="line">innobackupex --version</span><br></pre></td></tr></table></figure>

<h4 id="备份方式"><a href="#备份方式" class="headerlink" title="备份方式"></a>备份方式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.对于非Innodb表（比如 myisam）是，锁表cp数据文件，属于一种温备份。</span><br><span class="line">2.对于Innodb的表（支持事务的），不锁表，拷贝数据页，最终以数据文件的方式保存下来，把一部分redo和undo一并备走，属于热备方式</span><br></pre></td></tr></table></figure>

<h4 id="InnoDB表备份恢复流程"><a href="#InnoDB表备份恢复流程" class="headerlink" title="InnoDB表备份恢复流程"></a>InnoDB表备份恢复流程</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.xbk备份执行的瞬间,立即触发ckpt,已提交的数据脏页,从内存刷写到磁盘,并记录此时的LSN号</span><br><span class="line">2.备份时，拷贝磁盘数据页，并且记录备份过程中产生的redo和undo一起拷贝走,也就是checkpoint LSN之后的日志</span><br><span class="line">3.在恢复之前，模拟Innodb“自动故障恢复”的过程，将redo（前滚）与undo（回滚）进行应用</span><br><span class="line">4.恢复过程是cp 备份到原来数据目录下</span><br></pre></td></tr></table></figure>

<h4 id="innobackupex使用"><a href="#innobackupex使用" class="headerlink" title="innobackupex使用"></a><code>innobackupex</code>使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 会自动读取/etc/my.cnf 或者手动指定</span><br><span class="line">    # 配置文件修改</span><br><span class="line">    vim /etc/my.cnf</span><br><span class="line">    ...</span><br><span class="line">    [client]</span><br><span class="line">    socket=/tmp/mysql.sock</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    service mysqld restart </span><br><span class="line"></span><br><span class="line">    # 指定配置文件</span><br><span class="line">    innobackupex --defaults-file=/etc/my.cnf --user=root --password=1 /data/bak</span><br><span class="line"></span><br><span class="line"># 默认是全备</span><br><span class="line">mkdir -p /data/bak</span><br><span class="line">innobackupex --user=root --password=1 /data/bak</span><br><span class="line"></span><br><span class="line">innobackupex --defaults-file=/etc/my.cnf --user=root --password=1 --no-timestamp /data/bak/full_$(date +%F)</span><br><span class="line">--no-timestap  # 自定义备份目录名</span><br><span class="line"></span><br><span class="line"># 检查</span><br><span class="line">ls /data/bak  # 会自动以当前时间戳创建目录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 备份文件说明 </span><br><span class="line">    cat xtrabackup_binlog_info</span><br><span class="line">    mysql-bin.000010	274	5bee84cd-66ce-11ec-b1fd-525400aaf73e:1,</span><br><span class="line">    934ba059-66ca-11ec-8dce-525400aaf73e:1,</span><br><span class="line">    b25a4cc7-609b-11ec-afea-525400aaf73e:1-13</span><br><span class="line">    # 备份时刻的binlog位置</span><br><span class="line">    # 记录的是备份时刻，binlog的文件名字和当时的结束的position，可以用来作为截取binlog时的起点</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cat xtrabackup_checkpoints</span><br><span class="line">    backup_type = full-backuped</span><br><span class="line">    from_lsn = 0          # 上次所到达的LSN号(对于全备就是从0开始,对于增量有别的显示方法)</span><br><span class="line">    to_lsn = 155266303    #  备份开始时间(ckpt)点数据页的LSN    </span><br><span class="line">    last_lsn = 155266312  # 备份结束后，redo日志最终的LSN</span><br><span class="line">    compact = 0</span><br><span class="line">    recover_binlog_info = 0</span><br><span class="line">    # 备份时刻，立即将已经commit过的，内存中的数据页刷新到磁盘(CKPT).开始备份数据，数据文件的LSN会停留在to_lsn位置</span><br><span class="line">    # 备份时刻有可能会有其他的数据写入，已备走的数据文件就不会再发生变化了</span><br><span class="line">    # 在备份过程中，备份软件会一直监控着redo的undo，如果一旦有变化会将日志也一并备走，并记录LSN到last_lsn</span><br><span class="line">    # 从to_lsn ----&gt; last_lsn 就是，备份过程中产生的数据变化.</span><br><span class="line"></span><br><span class="line">    xtrabackup_info  # 整体统计</span><br><span class="line">    xtrabackup_logfile  # 部分redo日志</span><br></pre></td></tr></table></figure>

<h4 id="全备恢复"><a href="#全备恢复" class="headerlink" title="全备恢复"></a>全备恢复</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 全备</span></span><br><span class="line">innobackupex --defaults-file=/etc/my.cnf --user=root --password=1 /data/bak</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟删除(不代表生成操作)</span></span><br><span class="line">pkill mysql</span><br><span class="line">rm -rf /data/mysql/data/* </span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复步骤</span></span><br><span class="line"><span class="comment"># 准备备份(Prepared)，将redo进行重做，已提交的写到数据文件，未提交的使用undo回滚掉，模拟了CSR的过程</span></span><br><span class="line">innobackupex --apply-log  /data/bak/2021-12-27_14-51-12/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复启动</span></span><br><span class="line">cp -a /data/bak/2021-12-27_14-51-12/* /data/mysql/data/</span><br><span class="line">chown -R mysql:mysql /data/</span><br><span class="line">service mysqld restart</span><br></pre></td></tr></table></figure>

<h4 id="增量备份和恢复"><a href="#增量备份和恢复" class="headerlink" title="增量备份和恢复"></a>增量备份和恢复</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 说明</span></span><br><span class="line">(1)增量备份的方式，是基于上一次备份进行增量</span><br><span class="line">(2)增量备份无法单独恢复。必须基于全备进行恢复</span><br><span class="line">(3)所有增量必须要按顺序合并到全备中</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始模拟</span></span><br><span class="line"><span class="comment"># 全备一次</span></span><br><span class="line">innobackupex --user=root --password=1 --no-timestamp /data/bak/full_$(date +%F)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次数据变化</span></span><br><span class="line">create database xbk charset utf8mb4;</span><br><span class="line">use xbk;</span><br><span class="line">create table t1(id int);</span><br><span class="line">insert into t1 values (1),(2),(3);</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第一次数据变化的增量备份，基于全备而备份</span></span><br><span class="line">innobackupex --user=root --password=1 --no-timestamp --incremental --incremental-basedir=/data/bak/full_2021-12-27 /data/bak/inc1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次数据变化</span></span><br><span class="line">use xbk;</span><br><span class="line">create table t2(id int);</span><br><span class="line">insert into t2 values (11),(22),(33);</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二次数据变化的增量备份，基于第一次增量备份进行备份</span></span><br><span class="line">innobackupex --user=root --password=1 --no-timestamp --incremental --incremental-basedir=/data/bak/inc1 /data/bak/inc2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否备份成功，可以查看每个xtrabackup_checkpoints信息是否接上</span></span><br><span class="line"><span class="built_in">cd</span> /data/bak/</span><br><span class="line">cat full_2021-12-27/xtrabackup_checkpoints</span><br><span class="line">cat inc1/xtrabackup_checkpoints</span><br><span class="line">cat inc2/xtrabackup_checkpoints</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增量恢复</span></span><br><span class="line">合并所有的增备到全备</span><br><span class="line">每个XBK备份都需要恢复准备(prepare)</span><br><span class="line">参数:</span><br><span class="line">--apply-log </span><br><span class="line">--redo-noly</span><br><span class="line"></span><br><span class="line"><span class="comment"># 目录说明</span></span><br><span class="line">/data/bak/full_2021-12-27  <span class="comment"># 全备目录</span></span><br><span class="line">/data/bak/inc1  <span class="comment"># 第一次增备目录</span></span><br><span class="line">/data/bak/inc2  <span class="comment"># 第二次增备目录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 整理全备</span></span><br><span class="line">innobackupex --apply-log --redo-only /data/bak/full_2021-12-27 </span><br><span class="line"></span><br><span class="line"><span class="comment"># 整理并合并第一次数据变化的增量到全备</span></span><br><span class="line">innobackupex --apply-log --redo-only --incremental-dir=/data/bak/inc1 /data/bak/full_2021-12-27</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整理并合并第二次数据变化的增量到全备中</span></span><br><span class="line">innobackupex --apply-log --incremental-dir=/data/bak/inc2 /data/bak/full_2021-12-27</span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次整理全备</span></span><br><span class="line">innobackupex --apply-log /data/bak/full_2021-12-27</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模拟故障</span></span><br><span class="line">pkill mysql</span><br><span class="line">rm -rf /data/mysql/data*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 恢复</span></span><br><span class="line">cp -a /data/bak/full_2021-12-27/* /data/mysql/data/</span><br><span class="line">chown -R /data/</span><br><span class="line">service mysqld start</span><br></pre></td></tr></table></figure>

<p>检查是否增量备份成功：<br><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/40j93z.png" alt="40j93z"></p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># xtrabackup的全备目录内有表空间结构等信息</span></span><br><span class="line">ll /data/bak/full_2021-12-27/xbk/</span><br><span class="line">总用量 220</span><br><span class="line">-rw-r----- 1 mysql mysql    67 12月 27 17:10 db.opt</span><br><span class="line">-rw-r----- 1 mysql mysql  8556 12月 27 17:10 t1.frm</span><br><span class="line">-rw-r----- 1 mysql mysql 98304 12月 27 17:07 t1.ibd</span><br><span class="line">-rw-r----- 1 mysql mysql  8556 12月 27 17:10 t2.frm</span><br><span class="line">-rw-r----- 1 mysql mysql 98304 12月 27 17:10 t2.ibd</span><br><span class="line"><span class="comment"># 所以可以考虑使用迁移表空间恢复，参考 8、存储引擎 ---&gt; 迁移表空间</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生产中的备份命令</span></span><br><span class="line">innobackupex --defaults-file=/etc/my.cnf --user=root --password=1 --no-timestamp --stream=tar --use-memory=256M --parallel=2 /data/bak/full | gzip | ssh root@192.168.0.12 <span class="string">&quot;cat - &gt; /data/bak/full.tgz&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line">--stream=tar       <span class="comment"># 压缩</span></span><br><span class="line">--use-memory=256M  <span class="comment"># 开辟内存空间</span></span><br><span class="line">--parallel=8       <span class="comment"># 并发，依据CPU核心调整</span></span><br><span class="line">ssh root@192.168.0.12 <span class="string">&quot;cat - &gt; /data/bak/full.tgz&quot;</span>  <span class="comment"># 推送到 192.168.0.12 服务器上</span></span><br></pre></td></tr></table></figure>

<h3 id="MySQL数据迁移"><a href="#MySQL数据迁移" class="headerlink" title="MySQL数据迁移"></a>MySQL数据迁移</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 换主机</span><br><span class="line">    在线使用mysqldump和xtrabackup备份，传输到目标主机</span><br><span class="line">    追加所有备份后的日志</span><br><span class="line">    申请停机</span><br><span class="line">    剩余部分使用binlog继续恢复(使用主从的方式替代)</span><br><span class="line">    校验数据进行业务割接</span><br><span class="line"></span><br><span class="line">2. 换版本升级</span><br><span class="line">    5.6 ---&gt; 5.7</span><br><span class="line">    5.7 mysqld_safe mysql_upgrade</span><br><span class="line">    </span><br><span class="line">		建议使用mysqldump 逻辑备份方式，按业务库进行分别备份，排除掉information_schema,performance_schema.sys</span><br><span class="line">		恢复完成后，升级数据字典</span><br><span class="line"></span><br><span class="line">3. 异构迁移 ---&gt; 系统不一样</span><br><span class="line">4. 异构迁移 ---&gt; 数据库产品不同</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL日志管理</title>
    <url>/2386d3bc.html</url>
    <content><![CDATA[<h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><span id="more"></span>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/f262Yf.jpg" alt="f262Yf"></p>
<h3 id="错误日志-log-err"><a href="#错误日志-log-err" class="headerlink" title="错误日志(log_err)"></a>错误日志(<code>log_err</code>)</h3><ul>
<li><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">记录启动、关闭、日常运行过程中的状态信、警告、错误 </span><br></pre></td></tr></table></figure></li>
<li><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">默认开启的，默认位置在 /数据路径下/hostname.err</span><br><span class="line"></span><br><span class="line"># 自定义配置</span><br><span class="line">vim /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">...</span><br><span class="line">log_error=/data/mysql/data/mysql.log</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 重启生效</span><br><span class="line"></span><br><span class="line"># 数据库内查看错误日志文件位置</span><br><span class="line">select @@log_error;</span><br></pre></td></tr></table></figure></li>
<li><h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">主要关注[ERROR],看上下文</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="binlog-binary-logs-二进制日志"><a href="#binlog-binary-logs-二进制日志" class="headerlink" title="binlog(binary logs):二进制日志"></a><code>binlog(binary logs):</code>二进制日志</h3><h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.备份恢复必须依赖二进制日志</span><br><span class="line">2.主从环境必须依赖二进制日志</span><br></pre></td></tr></table></figure>

<h4 id="基础参数查看"><a href="#基础参数查看" class="headerlink" title="基础参数查看"></a>基础参数查看</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@log_bin;  # 开关</span><br><span class="line">select @@log_bin_basename;  # 日志路径及名字</span><br><span class="line">select @@server_id;  # 服务ID号</span><br><span class="line">select @@binlog_format;  # 二进制日志格式</span><br><span class="line">select @@sync_binlog;  # 双一标准之二</span><br><span class="line">show variables like &#x27;%log_bin%&#x27;; # mysql内查看二进制日志情况</span><br></pre></td></tr></table></figure>

<h4 id="配置开启二进制日志"><a href="#配置开启二进制日志" class="headerlink" title="配置开启二进制日志"></a>配置开启二进制日志</h4>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># MySQL默认是没有开启二进制日志的</span><br><span class="line"></span><br><span class="line"># 配置</span><br><span class="line">log_bin:    开关以及设置存放位置</span><br><span class="line">server_id:  5.6中不需要，5.7中必须加</span><br><span class="line"></span><br><span class="line">mkdir /data/binlog</span><br><span class="line">vim /etc/my.cnf</span><br><span class="line">...</span><br><span class="line">server_id=6</span><br><span class="line">log_bin=/data/binlog/mysql-bin</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">chown -R mysql.mysql /data/</span><br><span class="line">systemctl restart mysqld</span><br><span class="line"></span><br><span class="line">ls /data/binlog/</span><br><span class="line">-rw-r----- 1 mysql mysql 154 12月 24 15:10 mysql-bin.000001</span><br><span class="line">-rw-r----- 1 mysql mysql  30 12月 24 15:10 mysql-bin.index</span><br><span class="line"></span><br><span class="line"># 注意: 日志和数据分开存放(物理磁盘)</span><br></pre></td></tr></table></figure>

<h4 id="记录情况"><a href="#记录情况" class="headerlink" title="记录情况"></a>记录情况</h4>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">binlog是SQL层的功能。记录的是变更SQL语句，不记录查询语句</span><br><span class="line"></span><br><span class="line">DDL ：原封不动的记录当前DDL(statement)。</span><br><span class="line">DCL ：原封不动的记录当前DCL(statement)。</span><br><span class="line">DML ：只记录已经提交的事务DML</span><br><span class="line">三种记录方式：受binlog_format（binlog的记录格式）参数影响</span><br><span class="line"></span><br><span class="line">1. STATEMENT (5.6默认)   SBR  ：语句模式原封不动的记录当前DML            ---&gt; 行记录模式，记录行的变化</span><br><span class="line">2. ROW       (5.7默认值)	RBR  ：记录数据行的变化(用户看不懂，需要工具分析)  ---&gt; 语句记录模式，记录操作语句本身</span><br><span class="line">3. MIXED     (混合)模式  MBR  ：以上两种模式的混合                      ---&gt; 混合记录模式</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SBR与RBR模式的对比</span><br><span class="line">STATEMENT(SBR)：只记录语句本身，可读性较高，日志量少，但是不够严谨，对于函数类的操作，将来恢复时会造成错误</span><br><span class="line">ROW(RBR)      ：逐行记录日志，可读性很低，日志量大，足够严谨，不会出现记录错误</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.7默认是RBR模式，企业建议模式</span><br><span class="line"></span><br><span class="line"># 查看模式</span><br><span class="line">mysql&gt;select @@binlog_format;</span><br><span class="line"></span><br><span class="line"># 配置文件中可更改</span><br><span class="line">vim /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">...</span><br><span class="line">binlog_format=row</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h4 id="事件-event"><a href="#事件-event" class="headerlink" title="事件(event)"></a>事件(<code>event</code>)</h4><ul>
<li><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">二进制日志的最小记录单元</span><br><span class="line">对于DDL,DCL,一个语句就是一个event</span><br><span class="line">对于DML语句来讲:只记录已提交的事务</span><br><span class="line">例如以下列子,就被分为了4个event</span><br><span class="line"></span><br><span class="line">            position号码(字节偏移量，截取日志用)</span><br><span class="line">begin;      120  - 340</span><br><span class="line">DML1        340  - 460</span><br><span class="line">DML2        460  - 550</span><br><span class="line">commit;     550  - 760</span><br></pre></td></tr></table></figure></li>
<li><h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">三部分构成:</span><br><span class="line">(1) 事件的开始标识</span><br><span class="line">(2) 事件内容</span><br><span class="line">(3) 事件的结束标识</span><br><span class="line"></span><br><span class="line">Position:</span><br><span class="line">开始标识: at 194</span><br><span class="line">结束标识: end_log_pos 254</span><br><span class="line"></span><br><span class="line">194? 254?</span><br><span class="line">某个事件在binlog中的相对位置号</span><br><span class="line">位置号的作用是为了方便我们截取事件</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="日志文件的查看"><a href="#日志文件的查看" class="headerlink" title="日志文件的查看"></a>日志文件的查看</h4><ul>
<li><h5 id="简单查看"><a href="#简单查看" class="headerlink" title="简单查看"></a>简单查看</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看二进制日志位置</span><br><span class="line">show variables like &#x27;%log_bin%&#x27;;</span><br><span class="line"></span><br><span class="line">ll /data/binlog/</span><br><span class="line">-rw-r----- 1 mysql mysql 154 12月 24 15:10 mysql-bin.000001</span><br><span class="line">-rw-r----- 1 mysql mysql  30 12月 24 15:10 mysql-bin.index</span><br><span class="line"></span><br><span class="line"># 查看正在使用的二进制</span><br><span class="line">show binary logs;</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| Log_name         | File_size |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">| mysql-bin.000001 |       154 |</span><br><span class="line">+------------------+-----------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">Log_name: 目前MySQL存在的二进制日志名字</span><br><span class="line">File_size: 目前MySQL用到哪个Position号，使用的是最后一个文件</span><br><span class="line">Position：最后一个事件的结束位置号</span><br><span class="line"></span><br><span class="line"># 二进制文件会增加一个</span><br><span class="line">flush logs;</span><br><span class="line"></span><br><span class="line"># 查看正在使用的二进制文件</span><br><span class="line">show master status;</span><br><span class="line">+------------------+----------+--------------+------------------+------------------------------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                        |</span><br><span class="line">+------------------+----------+--------------+------------------+------------------------------------------+</span><br><span class="line">| mysql-bin.000003 |      154 |              |                  | 269f1ac3-8d95-11e9-8dc4-000c297969b7:1-7 |</span><br><span class="line">+------------------+----------+--------------+------------------+------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br></pre></td></tr></table></figure></li>
<li><h4 id="内容查看binlog文件内容"><a href="#内容查看binlog文件内容" class="headerlink" title="内容查看binlog文件内容"></a>内容查看<code>binlog</code>文件内容</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看二进制日志文件</span><br><span class="line"># 先查看正在使用的二进制文件</span><br><span class="line">show master status;</span><br><span class="line">+------------------+----------+--------------+------------------+------------------------------------------+</span><br><span class="line">| File             | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set                        |</span><br><span class="line">+------------------+----------+--------------+------------------+------------------------------------------+</span><br><span class="line">| mysql-bin.000003 |      154 |              |                  | 269f1ac3-8d95-11e9-8dc4-000c297969b7:1-7 |</span><br><span class="line">+------------------+----------+--------------+------------------+------------------------------------------+</span><br><span class="line">1 row in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 根据当前使用的二进制日志再查看当前的event</span><br><span class="line">show binlog events in &#x27;mysql-bin.000003&#x27;;</span><br><span class="line">+------------------+-----+----------------+-----------+-------------+---------------------------------------+</span><br><span class="line">| Log_name         | Pos | Event_type     | Server_id | End_log_pos | Info                                  |</span><br><span class="line">+------------------+-----+----------------+-----------+-------------+---------------------------------------+</span><br><span class="line">| mysql-bin.000003 |   4 | Format_desc    |         6 |         123 | Server ver: 5.7.31-log, Binlog ver: 4 |</span><br><span class="line">| mysql-bin.000003 | 123 | Previous_gtids |         6 |         154 |                                       |</span><br><span class="line">+------------------+-----+----------------+-----------+-------------+---------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 查看最开始的日志文件及说明</span><br><span class="line">show binlog events in &#x27;mysql-bin.000001&#x27;;</span><br><span class="line">+------------------+-----+----------------+-----------+-------------+---------------------------------------+</span><br><span class="line">| Log_name         | Pos | Event_type     | Server_id | End_log_pos | Info                                  |</span><br><span class="line">+------------------+-----+----------------+-----------+-------------+---------------------------------------+</span><br><span class="line">| mysql-bin.000001 |   4 | Format_desc    |         6 |         123 | Server ver: 5.7.31-log, Binlog ver: 4 |</span><br><span class="line">| mysql-bin.000001 | 123 | Previous_gtids |         6 |         154 |                                       |</span><br><span class="line">| mysql-bin.000001 | 154 | Rotate         |         6 |         201 | mysql-bin.000002;pos=4                |</span><br><span class="line">+------------------+-----+----------------+-----------+-------------+---------------------------------------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line">Pos 4 是保留字段</span><br><span class="line">Pos 154 是日志文件头格式信息(5.7版本是154个字节，5.6版本是前120个字节)  </span><br><span class="line">每一行都是一个事件</span><br><span class="line"></span><br><span class="line"># 说明</span><br><span class="line">Log_name    : 日志名    </span><br><span class="line">Pos         : 事件开始的Position</span><br><span class="line">Event_type  : 事件类型</span><br><span class="line">Server_id   : 发生在哪台机器的事件</span><br><span class="line">End_log_pos : 事件结束的位置</span><br><span class="line">Info        : 事件内容</span><br><span class="line"></span><br><span class="line"># 录入信息查看事件信息</span><br><span class="line"># 没录入信息之前</span><br><span class="line">show binlog events in &#x27;mysql-bin.000003&#x27;;</span><br><span class="line">+------------------+-----+----------------+-----------+-------------+---------------------------------------+</span><br><span class="line">| Log_name         | Pos | Event_type     | Server_id | End_log_pos | Info                                  |</span><br><span class="line">+------------------+-----+----------------+-----------+-------------+---------------------------------------+</span><br><span class="line">| mysql-bin.000003 |   4 | Format_desc    |         6 |         123 | Server ver: 5.7.31-log, Binlog ver: 4 |</span><br><span class="line">| mysql-bin.000003 | 123 | Previous_gtids |         6 |         154 |                                       |</span><br><span class="line">+------------------+-----+----------------+-----------+-------------+---------------------------------------+</span><br><span class="line">2 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 创建数据以及插入数据提交</span><br><span class="line">create database testdb;</span><br><span class="line">use testdb;</span><br><span class="line">create table t1(id int);</span><br><span class="line">insert into t1 values(1);</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line"># 查看录入数据之后的情况</span><br><span class="line">show binlog events in &#x27;mysql-bin.000003&#x27;;</span><br><span class="line">+------------------+-----+----------------+-----------+-------------+---------------------------------------+</span><br><span class="line">| Log_name         | Pos | Event_type     | Server_id | End_log_pos | Info                                  |</span><br><span class="line">+------------------+-----+----------------+-----------+-------------+---------------------------------------+</span><br><span class="line">| mysql-bin.000003 |   4 | Format_desc    |         6 |         123 | Server ver: 5.7.31-log, Binlog ver: 4 |</span><br><span class="line">| mysql-bin.000003 | 123 | Previous_gtids |         6 |         154 |                                       |</span><br><span class="line">| mysql-bin.000003 | 154 | Anonymous_Gtid |         6 |         219 | SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;  |</span><br><span class="line">| mysql-bin.000003 | 219 | Query          |         6 |         319 | create database testdb                |</span><br><span class="line">| mysql-bin.000003 | 319 | Anonymous_Gtid |         6 |         384 | SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;  |</span><br><span class="line">| mysql-bin.000003 | 384 | Query          |         6 |         485 | use `testdb`; create table t1(id int) |</span><br><span class="line">| mysql-bin.000003 | 485 | Anonymous_Gtid |         6 |         550 | SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;  |</span><br><span class="line">| mysql-bin.000003 | 550 | Query          |         6 |         624 | BEGIN                                 |</span><br><span class="line">| mysql-bin.000003 | 624 | Table_map      |         6 |         671 | table_id: 108 (testdb.t1)             |</span><br><span class="line">| mysql-bin.000003 | 671 | Write_rows     |         6 |         711 | table_id: 108 flags: STMT_END_F       |</span><br><span class="line">| mysql-bin.000003 | 711 | Xid            |         6 |         742 | COMMIT /* xid=38 */                   |</span><br><span class="line">+------------------+-----+----------------+-----------+-------------+---------------------------------------+</span><br><span class="line">11 rows in set (0.00 sec)</span><br><span class="line"># 这些可读性不强</span><br></pre></td></tr></table></figure></li>
<li><h5 id="binlog文件详细查看"><a href="#binlog文件详细查看" class="headerlink" title="binlog文件详细查看"></a><code>binlog</code>文件详细查看</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令行上执行</span></span><br><span class="line">cd /data/binlog/</span><br><span class="line">mysqlbinlog mysql-bin.000003</span><br><span class="line"></span><br><span class="line">mysqlbinlog mysql-bin.000003  |grep -v &#x27;SET&#x27;  # 这条命令得到也看不懂 有注释时间等</span><br><span class="line"></span><br><span class="line">mysqlbinlog --base64-output=decode-rows  -vvvv mysql-bin.000003</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/wzf7nb.png" alt="wzf7nb"></p>
</li>
</ul>
<h4 id="基于二进制日志数据恢复"><a href="#基于二进制日志数据恢复" class="headerlink" title="基于二进制日志数据恢复"></a>基于二进制日志数据恢复</h4><ul>
<li><h5 id="按需截取日志"><a href="#按需截取日志" class="headerlink" title="按需截取日志"></a>按需截取日志</h5><blockquote>
<p>截取二进制日志的核心在于找起点和终点</p>
</blockquote>
<ul>
<li><p>基于<code>position</code>号截取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mysqlbinlog 命令参数截取</span><br><span class="line">--start-position=</span><br><span class="line">--stop-position=</span><br><span class="line"></span><br><span class="line"># sql语句查到建库的position号</span><br><span class="line"> show binlog events in &#x27;mysql-bin.000003&#x27;;</span><br><span class="line">+------------------+-----+----------------+-----------+-------------+---------------------------------------+</span><br><span class="line">| Log_name         | Pos | Event_type     | Server_id | End_log_pos | Info                                  |</span><br><span class="line">+------------------+-----+----------------+-----------+-------------+---------------------------------------+</span><br><span class="line">| mysql-bin.000003 |   4 | Format_desc    |         6 |         123 | Server ver: 5.7.31-log, Binlog ver: 4 |</span><br><span class="line">| mysql-bin.000003 | 123 | Previous_gtids |         6 |         154 |                                       |</span><br><span class="line">| mysql-bin.000003 | 154 | Anonymous_Gtid |         6 |         219 | SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;  |</span><br><span class="line">| mysql-bin.000003 | 219 | Query          |         6 |         319 | create database testdb                |</span><br><span class="line">| mysql-bin.000003 | 319 | Anonymous_Gtid |         6 |         384 | SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;  |</span><br><span class="line">| mysql-bin.000003 | 384 | Query          |         6 |         485 | use `testdb`; create table t1(id int) |</span><br><span class="line">| mysql-bin.000003 | 485 | Anonymous_Gtid |         6 |         550 | SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;  |</span><br><span class="line">| mysql-bin.000003 | 550 | Query          |         6 |         624 | BEGIN                                 |</span><br><span class="line">| mysql-bin.000003 | 624 | Table_map      |         6 |         671 | table_id: 108 (testdb.t1)             |</span><br><span class="line">| mysql-bin.000003 | 671 | Write_rows     |         6 |         711 | table_id: 108 flags: STMT_END_F       |</span><br><span class="line">| mysql-bin.000003 | 711 | Xid            |         6 |         742 | COMMIT /* xid=38 */                   |</span><br><span class="line">+------------------+-----+----------------+-----------+-------------+---------------------------------------+</span><br><span class="line">11 rows in set (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 截取事件导出sql语句(命令行)</span><br><span class="line">mysqlbinlog --start-position=219 --stop-position=319 /data/binlog/mysql-bin.000003 &gt; /tmp/bin.sql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 恢复(sql语句)</span><br><span class="line"># 模拟删除(不代表生产)</span><br><span class="line">show databases;</span><br><span class="line">drop database testdb;</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line"># 临时关闭当前查看二进制日志记录开关</span><br><span class="line"># 因为已经有了二进制日志做恢复，再次恢复的时候会再次记录恢复的二进制日志，所以要先短暂关闭二进制记录，避免IO损耗</span><br><span class="line">set sql_log_bin=0;  </span><br><span class="line"></span><br><span class="line"># 恢复命令</span><br><span class="line">source /tmp/bin.sql;</span><br><span class="line"></span><br><span class="line"># 检查</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line">set sql_log_bin=1;</span><br><span class="line"># 恢复完成后需要退出当前窗口，当前窗口binlog二进制没有记录</span><br></pre></td></tr></table></figure>



<p>下图是根据<code>position</code>号截取的日志信息</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/LBFNQB.png" alt="LBFNQB"></p>
</li>
<li><p>基于时间截取</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--start-datetime</span><br><span class="line">--stop-datetime</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>案例恢复</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 使用binlog日志进行恢复</span><br><span class="line">#模拟删库</span><br><span class="line">create database binlog charset utf8mb4;</span><br><span class="line"></span><br><span class="line">use binlog;</span><br><span class="line">create table t1(id int);</span><br><span class="line">insert into t1 values(1);</span><br><span class="line">commit;</span><br><span class="line">insert into t1 values(2);</span><br><span class="line">commit;</span><br><span class="line">insert into t1 values(3);</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line">drop database binlog;</span><br><span class="line"></span><br><span class="line"># 恢复 </span><br><span class="line"># 查看当前的二进制日志文件是哪一个</span><br><span class="line">show master status;</span><br><span class="line"></span><br><span class="line"># 查看事件找到起点和终点</span><br><span class="line">show binlog events in &#x27;mysql-bin.000003&#x27;;</span><br><span class="line">......</span><br><span class="line">| mysql-bin.000003 |  905 | Anonymous_Gtid |         6 |         970 | SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;   |</span><br><span class="line">| mysql-bin.000003 |  970 | Query          |         6 |        1086 | create database binlog charset utf8mb4 |</span><br><span class="line">| mysql-bin.000003 | 1086 | Anonymous_Gtid |         6 |        1151 | SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;   |</span><br><span class="line">| mysql-bin.000003 | 1151 | Query          |         6 |        1252 | use `binlog`; create table t1(id int)  |</span><br><span class="line">| mysql-bin.000003 | 1252 | Anonymous_Gtid |         6 |        1317 | SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;   |</span><br><span class="line">| mysql-bin.000003 | 1317 | Query          |         6 |        1391 | BEGIN                                  |</span><br><span class="line">| mysql-bin.000003 | 1391 | Table_map      |         6 |        1438 | table_id: 110 (binlog.t1)              |</span><br><span class="line">| mysql-bin.000003 | 1438 | Write_rows     |         6 |        1478 | table_id: 110 flags: STMT_END_F        |</span><br><span class="line">| mysql-bin.000003 | 1478 | Xid            |         6 |        1509 | COMMIT /* xid=87 */                    |</span><br><span class="line">| mysql-bin.000003 | 1509 | Anonymous_Gtid |         6 |        1574 | SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;   |</span><br><span class="line">| mysql-bin.000003 | 1574 | Query          |         6 |        1648 | BEGIN                                  |</span><br><span class="line">| mysql-bin.000003 | 1648 | Table_map      |         6 |        1695 | table_id: 110 (binlog.t1)              |</span><br><span class="line">| mysql-bin.000003 | 1695 | Write_rows     |         6 |        1735 | table_id: 110 flags: STMT_END_F        |</span><br><span class="line">| mysql-bin.000003 | 1735 | Xid            |         6 |        1766 | COMMIT /* xid=89 */                    |</span><br><span class="line">| mysql-bin.000003 | 1766 | Anonymous_Gtid |         6 |        1831 | SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;   |</span><br><span class="line">| mysql-bin.000003 | 1831 | Query          |         6 |        1905 | BEGIN                                  |</span><br><span class="line">| mysql-bin.000003 | 1905 | Table_map      |         6 |        1952 | table_id: 110 (binlog.t1)              |</span><br><span class="line">| mysql-bin.000003 | 1952 | Write_rows     |         6 |        1992 | table_id: 110 flags: STMT_END_F        |</span><br><span class="line">| mysql-bin.000003 | 1992 | Xid            |         6 |        2023 | COMMIT /* xid=91 */                    |</span><br><span class="line">| mysql-bin.000003 | 2023 | Anonymous_Gtid |         6 |        2088 | SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;   |</span><br><span class="line">| mysql-bin.000003 | 2088 | Query          |         6 |        2186 | drop database binlog                   |</span><br><span class="line">+------------------+------+----------------+-----------+-------------+----------------------------------------+</span><br><span class="line"></span><br><span class="line">起点: 970</span><br><span class="line">终点: 2088(2186是删库语句，否则无意义)</span><br><span class="line"></span><br><span class="line"># 根据起点和终点截取需要的二进制日志(命令行操作)</span><br><span class="line">mysqlbinlog --start-position=970 --stop-position=2088 /data/binlog/mysql-bin.000003 &gt; /tmp/databse-binlog.sql</span><br><span class="line"></span><br><span class="line"># 恢复</span><br><span class="line">set sql_log_bin=0;</span><br><span class="line">source /tmp/databse-binlog.sql;</span><br><span class="line"></span><br><span class="line"># 验证结果</span><br><span class="line">show databases;</span><br><span class="line">select * from t1;</span><br></pre></td></tr></table></figure></li>
<li><h5 id="GTID功能的二进制日志"><a href="#GTID功能的二进制日志" class="headerlink" title="GTID功能的二进制日志"></a><code>GTID</code>功能的二进制日志</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create database binlog charset utf8mb4;</span><br><span class="line">use binlog;</span><br><span class="line">create table t1(id int);</span><br><span class="line">insert into t1 values(1);</span><br><span class="line">commit;</span><br><span class="line">insert into t1 values(2);</span><br><span class="line">commit;</span><br><span class="line">truncate table t1;  # 这条是误操作,不能恢复这条语句</span><br><span class="line">insert into t1 values(3);</span><br><span class="line">commit;</span><br><span class="line">drop database binlog;</span><br><span class="line"># 截取position号就比较麻烦 ，需要多次截取恢复，不方便</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>GTID</code>介绍</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GTID(全局事务编号)</span><br><span class="line">是对于一个已提交事务的编号，并且是一个全局唯一的编号。</span><br><span class="line">它的官方定义如下：</span><br><span class="line">GTID = source_id ：transaction_id</span><br><span class="line">7E11FA47-31CA-19E1-9E56-C43AA21293967:29</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">DDL DCL，一条语句(事件)就是一个事务，占一个GTID号</span><br><span class="line">DML，一个完整的事务(begin ---&gt; commit)，是一个事务，占一个GTID号</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">5.6 版本新加的特性,5.7中做了加强</span><br><span class="line">5.6 中不开启,没有这个功能.</span><br><span class="line">5.7 中的GTID,即使不开也会有自动生成</span><br><span class="line">SET @@SESSION.GTID_NEXT= &#x27;ANONYMOUS&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p><code>GTID</code>配置及截取使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改GTID相关的配置文件</span><br><span class="line">vim /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">...</span><br><span class="line">gtid-mode=on</span><br><span class="line">enforce-gtid-consistency=true</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"># 重启数据库</span><br><span class="line">systemctl restart mysql</span><br><span class="line"></span><br><span class="line"># GTID的前段</span><br><span class="line">cat /data/mysql/data/auto.cnf</span><br><span class="line">[auto]</span><br><span class="line">server-uuid=b25a4cc7-609b-11ec-afea-525400aaf73e</span><br><span class="line"></span><br><span class="line"># 查看GTID</span><br><span class="line"> show master status;  # Executed_Gtid_Set信息</span><br><span class="line"> </span><br><span class="line"># 创建数据查看GTID情况</span><br><span class="line"> create database testdb2 charset utf8mb4;</span><br><span class="line"> use testdb2;</span><br><span class="line"> create table t1 (id int);</span><br><span class="line"> insert into t1 values(1);</span><br><span class="line"> commit;</span><br><span class="line"> insert into t1 values(2);</span><br><span class="line"> commit;</span><br><span class="line"> insert into t1 values(3);</span><br><span class="line"> commit;</span><br><span class="line"> </span><br><span class="line"> show master status;</span><br><span class="line"> show binlog events in &#x27;mysql-bin.000004&#x27;;</span><br><span class="line"> </span><br><span class="line"> # 看到下图多了右边的编号，此时模拟执行数据库丢失</span><br><span class="line"> drop database testdb2;</span><br><span class="line"> </span><br><span class="line">show binlog events in &#x27;mysql-bin.000004&#x27;;  # 此时多了一条删库的编号</span><br><span class="line"></span><br><span class="line"># 基于GTID截取日志</span><br><span class="line"># 参数</span><br><span class="line">--include-gtids</span><br><span class="line">--exclude-gtids</span><br><span class="line">--skip-gtids</span><br><span class="line"></span><br><span class="line"># 错误的截取命令(命令行)</span><br><span class="line">mysqlbinlog --include-gtids=&#x27;b25a4cc7-609b-11ec-afea-525400aaf73e:1-5&#x27; /data/binlog/mysql-bin.000004 &gt; /tmp/testdb2.sql</span><br><span class="line"># 以上截取出来的日志不能直接恢复使用</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/GzZJIW.png" alt="GzZJIW"></p>
</li>
<li><p><code>GTID</code>幂等性</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开启GTID后,MySQL恢复Binlog时,重复GTID的事务不会再执行了</span><br><span class="line">show master status;  # 因为这条命令中出现的 Executed_Gtid_set信息 已经有了，表示不会再做了，检查幂等性</span><br><span class="line"></span><br><span class="line"># 恢复</span><br><span class="line"># 正确的截取日志命令(命令行)</span><br><span class="line">mysqlbinlog --skip-gtids --include-gtids=&#x27;b25a4cc7-609b-11ec-afea-525400aaf73e:1-5&#x27; /data/binlog/mysql-bin.000004 &gt; /tmp/testdb2.sql</span><br><span class="line"></span><br><span class="line"># sql语句恢复</span><br><span class="line">set sql_log_bin=0;</span><br><span class="line">source /tmp/testdb2.sql</span><br><span class="line">set sql_log_bin=1;</span><br><span class="line"></span><br><span class="line"># 检查</span><br><span class="line">show databases;</span><br><span class="line">select * from testdb2.t1;</span><br><span class="line"></span><br><span class="line"># 跳过某些GTID不截取</span><br><span class="line">mysqlbinlog --skip-gtids --include-gtids=&#x27;b25a4cc7-609b-11ec-afea-525400aaf73e:1-5&#x27; \</span><br><span class="line">--exclude-gtids=&#x27;b25a4cc7-609b-11ec-afea-525400aaf73e:6&#x27; \</span><br><span class="line">/data/binlog/mysql-bin.000004 &gt; /tmp/testdb2.sql</span><br><span class="line"></span><br><span class="line">单个: &#x27;b25a4cc7-609b-11ec-afea-525400aaf73e:6&#x27;</span><br><span class="line">连续个: &#x27;b25a4cc7-609b-11ec-afea-525400aaf73e:1-6&#x27;</span><br><span class="line">多个不连续: &#x27;b25a4cc7-609b-11ec-afea-525400aaf73e:2&#x27;,&#x27;b25a4cc7-609b-11ec-afea-525400aaf73e:3&#x27;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="二进制日志其他操作"><a href="#二进制日志其他操作" class="headerlink" title="二进制日志其他操作"></a>二进制日志其他操作</h4><ul>
<li><h5 id="临时关闭"><a href="#临时关闭" class="headerlink" title="临时关闭"></a>临时关闭</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 临时关闭二进制日志，退出mysql窗口就可以恢复，做数据恢复之前使用</span><br><span class="line">set sql_log_bin=0;</span><br></pre></td></tr></table></figure></li>
<li><h5 id="自动清理"><a href="#自动清理" class="headerlink" title="自动清理"></a>自动清理</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 窗口自动清理周期</span><br><span class="line">select @@expire_logs_days;</span><br><span class="line">show variables like &#x27;%expire%&#x27;;</span><br><span class="line"></span><br><span class="line"># 自动清理时间,是要按照全备周期+1</span><br><span class="line"># 企业建议,至少保留两个全备周期+1的binlog</span><br><span class="line">set global expire_logs_days=8;</span><br><span class="line"></span><br><span class="line"># 永久生效</span><br><span class="line">vim /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">...</span><br><span class="line">expire_logs_days=15;</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li><h5 id="手工清理"><a href="#手工清理" class="headerlink" title="手工清理"></a>手工清理</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 三天之前到现在的</span><br><span class="line">PURGE BINARY LOGS BEFORE now() - INTERVAL 3 day;</span><br><span class="line">PURGE BINARY LOGS TO &#x27;mysql-bin.000010&#x27;;</span><br><span class="line"></span><br><span class="line"># 查看binlog日志信息</span><br><span class="line">show binary logs;</span><br><span class="line"></span><br><span class="line"># 删除到哪个二进制日志为止</span><br><span class="line">PURGE BINARY LOGS TO &#x27;mysql-bin.000004&#x27;;</span><br><span class="line"></span><br><span class="line"># 注意:不要手工 rm binlog文件，如果 rm 删除了如下恢复</span><br><span class="line">1. my.cnf binlog关闭掉,启动数据库</span><br><span class="line">2.把数据库关闭,开启binlog,启动数据库</span><br><span class="line">删除所有binlog,并从000001开始重新记录日志</span><br><span class="line"></span><br><span class="line"># 重新计数二进制日志，主从关系中，主库执行此操作，主从环境必崩</span><br><span class="line">reset master;</span><br></pre></td></tr></table></figure></li>
<li><h5 id="日志滚动"><a href="#日志滚动" class="headerlink" title="日志滚动"></a>日志滚动</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 重启mysql也会自动滚动一个新的</span><br><span class="line"># 产生一个新的日志sql命令</span><br><span class="line">flush logs;</span><br><span class="line"></span><br><span class="line"># 默认日志文件大小1G，达到这个大小也回生成全新的，一般会设置小一点，避免分析的时候打不开</span><br><span class="line">show variables like &#x27;%max_binlog_size%&#x27;;</span><br><span class="line">+-----------------+------------+</span><br><span class="line">| Variable_name   | Value      |</span><br><span class="line">+-----------------+------------+</span><br><span class="line">| max_binlog_size | 1073741824 |</span><br><span class="line">+-----------------+------------+</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="slow-log慢日志"><a href="#slow-log慢日志" class="headerlink" title="slow_log慢日志"></a><code>slow_log</code>慢日志</h3><h4 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">记录慢SQL语句的日志,定位低效SQL语句的工具日志</span><br></pre></td></tr></table></figure>

<h4 id="开启慢日志"><a href="#开启慢日志" class="headerlink" title="开启慢日志"></a>开启慢日志</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看是否开启</span><br><span class="line">select @@slow_query_log;</span><br><span class="line"></span><br><span class="line"># 查看慢日志位置</span><br><span class="line">select @@slow_query_log_file;</span><br><span class="line"></span><br><span class="line"># 查看慢查询时间</span><br><span class="line">select @@long_query_time;</span><br><span class="line">select @@log_queries_not_using_indexes ;</span><br><span class="line"></span><br><span class="line"># 设置慢日志配置文件</span><br><span class="line">vim /etc/my.cnf</span><br><span class="line">slow_query_log=1                               # 开关</span><br><span class="line">slow_query_log_file=/data/mysql/data/slow.log  # 文件位置及名字 </span><br><span class="line">long_query_time=0.1                            # 设定慢查询时间</span><br><span class="line">log_queries_not_using_indexes                  # 没走索引的语句也记录</span><br><span class="line"></span><br><span class="line"># 重启mysql</span><br><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<h4 id="慢日志分析"><a href="#慢日志分析" class="headerlink" title="慢日志分析"></a>慢日志分析</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 模拟慢日志，多执行几次</span><br><span class="line">select * from t100w where k1=&quot;aa&quot; limit 1000,2000;</span><br><span class="line"></span><br><span class="line"># mysqldumpslow 分析慢日志</span><br><span class="line">mysqldumpslow -s c -t 10 /data/mysql/data/slow.log</span><br><span class="line"></span><br><span class="line"># 命令擦参数说明</span><br><span class="line">-s  # 以...排序</span><br><span class="line">c   # 执行次数</span><br><span class="line">-t  # top 10</span><br><span class="line"></span><br><span class="line"># 第三方工具</span><br><span class="line"># 下载地址 https://www.percona.com/downloads/percona-toolkit/LATEST/</span><br><span class="line"># wget https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/sql/percona-toolkit-3.2.1-1.el7.x86_64.rpm</span><br><span class="line">wget https://downloads.percona.com/downloads/percona-toolkit/3.3.1/binary/redhat/7/x86_64/percona-toolkit-3.3.1-1.el7.x86_64.rpm</span><br><span class="line">yum -y install perl-DBI perl-DBD-MySQL perl-Time-HiRes perl-IO-Socket-SSL perl-Digest-MD5</span><br><span class="line">yum -y localinstall percona-toolkit-3.3.1-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line"># toolkit工具包中的命令</span><br><span class="line">pt-query-diagest  /data/mysql/data/slow.log</span><br><span class="line"></span><br><span class="line"># 图形化的第三方工具</span><br><span class="line">Anemometer基于pt-query-digest将MySQL慢查询可视化</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL存储引擎(InnoDB)</title>
    <url>/ff3d77ac.html</url>
    <content><![CDATA[<h3 id="存储引擎介绍"><a href="#存储引擎介绍" class="headerlink" title="存储引擎介绍"></a>存储引擎介绍</h3><blockquote>
<p>类似于Linux系统中的文件系统</p>
</blockquote>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><span id="more"></span>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据读写</span><br><span class="line">数据安全和一致性</span><br><span class="line">提高性能</span><br><span class="line">热备份</span><br><span class="line">自动故障恢复</span><br><span class="line">高可用方面支持</span><br></pre></td></tr></table></figure>

<h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">InnoDB</span><br><span class="line">MyISAM</span><br><span class="line">MEMORY</span><br><span class="line">ARCHIVE</span><br><span class="line">FEDERATED</span><br><span class="line">EXAMPLE</span><br><span class="line">BLACKHOLE</span><br><span class="line">MERGE</span><br><span class="line">NDBCLUSTER</span><br><span class="line">CSV</span><br><span class="line"></span><br><span class="line"># 引擎种类查看</span><br><span class="line">show engines;</span><br><span class="line"></span><br><span class="line">存储引擎是作用在表上的，也就意味着，不同的表可以有不同的存储引擎类型。</span><br><span class="line">PerconaDB:默认是XtraDB</span><br><span class="line">MariaDB:默认是InnoDB</span><br><span class="line">其他的存储引擎支持:</span><br><span class="line">TokuDB</span><br><span class="line">RocksDB</span><br><span class="line">MyRocks</span><br><span class="line">以上三种存储引擎的共同点:压缩比较高,数据插入性能极高</span><br><span class="line">现在很多的NewSQL,使用比较多的功能特性.</span><br></pre></td></tr></table></figure>

<h3 id="InnoDB存储引擎介绍"><a href="#InnoDB存储引擎介绍" class="headerlink" title="InnoDB存储引擎介绍"></a>InnoDB存储引擎介绍</h3><blockquote>
<p>在MySQL5.5版本之后，默认的存储引擎，提供高可用性和高性能</p>
</blockquote>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/KssDvX.jpg" alt="KssDvX"></p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、事务（Transaction）</span><br><span class="line"><span class="number">2</span>、MVCC（Multi-Version Concurrency Control多版本并发控制）</span><br><span class="line"><span class="number">3</span>、行级锁(Row-level Lock)</span><br><span class="line"><span class="number">4</span>、ACSR（Auto Crash Safey Recovery）自动的故障安全恢复</span><br><span class="line"><span class="number">5</span>、支持热备份(Hot Backup)</span><br><span class="line"><span class="number">6</span>、Replication: Group Commit , GTID (<span class="keyword">Global</span> Transaction ID) ,多线程(Multi-Threads-SQL ) </span><br></pre></td></tr></table></figure>

<h4 id="存储引擎查看"><a href="#存储引擎查看" class="headerlink" title="存储引擎查看"></a>存储引擎查看</h4><ul>
<li><h5 id="使用select确认会话存储引擎"><a href="#使用select确认会话存储引擎" class="headerlink" title="使用select确认会话存储引擎"></a>使用select确认会话存储引擎</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@default_storage_engine;</span><br><span class="line">show variables like &#x27;%engine%&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><h5 id="默认存储引擎设置"><a href="#默认存储引擎设置" class="headerlink" title="默认存储引擎设置"></a>默认存储引擎设置</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 不会在生产中操作</span><br><span class="line">会话级别</span><br><span class="line">set default_storage_engine=myisam;</span><br><span class="line"></span><br><span class="line">全局级别(仅影响新会话)</span><br><span class="line">set global default_storage_engine=myisam;</span><br><span class="line">重启之后，所有参数均失效</span><br><span class="line"></span><br><span class="line"># 放入配置文件永久生效</span><br><span class="line">vim /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">default_storage_engine=myisam</span><br><span class="line"></span><br><span class="line">存储引擎是表级别的，每个表创建时可以指定不同的存储引擎，但是建议统一为Innodb</span><br></pre></td></tr></table></figure></li>
<li><h5 id="查看表的存储引擎"><a href="#查看表的存储引擎" class="headerlink" title="查看表的存储引擎"></a>查看表的存储引擎</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看单表的存储引擎</span><br><span class="line">show create table world.city\G</span><br><span class="line"></span><br><span class="line">use world;</span><br><span class="line">show table status like &#x27;countrylanguage&#x27;\G</span><br><span class="line"></span><br><span class="line"># 查看每个表的存储引擎</span><br><span class="line">select table_schema,table_name ,engine from information_schema.tables where table_schema not in (&#x27;sys&#x27;,&#x27;mysql&#x27;,&#x27;information_schema&#x27;,&#x27;performance_schema&#x27;);</span><br></pre></td></tr></table></figure></li>
<li><h5 id="修改一个表的存储引擎-碎片整理"><a href="#修改一个表的存储引擎-碎片整理" class="headerlink" title="修改一个表的存储引擎(碎片整理)"></a>修改一个表的存储引擎(碎片整理)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table world.city engine innodb;</span><br><span class="line"># 这条命令还可以进行innodb表的碎片化整理</span><br><span class="line"></span><br><span class="line"># 将test数据库下的所有1000表，存储引擎从MyISAM替换为innodb </span><br><span class="line">select concat(&quot;alter table &quot;,table_name,&quot; engine innodb;&quot;)</span><br><span class="line">from information_schema.tables </span><br><span class="line">where table_schema=&#x27;test&#x27;</span><br><span class="line">into outfile &#x27;/tmp/alter.sql&#x27;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="InnoDB物理存储结构"><a href="#InnoDB物理存储结构" class="headerlink" title="InnoDB物理存储结构"></a>InnoDB物理存储结构</h3><h4 id="最直观的存储方式"><a href="#最直观的存储方式" class="headerlink" title="最直观的存储方式"></a>最直观的存储方式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 数据目录 /data/mysql/data</span><br><span class="line">ibdata1：系统数据字典信息(统计信息)，UNDO（回滚）表空间等数据</span><br><span class="line">ib_logfile0 ~ ib_logfile1: REDO（重做日志）日志文件，事务日志文件</span><br><span class="line">ib_buffer_pool: 缓冲池(5.7) 上次关机之前的热数据会保存在这，下次启动后会加载这些数据</span><br><span class="line">ibtmp1： 临时表空间磁盘位置，存储临时表</span><br><span class="line">frm：存储表的列信息</span><br><span class="line">ibd：表的数据行和索引</span><br></pre></td></tr></table></figure>

<h4 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">需要将所有数据存储到同一个表空间中 ，管理比较混乱</span><br><span class="line">5.5版本出现的管理模式，也是默认的管理模式。（数据字典，undo，临时表，索引，表数据）</span><br><span class="line">5.6版本，共享表空间保留，只用来存储:数据字典信息,undo,临时表。</span><br><span class="line">5.7版本,临时表被独立出来了</span><br><span class="line">8.0版本,undo也被独立出去了</span><br><span class="line"></span><br><span class="line">具体变化参考官方文档:</span><br><span class="line">https://dev.mysql.com/doc/refman/5.6/en/innodb-architecture.html</span><br><span class="line">https://dev.mysql.com/doc/refman/5.7/en/innodb-architecture.html</span><br><span class="line">https://dev.mysql.com/doc/refman/5.8/en/innodb-architecture.html</span><br></pre></td></tr></table></figure>

<h5 id="共享表空间"><a href="#共享表空间" class="headerlink" title="共享表空间"></a>共享表空间</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 共享表空间 ibdata1</span><br><span class="line">select @@innodb_file_per_table;  # 默认是 1 ，代表当前独立表空间模式，代表每个表一个idb文件</span><br><span class="line">    # 当前 innodb_file_per_table 参数为 1 时创建表查看数据目录情况</span><br><span class="line">    mysql&gt;use world;</span><br><span class="line">    mysql&gt;create table tab(id int);</span><br><span class="line">    </span><br><span class="line">		# 此时在 /data/mysql/data/world 数据目录下会存在下面两个文件，记录表数据和索引</span><br><span class="line">    [root@db1 world]# ll</span><br><span class="line">    -rw-r----- 1 mysql mysql   8556 12月 23 09:52 tab.frm</span><br><span class="line">    -rw-r----- 1 mysql mysql  98304 12月 23 09:52 tab.ibd</span><br><span class="line"></span><br><span class="line">    # 临时设置 innodb_file_per_table 参数为 0 时创建表查看数据目录情况</span><br><span class="line">    set global innodb_file_per_table=0;</span><br><span class="line">    select @@innodb_file_per_table;</span><br><span class="line">    create table bb(id int);</span><br><span class="line">    </span><br><span class="line">    [root@db1 world]# ll</span><br><span class="line">    ...  # 此时没有bb.frm和bb.ibd 两个文件了，此时bb表数据和索引存放在了/data/mysql/ibdata1 文件里了</span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"># 共享表空间设置(在搭建MySQL时，初始化数据之前设置到参数文件中)</span><br><span class="line">select @@innodb_data_file_path;  # 查看ibdata1的信息</span><br><span class="line">+-------------------------+</span><br><span class="line">| @@innodb_data_file_path |</span><br><span class="line">+-------------------------+</span><br><span class="line">| ibdata1:12M:autoextend  |</span><br><span class="line">+-------------------------+</span><br><span class="line"># 默认设置为12M ，autoextend自增长，不够之后每次自增长64兆</span><br><span class="line"></span><br><span class="line">show variables like &#x27;%extend%&#x27;;  # 查看自增长大小，可设置</span><br><span class="line"></span><br><span class="line"># 初始化数据之前设置到参数文件中</span><br><span class="line">innodb_data_file_path=ibdata1:512M:ibdata2:512M:autoextend</span><br><span class="line">innodb_autoextend_increment=64</span><br></pre></td></tr></table></figure>

<h5 id="独立表空间"><a href="#独立表空间" class="headerlink" title="独立表空间"></a>独立表空间</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从5.6，默认表空间不再使用共享表空间，替换为独立表空间。</span><br><span class="line">主要存储的是用户数据</span><br><span class="line">存储特点为：一个表一个ibd文件，存储数据行和索引信息</span><br><span class="line"></span><br><span class="line">基本表结构元数据存储：</span><br><span class="line">xxx.frm</span><br><span class="line">最终结论：</span><br><span class="line">      元数据            数据行+索引</span><br><span class="line">mysql表数据    =（ibdataX+frm）+ibd(段、区、页)</span><br><span class="line">        DDL             DML+DQL</span><br><span class="line"></span><br><span class="line">MySQL的存储引擎日志：</span><br><span class="line">Redo Log: ib_logfile0  ib_logfile1，重做日志</span><br><span class="line">Undo Log: ibdata1 ibdata2(存储在共享表空间中)，回滚日志</span><br><span class="line">临时表:ibtmp1，在做join union操作产生临时数据，用完就自动</span><br><span class="line"></span><br><span class="line"># 独立表空间设置(在上面例子中)</span><br></pre></td></tr></table></figure>

<h5 id="迁移表空间"><a href="#迁移表空间" class="headerlink" title="迁移表空间"></a>迁移表空间</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 迁移表空间功能，导入和导出表空间</span><br><span class="line">alter table city discard tablespace;  # 删除city表空间  </span><br><span class="line">alter table city import tablespace;  # 导入city表空间</span><br><span class="line"></span><br><span class="line"># 小测试</span><br><span class="line"># 先备份ibd文件</span><br><span class="line">cd /data/mysql/data/school/</span><br><span class="line">cp teacher.ibd /opt/</span><br><span class="line"></span><br><span class="line"># 删除表空间</span><br><span class="line">use school;</span><br><span class="line">alter table teacher discard tablespace;</span><br><span class="line"></span><br><span class="line">ll /data/mysql/data/school/  # 该目录下teacher.ibd文件就mysql删除了</span><br><span class="line"></span><br><span class="line"># 表还在但是无法正常读取,ibdata不识别,统计信息等不存在</span><br><span class="line">show tables;</span><br><span class="line">select * from teacher;  # ERROR 1814 (HY000): Tablespace has been discarded for table &#x27;teacher&#x27;</span><br><span class="line"></span><br><span class="line"># 将备份的ibd文件恢复回位置</span><br><span class="line">cp /opt/teacher.ibd /data/mysql/data/school/</span><br><span class="line">chown -R mysql.mysql /data/mysql/data/school/</span><br><span class="line"></span><br><span class="line">select * from teacher;  # 拷贝回ibd文件之后还是不能查询,ibdata不识别,统计信息等不存在</span><br><span class="line">alter table teacher import tablespace;</span><br><span class="line">select * from teacher;  # 导入表空间之后正常了</span><br><span class="line"></span><br><span class="line"># 批量导入表空间</span><br><span class="line">select concat(&quot;alter table &quot;,table_schema,&quot;.&quot;,table_name,&quot; import tablespace;&quot;) from information_schema.tables where table_schema=&#x27;world&#x27; into outfile &#x27;/tmp/import.sql&#x27;;</span><br><span class="line"></span><br><span class="line"># 批量删除表空间</span><br><span class="line">select concat(&quot;alter table &quot;,table_schema,&quot;.&quot;,table_name,&quot; discard tablespace;&quot;) from information_schema.tables where table_schema=&#x27;world&#x27; into outfile &#x27;/tmp/discad.sql&#x27;;</span><br><span class="line"></span><br><span class="line"># 导入表空间时可能会报错,可以跳过外键检查</span><br><span class="line">set foreign_key_checks=0</span><br></pre></td></tr></table></figure>

<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="事务ACID特性"><a href="#事务ACID特性" class="headerlink" title="事务ACID特性"></a>事务<code>ACID</code>特性</h4><blockquote>
<p>影响DML语句(<code>insert</code>、<code>update</code>、<code>delete</code>和一部分<code>select</code>)</p>
</blockquote>
<p><code>Atomic</code>原子性</p>
<blockquote>
<p>所有语句作为一个单元全部成功执行或全部取消，不能出现中间状态</p>
</blockquote>
<p><code>Consistent</code>一致性</p>
<blockquote>
<p>如果数据库在事务开始时处于一致状态，则在执行该事务期间将保留一致状态</p>
</blockquote>
<p><code>Isolated</code>隔离性</p>
<blockquote>
<p>事务之间不相互影响</p>
</blockquote>
<p><code>Durable</code>持久性</p>
<blockquote>
<p>事务成功完成后，所做的所有更改都会准确地记录在数据库中，所做的更改不会丢失。</p>
</blockquote>
<h4 id="事务的生命周期"><a href="#事务的生命周期" class="headerlink" title="事务的生命周期"></a>事务的生命周期</h4><ul>
<li><p>事务的开始</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">begin;</span><br><span class="line">start transaction;</span><br><span class="line"># 在5.5 以上的版本，不需要手工begin，只要你执行的是一个DML，会自动在前面加一个begin命令。</span><br></pre></td></tr></table></figure></li>
<li><p>事务的结束</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">commit;</span><br><span class="line">完成一个事务，一旦事务提交成功，，就说明具备ACID特性了</span><br><span class="line"></span><br><span class="line">rollback; </span><br><span class="line">回滚事务</span><br><span class="line">将内存中已执行过的操作回滚回去</span><br></pre></td></tr></table></figure></li>
<li><p>例子</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mysql 窗口一</span><br><span class="line">user world;</span><br><span class="line">begin;</span><br><span class="line">delete from city where id &gt; 3000;</span><br><span class="line">delete from city where id &gt; 2000;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># mysql 窗口二</span><br><span class="line">use world;</span><br><span class="line">select * from city;  # 此时查询的数据还是4079条数据，并没有被删除</span><br><span class="line">begin;</span><br><span class="line">delete from city where id &gt; 1800;  </span><br><span class="line"># 此时会卡主，因为在等上一个事务，隔离性</span><br><span class="line"># 操作相同的语句会等上一个事务结束之后才会继续</span><br><span class="line"># 过了超时时间就会报 ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br><span class="line"></span><br><span class="line"># mysql 窗口一</span><br><span class="line">commit;  # 此时提交</span><br><span class="line"></span><br><span class="line"># mysql 窗口二</span><br><span class="line">delete from city where id &gt; 1800;  # 这个窗口就可以执行操作了</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line"># 回滚事务</span><br><span class="line">begin;</span><br><span class="line">delete from city where id=100;</span><br><span class="line">select * from city where id=100;</span><br><span class="line">rollback;  # 对上面的sql操作语句进行回滚，如果commit了，就不能回滚</span><br><span class="line">select * from city where id=100;</span><br><span class="line">commit;</span><br></pre></td></tr></table></figure></li>
<li><p>自动提交策略(<code>autocommit</code>)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">默认执行DML语句的时候会自动的在语句前加 begin 和 commit，针对需要使用事务功能的语句 begin 或者直接全部使用事务功能</span><br><span class="line"></span><br><span class="line">select @@autocommit;  # 默认开启的 1 为开启</span><br><span class="line"></span><br><span class="line">set autocommit=0;  # 关闭自动提交策略</span><br><span class="line">set global autocommit=0;  # 全局关闭自动提交策略</span><br><span class="line"></span><br><span class="line"># 永久关闭自动提交策略</span><br><span class="line">vim /etc/my.cnf</span><br><span class="line">[mysqld]</span><br><span class="line">...</span><br><span class="line">autocommit=0</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">自动提交是否打开，一般在有事务需求的MySQL中，将其关闭</span><br><span class="line">不管有没有事务需求，我们一般也都建议设置为0，可以很大程度上提高数据库性能</span><br></pre></td></tr></table></figure></li>
<li><p>事务的隐式控制</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 隐式回滚</span><br><span class="line">  1. 关闭窗口的时候会自动回滚</span><br><span class="line">    # 已经永久关闭了自动提交策略</span><br><span class="line"></span><br><span class="line">  2. 删除会话ID</span><br><span class="line">    show processlist;</span><br><span class="line">    kill 3;</span><br><span class="line">  </span><br><span class="line"># 隐式提交</span><br><span class="line">  begin;</span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  begin;  # 此时上面的事务自动提交了</span><br><span class="line"></span><br><span class="line">  begin;</span><br><span class="line">  a</span><br><span class="line">  b</span><br><span class="line">  set autocommit=1;  # 此时上面的事务也自动提交了</span><br><span class="line">  </span><br><span class="line"># 导致提交的非事务语句</span><br><span class="line">DDL语句: (ALTER、CREATE 和 DROP)</span><br><span class="line">DCL语句: (GRANT、REVOKE 和 SET PASSWORD)</span><br><span class="line">锁定语句: (LOCK TABLES 和 UNLOCK TABLES)</span><br><span class="line">导致隐式提交的语句示例：</span><br><span class="line">TRUNCATE TABLE</span><br><span class="line">LOAD DATA INFILE</span><br><span class="line">SELECT FOR UPDATE</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="InnoDB事务的ACID是如何保证的"><a href="#InnoDB事务的ACID是如何保证的" class="headerlink" title="InnoDB事务的ACID是如何保证的"></a>InnoDB事务的ACID是如何保证的</h4><ul>
<li><h5 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redo log          ---&gt; 重做日志 ib_logfile0~1  50M ,轮询使用</span><br><span class="line">redo log buffer   ---&gt; redo内存区域</span><br><span class="line">t1.ibd            ---&gt; 存储 数据行和索引 </span><br><span class="line">buffer pool       ---&gt; 数据缓冲区池,数据和索引的缓冲</span><br><span class="line"></span><br><span class="line">LSN : 日志序列号 </span><br><span class="line">磁盘数据页,redo文件,buffer pool,redo buffer</span><br><span class="line">MySQL 每次数据库启动,都会比较磁盘数据页和redolog的LSN,必须要求两者LSN一致数据库才能正常启动</span><br><span class="line"></span><br><span class="line">WAL : write ahead log 日志优先写的方式实现持久化</span><br><span class="line">脏页:  内存脏页,内存中发生了修改,没写入到磁盘之前,我们把内存页称之为脏页</span><br><span class="line">CKPT: Checkpoint,检查点,就是将脏页刷写到磁盘的动作</span><br><span class="line">TXID: 事务号,InnoDB会为每一个事务生成一个事务号,伴随着整个事务</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/jYSnqG.jpg" alt="jYSnqG"></p>
</li>
<li><h5 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a><code>redo log</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Redo是什么</span><br><span class="line">redo,顾名思义“重做日志”，是事务日志的一种。</span><br><span class="line"></span><br><span class="line"># 作用是什么</span><br><span class="line">在事务ACID过程中，实现的是“D”持久化的作用。对于AC也有相应的作用</span><br><span class="line"></span><br><span class="line"># redo日志位置</span><br><span class="line">redo的日志文件：iblogfile0 iblogfile1</span><br><span class="line"></span><br><span class="line"># redo buffer</span><br><span class="line">redo的buffer:数据页的变化信息+数据页当时的LSN号</span><br><span class="line">LSN：日志序列号  磁盘数据页、内存数据页、redo buffer、redolog</span><br><span class="line"></span><br><span class="line"># redo的刷新策略</span><br><span class="line">commit;</span><br><span class="line">刷新当前事务的redo buffer到磁盘</span><br><span class="line">还会顺便将一部分redo buffer中没有提交的事务日志也刷新到磁盘</span><br></pre></td></tr></table></figure></li>
<li><h5 id="CSR前滚"><a href="#CSR前滚" class="headerlink" title="CSR前滚"></a>CSR前滚</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MySQL : 在启动时,必须保证redo日志文件和数据文件LSN必须一致, 如果不一致就会触发CSR,最终保证一致</span><br><span class="line">情况一:</span><br><span class="line">我们做了一个事务,begin;update;commit.</span><br><span class="line">1.在begin ,会立即分配一个TXID=tx_01.</span><br><span class="line">2.update时,会将需要修改的数据页(dp_01,LSN=101),加载到data buffer中</span><br><span class="line">3.DBWR线程,会进行dp_01数据页修改更新,并更新LSN=102</span><br><span class="line">4.LOGBWR日志写线程,会将dp_01数据页的变化+LSN+TXID存储到redobuffer</span><br><span class="line">5. 执行commit时,LGWR日志写线程会将redobuffer信息写入redolog日志文件中,基于WAL原则,</span><br><span class="line">在日志完全写入磁盘后,commit命令才执行成功,(会将此日志打上commit标记)</span><br><span class="line">6.假如此时宕机,内存脏页没有来得及写入磁盘,内存数据全部丢失</span><br><span class="line">7.MySQL再次重启时,必须要redolog和磁盘数据页的LSN是一致的.但是,此时dp_01,TXID=tx_01磁盘是LSN=101,dp_01,TXID=tx_01,redolog中LSN=102</span><br><span class="line">MySQL此时无法正常启动,MySQL触发CSR.在内存追平LSN号,触发ckpt,将内存数据页更新到磁盘,从而保证磁盘数据页和redolog LSN一值.这时MySQL正长启动</span><br><span class="line">以上的工作过程,我们把它称之为基于REDO的&quot;前滚操作&quot;</span><br></pre></td></tr></table></figure></li>
<li><h5 id="undo回滚日志"><a href="#undo回滚日志" class="headerlink" title="undo回滚日志"></a><code>undo</code>回滚日志</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># undo是什么</span><br><span class="line">undo,顾名思义“回滚日志”</span><br><span class="line"></span><br><span class="line"># 作用是什么</span><br><span class="line">在事务ACID过程中，实现的是“A” 原子性的作用</span><br><span class="line">另外CI也依赖于Undo</span><br><span class="line">在rolback时,将数据恢复到修改之前的状态</span><br><span class="line">在CSR实现的是,将redo当中记录的未提交的时候进行回滚.</span><br><span class="line">undo提供快照技术,保存事务修改之前的数据状态.保证了MVCC,隔离性,mysqldump的热备</span><br><span class="line"></span><br><span class="line"># 概念性的东西</span><br><span class="line">redo怎么应用的</span><br><span class="line">undo怎么应用的</span><br><span class="line">CSR(自动故障恢复)过程</span><br><span class="line">LSN :日志序列号</span><br><span class="line">TXID:事务ID</span><br><span class="line">CKPT(Checkpoint)</span><br></pre></td></tr></table></figure></li>
<li><h5 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 锁介绍</span><br><span class="line">锁顾名思义就是锁定的意思，提供的是隔离的方面的功能，需要配合 undo+隔离级别一起来实现</span><br><span class="line"></span><br><span class="line"># InnoDB锁级别</span><br><span class="line">行级锁，修改这一行就会持有这行的锁，默认情况是排他锁(悲观锁)</span><br><span class="line">悲观锁:行级锁定(行锁)</span><br><span class="line">谁先操作某个数据行,就会持有&lt;这行&gt;的(X)锁.</span><br><span class="line">乐观锁: 没有锁</span><br><span class="line"></span><br><span class="line"># 死锁</span><br><span class="line">  # mysql窗口一</span><br><span class="line">  begin;</span><br><span class="line">  update city set countrycode=&#x27;CHN&#x27; where id=1;</span><br><span class="line">  update city set countrycode=&#x27;CHN&#x27; where id=2;</span><br><span class="line">  # mysql窗口二</span><br><span class="line">  begin;</span><br><span class="line">  update city set countrycode=&#x27;USA&#x27; where id=2;</span><br><span class="line">  update city set countrycode=&#x27;USA&#x27; where id=1;</span><br><span class="line">	</span><br><span class="line">	# 业务逻辑有问题，开发中不能出现</span><br><span class="line">	# ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</span><br><span class="line"></span><br><span class="line"># 锁的作用</span><br><span class="line">在事务ACID过程中，“锁”和“隔离级别”一起来实现“I”隔离性和&quot;C&quot; 一致性 (redo也有参与)</span><br></pre></td></tr></table></figure></li>
<li><h5 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">作用: 影响到数据的读取</span><br><span class="line">默认的级别是 RR模式</span><br><span class="line">transaction_isolation   隔离级别(参数)</span><br><span class="line">  # 查看隔离级别</span><br><span class="line">  select @@tx_isolation;</span><br><span class="line">  show variables like &#x27;%iso%&#x27;;</span><br><span class="line">  </span><br><span class="line">  # RR模式</span><br><span class="line">    # 创建表环境</span><br><span class="line">    use world;</span><br><span class="line">    begin;</span><br><span class="line">    create table t1 (id int not null , ticker int null);</span><br><span class="line">    desc t1;</span><br><span class="line">    insert into t1 values (1,1);</span><br><span class="line">    commit;</span><br><span class="line">    select * from t1;</span><br><span class="line"></span><br><span class="line">    # mysql窗口一</span><br><span class="line">    use world;</span><br><span class="line">    begin;</span><br><span class="line">    select * from t1;  # 这一步窗口二也开始查询</span><br><span class="line">    update t1 set ticker=0 where id=1;</span><br><span class="line">    select * from t1;</span><br><span class="line">    commit;</span><br><span class="line"></span><br><span class="line">    # mysql窗口二</span><br><span class="line">    use world;</span><br><span class="line">    select * from t1;  # 和窗口一的第一次查询时间同步</span><br><span class="line">    select * from t1;  # 当窗口一已经提交了事务之后再查询发现并没有改变</span><br><span class="line">    # 这个现象就是可重复读现象，如果想在窗口二看到改变后的情况，先commit一下</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 修改隔离级别</span><br><span class="line">    set global transaction_isolation=&#x27;read-committed&#x27;;  # 此时是RC模式  需要退出窗口后重新进入生效</span><br><span class="line">    # 测试，设置之后重新打开mysql窗口</span><br><span class="line"></span><br><span class="line">    # mysql窗口一</span><br><span class="line">    select @@tx_isolation;  # 查看隔离级别</span><br><span class="line">    use world;</span><br><span class="line">    begin;</span><br><span class="line">    select * from t1;  # # 这一步窗口二也开始查询</span><br><span class="line">    update t1 set ticker=1 where id=1;</span><br><span class="line">    select * from t1;</span><br><span class="line">    commit;</span><br><span class="line">    select * from t1;</span><br><span class="line"></span><br><span class="line">    # mysql窗口二</span><br><span class="line">    selet @@tx_isolation;  # 查看隔离级别</span><br><span class="line">    use world;</span><br><span class="line">    select * from t1;  # 和窗口一的第一次查询时间同步</span><br><span class="line">    select * from t1;  # 当窗口一提交了事务之后再查询发现此时已经改变了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">隔离级别负责的是,MVCC,读一致性问题</span><br><span class="line">RU  : 读未提交,可脏读,一般部议叙出现</span><br><span class="line">RC  : 读已提交,可能出现幻读,可以防止脏读.</span><br><span class="line">RR  : 解决了不可重复读,功能是防止&quot;幻读&quot;现象 ,利用的是undo的快照技术+GAP(间隙锁)+NextLock(下键锁)</span><br><span class="line">SR  : 可串行化,可以防止死锁,但是并发事务性能较差</span><br><span class="line"></span><br><span class="line">幻读现象是由MVCC+GAP+Next-Lock解决</span><br><span class="line"></span><br><span class="line">补充: 在RC级别下,可以减轻GAP+NextLock锁的问题,但是会出现幻读现象,一般在为了读一致性会在正常select后添加for update语句.但是,请记住执行完一定要commit 否则容易出现所等待比较严重.</span><br><span class="line">例如:</span><br><span class="line">[world]&gt;select * from city where id=999 for update;</span><br><span class="line">[world]&gt;commit;</span><br></pre></td></tr></table></figure></li>
<li><h5 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 环境准备</span><br><span class="line">select @@tx_isolation;  # RC模式</span><br><span class="line">select @@autocommit;  # 0</span><br><span class="line"></span><br><span class="line"># 建库建表</span><br><span class="line">create database test charset utf8mb4;</span><br><span class="line">use test;</span><br><span class="line">create table t1(id int not null primary key auto_increment, num int not null);</span><br><span class="line">insert into t1(num) values (1),(3),(5);</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line"># mysql 窗口一</span><br><span class="line">begin;</span><br><span class="line">update t1 set num=10 where num&gt;=3;</span><br><span class="line">commit;</span><br><span class="line"># 上面的更新语句和窗口二的插入语句两个事务同时进行</span><br><span class="line"></span><br><span class="line">select * from t1;  # 此时发现会多一条 num 为 7 的列，这种现象就是幻读</span><br><span class="line"></span><br><span class="line"># mysql 窗口二</span><br><span class="line">begin;</span><br><span class="line">insert into t1(num) values(7);</span><br><span class="line">commit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># RR 模式下</span><br><span class="line">    # 环境准备</span><br><span class="line">    set global transaction_isolation=&#x27;repeatable-read&#x27;;  # 需要退出窗口后重新进入</span><br><span class="line">    select @@tx_isolation;  # RR级别</span><br><span class="line">    select @@autocommit;  # 0</span><br><span class="line"></span><br><span class="line">    # 创建表</span><br><span class="line">    use test;</span><br><span class="line">    create table t2(id int not null primary key auto_increment, num int not null);</span><br><span class="line">    insert into t2(num) values (1),(3),(5);</span><br><span class="line">    alter table t2 add index idx(num); </span><br><span class="line">    commit;</span><br><span class="line"></span><br><span class="line">		# mysql 窗口一</span><br><span class="line">    begin;</span><br><span class="line">    update t2 set num=10 where num&gt;=3;  # 更新表之后开始窗口二</span><br><span class="line"></span><br><span class="line">    # mysql 窗口二</span><br><span class="line">    begin;</span><br><span class="line">    insert into t1(num) values(7);  </span><br><span class="line">    # 当窗口一更新之后此时再插入发现夯住 </span><br><span class="line">    # ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</span><br><span class="line">    # 防止幻读</span><br><span class="line">    # 辅助索引+Next-Lock</span><br></pre></td></tr></table></figure>
<p>幻读<br><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/yMjqBO.png" alt="yMjqBO"></p>
<p>不可幻读<br><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/GhQN3e.png" alt="GhQN3e"></p>
</li>
</ul>
<h4 id="InnoDB核心参数"><a href="#InnoDB核心参数" class="headerlink" title="InnoDB核心参数"></a>InnoDB核心参数</h4><h5 id="双一标准之一-innodb-flush-log-at-trx-commit"><a href="#双一标准之一-innodb-flush-log-at-trx-commit" class="headerlink" title="双一标准之一(innodb_flush_log_at_trx_commit)"></a>双一标准之一(<code>innodb_flush_log_at_trx_commit</code>)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 参数</span><br><span class="line">innodb_flush_log_at_trx_commit=1</span><br><span class="line"></span><br><span class="line"># 作用</span><br><span class="line">控制了redo buffer 刷写策略，是一个安全参数，是一个5.6版本的以上默认的参数</span><br><span class="line">redo buffer ---&gt; ib_logfileo~N</span><br><span class="line"></span><br><span class="line"># 查看参数</span><br><span class="line">select @@innodb_flush_log_at_trx_commit;</span><br><span class="line"></span><br><span class="line"># 参数说明</span><br><span class="line">1: 每次事务提交，都会立即刷下redo到磁盘(redo buffer --每事务--&gt;os buffer --每事务--&gt; 磁盘)</span><br><span class="line">0: 表示当事务提交时，不立即做日志写入操作(redo buffer --每秒--&gt;os buffer --每秒--&gt; 磁盘)</span><br><span class="line">2: 每次事务提交时写入文件缓存(redo buffer --每事务--&gt;os buffer --每秒--&gt; 磁盘)</span><br></pre></td></tr></table></figure>

<h5 id="Innodb-flush-method"><a href="#Innodb-flush-method" class="headerlink" title="Innodb_flush_method"></a><code>Innodb_flush_method</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 作用 </span><br><span class="line">	控制了redo buffer 和 data buffer 刷写磁盘的时候是否经过文件系统缓存</span><br><span class="line"> </span><br><span class="line"># 查看</span><br><span class="line">  show variables like &#x27;%innodb_flush%&#x27;;</span><br><span class="line"> </span><br><span class="line"># 参数值说明</span><br><span class="line">  O_DIRECT  :数据缓冲区写磁盘,不走OS buffer </span><br><span class="line">  fsync     :日志和数据缓冲区写磁盘,都走OS buffer </span><br><span class="line">  O_DSYNC   :日志缓冲区写磁盘,不走 OS buffer</span><br><span class="line"> </span><br><span class="line"># 使用建议 </span><br><span class="line">  最高安全模式</span><br><span class="line">  innodb_flush_log_at_trx_commit=1</span><br><span class="line">  innodb_flush_method=O_DIRECT</span><br><span class="line">  最高性能:</span><br><span class="line">  innodb_flush_log_at_trx_commit=0</span><br><span class="line">  innodb_flush_method=fsync</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/TsmCEP.jpg" alt="TsmCEP"></p>
<h5 id="redo日志参数设置"><a href="#redo日志参数设置" class="headerlink" title="redo日志参数设置"></a><code>redo</code>日志参数设置</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">innodb_log_buffer_size=16777216  # 调大并发的数量会越多，128M起，结合业务调整，这边单位是字节</span><br><span class="line">innodb_log_file_size=50331648  # 一般是log_buffer 1-2倍</span><br><span class="line">innodb_log_files_in_group = 3  # 3-4组</span><br></pre></td></tr></table></figure>

<h5 id="innodb-buffer-pool-size"><a href="#innodb-buffer-pool-size" class="headerlink" title="innodb_buffer_pool_size"></a><code>innodb_buffer_pool_size</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一般调整为物理内存的50%-80%(系统中只有一个mysql实例)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引管理</title>
    <url>/5c917bb6.html</url>
    <content><![CDATA[<h3 id="索引的作用"><a href="#索引的作用" class="headerlink" title="索引的作用"></a>索引的作用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">提供了类似书中目录的作用，目的是为了优化查询</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="索引的种类"><a href="#索引的种类" class="headerlink" title="索引的种类"></a>索引的种类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B树索引  # 默认使用的索引类型</span><br><span class="line">Hash索引</span><br><span class="line">R树索引</span><br><span class="line">Full text</span><br><span class="line">GIS</span><br></pre></td></tr></table></figure>

<h3 id="B树算法"><a href="#B树算法" class="headerlink" title="B树算法"></a>B树算法</h3><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/yMfE8O.jpg" alt="yMfE8O"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/b+tree.JPG" alt="b+tree"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B-tree</span><br><span class="line">B+Tree  # 在范围查询方面提供了更好的性能(&gt; &lt; &gt;= &lt;= like)  页子节点有双向指针</span><br><span class="line">B*Tree  # 枝节点有双向指针</span><br></pre></td></tr></table></figure>

<h3 id="辅助索引和聚集索引"><a href="#辅助索引和聚集索引" class="headerlink" title="辅助索引和聚集索引"></a>辅助索引和聚集索引</h3><h5 id="辅助索引-S-怎么构建B树结构"><a href="#辅助索引-S-怎么构建B树结构" class="headerlink" title="辅助索引(S)怎么构建B树结构"></a>辅助索引(S)怎么构建B树结构</h5>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 辅助索引是基于表的列进行生成的</span><br><span class="line">2. 取出索引列的所有值(取出所有键值)</span><br><span class="line">3. 进行所有键值的排序</span><br><span class="line">4. 将所有的键值按顺序落到BTree索引的叶子节点上(16K)</span><br><span class="line">5. 然后生成此索引键值所对应得后端数据页的指针</span><br><span class="line">6. 进而生成枝节点和根节点</span><br><span class="line">7. 叶子节点除了存储键值之外，还存储了相邻叶子节点的指针，另外还会保存原表数据的指针</span><br><span class="line"></span><br><span class="line">id  name  age  gender</span><br><span class="line">select  *  from  t1 where id=10;</span><br><span class="line">问题: 基于索引键做where查询,对于id列是顺序IO,但是对于其他列的查询,可能是随机IO.</span><br></pre></td></tr></table></figure>
<h5 id="聚集索引-C-怎么构建B树结构"><a href="#聚集索引-C-怎么构建B树结构" class="headerlink" title="聚集索引(C)怎么构建B树结构"></a>聚集索引(C)怎么构建B树结构</h5>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 建表时有主键列</span><br><span class="line">2. 表中进行数据存储时，会按照ID列的顺序，有序的存储一行一行的数据到数据页上(聚集索引组织表)</span><br><span class="line">3. 表中的数据页被作为聚集索引的叶子节点</span><br><span class="line">4. 把叶子节点的主键值生成上层枝节点和根节点</span><br></pre></td></tr></table></figure>
<h5 id="聚集索引和辅助索引构成区别总结"><a href="#聚集索引和辅助索引构成区别总结" class="headerlink" title="聚集索引和辅助索引构成区别总结"></a>聚集索引和辅助索引构成区别总结</h5>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 聚集索引只能有一个，非空唯一，一般是主键</span><br><span class="line">2. 辅助索引可以有多个，是配合聚集索引使用</span><br><span class="line">3. 聚集索引叶子节点，就是磁盘的数据行存储的数据页</span><br><span class="line">4. MySQL是根据聚集索引，组织存储数据，数据存储时就是安装聚集索引的顺序进行存储数据</span><br><span class="line">5. 辅助索引只会提取索引键值，进行自动排序生成B树结构</span><br></pre></td></tr></table></figure>
<h5 id="辅助索引细分"><a href="#辅助索引细分" class="headerlink" title="辅助索引细分"></a>辅助索引细分</h5>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">单列的辅助索引</span><br><span class="line">联合多列辅助索引(覆盖索引)</span><br><span class="line">唯一索引</span><br></pre></td></tr></table></figure>
<h5 id="影响索引树高度"><a href="#影响索引树高度" class="headerlink" title="影响索引树高度"></a>影响索引树高度</h5>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">数据行多  # 使用分表</span><br><span class="line">索引列字符长度  # 前缀索引</span><br><span class="line">数据类型 char varchar  # 优化表设计</span><br><span class="line">enum 优化索引高度  # 尽量使用</span><br></pre></td></tr></table></figure>

<h3 id="压测"><a href="#压测" class="headerlink" title="压测"></a>压测</h3><h5 id="产生数据"><a href="#产生数据" class="headerlink" title="产生数据"></a>产生数据</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 方式一 使用sql语句产生数据</span><br><span class="line">    create database d100w charset utf8mb4 collate utf8mb4_bin;</span><br><span class="line">    use d100w;</span><br><span class="line">    create table t100w (id int,num int,</span><br><span class="line">    k1 char(2),</span><br><span class="line">    k2 char(4),</span><br><span class="line">    dt timestamp) charset utf8mb4 collate utf8mb4_bin;</span><br><span class="line">    delimiter //</span><br><span class="line">    create  procedure rand_data(in num int)</span><br><span class="line">    begin</span><br><span class="line">    declare str char(62) default &#x27;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&#x27;;</span><br><span class="line">    declare str2 char(2);</span><br><span class="line">    declare str4 char(4);</span><br><span class="line">    declare i int default 0;</span><br><span class="line">    while i&lt;num do</span><br><span class="line">    set str2=concat(substring(str,1+floor(rand()*61),1),substring(str,1+floor(rand()*61),1));</span><br><span class="line">    set str4=concat(substring(str,1+floor(rand()*61),2),substring(str,1+floor(rand()*61),2));</span><br><span class="line">    set i=i+1;</span><br><span class="line">    insert into t100w values (i,floor(rand()*num),str2,str4,now());</span><br><span class="line">    end while;</span><br><span class="line">    end;</span><br><span class="line">    //</span><br><span class="line">    delimiter ;</span><br><span class="line"></span><br><span class="line">    # 插入100w条数据：</span><br><span class="line">    call rand_data(1000000);</span><br><span class="line">    commit;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 方式二 直接导入测试表(可以会出现链接失效的情况)</span><br><span class="line">    cd /tmp</span><br><span class="line">    wget https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/sql/100w.sql.zip </span><br><span class="line">    unzip 100w.sql.zip</span><br><span class="line">    mysql -uroot -p</span><br><span class="line"></span><br><span class="line">    create database test charset utf8mb4 collate utf8mb4_bin;</span><br><span class="line">    use test;</span><br><span class="line">    source /tmp/100w.sql</span><br></pre></td></tr></table></figure>
<h5 id="压力测试语句"><a href="#压力测试语句" class="headerlink" title="压力测试语句"></a>压力测试语句</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 没有创建索引之前</span><br><span class="line">    mysqlslap --defaults-file=/etc/my.cnf \</span><br><span class="line">    --concurrency=100 --iterations=1 --create-schema=&#x27;test&#x27; \</span><br><span class="line">    --query=&quot;select * from test.t100w where k2=&#x27;BC56&#x27;&quot; engine=innodb \</span><br><span class="line">    --number-of-queries=2000 -uroot -p1 -verbose</span><br><span class="line">    # 4c8g 运行了400多秒</span><br><span class="line"></span><br><span class="line"># 创建索引之后</span><br><span class="line">    # sql语句</span><br><span class="line">    alter table t100w add index idx_k2(k2);</span><br><span class="line">    </span><br><span class="line">    # 命令行</span><br><span class="line">    mysqlslap --defaults-file=/etc/my.cnf \</span><br><span class="line">    --concurrency=100 --iterations=1 --create-schema=&#x27;test&#x27; \</span><br><span class="line">    --query=&quot;select * from test.t100w where k2=&#x27;BC56&#x27;&quot; engine=innodb \</span><br><span class="line">    --number-of-queries=2000 -uroot -p1 -verbose</span><br><span class="line">    # 4c8g 此时只需要1秒不到</span><br></pre></td></tr></table></figure>

<h3 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h3><h5 id="表结构说明"><a href="#表结构说明" class="headerlink" title="表结构说明"></a>表结构说明</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">desc world.city;</span><br><span class="line">+-------------+----------+------+-----+---------+----------------+</span><br><span class="line">| Field       | Type     | Null | Key | Default | Extra          |</span><br><span class="line">+-------------+----------+------+-----+---------+----------------+</span><br><span class="line">| ID          | int(11)  | NO   | PRI | NULL    | auto_increment |</span><br><span class="line">| Name        | char(35) | NO   |     |         |                |</span><br><span class="line">| CountryCode | char(3)  | NO   | MUL |         |                |</span><br><span class="line">| District    | char(20) | NO   |     |         |                |</span><br><span class="line">| Population  | int(11)  | NO   |     | 0       |                |</span><br><span class="line">+-------------+----------+------+-----+---------+----------------+</span><br><span class="line"></span><br><span class="line">Field :列名字</span><br><span class="line">key  :有没有索引,索引类型</span><br><span class="line">PRI: 主键索引</span><br><span class="line">UNI: 唯一索引</span><br><span class="line">MUL: 辅助索引(单列,联和,前缀)</span><br></pre></td></tr></table></figure>

<h5 id="索引的创建"><a href="#索引的创建" class="headerlink" title="索引的创建"></a>索引的创建</h5><h6 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h6>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建索引的时候会短暂的锁表，业务不忙的时候操作</span><br><span class="line">alter table t100w add index idx_k2(k2);</span><br><span class="line"></span><br><span class="line"># 查看索引情况</span><br><span class="line">    use test;</span><br><span class="line">    desc t100w;</span><br><span class="line">    # 此时 k2 这一行中的 Key 值为 MUL, 为辅助索引 </span><br><span class="line"></span><br><span class="line">    show index from t100w\G</span><br></pre></td></tr></table></figure>

<h6 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h6>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 建立唯一索的列不能有重复值</span><br><span class="line"></span><br><span class="line"># 查看k1列不重复情况,如果有重复值就不能创建唯一索引</span><br><span class="line">select count(distinct k1) from t100w;</span><br><span class="line">select k1,count(k1) from t100w group by k1 having count(k1)  &gt;1;</span><br><span class="line"></span><br><span class="line"># 当有重复值的时候创建唯一索引时会报错</span><br><span class="line">alter table t100w add unique index idx_k1(k1);</span><br></pre></td></tr></table></figure>

<h6 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h6>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 只能用于字符串类型的列上</span><br><span class="line">desc world.city;</span><br><span class="line"></span><br><span class="line">alter table world.city add index indx_name(name(5));  # 用name列的前5个字符</span><br><span class="line"></span><br><span class="line">desc world.city;</span><br></pre></td></tr></table></figure>

<h6 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h6>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table world.city add index idx_co_po(countrycode,population);</span><br></pre></td></tr></table></figure>

<h6 id="查看删除索引"><a href="#查看删除索引" class="headerlink" title="查看删除索引"></a>查看删除索引</h6>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看索引</span><br><span class="line">show index from world.city;</span><br><span class="line"></span><br><span class="line"># 删除索引</span><br><span class="line">alter table world.city drop index idx_co_po;</span><br></pre></td></tr></table></figure>


<h3 id="索引应用规范"><a href="#索引应用规范" class="headerlink" title="索引应用规范"></a>索引应用规范</h3><h5 id="建立索引的原则-DBA运维规范"><a href="#建立索引的原则-DBA运维规范" class="headerlink" title="建立索引的原则(DBA运维规范)"></a>建立索引的原则(DBA运维规范)</h5><blockquote>
<p>为了使索引的使用效率更高，在创建索引时，必须考虑在哪些字段上创建索引和创建什么类型的索引。那么索引设计原则又是怎样的<br>建表时一定要有主键，一般是个无关列</p>
</blockquote>
<ul>
<li><p>选择唯一索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">唯一性索引的值是唯一的，可以更快速的通过该索引来确定某条记录。</span><br><span class="line">例如，学生表中学号是具有唯一性的字段。为该字段建立唯一性索引可以很快的确定某个学生的信息。</span><br><span class="line">如果使用姓名的话，可能存在同名现象，从而降低查询速度。</span><br><span class="line"></span><br><span class="line">优化方案:</span><br><span class="line">(1) 如果非得使用重复值较多的列作为查询条件(例如:男女),可以将表逻辑拆分</span><br><span class="line">(2) 可以将此列和其他的查询类,做联和索引</span><br><span class="line">select count(*) from world.city;</span><br><span class="line">select count(distinct countrycode) from world.city;</span><br><span class="line">select count(distinct countrycode,population ) from world.city;</span><br></pre></td></tr></table></figure></li>
<li><p>经常作为where条件列，<code>order by</code>、<code>group by</code>、<code>join on</code>、<code>distinct</code>的条件</p>
</li>
<li><p>列值长度较长的索引，建议使用前缀索引</p>
</li>
<li><p>降低索引条目，一方面不要创建没用索引，不常使用的索引清理，<code>percon-toolkit</code>有工具可以分析索引是否有用</p>
</li>
<li><p>大表建索引时，要在业务不繁忙期间操作</p>
</li>
<li><p>尽量少在经常更新值的列上建索引</p>
</li>
</ul>
<h5 id="不走索引的情况-开发规范"><a href="#不走索引的情况-开发规范" class="headerlink" title="不走索引的情况(开发规范)"></a>不走索引的情况(开发规范)</h5><ul>
<li>没有查询条件，或者查询条件没有建立索引</li>
<li>查询结果集是原表中的大部分数据，应该是25％以上</li>
<li>索引本身失效，统计数据不真实</li>
<li>查询条件使用函数在索引列上，或者对索引列进行运算，运算包括<code>(+，-，*，/，! </code>)</li>
<li>隐式转换导致索引失效.这一点应当引起重视.也是开发中经常会犯的错误</li>
<li><code>&lt;&gt;</code> ，<code>not in</code> 不走索引（辅助索引）</li>
<li><code>like &quot;%_&quot;</code> 百分号在最前面不走</li>
</ul>
<h3 id="执行计划"><a href="#执行计划" class="headerlink" title="执行计划"></a>执行计划</h3><h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 上线新的查询语句之前，进行提前预估语句的性能</span><br><span class="line">2. 在出现性能问题时，找到合理的解决思路</span><br></pre></td></tr></table></figure>

<h6 id="执行计划获取"><a href="#执行计划获取" class="headerlink" title="执行计划获取"></a>执行计划获取</h6>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 一般是针对 select 语句获取执行计划</span><br><span class="line"></span><br><span class="line"># 查看语句的执行计划</span><br><span class="line">desc select * from test.t100w where k2=&#x27;BC56&#x27;;</span><br><span class="line">explain select * from test.t100w where k2=&#x27;BC56&#x27;\G</span><br><span class="line"></span><br><span class="line"># 结果</span><br><span class="line">*************************** 1. row ***************************</span><br><span class="line">           id: 1</span><br><span class="line">  select_type: SIMPLE</span><br><span class="line">        table: t100w</span><br><span class="line">   partitions: NULL</span><br><span class="line">         type: ref</span><br><span class="line">possible_keys: idx_k2</span><br><span class="line">          key: idx_k2</span><br><span class="line">      key_len: 17</span><br><span class="line">          ref: const</span><br><span class="line">         rows: 406</span><br><span class="line">     filtered: 100.00</span><br><span class="line">        Extra: NULL</span><br><span class="line">1 row in set, 1 warning (0.00 sec)</span><br><span class="line"></span><br><span class="line"># 参数说明</span><br><span class="line">table: t100w  # 表名,多表查询的时候关注</span><br><span class="line">type: ref  # 索引的应用级别     </span><br><span class="line">possible_keys: idx_k2  # 可能会使用到的索引</span><br><span class="line">key: idx_k2  # 实际上使用的索引</span><br><span class="line">key_len: 17  # 联合索引覆盖长度</span><br><span class="line">rows: 406  # 查询的行数(越少越好)</span><br><span class="line">Extra: NULL  # 额外的信息</span><br></pre></td></tr></table></figure>

<h6 id="应用级别type详解"><a href="#应用级别type详解" class="headerlink" title="应用级别type详解"></a>应用级别<code>type</code>详解</h6>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># type的级别如下,从上到下性能越好,至少优化到range以上</span><br><span class="line">1. ALL: 全表扫描,不走索引</span><br><span class="line">    desc select * from t100w;  # 没有条件能走索引的</span><br><span class="line">     </span><br><span class="line">    没建立索引  </span><br><span class="line">    建立索引不走</span><br><span class="line">    desc select * from t100w where k1=&#x27;aa&#x27;;  # 上面例子中创建的索引时针对k2列的,k1列并没有创建索引</span><br><span class="line">    desc select * from t100w where k2!=&#x27;aaaa&#x27;;  # 不等于的条件也是不走索引的</span><br><span class="line">    desc select * from t100w where k2 like &#x27;%xt%&#x27;;  # 模糊查询时当%在前面时不走索引  或者not in也不走索引</span><br><span class="line"></span><br><span class="line">2. index: 全索引扫描,将整个索引树全部扫描一遍才能达到效果</span><br><span class="line">    desc select k2 from t100w;</span><br><span class="line"></span><br><span class="line">3. range: 索引范围扫描,扫描索引树的一部分</span><br><span class="line">    辅助索引 &gt; &lt; &gt;= &lt;= like in or  # 这些语句会走范围扫描,尽量避免 in or</span><br><span class="line">    主键 !=</span><br><span class="line">    desc select * from world.city where id &gt; 1000;</span><br><span class="line">    desc select * from world.city where id != 1000;</span><br><span class="line">    desc select * from world.city where countrycode like &#x27;C%&#x27;;</span><br><span class="line">		</span><br><span class="line">    desc select * from world.city where countrycode in (&#x27;CHN&#x27;,&#x27;USA&#x27;);  # 可以改写为下面的语句</span><br><span class="line">		</span><br><span class="line">    desc </span><br><span class="line">    select * from world.city where countrycode=&#x27;CHN&#x27; </span><br><span class="line">    union all </span><br><span class="line">    select * from world.city where countrycode=&#x27;USA&#x27;;</span><br><span class="line">    # 此时可以看到type级别为ref</span><br><span class="line">	</span><br><span class="line">4. ref: 辅助索引等值查询</span><br><span class="line">    desc select * from world.city where countrycode=&#x27;CHN&#x27;;</span><br><span class="line"></span><br><span class="line">5. eq_ref: 在多表连接查询时 on 的条件列时唯一索引或主键</span><br><span class="line">    desc </span><br><span class="line">    select a.name,b.name,b.surfacearea </span><br><span class="line">    from world.city as a </span><br><span class="line">    join world.country as b </span><br><span class="line">    on a.countrycode=b.code </span><br><span class="line">    where a.population &lt; 100;</span><br><span class="line"></span><br><span class="line">6. const,system: 主键或唯一键等值查询</span><br><span class="line">    desc select * from world.city where id=10;</span><br><span class="line">    </span><br><span class="line">7. null: 查不到数据的时候</span><br></pre></td></tr></table></figure>

<h6 id="Extra额外的信息"><a href="#Extra额外的信息" class="headerlink" title="Extra额外的信息"></a><code>Extra</code>额外的信息</h6><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 当出现 using filesort 时说明索引设计不合理, 使用了文件排序</span><br><span class="line">desc select * from world.city where countrycode=&#x27;CHN&#x27; order by population;</span><br><span class="line"></span><br><span class="line"># 没见索引之前</span><br><span class="line">desc select * from world.city where countrycode=&#x27;CHN&#x27; order by population limit 10;</span><br><span class="line"></span><br><span class="line"># 建立联合索引</span><br><span class="line">alter table world.city add index idx_co_po(countrycode,population);</span><br><span class="line">desc select * from world.city where countrycode=&#x27;CHN&#x27; order by population limit 10;</span><br><span class="line"></span><br><span class="line">结论: </span><br><span class="line">1.当我们看到执行计划extra位置出现filesort,说明由文件排序出现</span><br><span class="line">2.观察需要排序(ORDER BY,GROUP BY ,DISTINCT )的条件,有没有索引</span><br><span class="line">3. 根据子句的执行顺序,去创建联合索引</span><br></pre></td></tr></table></figure>
</code></pre>
<h6 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h6><pre><code><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">explain(desc)使用场景</span><br><span class="line">题目意思:  我们公司业务慢,请你从数据库的角度分析原因</span><br><span class="line">1.mysql出现性能问题,我总结有两种情况:</span><br><span class="line">（1）应急性的慢：突然夯住</span><br><span class="line">      应急情况:数据库hang(卡了,资源耗尽)</span><br><span class="line">      处理过程:</span><br><span class="line">      1.show processlist;  获取到导致数据库hang的语句</span><br><span class="line">      2. explain 分析SQL的执行计划,有没有走索引,索引的类型情况</span><br><span class="line">      3. 建索引,改语句</span><br><span class="line">（2）一段时间慢(持续性的):</span><br><span class="line">      (1)记录慢日志slowlog,分析slowlog</span><br><span class="line">      (2)explain 分析SQL的执行计划,有没有走索引,索引的类型情况</span><br><span class="line">      (3)建索引,改语句</span><br></pre></td></tr></table></figure>
</code></pre>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL基础应用</title>
    <url>/8da0cafb.html</url>
    <content><![CDATA[<h3 id="SQL介绍"><a href="#SQL介绍" class="headerlink" title="SQL介绍"></a>SQL介绍</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">结构化查询语言</span><br><span class="line">5.7 以后符合SQL92严格模式</span><br><span class="line">通过sql_mode参数来控制</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="常用SQL分类"><a href="#常用SQL分类" class="headerlink" title="常用SQL分类"></a>常用SQL分类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DDL：数据定义语言</span><br><span class="line">DCL：数据控制语言</span><br><span class="line">DML：数据操作语言</span><br><span class="line">DQL：数据的查询语言</span><br></pre></td></tr></table></figure>

<h3 id="数据类型、表属性、字符集"><a href="#数据类型、表属性、字符集" class="headerlink" title="数据类型、表属性、字符集"></a>数据类型、表属性、字符集</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul>
<li><p>作用</p>
<p>保证数据的准确性和标准性</p>
</li>
<li><p>种类</p>
<ul>
<li>数值类型<br><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/nhK9zp.jpg" alt="nhK9zp"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tinyint  ： -128~127</span><br><span class="line">int       ：-2^31~2^31-1</span><br><span class="line">说明：手机号是无法存储到int的。一般是使用char类型来存储手机号</span><br></pre></td></tr></table></figure></li>
<li>字符类型<br><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/1hM1f0.jpg" alt="1hM1f0"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">char(11) ：</span><br><span class="line">定长 的字符串类型,在存储字符串时，最大字符长度11个，立即分配11个字符长度的存储空间，如果存不满，空格填充。</span><br><span class="line">varchar(11):</span><br><span class="line">变长的字符串类型看，最大字符长度11个。在存储字符串时，自动判断字符长度，按需分配存储空间。</span><br><span class="line">enum(&#x27;bj&#x27;,&#x27;tj&#x27;,&#x27;sh&#x27;)：</span><br><span class="line">枚举类型，比较适合于将来此列的值是固定范围内的特点，可以使用enum,可以很大程度的优化我们的索引结构。</span><br></pre></td></tr></table></figure></li>
<li>时间类型<br> <img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/U36oxW.jpg" alt="U36oxW"> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">datatime</span><br><span class="line">范围为从 1000-01-01 00:00:00.000000 至 9999-12-31 23:59:59.999999</span><br><span class="line">timestamp</span><br><span class="line">范围为从 1970-01-01 00:00:00.000000 至 2038-01-19 03:14:07.999999</span><br></pre></td></tr></table></figure>
<ul>
<li>二进制类型<br><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/va4HxB.jpg" alt="va4HxB"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="列属性"><a href="#列属性" class="headerlink" title="列属性"></a>列属性</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">约束(一般建表时添加):</span><br><span class="line">primary key: 主键约束</span><br><span class="line">设置为主键的列，此列的值必须非空且唯一，主键在一个表中只能有一个</span><br><span class="line"></span><br><span class="line">not null: 非空约束</span><br><span class="line">列值不能为空，也是表设计的规范，尽可能将所有的列设置为非空，可以设置默认值0</span><br><span class="line"></span><br><span class="line">unique key: 唯一键</span><br><span class="line">列值不能重复</span><br><span class="line"></span><br><span class="line">unsigned: 无符号</span><br><span class="line">针对数字列，非负数</span><br><span class="line"></span><br><span class="line"># 其他属性:</span><br><span class="line">key: 索引</span><br><span class="line">可以在某列上建立索引，来优化索引，一般是根据需要后添加</span><br><span class="line"></span><br><span class="line">default: 默认值</span><br><span class="line">列中，没有录入值时，会自动使用default的值填充</span><br><span class="line"></span><br><span class="line">auto_increment: 自增长</span><br><span class="line">针对数字列，顺序的自动填充数据(默认是从1开始，将来可以设置起始点和偏移量)</span><br><span class="line"></span><br><span class="line">comment: 注释</span><br></pre></td></tr></table></figure>

<h4 id="表属性"><a href="#表属性" class="headerlink" title="表属性"></a>表属性</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">存储引擎:</span><br><span class="line">InnoDB（默认的）</span><br><span class="line"></span><br><span class="line">字符集和排序规则:</span><br><span class="line">utf8       </span><br><span class="line">utf8mb4</span><br></pre></td></tr></table></figure>

<h4 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show charset;  # 查看 mysql 支持的所有字符集</span><br><span class="line">utf8: 3 个字节</span><br><span class="line">utf8mb4: 4 个字节，支持 emoji</span><br></pre></td></tr></table></figure>

<h3 id="DDL的应用"><a href="#DDL的应用" class="headerlink" title="DDL的应用"></a>DDL的应用</h3><h4 id="库定义"><a href="#库定义" class="headerlink" title="库定义"></a>库定义</h4><ul>
<li><p>创建数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">建库规范：</span><br><span class="line">    1.库名不能有大写字母   </span><br><span class="line">    2.建库要加字符集         </span><br><span class="line">    3.库名不能有数字开头</span><br><span class="line">    4. 库名要和业务相关</span><br><span class="line">    </span><br><span class="line">建库标准语句</span><br><span class="line">create database test charset utf8mb4 collate utf8mb4_bin;</span><br></pre></td></tr></table></figure></li>
<li><p>删除</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 生产中禁止</span><br><span class="line">drop database school;</span><br></pre></td></tr></table></figure></li>
<li><p>修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个没有设置字符集的库</span><br><span class="line">create database school;</span><br><span class="line"></span><br><span class="line"># 如果是已经创建好的库的查看建库语句</span><br><span class="line">show create database school;</span><br><span class="line"></span><br><span class="line"># 修改字符集</span><br><span class="line">alter database school charset utf8mb4 collate utf8mb4_bin;</span><br><span class="line"># 注意：修改字符集，修改后的字符集一定是原字符集的严格超集(从小往大，不能从大往小)</span><br></pre></td></tr></table></figure></li>
<li><p>查询(属于DQL)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看所有库</span><br><span class="line">show databases;</span><br><span class="line"></span><br><span class="line"># 查看库的建库语句</span><br><span class="line">show create database test;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="表定义"><a href="#表定义" class="headerlink" title="表定义"></a>表定义</h4><ul>
<li><p>创建表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">建表规范:</span><br><span class="line">    1. 表名小写</span><br><span class="line">    2. 不能是数字开头</span><br><span class="line">    3. 注意字符集和存储引擎</span><br><span class="line">    4. 表名和业务有关</span><br><span class="line">    5. 选择合适的数据类型</span><br><span class="line">    6. 每个列都要有注释</span><br><span class="line">    7. 每个列设置为非空，无法保证非空，用0来填充</span><br><span class="line">    </span><br><span class="line">格式:</span><br><span class="line">    create table stu(</span><br><span class="line">    列1  属性（数据类型、约束、其他属性） ，</span><br><span class="line">    列2  属性，</span><br><span class="line">    列3  属性</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">创建一个学生表：</span><br><span class="line">use school;</span><br><span class="line">create table stu(</span><br><span class="line">id        int not null primary key auto_increment comment &#x27;学号&#x27;,</span><br><span class="line">sname     varchar(255) not null comment &#x27;姓名&#x27;,</span><br><span class="line">sage      tinyint unsigned not null default 0 comment &#x27;年龄&#x27;,</span><br><span class="line">sgender   enum(&#x27;m&#x27;,&#x27;f&#x27;,&#x27;n&#x27;) not null default &#x27;n&#x27; comment &#x27;性别&#x27;,</span><br><span class="line">sfz       char(18) not null unique comment &#x27;身份证&#x27;,</span><br><span class="line">intime    timestamp not null default now() comment &#x27;入学时间&#x27;</span><br><span class="line">) engine=innodb charset= utf8mb4 comment &#x27;学生表&#x27;;</span><br><span class="line"></span><br><span class="line">show tables;  # 查看是否创建成功</span><br><span class="line">desc stu;  # 查看表结构信息</span><br><span class="line">show create table stu;  # 查看建表语句</span><br></pre></td></tr></table></figure></li>
<li><p>修改表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在stu表中添加qq列</span><br><span class="line">alter table stu add qq varchar(20) not null unique comment &#x27;qq号&#x27;;</span><br><span class="line"></span><br><span class="line"># 在sname后加微信列</span><br><span class="line">alter table stu add wechat varchar(20) not null unique comment &#x27;微信号&#x27; after sname;</span><br><span class="line"></span><br><span class="line"># 在id列前面加一个新列的num</span><br><span class="line">alter table stu add num int not null comment &#x27;数字&#x27; first;</span><br><span class="line"></span><br><span class="line"># 修改sname数据类型</span><br><span class="line">alter table stu modify sname varchar(128) not null;</span><br><span class="line"></span><br><span class="line"># 将sgender该为sex 数据类型改为char类型</span><br><span class="line">alter table stu change sgender sex char(1) not null default &#x27;n&#x27;;</span><br><span class="line"></span><br><span class="line"># 删除刚才添加的列</span><br><span class="line">alter table stu drop num;</span><br><span class="line">alter table stu drop qq;</span><br><span class="line">alter table stu drop wechat;</span><br></pre></td></tr></table></figure></li>
<li><p>查询表属性(DQL)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use school;</span><br><span class="line">show tables;</span><br><span class="line">desc stu;</span><br><span class="line">show create table stu;</span><br><span class="line">create table test like stu;  # 创建一个和stu表结构一样的test表</span><br></pre></td></tr></table></figure></li>
<li><p>删除表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table stu;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="DCL的应用"><a href="#DCL的应用" class="headerlink" title="DCL的应用"></a>DCL的应用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用户的授权和权限的回收</span><br><span class="line">grant</span><br><span class="line">revoke</span><br></pre></td></tr></table></figure>

<h3 id="DML的应用"><a href="#DML的应用" class="headerlink" title="DML的应用"></a>DML的应用</h3><blockquote>
<p>对表中数据的增删改</p>
</blockquote>
<h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a><code>insert</code></h4>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 标准插入语句</span><br><span class="line">insert into stu(id,sname,sage,sex,sfz,intime)</span><br><span class="line">values</span><br><span class="line">(1,&#x27;zhangsan&#x27;,18,&#x27;m&#x27;,&#x27;110101199003070353&#x27;,now());</span><br><span class="line"></span><br><span class="line">select * from stu;  # 查看stu表内数据</span><br><span class="line"></span><br><span class="line"># 省事写法</span><br><span class="line">insert into stu</span><br><span class="line">values</span><br><span class="line">(2,&#x27;lisi&#x27;,19,&#x27;m&#x27;,&#x27;220101145664070363&#x27;,now());</span><br><span class="line"></span><br><span class="line"># 针对性录入数据</span><br><span class="line">insert into stu(sname,sfz)</span><br><span class="line">values(&#x27;wangwu&#x27;,&#x27;33452982337621&#x27;);</span><br><span class="line"></span><br><span class="line"># 同时录入多行数据</span><br><span class="line">insert into stu(sname,sfz)</span><br><span class="line">values</span><br><span class="line">(&#x27;tiansha&#x27;,&#x27;4324654324312&#x27;),</span><br><span class="line">(&#x27;aaa&#x27;,&#x27;321435212354154&#x27;),</span><br><span class="line">(&#x27;lxx&#x27;,&#x27;556652353265326&#x27;);</span><br></pre></td></tr></table></figure>

<h4 id="update"><a href="#update" class="headerlink" title="update"></a><code>update</code></h4>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from stu;</span><br><span class="line">update stu set sname=&#x27;lxx2&#x27; where id=9;</span><br><span class="line">select * from stu;</span><br><span class="line"></span><br><span class="line"># update语句必须要加where</span><br></pre></td></tr></table></figure>

<h4 id="delete"><a href="#delete" class="headerlink" title="delete"></a><code>delete</code></h4>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from stu where id=9;</span><br><span class="line"></span><br><span class="line"># 全表删除</span><br><span class="line">DELETE FROM stu</span><br><span class="line">truncate table stu;</span><br><span class="line"></span><br><span class="line">区别:</span><br><span class="line">delete: DML操作, 是逻辑性质删除,逐行进行删除,速度慢</span><br><span class="line">truncate: DDL操作,对与表段中的数据页进行清空,速度快</span><br><span class="line"></span><br><span class="line"># 伪删除</span><br><span class="line">	1.添加状态列</span><br><span class="line">  ALTER TABLE stu ADD state TINYINT NOT NULL DEFAULT 1 ;</span><br><span class="line">  SELECT * FROM stu;</span><br><span class="line">  2. UPDATE 替代 DELETE</span><br><span class="line">  UPDATE stu SET state=0 WHERE id=8;</span><br><span class="line">  3. 业务语句查询</span><br><span class="line">  SELECT * FROM stu WHERE state=1;</span><br></pre></td></tr></table></figure>

<h3 id="DQL的应用-select"><a href="#DQL的应用-select" class="headerlink" title="DQL的应用(select)"></a>DQL的应用(<code>select</code>)</h3><blockquote>
<p>作用: 获取MySQL中的数据行</p>
</blockquote>
<h4 id="单独使用"><a href="#单独使用" class="headerlink" title="单独使用"></a>单独使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- select @@xxx 查看系统参数</span><br><span class="line"></span><br><span class="line">SELECT @@port;  # 查看数据库软件的端口</span><br><span class="line">SELECT @@basedir;  # 查看数据库软件目录</span><br><span class="line">SELECT @@datadir;  # 查看数据库数据目录 </span><br><span class="line">SELECT @@socket;  # 查看数据库socket文件位置</span><br><span class="line">SELECT @@server_id;  # 查看server_id号</span><br><span class="line"></span><br><span class="line">show variables like &#x27;%innodb%&#x27;;</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- select 函数();</span><br><span class="line"></span><br><span class="line">SELECT NOW();</span><br><span class="line">SELECT DATABASE();</span><br><span class="line">SELECT USER();</span><br><span class="line">SELECT VERSION();</span><br><span class="line">SELECT CONCAT(&quot;hello world&quot;);</span><br><span class="line">SELECT CONCAT(USER,&quot;@&quot;,HOST) FROM mysql.user;</span><br><span class="line">SELECT GROUP_CONCAT(USER,&quot;@&quot;,HOST) FROM mysql.user;</span><br></pre></td></tr></table></figure>

<h4 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h4><p>SQL92标准的使用语法</p>
<h4 id="select语法执行顺序"><a href="#select语法执行顺序" class="headerlink" title="select语法执行顺序"></a>select语法执行顺序</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select开始 ----&gt; from子句 ----&gt; where子句 ----&gt; group by子句 ----&gt; select后执行条件 ----&gt; having子句 ----&gt; order by子句 ----&gt; limit</span><br></pre></td></tr></table></figure>

<h4 id="单表环境准备"><a href="#单表环境准备" class="headerlink" title="单表环境准备"></a>单表环境准备</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果下面的失效了在该网站下载, https://dev.mysql.com/doc/index-other.html</span></span><br><span class="line">wget https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/sql/world.sql</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql -uroot -p1 &lt; world.sql</span><br><span class="line"></span><br><span class="line">mysql -uroot -p1 -e <span class="string">&#x27;show databases;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看表</span></span><br><span class="line">show tables from world;</span><br><span class="line">city            </span><br><span class="line">country         </span><br><span class="line">countrylanguage </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看表结构</span></span><br><span class="line">desc city;</span><br></pre></td></tr></table></figure>

<h5 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a><code>FROM</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">use world;</span><br><span class="line">select * from city;  # 适合表数据行较少的，生产中较少使用，会造成数据库压力过大</span><br><span class="line"></span><br><span class="line"># 查询name 和 population的所有值</span><br><span class="line">select name,population from world.city;</span><br></pre></td></tr></table></figure>

<h5 id="WHERE"><a href="#WHERE" class="headerlink" title="WHERE"></a><code>WHERE</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># where 配合 等值查询(=)</span><br><span class="line">  # 查询 city 表中,中国城市信息</span><br><span class="line">  select * from world.city where countrycode=&#x27;CHN&#x27;;</span><br><span class="line"></span><br><span class="line"># where 配合 不等值查询(&gt; &gt;= &lt; &lt;= &lt;&gt;)</span><br><span class="line">  # 查询世界人口小于100人的城市</span><br><span class="line">  select * from world.city where population&lt;100;</span><br><span class="line">  </span><br><span class="line">  # 查询世界人口大于10000000的城市</span><br><span class="line">	select * from world.city where population &gt; 10000000;</span><br><span class="line">	</span><br><span class="line"># where 配合 模糊查询(like)</span><br><span class="line">  # 查询国家代号是 C 开头的城市</span><br><span class="line">  select * from world.city where CountryCode like &#x27;C%&#x27;;  # 不要出现 % 在前面的情况, 效率低,不走索引</span><br><span class="line">  </span><br><span class="line"># where 配合 逻辑连接符查询(and or)</span><br><span class="line">  # 查询城市人口在10000到20000之间的城市</span><br><span class="line">  select * from world.city where population &gt;= 10000 and population &lt;= 20000;</span><br><span class="line">  select * from world.city where population between 10000 and 20000;</span><br><span class="line">  </span><br><span class="line">  # 查询中国或美国的城市信息</span><br><span class="line">  select * from world.city where CountryCode=&#x27;CHN&#x27; or CountryCode=&#x27;USA&#x27;;</span><br><span class="line">  select * from world.city where CountryCode in (&#x27;CHN&#x27;, &#x27;USA&#x27;);</span><br><span class="line">  </span><br><span class="line">  # distinct: 去重复</span><br><span class="line">  select countrycode from city;</span><br><span class="line">  select distinct(countrycode) from city;</span><br><span class="line">  </span><br><span class="line">  # 聚合</span><br><span class="line">  union  # 如果结果有重复项会自动去重复</span><br><span class="line">  union all  # 如果有重复项不会去重复</span><br><span class="line">  </span><br><span class="line">  # 这条语句性能比上面两条语句高</span><br><span class="line">  select * from world.city where CountryCode=&#x27;CHN&#x27;</span><br><span class="line">  union all</span><br><span class="line">  select * from world.city where CountryCode=&#x27;USA&#x27;;</span><br></pre></td></tr></table></figure>

<h5 id="group-by配合聚合函数应用"><a href="#group-by配合聚合函数应用" class="headerlink" title="group by配合聚合函数应用"></a><code>group by</code>配合聚合函数应用</h5><blockquote>
<p>根据 by后面的条件进行分组，方便统计，by后面跟一个列或多个列</p>
</blockquote>
<ul>
<li><p>常用聚合函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">max()  # 最大值</span><br><span class="line">min()  # 最小值</span><br><span class="line">avg()  # 平均值</span><br><span class="line">sum()  # 总和</span><br><span class="line">count()  # 个数</span><br><span class="line">group_concat()  # 列转行</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 统计每个国家的总人口</span><br><span class="line">select CountryCode,sum(population) from world.city group by CountryCode;</span><br><span class="line"></span><br><span class="line"># 统计每个国家 的城市个数</span><br><span class="line">select CountryCode,count(Name) from world.city group by CountryCode;</span><br><span class="line"></span><br><span class="line"># 统计并显示每个国家的省名字列表</span><br><span class="line">select  CountryCode,group_concat(district)  from world.city group by CountryCode;</span><br><span class="line"></span><br><span class="line"># 统计中国每个省的城市列表</span><br><span class="line">select district, group_concat(Name) from world.city where CountryCode=&#x27;CHN&#x27; group by district;</span><br><span class="line"></span><br><span class="line"># 统计中国每个省的总人口数</span><br><span class="line">select district,sum(population) from world.city where CountryCode=&#x27;CHN&#x27; group by district;</span><br></pre></td></tr></table></figure>

<h5 id="having"><a href="#having" class="headerlink" title="having"></a><code>having</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 统计中国每个省的总人口数，只打印总人口数小于1000000的省</span><br><span class="line">select district,sum(population) from world.city where CountryCode=&#x27;CHN&#x27; group by district having sum(population) &lt; 1000000;</span><br><span class="line"></span><br><span class="line"># having 后的条件是不走索引的，可以进行一些优化手段处理</span><br></pre></td></tr></table></figure>

<h5 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a><code>order by</code></h5><blockquote>
<p>实现先排序, by后添加条件列</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 统计中国每个省的总人口数并从小到大排序</span><br><span class="line">select district,sum(population) from world.city where CountryCode=&#x27;CHN&#x27; group by district order by sum(population);</span><br><span class="line"></span><br><span class="line"># 统计中国每个省的总人口数并从大到小排序</span><br><span class="line">select district,sum(population) from world.city where CountryCode=&#x27;CHN&#x27; group by district order by sum(population) desc;</span><br><span class="line"></span><br><span class="line"># 查询中国所有的城市，并以人口数降序排序</span><br><span class="line">select  Name, population from world.city where CountryCode=&#x27;CHN&#x27; order by population desc;</span><br></pre></td></tr></table></figure>

<h5 id="limit"><a href="#limit" class="headerlink" title="limit"></a><code>limit</code></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 统计中国每个省的总人口数并从大到小排序只显示前5个</span><br><span class="line">select district,sum(population) from world.city where CountryCode=&#x27;CHN&#x27; group by district order by sum(population) desc limit 5; </span><br><span class="line"></span><br><span class="line"># 统计中国每个省的总人口数并从大到小排序,显示第6-第10个</span><br><span class="line"># 第一种</span><br><span class="line">select district,sum(population) </span><br><span class="line">from world.city </span><br><span class="line">where CountryCode=&#x27;CHN&#x27; </span><br><span class="line">group by district </span><br><span class="line">order by sum(population) desc </span><br><span class="line">limit 5, 5;  </span><br><span class="line"># 第一个5代表跳过前五行, 第二个5表示再显示5行</span><br><span class="line"></span><br><span class="line"># 第二种</span><br><span class="line">select district,sum(population) </span><br><span class="line">from world.city </span><br><span class="line">where CountryCode=&#x27;CHN&#x27; </span><br><span class="line">group by district </span><br><span class="line">order by sum(population) desc </span><br><span class="line">limit 5 offset 5;  </span><br><span class="line"># 第一个5代表显示5行, offset代表偏移五行,跳过前五行</span><br></pre></td></tr></table></figure>

<h4 id="多表连接查询"><a href="#多表连接查询" class="headerlink" title="多表连接查询"></a>多表连接查询</h4><blockquote>
<p>将来要查询的数据,是来自于多张表时,可以用多表连接</p>
</blockquote>
<h5 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">表结构:</span><br><span class="line">use school</span><br><span class="line">student ：学生表</span><br><span class="line">sno：    学号</span><br><span class="line">sname：学生姓名</span><br><span class="line">sage： 学生年龄</span><br><span class="line">ssex： 学生性别</span><br><span class="line"></span><br><span class="line">teacher ：教师表</span><br><span class="line">tno：     教师编号</span><br><span class="line">tname：教师名字</span><br><span class="line"></span><br><span class="line">course ：课程表</span><br><span class="line">cno：  课程编号</span><br><span class="line">cname：课程名字</span><br><span class="line">tno：  教师编号</span><br><span class="line"></span><br><span class="line">score  ：成绩表</span><br><span class="line">sno：  学号</span><br><span class="line">cno：  课程编号</span><br><span class="line">score：成绩</span><br><span class="line"></span><br><span class="line"># 构建表</span><br><span class="line">create database school charset utf8mb4;</span><br><span class="line">use school;</span><br><span class="line"></span><br><span class="line">create table student(</span><br><span class="line">sno int not null primary key auto_increment comment &#x27;学号&#x27;,</span><br><span class="line">sname varchar(20) not null comment &#x27;姓名&#x27;,</span><br><span class="line">sage tinyint unsigned not null comment &#x27;年龄&#x27;,</span><br><span class="line">ssex enum(&#x27;f&#x27;,&#x27;m&#x27;) not null default &#x27;m&#x27; comment &#x27;性别&#x27;</span><br><span class="line">) engine=innodb charset=utf8;</span><br><span class="line"></span><br><span class="line">create table teacher(</span><br><span class="line">tno int not null primary key comment &#x27;教师编号&#x27;,</span><br><span class="line">tname varchar(20) not null comment &#x27;教师姓名&#x27;</span><br><span class="line">) engine=innodb charset=utf8;</span><br><span class="line"></span><br><span class="line">create table course(</span><br><span class="line">cno int not null comment &#x27;课程编号&#x27;,</span><br><span class="line">cname varchar(20) not null comment &#x27;课程名字&#x27;,</span><br><span class="line">tno int not null comment &#x27;教师编号&#x27;</span><br><span class="line">) engine=innodb charset=utf8;</span><br><span class="line"></span><br><span class="line">create table sc(</span><br><span class="line">sno int not null comment &#x27;学号&#x27;,</span><br><span class="line">cno int not null comment &#x27;课程编号&#x27;,</span><br><span class="line">score int not null comment &#x27;成绩&#x27;</span><br><span class="line">) engine=innodb charset=utf8;</span><br><span class="line"></span><br><span class="line"># 插入数据</span><br><span class="line">INSERT INTO student(sno,sname,sage,ssex)</span><br><span class="line">VALUES (1,&#x27;zhang3&#x27;,18,&#x27;m&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO student(sno,sname,sage,ssex)</span><br><span class="line">VALUES</span><br><span class="line">(2,&#x27;zhang4&#x27;,18,&#x27;m&#x27;),</span><br><span class="line">(3,&#x27;li4&#x27;,18,&#x27;m&#x27;),</span><br><span class="line">(4,&#x27;wang5&#x27;,19,&#x27;f&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO student</span><br><span class="line">VALUES</span><br><span class="line">(5,&#x27;zh4&#x27;,18,&#x27;m&#x27;),</span><br><span class="line">(6,&#x27;zhao4&#x27;,18,&#x27;m&#x27;),</span><br><span class="line">(7,&#x27;ma6&#x27;,19,&#x27;f&#x27;);</span><br><span class="line"></span><br><span class="line">INSERT INTO student(sname,sage,ssex)</span><br><span class="line">VALUES</span><br><span class="line">(&#x27;oldboy&#x27;,20,&#x27;m&#x27;),</span><br><span class="line">(&#x27;oldgirl&#x27;,20,&#x27;f&#x27;),</span><br><span class="line">(&#x27;oldp&#x27;,25,&#x27;m&#x27;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO teacher(tno,tname) VALUES</span><br><span class="line">(101,&#x27;oldboy&#x27;),</span><br><span class="line">(102,&#x27;hesw&#x27;),</span><br><span class="line">(103,&#x27;oldguo&#x27;);</span><br><span class="line"></span><br><span class="line">DESC course;</span><br><span class="line">INSERT INTO course(cno,cname,tno)</span><br><span class="line">VALUES</span><br><span class="line">(1001,&#x27;linux&#x27;,101),</span><br><span class="line">(1002,&#x27;python&#x27;,102),</span><br><span class="line">(1003,&#x27;mysql&#x27;,103);</span><br><span class="line"></span><br><span class="line">DESC sc;</span><br><span class="line">INSERT INTO sc(sno,cno,score)</span><br><span class="line">VALUES</span><br><span class="line">(1,1001,80),</span><br><span class="line">(1,1002,59),</span><br><span class="line">(2,1002,90),</span><br><span class="line">(2,1003,100),</span><br><span class="line">(3,1001,99),</span><br><span class="line">(3,1003,40),</span><br><span class="line">(4,1001,79),</span><br><span class="line">(4,1002,61),</span><br><span class="line">(4,1003,99),</span><br><span class="line">(5,1003,40),</span><br><span class="line">(6,1001,89),</span><br><span class="line">(6,1003,77),</span><br><span class="line">(7,1001,67),</span><br><span class="line">(7,1003,82),</span><br><span class="line">(8,1001,70),</span><br><span class="line">(9,1003,80),</span><br><span class="line">(10,1003,96);</span><br><span class="line"></span><br><span class="line">SELECT * FROM student;</span><br><span class="line">SELECT * FROM teacher;</span><br><span class="line">SELECT * FROM course;</span><br><span class="line">SELECT * FROM sc;</span><br></pre></td></tr></table></figure>

<ul>
<li>表之间的关系<br><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/sfiZ6Y.png" alt="sfiZ6Y"></li>
</ul>
<h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查询人口数量小于100人的国家名,城市名,国土面积</span><br><span class="line">select country.name,city.name,country.surfacearea</span><br><span class="line">from</span><br><span class="line">city join country</span><br><span class="line">on city.countrycode=country.code</span><br><span class="line">where city.population &lt; 100;</span><br><span class="line"></span><br><span class="line"># 查询oldguo老师和他教的课程名称</span><br><span class="line">select teacher.tname,course.cname</span><br><span class="line">from</span><br><span class="line">teacher join course</span><br><span class="line">on teacher.tno=course.tno</span><br><span class="line">where teacher.tname=&#x27;oldguo&#x27;;</span><br><span class="line"></span><br><span class="line"># 统计一下每门课程的总成绩</span><br><span class="line">select course.cname,sum(sc.score)</span><br><span class="line">from</span><br><span class="line">course join sc</span><br><span class="line">on course.cno=sc.cno</span><br><span class="line">group by course.cname,course.cno;</span><br><span class="line"></span><br><span class="line"># only_full_group_by错误</span><br><span class="line">1.在select后面出现的列，不是分组条件，并且没有函数中出现</span><br><span class="line">2.如果group by 后是主键列或者是唯一条件列</span><br><span class="line"></span><br><span class="line">select course.cno,course.cname,sum(sc.score)</span><br><span class="line">from</span><br><span class="line">course join sc</span><br><span class="line">on course.cno=sc.cno</span><br><span class="line">group by course.cname;</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/cuanQc.png" alt="cuanQc"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查询oldguo老师教的学生姓名列表</span><br><span class="line">select teacher.tname,group_concat(student.sname)</span><br><span class="line">from</span><br><span class="line">teacher join course</span><br><span class="line">on teacher.tno=course.tno</span><br><span class="line">join sc</span><br><span class="line">on course.cno=sc.cno</span><br><span class="line">join student</span><br><span class="line">on sc.sno=student.sno</span><br><span class="line">where teacher.tname=&#x27;oldguo&#x27;;</span><br><span class="line"></span><br><span class="line"># 查询每个老师教的学生姓名列表</span><br><span class="line">select teacher.tname,group_concat(student.sname)</span><br><span class="line">from </span><br><span class="line">teacher join course</span><br><span class="line">on teacher.tno=course.tno</span><br><span class="line">join sc</span><br><span class="line">on course.cno=sc.cno</span><br><span class="line">join student</span><br><span class="line">on sc.sno=student.sno</span><br><span class="line">group by teacher.tname;</span><br><span class="line"></span><br><span class="line"># 查询oldguo老师教的不及格的学生姓名</span><br><span class="line">select student.sname</span><br><span class="line">from</span><br><span class="line">teacher join course</span><br><span class="line">on teacher.tno=course.tno</span><br><span class="line">join sc</span><br><span class="line">on course.cno=sc.cno</span><br><span class="line">join student</span><br><span class="line">on sc.sno=student.sno</span><br><span class="line">where teacher.tname=&#x27;oldguo&#x27; and sc.score &lt; 60;</span><br><span class="line"></span><br><span class="line"># 统计zhang3 学习了几门课</span><br><span class="line">select student.sname,count(sc.cno)</span><br><span class="line">from student</span><br><span class="line">join sc</span><br><span class="line">on student.sno=sc.sno</span><br><span class="line">where student.sname=&#x27;zhang3&#x27;;</span><br><span class="line"></span><br><span class="line"># 查询zhang3 学习的课程名称有哪些</span><br><span class="line">select student.sname , group_concat(course.cname)</span><br><span class="line">from student</span><br><span class="line">join sc</span><br><span class="line">on student.sno=sc.sno</span><br><span class="line">join course</span><br><span class="line">on sc.cno=course.cno</span><br><span class="line">where student.sname=&#x27;zhang3&#x27;;</span><br><span class="line">    </span><br><span class="line"># 查询oldguo 所教课程的平均分数</span><br><span class="line">select teacher.tname,avg(sc.score)</span><br><span class="line">from teacher</span><br><span class="line">JOIN course</span><br><span class="line">ON teacher.tno=course.tno</span><br><span class="line">JOIN sc</span><br><span class="line">ON course.cno=sc.cno</span><br><span class="line">WHERE teacher.tname=&#x27;oldguo&#x27;;</span><br><span class="line"></span><br><span class="line"># 每位老师所教课程的平均分 并按平均分排序</span><br><span class="line">select teacher.tname,course.cname, avg(sc.score)</span><br><span class="line">from</span><br><span class="line">teacher join course</span><br><span class="line">on teacher.tno=course.tno</span><br><span class="line">join sc</span><br><span class="line">on course.cno=sc.cno</span><br><span class="line">join student</span><br><span class="line">on sc.sno=student.sno</span><br><span class="line">group by teacher.tname,course.cname</span><br><span class="line">order by avg(sc.score) desc;</span><br><span class="line"></span><br><span class="line"># 查询所有老师所教学生不及格的信息</span><br><span class="line">select student.sname,course.cname,sc.score</span><br><span class="line">from</span><br><span class="line">teacher join course</span><br><span class="line">on teacher.tno=course.tno</span><br><span class="line">join sc</span><br><span class="line">on course.cno=sc.cno</span><br><span class="line">join student</span><br><span class="line">on sc.sno=student.sno</span><br><span class="line">where sc.score &lt; 60;</span><br></pre></td></tr></table></figure>

<h5 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 表别名设置</span><br><span class="line"># 查询所有老师所教学生不及格的信息</span><br><span class="line">select d.sname,b.cname,c.score</span><br><span class="line">from</span><br><span class="line">teacher as a</span><br><span class="line">join course as b</span><br><span class="line">on a.tno=b.tno</span><br><span class="line">join sc as c</span><br><span class="line">on b.cno=c.cno</span><br><span class="line">join student as d</span><br><span class="line">on c.sno=d.sno</span><br><span class="line">where c.score &lt; 60;</span><br><span class="line"></span><br><span class="line"># 列别名</span><br><span class="line">select count(distinct(name)) from world.city;</span><br><span class="line">select count(distinct(name)) as a from world.city;</span><br></pre></td></tr></table></figure>

<h5 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h5><blockquote>
<p>左外连接和右外连接</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 内连接</span><br><span class="line">select a.name,b.name, b.surfacearea</span><br><span class="line">from world.city as a</span><br><span class="line">join world.country as b</span><br><span class="line">on a.countrycode=b.code</span><br><span class="line">where a.population &lt; 100;</span><br><span class="line"></span><br><span class="line"># 左外连接</span><br><span class="line">select a.name,b.name, b.surfacearea</span><br><span class="line">from world.city as a</span><br><span class="line">left join world.country as b</span><br><span class="line">on a.countrycode=b.code</span><br><span class="line">and a.population &lt; 100;</span><br><span class="line"># a.name的值全部出来了, b.name和b.surfacearea不满足的会用NULL填充</span><br><span class="line"></span><br><span class="line">select a.name,b.name, b.surfacearea</span><br><span class="line">from world.city as a</span><br><span class="line">left join world.country as b</span><br><span class="line">on a.countrycode=b.code</span><br><span class="line">where a.population &lt; 100;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 右外连接</span><br><span class="line">select a.name,b.name, b.surfacearea</span><br><span class="line">from world.city as a</span><br><span class="line">right join world.country as b</span><br><span class="line">on a.countrycode=b.code</span><br><span class="line">and a.population &lt; 100;</span><br></pre></td></tr></table></figure>

<h3 id="information-schema-tables视图"><a href="#information-schema-tables视图" class="headerlink" title="information_schema.tables视图"></a><code>information_schema.tables</code>视图</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.虚拟库</span><br><span class="line">2.开启数据库时产生的</span><br><span class="line">3.不能被删除和修改</span><br><span class="line">4.库中存储的是视图</span><br><span class="line">5.此库中的视图也是不能被删除和修改的,只能select查询</span><br></pre></td></tr></table></figure>

<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">此库中的视图是用来,间接的查询数据库的&quot;元数据&quot;(&quot;基表&quot;数据)</span><br><span class="line">基表:数据是通过自动统计收集而来的.</span><br><span class="line">基表:是不允许人为直接增\删\改\查的</span><br><span class="line">必须通过:专用的DDL,DCL实现增\删\改,show语句和information_schema可以做查询</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 记录了:整个MySQL数据库中,所有的表的详细属性信息</span><br><span class="line">desc information_schema.tables;</span><br><span class="line">TABLE_SCHEMA    ----&gt;库名</span><br><span class="line">TABLE_NAME      ----&gt;表名</span><br><span class="line">ENGINE          ----&gt;引擎</span><br><span class="line">TABLE_ROWS      ----&gt;表的行数</span><br><span class="line">AVG_ROW_LENGTH  ----&gt;表中行的平均行（字节）</span><br><span class="line">INDEX_LENGTH    ----&gt;索引的占用空间大小（字节）</span><br></pre></td></tr></table></figure>

<h4 id="CONCAT-函数使用"><a href="#CONCAT-函数使用" class="headerlink" title="CONCAT()函数使用"></a><code>CONCAT()</code>函数使用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 简单使用</span><br><span class="line">select user, host from mysql.user;</span><br><span class="line"></span><br><span class="line">select concat(user,&quot;@&quot;,host) from mysql.user;</span><br><span class="line"></span><br><span class="line"># 生产需求，下例子批量备份语句</span><br></pre></td></tr></table></figure>

<h4 id="相关使用"><a href="#相关使用" class="headerlink" title="相关使用"></a>相关使用</h4><ul>
<li><p>查询整个数据库中所有库和所对应的表信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select table_schema,group_concat(table_name)</span><br><span class="line">from information_schema.tables</span><br><span class="line">group by table_schema;</span><br></pre></td></tr></table></figure></li>
<li><p>统计所有库下 的表个数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select table_schema,count(table_name)</span><br><span class="line">from information_schema.tables</span><br><span class="line">group by table_schema;</span><br></pre></td></tr></table></figure></li>
<li><p>查询所有innodb引擎的表及所在的库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select table_schema,table_name,engine</span><br><span class="line">from information_schema.tables</span><br><span class="line">where engine=&#x27;innodb&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p>统计world的数据库下每个表的行数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select table_name,table_rows</span><br><span class="line">from information_schema.tables</span><br><span class="line">where table_schema=&#x27;world&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p>统计world数据库下每张表的磁盘空间占用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select table_name,concat((TABLE_ROWS*AVG_ROW_LENGTH+INDEX_LENGTH)/1024,&quot; KB&quot;) as size_KB</span><br><span class="line">from information_schema.tables </span><br><span class="line">where table_schema=&#x27;world&#x27;;</span><br></pre></td></tr></table></figure></li>
<li><p>统计所有数据库的总磁盘空间占用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select table_schema,concat(sum(TABLE_ROWS*AVG_ROW_LENGTH+INDEX_LENGTH)/1024,&quot; KB&quot;) as Total_KB</span><br><span class="line">from information_schema.tables</span><br><span class="line">group by table_schema;</span><br><span class="line"></span><br><span class="line">mysql -uroot -p1 -e &#x27;select table_schema,concat(sum(TABLE_ROWS*AVG_ROW_LENGTH+INDEX_LENGTH)/1024,&quot; KB&quot;) as Total_KB from information_schema.tables group by table_schema;&#x27;</span><br></pre></td></tr></table></figure></li>
<li><p>生成整个数据库下的所有表的单独备份语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/my.cnf</span><br><span class="line">secure-file-priv=/tmp  # 在mysqld 标签下添加</span><br><span class="line">systemctl restart mysqld.service  # 重启数据库</span><br><span class="line"></span><br><span class="line">模板语句：</span><br><span class="line">mysqldump -uroot -p123 world city &gt;/tmp/world_city.sql</span><br><span class="line"></span><br><span class="line">批量生成整个数据库的所有表的备份语句:</span><br><span class="line">select concat(&quot;mysqldump -uroot -p1 &quot;,table_schema,&quot; &quot;,table_name,&quot;  &gt; /bak/&quot;,table_schema,&quot;_&quot;,table_name,&quot;.sql&quot;) from information_schema.tables;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="常用show语句"><a href="#常用show语句" class="headerlink" title="常用show语句"></a>常用show语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show databases;                      # 查看所有数据库</span><br><span class="line">show tables;                         # 查看当前库下的表</span><br><span class="line">show tables from xxx;                # 查看指定库下的表</span><br><span class="line">show create database xxx;            # 查看建库语句</span><br><span class="line">show create table;                   # 查看建表语句</span><br><span class="line">show grants for root@&#x27;localhost&#x27;;    # 查看用户权限信息</span><br><span class="line">show charset;                        # 查看所有字符集</span><br><span class="line">show collation;                      # 校对规则</span><br><span class="line">show engines;                        # 查看存储引擎支持情况</span><br><span class="line">show status;                         # 看数据库的整体状态</span><br><span class="line">show status like &#x27;%lock%&#x27;            # 模糊查找数据库的状态</span><br><span class="line">show variables;                      # 查看数据库所有变量情况</span><br><span class="line">show variables like &#x27;%log%&#x27;;         # 模糊查找相关数据库的变量情况</span><br><span class="line">show full processlist;               # 看数据库连接线程状态</span><br><span class="line">show engine innodb status \G         # 看innodb存储引擎总状态</span><br><span class="line">show master status;                  # 主从复制中库信息</span><br><span class="line">show slave status \G                 # 主从复制从库状态</span><br><span class="line">show binary logs;                    # 可用的binlog文件名</span><br><span class="line">show binlog events in &#x27;&#x27;;            # binlog日志的事件信息</span><br><span class="line">show relaylog events in &#x27;&#x27;;          # 查看relaylog日志情况</span><br><span class="line"></span><br><span class="line">select @@log_error;                  # 查看某个参数的定义信息</span><br><span class="line">select now();                        # 查看当前时间</span><br><span class="line">select database();                   # 查看当前use到的库</span><br><span class="line">select user();                       # 当前登录的用户</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL初始化配置</title>
    <url>/37f9f562.html</url>
    <content><![CDATA[<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">控制MySQL的启动</span><br><span class="line">影响到客户端的连接</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="初始化配置的方法"><a href="#初始化配置的方法" class="headerlink" title="初始化配置的方法"></a>初始化配置的方法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">初始化配置文件(例如/etc/my.cnf)</span><br><span class="line">启动命令行上进行设置(例如:mysqld_safe mysqld)</span><br><span class="line">预编译时设置(仅限于编译安装时设置)</span><br></pre></td></tr></table></figure>

<h3 id="初始化配置文件"><a href="#初始化配置文件" class="headerlink" title="初始化配置文件"></a>初始化配置文件</h3><p>初始化配置文件的默认读取路径</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 默认配置文件读取顺序</span><br><span class="line">mysqld --help --verbose |grep my.cnf</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/local/mysql/etc/my.cnf ~/.my.cnf</span><br><span class="line"></span><br><span class="line">默认情况下，MySQL启动时，会依次读取以上配置文件，如果有重复选项，会以最后一个文件设置的为准</span><br><span class="line">如果启动时加入了--defaults-file=xxxx时，以上的所有文件都不会读取</span><br></pre></td></tr></table></figure>

<p>配置文件的书写方式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式:</span><br><span class="line">    [标签]</span><br><span class="line">    配置项=xxxx</span><br><span class="line"></span><br><span class="line">    标签类型：服务端、客户端</span><br><span class="line">    服务器端标签：</span><br><span class="line">    [mysqld]</span><br><span class="line">    [mysqld_safe]</span><br><span class="line">    [server]</span><br><span class="line"></span><br><span class="line">    客户端标签：</span><br><span class="line">    [mysql]</span><br><span class="line">    [mysqldump]</span><br><span class="line">    [client]</span><br><span class="line"></span><br><span class="line">配置文件的示例：</span><br><span class="line">    cat /etc/my.cnf</span><br><span class="line">    [mysqld]</span><br><span class="line">    user=mysql  # 用户                 </span><br><span class="line">    basedir=/usr/local/mysql  # 软件目录</span><br><span class="line">    datadir=/data/mysql/data  # 数据目录</span><br><span class="line">    socket=/tmp/mysql.sock  # socket位置</span><br><span class="line">    server_id=6  # 服务器ID号</span><br><span class="line">    port=3306  # 端口</span><br><span class="line">    log_error=/data/mysql/mysql.log  # 日志位置</span><br><span class="line">    [mysql]</span><br><span class="line">    socket=/tmp/mysql.sock</span><br></pre></td></tr></table></figure>

<h3 id="多实例配置"><a href="#多实例配置" class="headerlink" title="多实例配置"></a>多实例配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 数据目录准备</span></span><br><span class="line">mkdir /data/330&#123;7,8,9&#125;/data -p</span><br><span class="line">chown -R mysql.mysql /data/*</span><br><span class="line">tree -L 2 /data/</span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 配置文件</span></span><br><span class="line">cat &gt; /data/3307/my.cnf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[mysqld]</span></span><br><span class="line"><span class="string">basedir=/usr/local/mysql</span></span><br><span class="line"><span class="string">datadir=/data/3307/data</span></span><br><span class="line"><span class="string">socket=/data/3307/mysql.sock</span></span><br><span class="line"><span class="string">log_error=/data/3307/mysql.log</span></span><br><span class="line"><span class="string">port=3307</span></span><br><span class="line"><span class="string">server_id=7</span></span><br><span class="line"><span class="string">log_bin=/data/3307/mysql-bin</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cat &gt; /data/3308/my.cnf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[mysqld]</span></span><br><span class="line"><span class="string">basedir=/usr/local/mysql</span></span><br><span class="line"><span class="string">datadir=/data/3308/data</span></span><br><span class="line"><span class="string">socket=/data/3308/mysql.sock</span></span><br><span class="line"><span class="string">log_error=/data/3308/mysql.log</span></span><br><span class="line"><span class="string">port=3308</span></span><br><span class="line"><span class="string">server_id=8</span></span><br><span class="line"><span class="string">log_bin=/data/3308/mysql-bin</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">cat &gt; /data/3309/my.cnf &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">[mysqld]</span></span><br><span class="line"><span class="string">basedir=/usr/local/mysql</span></span><br><span class="line"><span class="string">datadir=/data/3309/data</span></span><br><span class="line"><span class="string">socket=/data/3309/mysql.sock</span></span><br><span class="line"><span class="string">log_error=/data/3309/mysql.log</span></span><br><span class="line"><span class="string">port=3309</span></span><br><span class="line"><span class="string">server_id=9</span></span><br><span class="line"><span class="string">log_bin=/data/3309/mysql-bin</span></span><br><span class="line"><span class="string">EOF</span></span><br></pre></td></tr></table></figure>



<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 移动原来的配置文件</span></span><br><span class="line">mv /etc/my.cnf&#123;,.bak&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化三套数据库</span></span><br><span class="line">mysqld --initialize-insecure  --user=mysql --datadir=/data/3307/data --basedir=/usr/<span class="built_in">local</span>/mysql</span><br><span class="line">mysqld --initialize-insecure  --user=mysql --datadir=/data/3308/data --basedir=/usr/<span class="built_in">local</span>/mysql</span><br><span class="line">mysqld --initialize-insecure  --user=mysql --datadir=/data/3309/data --basedir=/usr/<span class="built_in">local</span>/mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动文件配置</span></span><br><span class="line">cp /etc/systemd/system/mysqld.service  /etc/systemd/system/mysqld3307.service</span><br><span class="line">cp /etc/systemd/system/mysqld.service  /etc/systemd/system/mysqld3308.service</span><br><span class="line">cp /etc/systemd/system/mysqld.service  /etc/systemd/system/mysqld3309.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改相关启动文件</span></span><br><span class="line">vim /etc/systemd/system/mysqld3307.service</span><br><span class="line">ExecStart=/application/mysql/bin/mysqld  --defaults-file=/data/3307/my.cnf</span><br><span class="line"></span><br><span class="line">vim /etc/systemd/system/mysqld3308.service</span><br><span class="line">ExecStart=/application/mysql/bin/mysqld  --defaults-file=/data/3308/my.cnf</span><br><span class="line"></span><br><span class="line">vim /etc/systemd/system/mysqld3309.service</span><br><span class="line">ExecStart=/application/mysql/bin/mysqld  --defaults-file=/data/3309/my.cnf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">systemctl start mysqld3307.service</span><br><span class="line">systemctl start mysqld3308.service</span><br><span class="line">systemctl start mysqld3309.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查验证多实例</span></span><br><span class="line">ps -ef |grep mysql</span><br><span class="line">netstat -lntup|grep 330</span><br><span class="line"></span><br><span class="line">mysql -S /data/3307/mysql.sock  -e <span class="string">&#x27;select @@server_id&#x27;</span></span><br><span class="line">mysql -S /data/3308/mysql.sock  -e <span class="string">&#x27;select @@server_id&#x27;</span></span><br><span class="line">mysql -S /data/3309/mysql.sock  -e <span class="string">&#x27;select @@server_id&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL基础管理</title>
    <url>/d7227a45.html</url>
    <content><![CDATA[<h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><p>作用: 登录、管理数据逻辑对象</p>
<span id="more"></span>
<p>定义:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">格式:</span><br><span class="line">用户名@&#x27;白名单&#x27;</span><br><span class="line"></span><br><span class="line">白名单支持的方式:</span><br><span class="line">wordpress@&#x27;10.0.0.%&#x27;     # 10.0.0.0 段</span><br><span class="line">wordpress@&#x27;%&#x27;            # 所有</span><br><span class="line">wordpress@&#x27;10.0.0.200&#x27;   # 指定IP</span><br><span class="line">wordpress@&#x27;localhost&#x27;    # 本地localhost</span><br><span class="line">wordpress@&#x27;db02&#x27;         # 指定主机名,能解析该主机名</span><br><span class="line">wordpress@&#x27;10.0.0.5%&#x27;    # 10.0.0.5x 段</span><br><span class="line">wordpress@&#x27;10.0.0.0/255.255.254.0&#x27;  # 子网掩码方式</span><br></pre></td></tr></table></figure>

<p>管理操作:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建用户</span><br><span class="line">create user wordpress@&#x27;192.168.0.%&#x27; identified by &#x27;123&#x27;;</span><br><span class="line"></span><br><span class="line"># 查询用户</span><br><span class="line">select user, host from mysql.user;</span><br><span class="line"></span><br><span class="line"># 修改用户密码</span><br><span class="line"> alter user wordpress@&#x27;192.168.0.%&#x27; identified by &#x27;456&#x27;;</span><br><span class="line"> </span><br><span class="line"># 删除用户</span><br><span class="line">drop user wordpress@&#x27;192.168.0.%&#x27;;</span><br><span class="line"></span><br><span class="line"># 创建用户密码以及授权操作</span><br><span class="line"># 5.7版本 创建用户以及授权一步完成</span><br><span class="line">grant all on *.* to wordpress@&#x27;192.168.0.%&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line"></span><br><span class="line"># 8.0版本 必须先创建用户之后才能授权</span><br><span class="line">create user wordpress@&#x27;192.168.0.%&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line">grant all on *.* to wordpress@&#x27;192.168.0.%&#x27; identified by &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="用户权限"><a href="#用户权限" class="headerlink" title="用户权限"></a>用户权限</h3><h4 id="常用权限"><a href="#常用权限" class="headerlink" title="常用权限"></a>常用权限</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALL:</span><br><span class="line">SELECT,INSERT, UPDATE, DELETE, CREATE, DROP, RELOAD, SHUTDOWN, PROCESS, FILE, REFERENCES, INDEX, ALTER, SHOW DATABASES, SUPER, CREATE TEMPORARY TABLES, LOCK TABLES, EXECUTE, REPLICATION SLAVE, REPLICATION CLIENT, CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, CREATE USER, EVENT, TRIGGER, CREATE TABLESPACE</span><br><span class="line">ALL : 以上所有权限，一般是普通管理员拥有的</span><br></pre></td></tr></table></figure>

<h4 id="授权命令"><a href="#授权命令" class="headerlink" title="授权命令"></a>授权命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant 权限 on 作用目标 to 用户 identified 密码 with grant option</span><br><span class="line"></span><br><span class="line">作用目标：</span><br><span class="line">*.*：代表授权所有库所有表权限</span><br><span class="line">wordpress.*：代表授权 wordpress 库下的所有表权限</span><br><span class="line">worpress.t1：代表授权 wordpress </span><br><span class="line"></span><br><span class="line">with grant option：超级管理员才具备的，给别的用户授权的功能</span><br></pre></td></tr></table></figure>

<h4 id="授权相关"><a href="#授权相关" class="headerlink" title="授权相关"></a>授权相关</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建一个管理员用户root,可以通过192.168.0网段登录,管理所有数据库</span><br><span class="line">grant all  on *.* to root@&#x27;192.168.0.%&#x27; identified by &#x27;123456&#x27;;</span><br><span class="line"></span><br><span class="line"># 创建一个应用用户app用户,可以远程登录mysql,并能操作app库</span><br><span class="line">grant select,update,insert,delete on app.* to app@&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="查看授权"><a href="#查看授权" class="headerlink" title="查看授权"></a>查看授权</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show grants for root@&#x27;%&#x27;;</span><br><span class="line">show grants for app@&#x27;%&#x27;&#x27;;</span><br></pre></td></tr></table></figure>

<h4 id="回收权限"><a href="#回收权限" class="headerlink" title="回收权限"></a>回收权限</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 回收app用户对app库下所有表的删除的权限</span><br><span class="line">revoke delete on app.* from app@&#x27;%&#x27;;</span><br><span class="line"></span><br><span class="line"># 回收app用户对app库下所有表查询 更新 插入权限</span><br><span class="line">revoke select,update,insert  on app.* from app@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><ul>
<li>常用参数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-u                   用户</span><br><span class="line">-p                   密码</span><br><span class="line">-h                   IP</span><br><span class="line">-P                   端口</span><br><span class="line">-S                   socket文件</span><br><span class="line">-e                   免交互执行命令</span><br><span class="line">&lt;                    导入SQL脚本</span><br><span class="line"></span><br><span class="line"># 远程连接</span><br><span class="line">mysql -uroot -p -h 192.168.0.11 -P3306</span><br><span class="line"></span><br><span class="line"># 免交互执行sql语句</span><br><span class="line">mysql -uroot -p1 -e &quot;select user,host from mysql.user;&quot;</span><br><span class="line"></span><br><span class="line"># 导入sql脚本</span><br><span class="line">mysql -uroot -p1 &lt;world.sql</span><br><span class="line"></span><br><span class="line"># 查看socket</span><br><span class="line">mysql&gt; select @@socket;</span><br><span class="line"></span><br><span class="line"># 查看连接情况</span><br><span class="line">mysql&gt; show processlist;</span><br><span class="line"></span><br><span class="line"># 内置命令</span><br><span class="line">help     打印 mysql 帮助</span><br><span class="line">\c       ctrl+c 结束上个命令运行</span><br><span class="line">\q       quit; exit; ctrl+d 退出 mysql</span><br><span class="line">\G       将数据竖起来显示</span><br><span class="line">source   恢复备份文件</span><br></pre></td></tr></table></figure>

<h3 id="启动方式"><a href="#启动方式" class="headerlink" title="启动方式"></a>启动方式</h3><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/AN1ZCg.jpg" alt="AN1ZCg"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">以上多种方式，都可以单独启动MySQL服务</span><br><span class="line">mysqld_safe和mysqld一般是在临时维护时使用。</span><br><span class="line">另外，从Centos 7系统开始，支持systemd直接调用mysqld的方式进行启动数据库</span><br><span class="line"></span><br><span class="line">维护性的启动方式</span><br><span class="line">我们一般会将我们需要的参数临时加到命令行。也会读取/etc/my.cnf 的内容,但是如果冲突,命令行优先级最高</span><br><span class="line"></span><br><span class="line">/usr/local/mysql/bin/mysqld_safe  --skip-grant-tables --skip-networking &amp;</span><br><span class="line">/usr/local/mysql/bin/mysqld &amp;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
  </entry>
  <entry>
    <title>MySQL体系结构</title>
    <url>/3c4a0863.html</url>
    <content><![CDATA[<h3 id="C-S模型介绍"><a href="#C-S模型介绍" class="headerlink" title="C/S模型介绍"></a>C/S模型介绍</h3><span id="more"></span>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/AuYdO0.jpg" alt="AuYdO0"></p>
<ul>
<li><p>连接方式</p>
<ul>
<li><p>TCP/IP方式(远程、本地)</p>
<p><code>mysql -uroot -p1 -h 192.168.0.11 -P3306</code></p>
</li>
<li><p>Socket方式(仅本地)</p>
<p><code>mysql -uroot -p1 -S /tmp/mysql.sock</code></p>
</li>
</ul>
</li>
<li><p>实例介绍</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">实例=mysqld后台守护进程+Master Thread +干活的Thread+预分配的内存</span><br><span class="line">公司=老板+经理+员工+办公室</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="MySQL程序运行原理"><a href="#MySQL程序运行原理" class="headerlink" title="MySQL程序运行原理"></a>MySQL程序运行原理</h3><ul>
<li><p>MySQL程序结构</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/kfNBL7.jpg" alt="kfNBL7"></p>
<p>​    </p>
</li>
<li><p>一条SQL语句的执行过程</p>
<ul>
<li><p>连接层</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（1）提供连接协议：TCP/IP 、SOCKET</span><br><span class="line">（2）提供验证：用户、密码，IP，SOCKET</span><br><span class="line">（3）提供专用连接线程：接收用户SQL，返回结果</span><br><span class="line">通过以下语句可以查看到连接线程基本情况</span><br><span class="line">show processlist;</span><br></pre></td></tr></table></figure></li>
<li><p>SQL层</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">（1）接收上层传送的SQL语句</span><br><span class="line">（2）语法验证模块：验证语句语法,是否满足SQL_MODE</span><br><span class="line">（3）语义检查：判断SQL语句的类型</span><br><span class="line">    DDL ：数据定义语言</span><br><span class="line">    DCL ：数据控制语言</span><br><span class="line">    DML ：数据操作语言</span><br><span class="line">    DQL： 数据查询语言</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">（4）权限检查：用户对库表有没有权限</span><br><span class="line">（5）解析器：对语句执行前,进行预处理，生成解析树(执行计划),说白了就是生成多种执行方案.</span><br><span class="line">（6）优化器：根据解析器得出的多种执行计划，进行判断，选择最优的执行计划</span><br><span class="line">        代价模型：资源（CPU IO MEM）的耗损评估性能好坏</span><br><span class="line">（7）执行器：根据最优执行计划，执行SQL语句，产生执行结果</span><br><span class="line">执行结果：在磁盘的xxxx位置上</span><br><span class="line">（8）提供查询缓存（默认是没开启的），会使用redis tair替代查询缓存功能</span><br><span class="line">（9）提供日志记录（日志管理章节）：binlog，默认是没开启的。</span><br></pre></td></tr></table></figure></li>
<li><p>存储引擎层(类似LInux的文件系统)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">负责根据SQL层执行的结果，从磁盘上拿数据。</span><br><span class="line">将16进制的磁盘数据，交由SQL结构化化成表，</span><br><span class="line">连接层的专用线程返回给用户</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/ZQGxzu.jpg" alt="ZQGxzu"></p>
<h3 id="物理存储结构"><a href="#物理存储结构" class="headerlink" title="物理存储结构"></a>物理存储结构</h3><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/aZsnpd.jpg" alt="aZsnpd"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">表的物理存储结构</span><br><span class="line">MyISAM 引擎（相当于 Linux 的 ext2 文件系统）</span><br><span class="line">user.frm：存储的表结构（列，列属性）</span><br><span class="line">user.MYD：存储的数据记录</span><br><span class="line">user.MYI：存储索引</span><br><span class="line"><span class="comment"># ps: mysql 8.0 版本之后不再支持 MyISAM 引擎</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">InnoDB 引擎（相当于 Linux 的 XFS 文件系统）</span><br><span class="line">time_zone.frm：存储的表结构（列，列属性）</span><br><span class="line">time_zone.ibd：存储的数据记录和索引</span><br></pre></td></tr></table></figure>

<h3 id="InnoDB段、区、页"><a href="#InnoDB段、区、页" class="headerlink" title="InnoDB段、区、页"></a>InnoDB段、区、页</h3><p>InnoDB 存储引擎的逻辑存储结构中所有数据都被逻辑地存放在一个空间 中 ，我们称之为表空间（tablespace），空间又由段（segment）、区（extent）、 页(page）组成 。 </p>
<p>页： InnoDB 管理存储空间的基本单位，数据页大小默认为 16KB，我们表中记录 都是存放在页中的，官方称这种存放记录的页为索引（INDEX）页。因为这种类 型的页是用来存放表数据的，也可以称为数据页。 </p>
<p>区： 区是由连续的页组成的空间，无论页的大小怎么变，区的大小默认总是为 1MB。如连续的 64 个 16K 的页就是一个区，连续的 32 个 32K 的页也是一个区。 为了保证区中的页的连续性，InnoDB 存储引擎一次从磁盘申请 4-5 个区，在创 建一个段时就会创建一个默认的区。</p>
<p> 段： MySQL 的表根据存储需求会分配多个区，多个区构成的表称为段，理论上一 个表就是一个段（非分区表）。 总结： 一般情况下（非分区表） 一个表就是一个段 一个段由多个区构成 一个区在（16k），64 个连续的页，1M 大小</p>
<p>总结：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">页：最小的存储单元，默认16k</span><br><span class="line">区：64个连续的页，共1M</span><br><span class="line">段：一个表就是一个段，包含一个或多个区</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL登录及密码管理</title>
    <url>/318aa70a.html</url>
    <content><![CDATA[<h3 id="已知密码情况下"><a href="#已知密码情况下" class="headerlink" title="已知密码情况下"></a>已知密码情况下</h3><span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysqladmin -uroot -p password 123456</span><br><span class="line"><span class="comment"># Enter password: #因为我们现在没有密码，直接回车即可！</span></span><br><span class="line"><span class="comment"># 修改密码和上面一样，只是在要求输入密码时输入正确的密码即可</span></span><br></pre></td></tr></table></figure>

<h3 id="忘记密码修改"><a href="#忘记密码修改" class="headerlink" title="忘记密码修改"></a>忘记密码修改</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭数据库</span></span><br><span class="line">systemctl stop mysqld.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动数据库到维护模式</span></span><br><span class="line">mysqld_safe --skip-grant-tables --skip-networking &amp;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数解释 </span></span><br><span class="line">--skip-grant-tables  <span class="comment"># 跳过授权表</span></span><br><span class="line">--skip-networking    <span class="comment"># 跳过远程登录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 直接加入mysql</span></span><br><span class="line">mysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># mysql语句,重新修改密码</span></span><br><span class="line">flush privileges;</span><br><span class="line">alter user root@<span class="string">&#x27;localhost&#x27;</span> identified by <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="built_in">exit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启数据库</span></span><br><span class="line">pkill mysqld</span><br><span class="line">systemctl restart mysqld.service</span><br><span class="line"></span><br><span class="line"><span class="comment"># 此时用密码 1 即可进入数据库</span></span><br><span class="line"> mysql -uroot -p1</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/eOzO9V.png" alt="eOzO9V"></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL二进制安装</title>
    <url>/f88e38d3.html</url>
    <content><![CDATA[<h2 id="Centos7下二进制安装"><a href="#Centos7下二进制安装" class="headerlink" title="Centos7下二进制安装"></a>Centos7下二进制安装</h2><span id="more"></span>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-5.7/</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭防火墙及selinux</span></span><br><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">setenforce 0</span><br><span class="line">sed -i  s#enforcing#disabled#g /etc/selinux/config</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 卸载mariadb相关软件包</span></span><br><span class="line">yum remove mariadb* -y</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载依赖包</span></span><br><span class="line">yum install  libaio-devel -y</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载tar包</span></span><br><span class="line">wget https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/MySQL-5.7/mysql-5.7.34-el7-x86_64.tar.gz</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">tar xf mysql-5.7.31-el7-x86_64.tar.gz </span><br><span class="line">mv mysql-5.7.31-el7-x86_64 /usr/local/mysql</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建mysql用户</span></span><br><span class="line">useradd -s /sbin/nologin mysql</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">添加环境变量</span></span><br><span class="line">echo &#x27;export PATH=/usr/local/mysql/bin:$PATH&#x27; &gt;&gt;/etc/profile</span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mysql软件目录授权mysql用户</span></span><br><span class="line">chown -R mysql:mysql /usr/local/mysql</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看版本</span></span><br><span class="line">mysql -V</span><br></pre></td></tr></table></figure>

<p>数据目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 数据库数据目录应该单独用一块盘挂载</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mkfs.xfs /dev/sdb</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vim /etc/fstab</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> mount -a</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这边测试就直接创建目录了</span></span><br><span class="line">mkdir /data/mysql/data -p</span><br><span class="line">chown -R mysql:mysql /data</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 初始化</span></span><br><span class="line">/usr/local/mysql/bin/mysqld --initialize-insecure --user=mysql --basedir=/usr/local/mysql --datadir=/data/mysql/data</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数说明</span></span><br><span class="line">--initialize-insecure  # 使用空密码,后续手动添加密码即可</span><br><span class="line">--initialize           # 会产生一个临时密码</span><br><span class="line">--user                 # 指定用户</span><br><span class="line">--basedir              # 指定软件路径</span><br><span class="line">--datadir              # 指定数据路径</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最简配置文件</span></span><br><span class="line">cat &gt;/etc/my.cnf &lt;&lt;EOF</span><br><span class="line">[mysqld]</span><br><span class="line">user=mysql</span><br><span class="line">basedir=/usr/local/mysql</span><br><span class="line">datadir=/data/mysql/data</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">server_id=6</span><br><span class="line">port=3306</span><br><span class="line">[mysql]</span><br><span class="line">socket=/tmp/mysql.sock</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动配置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方法一: mysql的脚本启动文件</span></span><br><span class="line">cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld</span><br><span class="line">chmod +x /etc/init.d/mysqld</span><br><span class="line">service mysqld start  # 该方法启动命令</span><br><span class="line">service mysqld stop  # 该方法停止命令</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方法二: systemd启动配置</span></span><br><span class="line">cat &gt;/etc/systemd/system/mysqld.service &lt;&lt;EOF</span><br><span class="line">[Unit]</span><br><span class="line">Description=MySQL Server</span><br><span class="line">Documentation=man:mysqld(8)</span><br><span class="line">Documentation=http://dev.mysql.com/doc/refman/en/using-systemd.html</span><br><span class="line">After=network.target</span><br><span class="line">After=syslog.target</span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line">[Service]</span><br><span class="line">User=mysql</span><br><span class="line">Group=mysql</span><br><span class="line">ExecStart=/usr/local/mysql/bin/mysqld --defaults-file=/etc/my.cnf</span><br><span class="line">LimitNOFILE = 5000</span><br><span class="line">EOF</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用systemd启动和检查</span></span><br><span class="line">systemctl start mysqld.service</span><br><span class="line">systemctl status mysqld.service</span><br><span class="line">netstat -lntup |grep 3306</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 数据库启动错误分析</span></span><br><span class="line"> without updating PID 类似错误 </span><br><span class="line">查看日志：</span><br><span class="line">	/data/mysql/data/主机名.err </span><br><span class="line">	[ERROR] 上下文</span><br><span class="line">可能情况：</span><br><span class="line">	/etc/my.cnf 路径不对等</span><br><span class="line">	/tmp/mysql.sock文件修改过 或 删除过 </span><br><span class="line">	数据目录权限不是mysql</span><br><span class="line">	参数改错了</span><br><span class="line"><span class="meta">	</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 调试命令</span></span><br><span class="line">mysqld --default-file=/etc/my.cnf</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux目录结构</title>
    <url>/5e2eb880.html</url>
    <content><![CDATA[<h1 id="虚拟机快照"><a href="#虚拟机快照" class="headerlink" title="虚拟机快照"></a>虚拟机快照</h1><h3 id="1、拍摄快照"><a href="#1、拍摄快照" class="headerlink" title="1、拍摄快照"></a>1、拍摄快照</h3><p><img src="https://gitee.com/gengff/blogimage/raw/master/images/image-20211209204224924.png" alt="image-20211209204224924"></p>
<span id="more"></span>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/image-20211209204345586.png" alt="image-20211209204345586"></p>
<h3 id="2、恢复快照"><a href="#2、恢复快照" class="headerlink" title="2、恢复快照"></a>2、恢复快照</h3><p><img src="https://gitee.com/gengff/blogimage/raw/master/images/image-20211209204613798.png" alt="image-20211209204613798"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1</span>、克隆主机</span><br><span class="line">		 管理 ---&gt; 克隆</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>、改ip</span><br><span class="line"></span><br><span class="line">	最后一位<span class="number">3</span> - <span class="number">254</span></span><br><span class="line">    <span class="comment"># 查看网卡名称，或者查看本机IP</span></span><br><span class="line">    [root@localhost ~]<span class="comment"># ip a</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 修改网卡</span></span><br><span class="line">    [root@localhost ~]<span class="comment"># </span></span><br><span class="line">    </span><br><span class="line">    [root@localhost ~]<span class="comment"># sed -i &#x27;s#.100#.101#g&#x27; /etc/sysconfig/network-scripts/ifcfg-eth[01]-</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重启系统网络</span></span><br><span class="line">    [root@localhost ~]<span class="comment"># systemctl restart network</span></span><br></pre></td></tr></table></figure>

<h1 id="bash概述"><a href="#bash概述" class="headerlink" title="bash概述"></a>bash概述</h1><p>bash（壳）是一个命令解释器，负责跟系统的内核进行交互，在操作系统的最外层</p>
<p> bash可以干什么？针对于操作系统做了一些操作</p>
<ul>
<li><p>文件管理</p>
</li>
<li><p>目录管理</p>
</li>
<li><p>权限管理</p>
</li>
<li><p>用户管理</p>
</li>
<li><p>应用管理</p>
</li>
<li><p>软件管理</p>
</li>
<li><p>磁盘管理</p>
</li>
<li><p>等等</p>
<p>执行方式 操作简单 针对简单的管理操作</p>
<p>脚本script 操作复杂 操作一些复杂性较大的操作</p>
</li>
</ul>
<h1 id="系统命令行介绍"><a href="#系统命令行介绍" class="headerlink" title="系统命令行介绍"></a>系统命令行介绍</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、ping</span><br><span class="line">	格式：</span><br><span class="line">    	ping [网址]</span><br><span class="line"></span><br><span class="line">2、主机登录用户信息</span><br><span class="line">	[root@localhost ~]<span class="comment">#   :  #表示超级用户管理员命令提示符，注释	</span></span><br><span class="line">	[<span class="built_in">test</span>@localhost ~]		:  $普通用户命令提示符</span><br><span class="line">	</span><br><span class="line">    root  		:  登录当前系统的用户名</span><br><span class="line">    @     		:  表示分隔符，没有特殊含义</span><br><span class="line">    localhost :  表示当前系统的主机名</span><br><span class="line">    ~     		:  表示当前所在的目录（~ 代表的是当前的家目录， /root）</span><br><span class="line">    []	 	    :  表示括号，没有其他的作用</span><br><span class="line">    <span class="comment">#			    :  没有实际含义</span></span><br><span class="line">    </span><br><span class="line">3、自定义系统登录用户信息</span><br><span class="line">	PS1 环境变量</span><br><span class="line">	</span><br><span class="line">	[root@localhost ~]<span class="comment"># echo $PS1</span></span><br><span class="line">  [\u@\h \W]\$</span><br><span class="line">  [root@localhost ~]<span class="comment"># PS1=&#x27;[\u@\h --- \W]\$&#x27;</span></span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">知识储备：</span><br><span class="line">	<span class="built_in">print</span>(<span class="string">&#x27;Hello World&#x27;</span>)</span><br><span class="line">	<span class="built_in">echo</span> <span class="string">&quot;Hello World!&quot;</span></span><br></pre></td></tr></table></figure>

<h1 id="系统命令语法格式"><a href="#系统命令语法格式" class="headerlink" title="系统命令语法格式"></a>系统命令语法格式</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">通常系统命令语法格式：</span><br><span class="line">一条完整命令</span><br><span class="line">	命令      [参数] 				[选项] 			[路径]</span><br><span class="line">	</span><br><span class="line"><span class="built_in">command</span>		[arguments]  [options]	</span><br><span class="line"></span><br><span class="line">1、中括号内的内容是可有可无的，选项和参数不是必须的</span><br><span class="line">2、命令是指令的主体，是必须存在的</span><br><span class="line">3、选项是用于调节命令的某个功能</span><br><span class="line">		引导短格式（单个字符）	以短横杠表示‘-’	例如	-l</span><br><span class="line">		引导长格式（多个字符）	多个字符表示一定的含义	以‘--’表示		--all</span><br><span class="line">		多个短格式（多个字符）	每个字符都有一定的功能，‘-’	-al</span><br><span class="line">4、参数是命令操作的对象，文件或者目录</span><br><span class="line">5、指令、选项、参数两两之间必须要有一个空格</span><br><span class="line">6、完整的命令、选项、参数之间不能有空格</span><br><span class="line">7、命令的位置是在最前面的，是不能改变位置的</span><br><span class="line">8、选项和参数的位置是可以发生改变的</span><br></pre></td></tr></table></figure>

<h1 id="系统运行命令"><a href="#系统运行命令" class="headerlink" title="系统运行命令"></a>系统运行命令</h1><h2 id="1、关机"><a href="#1、关机" class="headerlink" title="1、关机"></a>1、关机</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">同步时间：</span><br><span class="line">yun install -y ntpdate</span><br><span class="line">ntpdate ntp.aliyun.com</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">shutdown	：关机或重启</span><br><span class="line">			参数：-h : 指定关机的延时时间</span><br><span class="line">			   	 -c : 取消关机</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  关机/取消：			   </span><br><span class="line">    shutdown -h 10	<span class="comment"># 10是以分钟为节点的	</span></span><br><span class="line">    shutdown -h 11:00	<span class="comment"># 定时关机</span></span><br><span class="line">    shutdown -c	<span class="comment"># 取消你的关机操作			   </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  立即关机:</span><br><span class="line">    shutdown -h now  <span class="comment"># 立刻关机</span></span><br><span class="line">    shutdown -h 0  <span class="comment"># 立刻关机</span></span><br><span class="line">		</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">halt		:  禁用CPU资源</span><br><span class="line">halt -p <span class="comment"># 立刻关机，不加-p只关闭系统</span></span><br><span class="line">	</span><br><span class="line">poweroff	： 立即关闭电源</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">init	：设置系统启动模式</span><br><span class="line">	参数： 0 ： 立刻关机</span><br><span class="line">        1 ： 单用户模式</span><br><span class="line">        2 ： 多用户无网络模式</span><br><span class="line">        3 ： 多用户模式</span><br><span class="line">        4 ： 待定</span><br><span class="line">        5 ： 桌面模式</span><br><span class="line">        6 ： 重启</span><br></pre></td></tr></table></figure>

<h2 id="2、重启"><a href="#2、重启" class="headerlink" title="2、重启"></a>2、重启</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shutdown</span><br><span class="line">		参数：</span><br><span class="line">			-r : 指定重启的延时时间</span><br><span class="line">			</span><br><span class="line">    shutdown -r 10 <span class="comment"># 10分钟后立刻重启</span></span><br><span class="line">    shutdown -r 0	 <span class="comment"># 立即重启</span></span><br><span class="line">    shutdown -r now	<span class="comment"># 立即重启</span></span><br><span class="line">    shutdown -r 11:00	<span class="comment"># 11:00重启			</span></span><br><span class="line">		</span><br><span class="line">reboot</span><br><span class="line">		reboot	<span class="comment"># 系统推荐的重启操作</span></span><br></pre></td></tr></table></figure>

<h2 id="3、注销"><a href="#3、注销" class="headerlink" title="3、注销"></a>3、注销</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">logout</span>	: 退出当前登录的用户	只能退出登录式shell，不能退出非登陆式shell</span><br><span class="line"></span><br><span class="line">ctrl+d	: 快捷键	退出当前登录的用户</span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span>	  :  退出当前登录的用户	能退出登录式shell，也能退出非登陆式shell，主要用于脚本退出</span><br></pre></td></tr></table></figure>



<h1 id="查看系统命令帮助"><a href="#查看系统命令帮助" class="headerlink" title="查看系统命令帮助"></a>查看系统命令帮助</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	man [需要查看帮助的命令]    ：详细的显示一个命令的使用方法</span><br><span class="line">	</span><br><span class="line">		命令解释说明信息：NAME</span><br><span class="line">		命令语法说明信息：SYNOPSIS</span><br><span class="line">		命令描述详细说明：DESCRIPTION</span><br><span class="line">		命令参数详细说明：OPTIONS</span><br><span class="line"></span><br><span class="line">	q : 退出</span><br><span class="line">	/[搜索内容] ： 搜索内容</span><br><span class="line">	</span><br><span class="line">	推荐网址：https://www.linuxcool.com/</span><br></pre></td></tr></table></figure>



<h1 id="设置别名"><a href="#设置别名" class="headerlink" title="设置别名"></a>设置别名</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">alias</span></span><br><span class="line"><span class="comment"># 格式：</span></span><br><span class="line">[root@localhost ~]<span class="comment"># alias alias net_test = &#x27;ping baidu.com&#x27;   #设置别名</span></span><br><span class="line">	</span><br><span class="line">[root@localhost ~]<span class="comment"># alias  #查看系统别名是否设置成功</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># net_test  #测试别名</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># unalias net_test  #取消别名</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># alias rm=&#x27;xxx&#x27;   #设置系统别名</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不使用别名，就在命令之前增加\，\代表转义</span></span><br><span class="line">	[root@localhost ~]<span class="comment"># \rm 1.txt</span></span><br></pre></td></tr></table></figure>



<h1 id="系统路径的类型"><a href="#系统路径的类型" class="headerlink" title="系统路径的类型"></a>系统路径的类型</h1><ul>
<li>绝对路径：参照物是根（/）路径，凡是以/开始的路径就是绝对路径    或者以~为开头的路径也是绝对路径</li>
<li>相对路径：参照物是当前路径，不是以/开头的路径就是相对路径    针对当前路径而言的</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 包含整个文件名称及文件的位置	这样的定位称之为路径</span></span><br><span class="line"><span class="comment"># 路径就是对于文件的定位的一种方式</span></span><br><span class="line"><span class="comment"># 每个目录下都有一个.和..</span></span><br><span class="line"></span><br><span class="line">.	    <span class="comment"># 表示的是当前所在的目录</span></span><br><span class="line">..	  <span class="comment"># 当前目录的上一级目录</span></span><br><span class="line">./	  <span class="comment"># 用于表示当前目录</span></span><br><span class="line">../	  <span class="comment"># 从当前目录的上一级目录开始</span></span><br><span class="line">~     <span class="comment"># 家目录</span></span><br></pre></td></tr></table></figure>



<h1 id="系统目录结构"><a href="#系统目录结构" class="headerlink" title="系统目录结构"></a>系统目录结构</h1><p><strong>在Linux中，所有的文件或者目录的起点或者顶点都是以(/)开始。</strong></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/image-20211213184825727.png"></p>
<p><strong>Linux的目录结构拥有层次，就像是一个倒挂的树形结构</strong></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/xitongmulu.jpg" alt="xitongmulu"></p>
<p>Linux<strong>系统中的目录需要挂载使用</strong></p>
<h4 id="目录挂载初识"><a href="#目录挂载初识" class="headerlink" title="目录挂载初识"></a>目录挂载初识</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">挂载的命令：mount</span><br><span class="line">   mount [磁盘路径] [挂载的路径]</span><br><span class="line">	</span><br><span class="line">查看本机挂载的命令</span><br><span class="line">   [root@localhost dev]<span class="comment"># df -h</span></span><br><span class="line">	</span><br><span class="line">卸载挂载的磁盘</span><br><span class="line">   [root@localhost dev]<span class="comment"># umount /mnt/</span></span><br></pre></td></tr></table></figure>

<p><strong>必知必会的目录及文件</strong></p>
<ul>
<li><p><strong>/bin</strong><br>bin 是 Binaries (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。</p>
</li>
<li><p><strong>/sbin：</strong>存放系统命令的目录 需要管理员权限才可以执行的命令</p>
</li>
<li><p><strong>/boot</strong><br>这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。</p>
</li>
<li><p><strong>/dev</strong><br>dev 是 Device(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。</p>
<ul>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/dev/cdrom	#光盘镜像</span><br><span class="line">/dev/null	#黑洞设备	将一些不用的数据导入到黑洞设备</span><br><span class="line">/dev/zero	#字符设备	会源源不断的产生数据，字符</span><br><span class="line">/dev/random	#产生随机数的设备</span><br><span class="line"></span><br><span class="line">#磁盘设备及分区</span><br><span class="line">/dev/sda</span><br><span class="line">/dev/sda1</span><br><span class="line">/dev/sda2</span><br><span class="line">/dev/sda3</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>/etc</strong><br>etc 是 Etcetera(等等) 的缩写,这个目录用来存放所有的系统管理所需要的配置文件和子目录。</p>
<ul>
<li><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/sysconfig/network-scripts/ifcfg-*	#查看网卡配置文件</span><br><span class="line">/etc/hosts#	本地域名解析文件	#记录ip地址与主机名的对应映射关系</span><br><span class="line">/etc/resolv.conf	#本地DNS配置文件</span><br><span class="line">/etc/fstab	#挂载设备目录配置文件	开机自启动挂载列表</span><br><span class="line">/etc/hostname	#主机名字配置文件</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>/home</strong><br>用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。</p>
</li>
<li><p><strong>/lib</strong><br>lib 是 Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。</p>
<ul>
<li>/lib #库文件目录 32位库文件<br>/lib64 #库文件目录 64位库文件</li>
</ul>
</li>
<li><p><strong>/lost+found</strong><br>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p>
</li>
<li><p><strong>/media</strong><br>linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。</p>
</li>
<li><p><strong>/mnt</strong><br>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。</p>
</li>
<li><p><strong>/opt</strong><br>opt 是 optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。</p>
</li>
<li><p><strong>/proc</strong></p>
<p>虚拟可变的目录 记录了系统的实时状态–&gt;类似于汽车的仪表盘</p>
</li>
<li><p><strong>/root</strong><br>该目录为系统管理员，也称作超级权限者的用户主目录。</p>
</li>
<li><p><strong>/sbin</strong><br>s 就是 Super User 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。</p>
</li>
<li><p><strong>/selinux</strong><br>这个目录是 Redhat/CentOS 所特有的目录，Selinux 是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放selinux相关的文件的。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">关闭selinux</span><br><span class="line">   临时关闭</span><br><span class="line">    [root@localhost ~]<span class="comment"># setenforce 0</span></span><br><span class="line">   永久关闭</span><br><span class="line">    [root@localhost ~]<span class="comment"># vim /etc/selinux/config</span></span><br><span class="line">    SELINUX=disabled  <span class="comment">#编辑改成永久关闭</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>/srv</strong><br>物理设备所产生的一些文件</p>
</li>
<li><p><strong>/sys</strong></p>
<p>物理设备的驱动信息文件</p>
<p>这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs 。</p>
<p>sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。</p>
<p>该文件系统是内核设备树的一个直观反映。</p>
<p>当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。</p>
</li>
<li><p><strong>/tmp</strong><br>公共临时目录 公共场所 只能针对自己的文件进行操作 系统会定时的删除这个目录下长时间没有访问的文件</p>
</li>
<li><p><strong>/usr</strong></p>
<p>/usr #系统目录 系统文件目录 跟windows目录一样<br>/userlocal #系统软件安装目录 跟windows的一样</p>
</li>
<li><p>**/usr/bin<br>系统用户使用的应用程序。</p>
</li>
<li><p>**/usr/sbin<br>超级用户使用的比较高级的管理程序和系统守护程序。</p>
</li>
<li><p>**/usr/src<br>内核源代码默认的放置目录。</p>
</li>
<li><p><strong>/var</strong></p>
<p>这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 /var/log 目录下，另外 mail 的预设放置也是在这里。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/var/log	#系统日志存放目录</span><br><span class="line">/var/log/messages	#系统级别日志</span><br><span class="line">/var/log/secure	#用户登录日志</span><br><span class="line">/var/tmp	#程序运行时所产生的一些进程文件</span><br></pre></td></tr></table></figure></li>
<li><p><strong>/run</strong><br>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 /var/run 目录，应该让它指向 run。</p>
</li>
</ul>
<p>在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。</p>
<p><strong>/etc</strong>： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。</p>
<p><strong>/bin, /sbin, /usr/bin, /usr/sbin</strong>: 这是系统预设的执行文件的放置目录，比如 ls 就是在 /bin/ls 目录下的。</p>
<p>值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给 root 使用的指令。</p>
<ul>
<li><strong>stderr -&gt; /proc/self/fd/2 #错误输出2&gt;</strong><br><strong>stdin -&gt; /proc/self/fd/0 #标准输入&lt;**<br>**stdout -&gt; /proc/self/fd/1 #标准输出&gt;</strong></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux安装、远程连接</title>
    <url>/20cf8e98.html</url>
    <content><![CDATA[<h1 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h1><p>主要介绍企业中常用的服务器操作系统</p>
<ul>
<li><p>什么是Linux？</p>
<p>类似于windows，是一个服务器上使用的操作系统，Linux支持多用户，多进程，多CPU，多任务等功能，而且Linux是开源的，支持嵌入式等。</p>
<span id="more"></span>
<h2 id="Linux发展史"><a href="#Linux发展史" class="headerlink" title="Linux发展史"></a>Linux发展史</h2></li>
</ul>
<p>1969年，美国贝尔实验室开发，Unix</p>
<ul>
<li>优点：性能好</li>
<li>缺点：消耗资源大</li>
</ul>
<p>1987年，谭宁邦开发微内核unix，主要用来教学</p>
<p>1991年，芬兰 林纳斯-托瓦丝 在大学期间基于unix微内核开发了第一款Linux内核，并且开源，并且很快加入FSF基金会，</p>
<h2 id="Linux核心概念"><a href="#Linux核心概念" class="headerlink" title="Linux核心概念"></a>Linux核心概念</h2><p>FSF基金会，GPL通用公共协议：开源的公共协议</p>
<p>GNU</p>
<p>Linux的组成：Linux内核—&gt;系统软件—&gt;个人软件 GNU Linux</p>
<h1 id="虚拟机介绍"><a href="#虚拟机介绍" class="headerlink" title="虚拟机介绍"></a>虚拟机介绍</h1><ul>
<li><p>网络类型</p>
<ul>
<li><p>仅主机</p>
<p>只能跟宿主主机进行连接</p>
</li>
<li><p>桥接</p>
<p>共享宿主主机网卡，跟宿主主机处于同一个局域网</p>
</li>
<li><p>NAT</p>
<p>使用自己的虚拟网卡，有自己的一套网络</p>
</li>
</ul>
</li>
</ul>
<h2 id="Linux发现版本"><a href="#Linux发现版本" class="headerlink" title="Linux发现版本"></a>Linux发现版本</h2><ul>
<li>RedHat/CentOS</li>
<li>Ubuntu</li>
<li>Debian</li>
</ul>
<h2 id="虚拟机软件"><a href="#虚拟机软件" class="headerlink" title="虚拟机软件"></a>虚拟机软件</h2><p>一般用来虚拟化一台主机的</p>
<ul>
<li>虚拟机软件分类<ul>
<li>vmware workstation（个人使用，或者开发者使用）</li>
<li>KVM一般用在云服务平台上</li>
<li>ESXI部署在物理主机上</li>
</ul>
</li>
</ul>
<p>`<img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208102719.png" alt="微信截图_20211208102719"></p>
<h1 id="网卡设置"><a href="#网卡设置" class="headerlink" title="网卡设置"></a>网卡设置</h1><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208103459.png" alt="微信截图_20211208103459" style="zoom: 50%;" />

<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208103520.png" alt="微信截图_20211208103520"></p>
<img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208103635-8967853.png" style="zoom:50%;" />

<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208103657.png" alt="微信截图_20211208103657"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208103734.png" alt="微信截图_20211208103734"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208103839.png" alt="微信截图_20211208103839"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208103909.png" alt="微信截图_20211208103909"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208104113.png" alt="微信截图_20211208104113"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208104202.png" alt="微信截图_20211208104202"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208104214.png" alt="微信截图_20211208104214"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208104400.png" alt="微信截图_20211208104400"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208104445.png" alt="微信截图_20211208104445"></p>
<h1 id="安装Linux系统"><a href="#安装Linux系统" class="headerlink" title="安装Linux系统"></a>安装Linux系统</h1><p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208104743.png" alt="微信截图_20211208104743"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208104909.png" alt="微信截图_20211208104909"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208104924.png" alt="微信截图_20211208104924"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208105046.png" alt="微信截图_20211208105046"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208105219.png" alt="微信截图_20211208105219"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208105400.png" alt="微信截图_20211208105400"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/43C18B4F-1B0A-42E9-BB78-D3E5682D4106.png" alt="43C18B4F-1B0A-42E9-BB78-D3E5682D4106"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/AE1A21DF-E10A-4841-9DBB-A85212501759.png" alt="AE1A21DF-E10A-4841-9DBB-A85212501759"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208105638.png" alt="微信截图_20211208105638"></p>
<img src="https://gitee.com/gengff/blogimage/raw/master/images/WX20211208-170046@2x.png" alt="WX20211208-170046@2x" style="zoom: 50%;" />



<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208110204.png" alt="微信截图_20211208110204"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208110217.png" alt="微信截图_20211208110217"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208110341.png" alt="微信截图_20211208110341"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/20211208110532.png" alt="20211208110532"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208110550.png" alt="微信截图_20211208110550"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208110602.png" alt="微信截图_20211208110602"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208110629.png" alt="微信截图_20211208110629"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208110745.png" alt="微信截图_20211208110745"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/WeChatb1cc04bfcdf1fe355a7179e717e66de9.png" alt="WeChatb1cc04bfcdf1fe355a7179e717e66de9"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208111408.png" alt="微信截图_20211208111408"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208113903.png" alt="微信截图_20211208113903"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/7590A4DC-6E12-4888-A23A-287833B9853D.png" alt="7590A4DC-6E12-4888-A23A-287833B9853D"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208114033.png" alt="微信截图_20211208114033"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208114119.png" alt="微信截图_20211208114119"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208114253.png" alt="微信截图_20211208114253"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208114459.png" alt="微信截图_20211208114459"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/4AE29186-308D-46BE-B840-0246191C2BF6.png" alt="4AE29186-308D-46BE-B840-0246191C2BF6"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/70388F5F-6915-4105-B8E7-61000F4D8607.png" alt="70388F5F-6915-4105-B8E7-61000F4D8607"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/C9FB0F45-D71B-4207-8631-C60196830281.png" alt="C9FB0F45-D71B-4207-8631-C60196830281"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208114651.png" alt="微信截图_20211208114651"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208114833.png" alt="微信截图_20211208114833"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208114846.png" alt="微信截图_20211208114846"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208114953.png" alt="微信截图_20211208114953"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208115212.png" alt="微信截图_20211208115212"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208115358.png" alt="微信截图_20211208115358"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208115413.png" alt="微信截图_20211208115413"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208115438.png" alt="微信截图_20211208115438"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208115855.png" alt="微信截图_20211208115855"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208115921.png" alt="微信截图_20211208115921"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208120050.png" alt="微信截图_20211208120050"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208120113.png"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208120130.png" alt="微信截图_20211208120130"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208120201.png" alt="微信截图_20211208120201"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208120239.png" alt="微信截图_20211208120239"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208120311.png" alt="微信截图_20211208120311"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208120427.png" alt="微信截图_20211208120427"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208120907.png" alt="微信截图_20211208120907"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/WX20211208-204050@2x.png" alt="WX20211208-204050@2x"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208121606.png" alt="微信截图_20211208121606"></p>
<h1 id="连接-X-shell"><a href="#连接-X-shell" class="headerlink" title="连接 X-shell"></a>连接 X-shell</h1><p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208122027.png" alt="微信截图_20211208122027"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208122101.png" alt="微信截图_20211208122101"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208122135.png" alt="微信截图_20211208122135"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208122151.png" alt="微信截图_20211208122151"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208122205.png" alt="微信截图_20211208122205"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211208122218.png" alt="微信截图_20211208122218"></p>
<h1 id="mac网卡配置"><a href="#mac网卡配置" class="headerlink" title="mac网卡配置"></a>mac网卡配置</h1><p><img src="https://gitee.com/gengff/blogimage/raw/master/images/wangka1.png" alt="wangka1"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/wangka2.png" alt="wangka2"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/wangka3.png"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/wangka44.png" alt="wangka44"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/wangka5.png" alt="wangka5"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/wangka6.png" alt="wangka6"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/wangka7.png" alt="wangka7"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/wangka8.png" alt="wangka8"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/wangka9.png" alt="wangka9"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/wangka10.png" alt="wangka10"></p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/wangka11.png" alt="wangka11"></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux三剑客</title>
    <url>/bfa86649.html</url>
    <content><![CDATA[<p>Linux中最重要的三个命令在业界被称为“<strong>三剑客</strong>”，它们是grep，sed，awk。</p>
<p>我们知道Linux下一切皆文件，对Linux的操作就是对文件的处理，那么怎么能更好的处理文件呢？这就要用到我们的三剑客命令。</p>
<span id="more"></span>
<ul>
<li>grep ：过滤文本</li>
<li>sed  :  修改文本</li>
<li>awk  :  处理文本</li>
</ul>
<p>使用这三个工具可以提升运维效率，熟练掌握好正则表达式是使用<code>Linux三剑客</code>的前提，在说三剑客前我们要插入一个小插曲就是“正则表达式”。在掌握好正则表达式后，将具体讲解三剑客的用法。</p>
<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则表达式：REGular EXPression, REGEXP。我们通过特定的字符串匹配模板，来获取到所需的内容。</p>
<p>Linux 三剑客以正则表达式作为基础，而在Linux系统中，支持两种正则表达式：</p>
<ul>
<li>标准正则表达式</li>
<li>扩展正则表达式</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">标准正则表达式：</span><br><span class="line">	</span><br><span class="line"> ^    <span class="comment">#以某字符开头</span></span><br><span class="line"> $    <span class="comment">#以某字符结尾</span></span><br><span class="line"> .    <span class="comment">#匹配除换行符之外的任意单个字符</span></span><br><span class="line"> *    <span class="comment">#匹配前导字符的任意个数</span></span><br><span class="line"> []   <span class="comment">#某组字符串的任意一个字符</span></span><br><span class="line"> [^]  <span class="comment">#取反</span></span><br><span class="line"> [a-z]    <span class="comment">#匹配小写字母</span></span><br><span class="line"> [A-Z]    <span class="comment">#匹配大写字母</span></span><br><span class="line"> [a-zA-Z] <span class="comment">#匹配字母</span></span><br><span class="line"> [0-9]    <span class="comment">#匹配数字</span></span><br><span class="line"> \      <span class="comment">#取消转义</span></span><br><span class="line"> ()     <span class="comment">#分组</span></span><br><span class="line"> \n     <span class="comment">#代表第n个分组</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">扩展正则表达式：</span><br><span class="line"> &#123;&#125;     <span class="comment">#匹配的次数</span></span><br><span class="line"> &#123;n&#125;    <span class="comment">#匹配n次</span></span><br><span class="line"> &#123;n,&#125;   <span class="comment">#至少匹配n次</span></span><br><span class="line"> &#123;n,m&#125;  <span class="comment">#匹配 n 到 m 次</span></span><br><span class="line"> &#123;,m&#125;   <span class="comment">#最多匹配m次</span></span><br><span class="line">  +     <span class="comment">#匹配至少有一个前导字符</span></span><br><span class="line">  ?     <span class="comment">#匹配一个或零个前导字符</span></span><br><span class="line">  |     <span class="comment">#或</span></span><br></pre></td></tr></table></figure>



<h1 id="linux三剑客之grep"><a href="#linux三剑客之grep" class="headerlink" title="linux三剑客之grep"></a>linux三剑客之grep</h1><ul>
<li>文本过滤器（根据文本内容过滤文件）</li>
<li>grep命令家族由grep, egrep, fgrep 三个子命令组成，适用于不同的场景。具体如下：<ul>
<li>命令描述<ul>
<li>grep 原生的grep命令，使用“标准正则表达式”作为匹配标准。</li>
<li>egrep 扩展的grep命令，相当于<code>$(grep -E)</code>，使用“扩展正则表达式”作为匹配标准。</li>
<li>fgrep 简化版的grep命令，不支持正则表达式，但搜索速度快，系统资源使用率低。</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">语法格式：</span><br><span class="line">  grep [参数] [匹配规则] [操作对象]</span><br><span class="line"></span><br><span class="line"> 参数：</span><br><span class="line">   -n  <span class="comment">#过滤文本时，将过滤出来的内容在文件内的行号显示出来</span></span><br><span class="line">   -A  <span class="comment">#匹配成功之后，将匹配行的后n行显示出来</span></span><br><span class="line">   -B  <span class="comment">#匹配成功之后，将匹配行的前n行显示出来</span></span><br><span class="line">   -C  <span class="comment">#匹配成功之后，将匹配行的前后各n行显示出来</span></span><br><span class="line">   -c  <span class="comment">#只显示匹配成功的行数</span></span><br><span class="line">   -o  <span class="comment">#只显示匹配成功的内容</span></span><br><span class="line">   -v  <span class="comment">#显示不包含匹配文本的所有行（反向过滤）</span></span><br><span class="line">   -q  <span class="comment">#静默输出(禁止输出任何结果，已退出状态表示搜索是否成功)</span></span><br><span class="line">   -i  <span class="comment">#搜索时，忽略大小写</span></span><br><span class="line">   -l  <span class="comment">#匹配成功之后，将文本的名称打印出来</span></span><br><span class="line">   -h	 <span class="comment">#查询多文件时不显示文件名</span></span><br><span class="line">   -b  <span class="comment">#打印匹配行距文件头部的偏移量，以字节为单位</span></span><br><span class="line">   -s	 <span class="comment">#不显示不存在、没有匹配文本的错误信息</span></span><br><span class="line">   -w  <span class="comment">#匹配整词</span></span><br><span class="line">   -x  <span class="comment">#匹配整行</span></span><br><span class="line">   -R|-r <span class="comment">#递归匹配 </span></span><br><span class="line">   -E    <span class="comment">#使用扩展正则,等价于 egrep</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">知识储备：</span><br><span class="line">  $?  <span class="comment">#上一行命令执行的结果，0代表执行成功，其他数字代表执行失败。</span></span><br><span class="line">  wc  <span class="comment">#匹配行数</span></span><br><span class="line">   参数：</span><br><span class="line">		-l  <span class="comment">#打印匹配行数</span></span><br><span class="line">		-c  <span class="comment">#打印匹配的字节数	</span></span><br><span class="line">	</span><br><span class="line">案例：</span><br><span class="line"> <span class="comment"># 在/etc目录下，有多少个文件包含root。</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># grep -rl &#x27;root&#x27; /etc/ | wc -l</span></span><br><span class="line">   130</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 在/etc/passwd文件中，匹配以ftp开头的行</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># grep &#x27;^root&#x27; /etc/passwd</span></span><br><span class="line">   root:x:0:0:root:/root:/bin/bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 在/etc/passwd文件中，匹配以bash结尾的行,-n显示行号</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># grep -n &#x27;bash$&#x27; /etc/passwd</span></span><br><span class="line">   1:root:x:0:0:root:/root:/bin/bash</span><br><span class="line">   21:<span class="built_in">test</span>:x:1001:1001::/home/<span class="built_in">test</span>/:/bin/bash</span><br><span class="line">   22:gf:x:1002:1002::/home/gf:/bin/bash</span><br><span class="line">   28:tony:x:1004:1004::/home/tony:/bin/bash</span><br><span class="line">   29:user:x:1006:1001::/home/user:/bin/bash</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 匹配本机中有哪些ip</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># ip a | grep -oE &#x27;([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&#123;1,3&#125;&#x27;</span></span><br><span class="line">   127.0.0.1</span><br><span class="line">   192.168.15.100</span><br><span class="line">   192.168.15.255</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 要求将/etc/fstab中的去掉包含 # 开头的行，且要求 # 后至少有一个空格</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># grep -vE &#x27;^#\ +&#x27; /etc/fstab</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">#</span></span><br><span class="line">   <span class="comment">#</span></span><br><span class="line">   <span class="comment">#</span></span><br><span class="line">   /dev/mapper/centos-root /      xfs     defaults    0 0</span><br><span class="line">   UUID=9f8a98b0-805c-4adf-b9ef-517a2b527f89 /boot   xfs   defaults    0 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 找出文件中至少有一个空格的行</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># grep -E &#x27;\ +&#x27; 1.txt </span></span><br><span class="line">   11 11</span><br><span class="line">   22 22</span><br><span class="line">   5 5 5 5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 将 nginx.conf 文件中以#开头的行和空行，全部删除 </span></span><br><span class="line">  [root@localhost ~]<span class="comment"># grep -vE &#x27;^\ *#|^$&#x27; /etc/nginx/nginx.conf</span></span><br></pre></td></tr></table></figure>



<h1 id="linux三剑客之sed"><a href="#linux三剑客之sed" class="headerlink" title="linux三剑客之sed"></a>linux三剑客之sed</h1><ul>
<li><p>sed是一个流式编辑器，在处理行内容时功能十分强大。</p>
<ul>
<li><p>定位到某一行，将某一行的某一部分给替换掉</p>
</li>
<li><p>定位到某一行，然后删除</p>
</li>
<li><p>定位到某一行，在该行后添加新的配置</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">语法格式</span><br><span class="line">  sed [参数] <span class="string">&#x27;处理规则&#x27;</span> [操作对象]</span><br><span class="line"></span><br><span class="line"> 参数</span><br><span class="line">   -n  <span class="comment">#取消默认输出</span></span><br><span class="line">   -e  <span class="comment">#允许多项编辑</span></span><br><span class="line">   -i  <span class="comment">#直接编辑源文件（把流向屏幕的内容写到文件中）</span></span><br><span class="line">   -r  <span class="comment">#支持扩展正则</span></span><br><span class="line">   -f  <span class="comment">#指定sed匹配规则脚本文件</span></span><br><span class="line"></span><br><span class="line"> 定位</span><br><span class="line"><span class="comment"># 1、行号定位法，指定行号定位</span></span><br><span class="line">  <span class="comment"># 不写代表定位所有行</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># sed &#x27;&#x27; 1.txt </span></span><br><span class="line">   1111</span><br><span class="line">   2222</span><br><span class="line">   3333</span><br><span class="line">   4444</span><br><span class="line">   5555</span><br><span class="line">   </span><br><span class="line">  <span class="comment"># 3定位到第三行</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># sed &#x27;3d&#x27; 1.txt   </span></span><br><span class="line">   1111</span><br><span class="line">   2222</span><br><span class="line">   4444</span><br><span class="line">   5555</span><br><span class="line">   </span><br><span class="line">  <span class="comment"># 2，3从第二行到第三行</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># sed &#x27;2,3d&#x27; 1.txt </span></span><br><span class="line">   1111</span><br><span class="line">   4444</span><br><span class="line">   5555</span><br><span class="line">   </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 2、正则定位法，指定正则定位。</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># sed &#x27;&#x27; 2.txt</span></span><br><span class="line">   gen111</span><br><span class="line">   222gen</span><br><span class="line">   333gen333</span><br><span class="line">   444xxx444</span><br><span class="line">   555gen555gen</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">  <span class="comment"># 删除包含gen的行</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># sed &#x27;/gen/d&#x27; 2.txt </span></span><br><span class="line">   444xxx444</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">  <span class="comment"># 删除以gen开头的行</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># sed &#x27;/^gen/d&#x27; 2.txt </span></span><br><span class="line">   222gen</span><br><span class="line">   333gen333</span><br><span class="line">   444xxx444</span><br><span class="line">   555gen555gen</span><br><span class="line">   </span><br><span class="line">  <span class="comment"># 删除以gen结尾的行</span></span><br><span class="line">	[root@localhost ~]<span class="comment"># sed &#x27;/gen$/d&#x27; 2.txt </span></span><br><span class="line">   gen111</span><br><span class="line">   333gen333</span><br><span class="line">   444xxx444</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、数字+正则定位法</span></span><br><span class="line">  <span class="comment"># 把1-3行的gen换成GEN</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># sed &#x27;1,3s/gen/GEN/&#x27; 2.txt </span></span><br><span class="line">   GEN111</span><br><span class="line">   222GEN</span><br><span class="line">   333GEN333</span><br><span class="line">   444xxx444</span><br><span class="line">   555gen555gen</span><br><span class="line">   </span><br><span class="line">  <span class="comment"># 把所有的gen换成GEN</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># sed &#x27;s/gen/GEN/g&#x27; 2.txt </span></span><br><span class="line">   GEN111</span><br><span class="line">   222GEN</span><br><span class="line">   333GEN333</span><br><span class="line">   444xxx444</span><br><span class="line">   555GEN555GEN</span><br><span class="line">   </span><br><span class="line">  <span class="comment"># 把所有的gen换成fen执行到文件中</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># sed -i &#x27;s/gen/fen/g&#x27; 2.txt </span></span><br><span class="line">  [root@localhost ~]<span class="comment"># cat 2.txt </span></span><br><span class="line">   fen111</span><br><span class="line">   222fen</span><br><span class="line">   333fen333</span><br><span class="line">   444xxx444</span><br><span class="line">   555fen555fen</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sed的编辑模式：</span><br><span class="line">  d ：删除 </span><br><span class="line">  p ：打印</span><br><span class="line">  a : 在当前行后添加一行</span><br><span class="line">  c ：用新文本修改（替换）当前行</span><br><span class="line">  i : 在当前行之前，插入文本（单独使用时）</span><br><span class="line">  r : 在文件中读内容</span><br><span class="line">  w : 将指定行写入文件</span><br><span class="line">  y : 将字符转换成另一个字符</span><br><span class="line">  s : 将字符串转换成另一个字符串（每一行只替换一次）</span><br><span class="line">  g : 全部执行</span><br><span class="line">  i : 忽略大小写（跟 s 模式一起使用时）	</span><br><span class="line">  &amp; ：代表前面匹配到的内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">	<span class="comment"># a模式：在第二行后面添加一行xxx</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># sed &#x27;2axxx&#x27; 2.txt </span></span><br><span class="line">   fen111</span><br><span class="line">   222fen</span><br><span class="line">   xxx</span><br><span class="line">   333fen333</span><br><span class="line">   444xxx444</span><br><span class="line">   555fen555fen</span><br><span class="line"></span><br><span class="line">  <span class="comment"># c模式：将第一行的内容替换为xxx</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># sed &#x27;1cxxx&#x27; 2.txt </span></span><br><span class="line">   xxx</span><br><span class="line">   222fen</span><br><span class="line">   333fen333</span><br><span class="line">   444xxx444</span><br><span class="line">   555fen555fen</span><br><span class="line"></span><br><span class="line">  <span class="comment"># i模式：在第五行之前插入xxx</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># sed &#x27;5ixxx&#x27; 2.txt</span></span><br><span class="line">   fen111</span><br><span class="line">   222fen</span><br><span class="line">   333fen333</span><br><span class="line">   444xxx444</span><br><span class="line">   xxx</span><br><span class="line">   555fen555fen</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># r模式：将3.txt内容读到2.txt中第二行后显示</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># sed &#x27;2r w.txt&#x27; 2.txt </span></span><br><span class="line">   fen111</span><br><span class="line">   222fen</span><br><span class="line">   hahaha</span><br><span class="line">   333fen333</span><br><span class="line">   444xxx444</span><br><span class="line">   555fen555fen</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment"># w模式：将第二行的内容写入w.txt 文件，文件不存在自动创建</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># sed &#x27;2w w.txt&#x27; 2.txt </span></span><br><span class="line">  [root@localhost ~]<span class="comment"># cat w.txt </span></span><br><span class="line">   222fen</span><br><span class="line"></span><br><span class="line">  <span class="comment"># y模式：将第二行内容替换</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># sed &#x27;2y/fe/FE/&#x27; 2.txt </span></span><br><span class="line">   fen111</span><br><span class="line">   222FEn</span><br><span class="line">   333fen333</span><br><span class="line">   444xxx444</span><br><span class="line">   555fen555fen</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、将nginx.conf中的注释行全部去掉</span><br><span class="line">   [root@localhost ~]<span class="comment"># sed &#x27;/^ *#/d&#x27; /etc/nginx/nginx.conf</span></span><br><span class="line"></span><br><span class="line">2、将nginx.conf中每一行之前增加注释</span><br><span class="line">   [root@localhost ~]<span class="comment"># sed &#x27;s/.*/# &amp;/g&#x27; /etc/nginx/nginx.conf</span></span><br><span class="line"></span><br><span class="line">3、要求一键修改本机的ip，</span><br><span class="line">   192.168.15.100 ---&gt; 192.168.15.101</span><br><span class="line">   172.16.1.100   ---&gt; 172.16.1.101</span><br><span class="line">   sed -i <span class="string">&#x27;s#.100#.101#g&#x27;</span> /etc/sysconfig/network-scripts/ifcfg-eth[01]</span><br><span class="line">	</span><br><span class="line">4、将/etc/passwd中的root修改成ROOT</span><br><span class="line">   sed -i <span class="string">&#x27;s#root#ROOT#g&#x27;</span> /etc/passwd</span><br></pre></td></tr></table></figure>

<h1 id="linux三剑客之awk"><a href="#linux三剑客之awk" class="headerlink" title="linux三剑客之awk"></a>linux三剑客之awk</h1><p><img src="https://gitee.com/gengff/blogimage/raw/master/images/awk.jpg" alt="awk"></p>
<ul>
<li><p>awk是一个强大的Linux命令，有强大的文本格式化的能力。相对于grep的查找，sed的编辑，awk在其对数据分析并生成报告时，显得尤为强大。简单来说awk就是把文件逐行的读入，以空格为默认分隔符将每行切片，切开的部分再进行各种分析处理。</p>
<p>awk其名称得自于它的创始人 Alfred Aho 、Peter Weinberger 和 Brian Kernighan 姓氏的首个字母。实际上 AWK 的确拥有自己的语言： AWK 程序设计语言 ， 三位创建者已将它正式定义为“样式扫描和处理语言”。它允许您创建简短的程序，这些程序读取输入文件、为数据排序、处理数据、对输入执行计算以及生成报表，还有无数其他的功能</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">语法格式：</span><br><span class="line">  awk [选项]  <span class="string">&#x27;模式&#123;动作&#125;&#x27;</span> [文件信息]</span><br><span class="line">	awk [参数]  [处理规则] [操作对象]</span><br><span class="line"></span><br><span class="line">  参数</span><br><span class="line">   -F  <span class="comment">#指定文本分隔符（默认是以空格作为分隔符）</span></span><br><span class="line"></span><br><span class="line">案例：   </span><br><span class="line"> <span class="comment"># 准备文本文件  </span></span><br><span class="line"> [root@localhost ~]<span class="comment"># cat 3.txt </span></span><br><span class="line">  test1d test2f test3y</span><br><span class="line">  test4d test5f test6y</span><br><span class="line">  test7d test7f test9y</span><br><span class="line"> <span class="comment"># 以字符d为分割符</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># awk -F&#x27;d&#x27; &#x27;&#123;print $NF&#125;&#x27; 3.txt </span></span><br><span class="line">  test2f test3y</span><br><span class="line">  test5f test6y</span><br><span class="line">  test7f test9y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">案例：打印系统所有用户的解析器</span><br><span class="line">   [root@localhost ~]<span class="comment"># awk -F: &#x27;&#123;print $NF&#125;&#x27; /etc/passwd</span></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"><span class="comment"># awk中的内置变量</span></span><br><span class="line">	<span class="variable">$0</span> : 代表当前行</span><br><span class="line">		[root@localhost ~]<span class="comment"># awk -F: &#x27;&#123;print $0, &quot;---&quot;&#125;&#x27; /etc/passwd</span></span><br><span class="line">		</span><br><span class="line">	<span class="variable">$n</span> : 代表第n列</span><br><span class="line">		[root@localhost ~]<span class="comment"># awk -F: &#x27;&#123;print $1&#125;&#x27; /etc/passwd	</span></span><br><span class="line">		</span><br><span class="line">	NF : 记录当前行的字段数</span><br><span class="line">		[root@localhost ~]<span class="comment"># awk -F: &#x27;&#123;print NF&#125;&#x27; /etc/passwd</span></span><br><span class="line">		</span><br><span class="line">	<span class="variable">$NF</span> : 代表最后一列</span><br><span class="line">		[root@localhost ~]<span class="comment"># awk -F: &#x27;&#123;print $NF&#125;&#x27; /etc/passwd</span></span><br><span class="line">		</span><br><span class="line">	NR : 用来记录行号</span><br><span class="line">		[root@localhost ~]<span class="comment"># awk -F: &#x27;&#123;print NR&#125;&#x27; /etc/passwd</span></span><br><span class="line">		</span><br><span class="line">	FS : 指定文本内容分隔符（默认是空格）<span class="comment"># FS 的优先级要高于 -F</span></span><br><span class="line">		[root@localhost ~]<span class="comment"># awk &#x27;BEGIN&#123;FS=&quot;:&quot;&#125;&#123;print $NF, $1&#125;&#x27; /etc/passwd</span></span><br><span class="line">		</span><br><span class="line">	OFS : 指定打印分隔符（默认空格）</span><br><span class="line">		[root@localhost ~]<span class="comment"># awk -F: &#x27;BEGIN&#123;OFS=&quot; &gt;&gt;&gt; &quot;&#125;&#123;print $NF, $1&#125;&#x27; /etc/passwd</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="awk的生命周期和处理规则的执行流程"><a href="#awk的生命周期和处理规则的执行流程" class="headerlink" title="awk的生命周期和处理规则的执行流程"></a>awk的生命周期和处理规则的执行流程</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># awk的生命周期和</span></span><br><span class="line">  grep、sed 和 awk 都是读一行处理一行，直至处理完成。</span><br><span class="line">	</span><br><span class="line">  ① 接收一行作为输入</span><br><span class="line">  ② 把刚刚读入进来得到文本进行分解</span><br><span class="line">  ③ 使用处理规则处理文本</span><br><span class="line">  ④ 输入一行，赋值给<span class="variable">$0</span>，直至处理完成</span><br><span class="line">  ⑤ 把处理完成之后的所有的数据交给END&#123;&#125;来再次处理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># awk处理规则的执行流程</span></span><br><span class="line"> awk [参数][分隔符] <span class="string">&#x27;&#123;BEGIN&#123;开始初需要的处理&#125;/定位/&#123;循环&#125;END&#123;结束前需要的处理&#125;&#125;&#x27;</span> [操作对象]</span><br><span class="line">   BEGIN&#123;&#125; <span class="comment">#开始语句：定义变量在BEGIN块里面		 </span></span><br><span class="line">    //     <span class="comment">#定位：正则匹配</span></span><br><span class="line">    &#123;&#125;     <span class="comment">#循环语句：循环处理文本</span></span><br><span class="line">   END&#123;&#125;   <span class="comment">#结束语句：打印之前统一处理</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/21-1.png" alt="21-1"></p>
<h2 id="awk中的函数"><a href="#awk中的函数" class="headerlink" title="awk中的函数"></a>awk中的函数</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只能用于循环语句和结束语句</span></span><br><span class="line">  <span class="built_in">print</span> : 打印</span><br><span class="line">  <span class="built_in">printf</span> : 格式化打印</span><br><span class="line">   参数：</span><br><span class="line">      %s  <span class="comment">#字符串</span></span><br><span class="line">      %d  <span class="comment">#数字</span></span><br><span class="line">       -  <span class="comment">#左对齐</span></span><br><span class="line">       +  <span class="comment">#右对齐</span></span><br><span class="line">      15  <span class="comment">#至少占用15字符</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># awk -F: &#x27;BEGIN&#123;OFS=&quot; | &quot;&#125;&#123;printf &quot;|%+15s|%-15s|\n&quot;, $NF,$1&#125;&#x27; /etc/passwd</span></span><br><span class="line">  |      /bin/bash|root           |</span><br><span class="line">  |  /sbin/nologin|bin            |</span><br><span class="line">  |  /sbin/nologin|daemon         |</span><br><span class="line">  |  /sbin/nologin|adm            |</span><br><span class="line">  |  /sbin/nologin|lp             |</span><br><span class="line">  |      /bin/sync|sync           |</span><br><span class="line">  | /sbin/shutdown|shutdown       |</span><br><span class="line">  |     /sbin/halt|halt           |</span><br><span class="line">  |  /sbin/nologin|mail           |</span><br><span class="line">  |  /sbin/nologin|operator       |</span><br><span class="line">  |  /sbin/nologin|games          |</span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="awk中的定位和流程控制"><a href="#awk中的定位和流程控制" class="headerlink" title="awk中的定位和流程控制"></a>awk中的定位和流程控制</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># awk中的定位</span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 1、正则表达式</span></span><br><span class="line">   <span class="comment"># 打印含root所在行的所有内容</span></span><br><span class="line">   [root@localhost ~]<span class="comment"># awk -F: &#x27;/root/&#123;print $0&#125;&#x27; /etc/passwd</span></span><br><span class="line">   </span><br><span class="line">   <span class="comment"># 打印以root开头所在行的所有内容</span></span><br><span class="line">   [root@localhost ~]<span class="comment"># awk -F: &#x27;/^root/&#123;print $0&#125;&#x27; /etc/passwd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 2、比较表达式</span></span><br><span class="line">    &gt;   <span class="comment">#大于</span></span><br><span class="line">    &lt;   <span class="comment">#小于</span></span><br><span class="line">    &gt;=  <span class="comment">#大于等于</span></span><br><span class="line">    &lt;=  <span class="comment">#小于等于</span></span><br><span class="line">    ~	  <span class="comment">#表示匹配后面的正则表达式</span></span><br><span class="line">    !~  <span class="comment">#表示匹配后面的正则表达式</span></span><br><span class="line">		</span><br><span class="line">  案例：要求打印属组ID大于属主ID的行</span><br><span class="line">   [root@localhost ~]<span class="comment"># awk -F: &#x27;$4 &gt; $3&#123;print $0&#125;&#x27; /etc/passwd</span></span><br><span class="line">		</span><br><span class="line">  案例：结尾包含bash</span><br><span class="line">   [root@localhost ~]<span class="comment"># awk -F: &#x27;$NF ~ /bash/&#123;print $0&#125;&#x27; /etc/passwd</span></span><br><span class="line">		</span><br><span class="line">  案例：结尾不包含bash</span><br><span class="line">   [root@localhost ~]<span class="comment"># awk -F: &#x27;$NF !~ /bash/&#123;print $0&#125;&#x27; /etc/passwd</span></span><br><span class="line">		</span><br><span class="line">  <span class="comment"># 3、逻辑表达式</span></span><br><span class="line">   &amp;&amp;	<span class="comment">#与</span></span><br><span class="line">    [root@localhost ~]<span class="comment"># awk -F: &#x27;$3 + $4 &gt; 2000 &amp;&amp; $3 * $4 &gt; 2000&#123;print $0&#125;&#x27; /etc/passwd</span></span><br><span class="line">   </span><br><span class="line">   || <span class="comment">#或</span></span><br><span class="line">   </span><br><span class="line">    [root@localhost ~]<span class="comment"># awk -F: &#x27;$3 + $4 &gt; 2000 || $3 * $4 &gt; 2000&#123;print $0&#125;&#x27; /etc/passwd</span></span><br><span class="line">   !  <span class="comment">#非</span></span><br><span class="line">    [root@localhost ~]<span class="comment"># awk -F: &#x27;!($3 + $4 &gt; 2000)&#123;print $0&#125;&#x27; /etc/passwd</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">  <span class="comment"># 4、算术表达式</span></span><br><span class="line">    +  <span class="comment">#加</span></span><br><span class="line">    -  <span class="comment">#减</span></span><br><span class="line">    *  <span class="comment">#乘</span></span><br><span class="line">    /  <span class="comment">#除</span></span><br><span class="line">    %  <span class="comment">#取余</span></span><br><span class="line"></span><br><span class="line">   案例：要求属组 + 属主的ID 大于 2000</span><br><span class="line">    [root@localhost ~]<span class="comment"># awk -F: &#x27;$3 + $4 &gt; 2000&#123;print $0&#125;&#x27; /etc/passwd</span></span><br><span class="line">    </span><br><span class="line">   案例：要求属组 * 属主的ID 大于 2000</span><br><span class="line">    [root@localhost ~]<span class="comment"># awk -F: &#x27;$3 * $4 &gt; 2000&#123;print $0&#125;&#x27; /etc/passwd</span></span><br><span class="line">    </span><br><span class="line">   案例：要求打印偶数行</span><br><span class="line">    [root@localhost ~]<span class="comment"># awk -F: &#x27;NR % 2 == 0&#123;print $0&#125;&#x27; /etc/passwd</span></span><br><span class="line">    </span><br><span class="line">   案例：要求打印奇数行</span><br><span class="line">    [root@localhost ~]<span class="comment"># awk -F: &#x27;NR % 2 == 1&#123;print $0&#125;&#x27; /etc/passwd</span></span><br><span class="line">			</span><br><span class="line">  <span class="comment"># 5、条件表达式</span></span><br><span class="line">    ==  <span class="comment">#等于</span></span><br><span class="line">    &gt;   <span class="comment">#大于</span></span><br><span class="line">    &lt;   <span class="comment">#小于</span></span><br><span class="line">    &gt;=  <span class="comment">#大于等于</span></span><br><span class="line">    &lt;=  <span class="comment">#小于等于</span></span><br><span class="line">    </span><br><span class="line">   案例：要求打印第三行</span><br><span class="line">    [root@localhost ~]<span class="comment"># awk -F: &#x27;NR == 3&#123;print $0&#125;&#x27; /etc/passwd</span></span><br><span class="line">		</span><br><span class="line">  <span class="comment"># 6、范围表达式：一个选定条件到另一个选定条件之间的数据</span></span><br><span class="line">		案例： </span><br><span class="line">		[root@localhost ~]<span class="comment"># awk -F: &#x27;/^root/,/^ftp/&#123;print $0&#125;&#x27; /etc/passwd</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 流程控制</span></span><br><span class="line">  只存在循环之中。</span><br><span class="line">  <span class="keyword">if</span></span><br><span class="line">    [root@localhost ~]<span class="comment"># awk -F: &#x27;&#123;if($3&gt;$4)&#123;print &quot;大于&quot;&#125;else&#123;print &quot;小于或等于&quot;&#125;&#125;&#x27; /etc/passwd</span></span><br><span class="line">			</span><br><span class="line">      <span class="function"><span class="title">if</span></span>()&#123;&#125;</span><br><span class="line">      <span class="function"><span class="title">if</span></span>()&#123;&#125;<span class="keyword">else</span>&#123;&#125;</span><br><span class="line">      <span class="function"><span class="title">if</span></span>()&#123;&#125;<span class="keyword">else</span> <span class="function"><span class="title">if</span></span>()&#123;&#125;<span class="keyword">else</span>&#123;&#125;</span><br><span class="line">  <span class="keyword">for</span></span><br><span class="line">		</span><br><span class="line">    [root@localhost ~]<span class="comment"># awk -F: &#x27;&#123;for(i=10;i&gt;0;i--)&#123;print $0&#125;&#125;&#x27; /etc/passwd</span></span><br><span class="line">		</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="string">&quot;初始值&quot;</span>;条件判断;游标)&#123;&#125;</span><br><span class="line">		</span><br><span class="line">  <span class="keyword">while</span></span><br><span class="line">	</span><br><span class="line">    [root@localhost ~]<span class="comment"># awk -F: &#x27;&#123;i=1; while(i&lt;10)&#123;print $0, i++&#125;&#125;&#x27; /etc/passwd</span></span><br><span class="line">	</span><br><span class="line">    <span class="keyword">while</span>(条件判断)&#123;&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">    每隔5行，打印一行横线</span><br><span class="line">    -------------------------------------------------------------------------</span><br><span class="line">    </span><br><span class="line">    [root@localhost ~]<span class="comment"># awk -F: &#x27;&#123;if(NR%5==0)&#123;print &quot;----------------&quot;&#125;print $0&#125;&#x27; /etc/passwd</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文本处理和find命令</title>
    <url>/47edf33b.html</url>
    <content><![CDATA[<h1 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h1><ul>
<li><p>根据文件的名称或者属性查找文件。</p>
</li>
<li><p>为什么要有文件查找，因为很多时候我们可能会忘了某个文件所在的位置，此时就需要通过find来查找。<br>find命令可以根据不同的条件来进行查找文件，例如：文件名称、文件大小、文件修改时间、属主属组、权限、等等方式。同时find命令是Linux下必须掌握的</p>
<span id="more"></span>
<h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">find [查找范围(路径)]  [参数]  [参数相关匹配值]  [指令（-<span class="built_in">print</span>）]</span><br></pre></td></tr></table></figure>

<h2 id="参数及示例"><a href="#参数及示例" class="headerlink" title="参数及示例"></a>参数及示例</h2><h3 id="1、find名称查找"><a href="#1、find名称查找" class="headerlink" title="1、find名称查找"></a>1、find名称查找</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-name : 按照文件的名字查找文件</span><br><span class="line">   *   <span class="comment">#通配符</span></span><br><span class="line">-iname : 按照文件的名字查找文件(-i忽略大小写)</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 1.创建文件</span></span><br><span class="line">touch /etc/sysconfig/network-scripts/&#123;ifcfg-eth1,IFCFG-ETH1&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查找/etc目录下包含ifcfg-eth0名称的文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /etc -name &quot;ifcfg-eth1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.-i 忽略大小写</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /etc -iname &quot;ifcfg-eth1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查找/etc目录下包含ifcfg-eth名称所有文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /etc/ -name &quot;ifcfg-eth*&quot;</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /etc -iname &quot;ifcfg-eth*&quot;    </span></span><br></pre></td></tr></table></figure>

<h3 id="2、find大小查找"><a href="#2、find大小查找" class="headerlink" title="2、find大小查找"></a>2、find大小查找</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-size n(单位) : 按照文件的大小查询文件</span><br><span class="line">      +n   <span class="comment">#大于n个单位</span></span><br><span class="line">      -n   <span class="comment">#小于n个单位</span></span><br><span class="line">       n   <span class="comment">#等于n个单位</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 注：find查找同时打印出隐藏文件</span></span><br><span class="line"><span class="comment"># 注：n 必须是整数，不能是小数</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 1.查找大于5M的文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /etc -size +5M</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查找等于5M的文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /etc -size 5M</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查找小于5M的文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /etc -size -5M     </span></span><br></pre></td></tr></table></figure>

<h3 id="3、find时间查找"><a href="#3、find时间查找" class="headerlink" title="3、find时间查找"></a>3、find时间查找</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-atime : 访问时间（cat）</span><br><span class="line">-ctime : 文件变更时间（修改了位置（mv）、所属组、所属用户）</span><br><span class="line"></span><br><span class="line">-mtime : 按照修改时间去查询(包含创建时间)</span><br><span class="line">     +n  <span class="comment">#n 天以前</span></span><br><span class="line">     -n  <span class="comment">#n 天以内  </span></span><br><span class="line">      n  <span class="comment">#</span></span><br><span class="line">      </span><br><span class="line"><span class="comment"># 1.创建测试文件(后期shell会讲)</span></span><br><span class="line">[root@localhost ~]<span class="comment"># for i in &#123;01..28&#125;;do date -s  201904$i &amp;&amp; touch file-$i;done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查找3天以前的文件(不会打印当天的文件)</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find ./ -iname &quot;file-*&quot; -mtime +7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.查找3天以内的文件，不建议使用(会打印当天的文件)</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find ./ -iname &quot;file-*&quot; -mtime -7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.查找3天以前（一天之内）的文件(不会打印当天的文件)</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find ./ -iname &quot;file-*&quot; -mtime 7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.本地文件保留最近7天的备份文件, 备份服务器保留3个月的备份文件(实际使用方案)</span></span><br><span class="line">find /backup/ -iname <span class="string">&quot;*.bak&quot;</span> -mtime +7 -delete</span><br><span class="line">find /backup/ -iname <span class="string">&quot;*.bak&quot;</span> -mtime +90 -delete</span><br></pre></td></tr></table></figure>

<h3 id="4、find用户查找"><a href="#4、find用户查找" class="headerlink" title="4、find用户查找"></a>4、find用户查找</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  -user : 按照用户的属主查询</span><br><span class="line">  -group : 按照用户的属组查询</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 查找属主是tony</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /home -user tony</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找属组是admin</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /home -group admin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找属主是tony, 属组是admin</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /home -user tony -group admin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找属主是tony, 并且属组是admin</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /home -user tony -a -group admin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找属主是tony, 或者属组是admin</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /home -user tony -o -group admin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找没有属主</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /home -nouser</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找没有属组</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /home -nogroup</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找没有属主或属组</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /home -nouser -o -nogroup</span></span><br></pre></td></tr></table></figure>

<h3 id="5、find类型查找"><a href="#5、find类型查找" class="headerlink" title="5、find类型查找"></a>5、find类型查找</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-<span class="built_in">type</span> : 按照文件的类型查询</span><br><span class="line">   f(-) <span class="comment">#普通文件</span></span><br><span class="line">      d <span class="comment">#目录</span></span><br><span class="line">      l <span class="comment">#链接文件</span></span><br><span class="line">      s <span class="comment">#套接字文件</span></span><br><span class="line">      p <span class="comment">#管道文件</span></span><br><span class="line">      c <span class="comment">#字符文件</span></span><br><span class="line">      b <span class="comment">#磁盘文件</span></span><br><span class="line">      </span><br><span class="line"><span class="comment"># f 普通文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /dev -type f</span></span><br><span class="line"><span class="comment"># d 目录</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /dev -type d</span></span><br><span class="line"><span class="comment"># l 链接文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /dev -type l</span></span><br><span class="line"><span class="comment"># s 套接字文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /dev -type s</span></span><br><span class="line"><span class="comment"># p 管道文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /dev -type p      </span></span><br><span class="line"><span class="comment"># c 字符文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /dev -type c</span></span><br><span class="line"><span class="comment"># b 磁盘文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /dev -type b</span></span><br></pre></td></tr></table></figure>

<h3 id="6、find权限查找"><a href="#6、find权限查找" class="headerlink" title="6、find权限查找"></a>6、find权限查找</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-perm ：按照文件的权限查询</span><br><span class="line"></span><br><span class="line"><span class="comment">#精切匹配644权限</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find . -perm 644 -ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#包含444权限即可</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find . -perm -444  -ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查找全局可写(每位权限必须包含w)</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find . -perm -222 -ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#包含set uid</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find  /usr/sbin -perm -4000 -ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#包含set gid</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find  /usr/sbin -perm -2000 -ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#包含sticky</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find  /usr/sbin -perm -1000 -ls</span></span><br></pre></td></tr></table></figure>

<h3 id="7、find逻辑运算符"><a href="#7、find逻辑运算符" class="headerlink" title="7、find逻辑运算符"></a>7、find逻辑运算符</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-a : 与（可以省略，默认时并且）</span><br><span class="line">-o : 或</span><br><span class="line">-not|! : 非</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 1.查找当前目录下，属主不是hdfs的所有文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find . -not -user hdfs </span></span><br><span class="line">[root@localhost ~]<span class="comment"># find . ! -user hdfs</span></span><br><span class="line">        </span><br><span class="line"><span class="comment"># 2.查找当前目录下，属主属于hdfs，且大小大于300字节的文件(c代表字节)</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find . -type f -a -user hdfs -a -size +300c</span></span><br><span class="line">            </span><br><span class="line"><span class="comment"># 3.查找当前目录下的属主为hdfs或者以xml结尾的普通文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find . -type f -a \( -user hdfs -o -name &#x27;*.xml&#x27; \)</span></span><br><span class="line">	</span><br><span class="line">		</span><br><span class="line">-inum : 根据index node号码查询</span><br><span class="line">-maxdepth : 查询的目录深度（必须放置与第一个参数位） </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">知识储备：</span><br><span class="line"> dd : 生成文件</span><br><span class="line">    <span class="keyword">if</span>   <span class="comment">#从什么地方读</span></span><br><span class="line">    of   <span class="comment">#写入到什么文件</span></span><br><span class="line">    bs   <span class="comment">#每次写入多少内容</span></span><br><span class="line">    count <span class="comment">#写入多少次</span></span><br><span class="line"></span><br><span class="line">案例：</span><br><span class="line">  案例1：查询/etc目录下hosts文件</span><br><span class="line">    [root@localhost ~]<span class="comment"># find /etc/ -name &#x27;hosts&#x27;</span></span><br><span class="line">       /etc/hosts</span><br><span class="line">  案例2：查询/etc目录下名称中包含hosts文件</span><br><span class="line">    [root@localhost ~]<span class="comment"># find /etc/ -name &#x27;*hosts*&#x27;</span></span><br><span class="line"></span><br><span class="line">  案例3：要求把/etc目录下，所有的普通文件打包压缩到/tmp目录</span><br><span class="line">    [root@localhost /tmp]<span class="comment"># tar -czPf /tmp/etcv2.tar.gz `find /etc/ -type f | xargs`</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">知识储备</span><br><span class="line">   |    <span class="comment">#前面一个命令的结果交给后面一个命令处理</span></span><br><span class="line"> xargs  <span class="comment">#把处理的文本变成以空格分割的一行</span></span><br><span class="line">   ``   <span class="comment">#提前执行命令，然后将结果交给其他命令来处理</span></span><br><span class="line">	</span><br><span class="line"> <span class="comment">#xargs将前者命令查找到的文件作为一个整体传递后者命令的输入</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># touch file.txt</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># find . -name &quot;file.txt&quot; |xargs rm -f</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># find . -name &quot;file.txt&quot; |xargs -I &#123;&#125; cp -rvf &#123;&#125; /var/tmp	</span></span><br></pre></td></tr></table></figure>

<h3 id="8、find指令"><a href="#8、find指令" class="headerlink" title="8、find指令"></a>8、find指令</h3><ul>
<li>-print ：打印结果集</li>
<li>-ls ： 打印结果集详情</li>
<li>-delete : 删除结果集</li>
<li>-exec : 将find处理好的结果集进行下一步处理</li>
<li>-ok : 将find处理好对结果集进行下一步处理（交互）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印结果集</span></span><br><span class="line">[root@localhost dev]<span class="comment"># find / -type s -ctime -3 -print</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果集详情</span></span><br><span class="line">[root@localhost dev]<span class="comment"># find / -type s -ctime -3 -ls</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除结果集</span></span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># ls</span></span><br><span class="line"> Abc  abc1  Abc1  abc10  abc2  abc23  abc3  abc4  abc5</span><br><span class="line">[root@localhost <span class="built_in">test</span>]<span class="comment"># find ./ -iname &quot;abc?&quot; -delete</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对结果集进行下一步处理</span></span><br><span class="line"><span class="comment"># 格式</span></span><br><span class="line">	find 路径 参数  参数表达式  -<span class="built_in">exec</span>  命令 &#123;&#125; \;</span><br><span class="line"> [root@localhost <span class="built_in">test</span>]<span class="comment"># find ./ -iname &quot;abc&quot;</span></span><br><span class="line">  ./Abc</span><br><span class="line"> [root@localhost <span class="built_in">test</span>]<span class="comment"># find ./ -iname &quot;abc&quot; -exec ls -l &#123;&#125; \;</span></span><br><span class="line">  -rw-r--r-- 1 root root 0 Mar 10 09:44 ./Abc</span><br><span class="line"> [root@localhost <span class="built_in">test</span>]<span class="comment"># </span></span><br><span class="line"> [root@localhost <span class="built_in">test</span>]<span class="comment"># find ./ -iname &quot;abc&quot;</span></span><br><span class="line">  ./Abc</span><br><span class="line"> [root@localhost <span class="built_in">test</span>]<span class="comment"># find ./ -iname &quot;abc&quot; -exec rm -rf &#123;&#125; \;</span></span><br><span class="line"> [root@localhost <span class="built_in">test</span>]<span class="comment"># ls</span></span><br><span class="line">  abc10  abc23</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 对结果集进行下一步处理（交互）</span></span><br><span class="line"> <span class="comment"># 格式</span></span><br><span class="line">  find 路径 参数  参数表达式  -ok   命令 &#123;&#125; \;</span><br><span class="line"></span><br><span class="line"> [root@localhost <span class="built_in">test</span>]<span class="comment"># find ./ -iname &quot;abc10&quot; </span></span><br><span class="line">  ./abc10</span><br><span class="line"> [root@localhost <span class="built_in">test</span>]<span class="comment"># find ./ -iname &quot;abc10&quot; -ok rm &#123;&#125; \;</span></span><br><span class="line">  &lt; rm ... ./abc10 &gt; ? n</span><br><span class="line"> [root@localhost <span class="built_in">test</span>]<span class="comment"># ls</span></span><br><span class="line">  abc10  abc23</span><br><span class="line"> [root@localhost <span class="built_in">test</span>]<span class="comment"># find ./ -iname &quot;abc10&quot; -ok rm &#123;&#125; \;</span></span><br><span class="line">  &lt; rm ... ./abc10 &gt; ? y</span><br><span class="line"> [root@localhost <span class="built_in">test</span>]<span class="comment"># ls</span></span><br><span class="line">  abc23</span><br></pre></td></tr></table></figure>

<p><strong>find相关练习题</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.查找/tmp目录下，属主不是root，且文件名不以f开头的文件</span><br><span class="line">2.查找/var目录下属主为root，且属组为mail的所有文件</span><br><span class="line">3.查找/var目录下不属于root、lp、gdm的所有文件</span><br><span class="line">4.查找/var目录下最近一周内其内容修改过，同时属主不为root，也不是postfix的文件</span><br><span class="line">5.查找/etc目录下大于1M且类型为普通文件的所有文件</span><br><span class="line">6.将/etc/中的所有目录(仅目录)复制到/tmp下，目录结构不变</span><br><span class="line">7.将/etc目录复制到/var/tmp/,/var/tmp/etc的所有目录权限777/var/tmp/etc目录中所有文件权限666</span><br><span class="line">8.保留/var/<span class="built_in">log</span>/下最近7天的日志文件,其他全部删除</span><br><span class="line">9.创建touch file&#123;1..10&#125;10个文件, 保留file9,其他一次全部删除</span><br><span class="line">10.解释如下每条命令含义</span><br><span class="line">mkdir /root/dir1</span><br><span class="line">touch /root/dir1/file&#123;1..10&#125;</span><br><span class="line">find /root/dir1 -<span class="built_in">type</span> f -name <span class="string">&quot;file5&quot;</span></span><br><span class="line">find /root/dir1 ! -name <span class="string">&quot;file5&quot;</span></span><br><span class="line">find /root/dir1 -name <span class="string">&quot;file5&quot;</span> -o -name <span class="string">&quot;file9&quot;</span></span><br><span class="line">find /root/dir1 -name <span class="string">&quot;file5&quot;</span> -o -name <span class="string">&quot;file9&quot;</span> -ls</span><br><span class="line">find /root/dir1 \( -name <span class="string">&quot;file5&quot;</span> -o -name <span class="string">&quot;file9&quot;</span> \) -ls</span><br><span class="line">find /root/dir1 \( -name <span class="string">&quot;file5&quot;</span> -o -name <span class="string">&quot;file9&quot;</span> \) -<span class="built_in">exec</span> rm -rvf &#123;&#125; \;</span><br><span class="line">find /root/dir1  ! \( -name <span class="string">&quot;file4&quot;</span> -o -name <span class="string">&quot;file8&quot;</span> \) -<span class="built_in">exec</span> rm -vf &#123;&#125;  \; </span><br></pre></td></tr></table></figure>

<h1 id="字符处理命令"><a href="#字符处理命令" class="headerlink" title="字符处理命令"></a>字符处理命令</h1><h2 id="1、sort命令"><a href="#1、sort命令" class="headerlink" title="1、sort命令"></a>1、sort命令</h2><ul>
<li>用于将文本文件内容加以排序</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sort [参数] 需要排序的对象</span><br><span class="line"> 参数：</span><br><span class="line">  -n <span class="comment"># 依照数值的大小排序</span></span><br><span class="line">  -r <span class="comment"># 以相反的顺序来排序</span></span><br><span class="line">  -k <span class="comment"># 以某列进行排序</span></span><br><span class="line">  -t <span class="comment"># 指定分割符，默认是以空格为分隔符</span></span><br><span class="line"></span><br><span class="line">	cat 3.txt | sort -n -r -k3 -t <span class="string">&#x27;|&#x27;</span></span><br><span class="line"><span class="comment"># 1.首先创建一个文件，写入一写无序的内容</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat &gt;&gt; file.txt &lt;&lt;EOF</span></span><br><span class="line"> b:3</span><br><span class="line"> c:2</span><br><span class="line"> a:4</span><br><span class="line"> e:5</span><br><span class="line"> d:1</span><br><span class="line"> f:11</span><br><span class="line"> EOF</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.使用sort下面对输出的内容进行排序</span></span><br><span class="line">[root@localhost ~]<span class="comment"># sort file.txt</span></span><br><span class="line"> a:4</span><br><span class="line"> b:3</span><br><span class="line"> c:2</span><br><span class="line"> d:1</span><br><span class="line"> e:5</span><br><span class="line"> f:11</span><br><span class="line"></span><br><span class="line"><span class="comment">#结果并不是按照数字排序，而是按字母排序。</span></span><br><span class="line"><span class="comment">#可以使用-t指定分隔符, 使用-k指定需要排序的列。</span></span><br><span class="line">[root@localhost ~]<span class="comment"># sort -t &quot;:&quot; -k2 sort.txt</span></span><br><span class="line"> d:1</span><br><span class="line"> f:11 <span class="comment">#第二行为什么是11？不应该按照顺序排列？</span></span><br><span class="line"> c:2</span><br><span class="line"> b:3</span><br><span class="line"> a:4</span><br><span class="line"> e:5</span><br><span class="line"></span><br><span class="line"><span class="comment">#按照排序的方式, 只会看到第一个字符,11的第一个字符是1, 按照字符来排序确实比2小。 </span></span><br><span class="line"><span class="comment">#如果想要按照数字的方式进行排序, 需要使用 -n参数。</span></span><br><span class="line">[root@localhost ~]<span class="comment"># sort -t &quot;:&quot; -n -k2 p.txt</span></span><br><span class="line"> d:1</span><br><span class="line"> c:2</span><br><span class="line"> b:3</span><br><span class="line"> a:4</span><br><span class="line"> e:5</span><br><span class="line"> f:11</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#测试案例，下载文件http://fj.xuliangwei.com/public/ip.txt，对该文件进行排序</span></span><br><span class="line">[root@localhost ~]<span class="comment"># sort -t. -k3.1,3.1nr -k4.1,4.3nr ip.txt</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2、uniq-命令"><a href="#2、uniq-命令" class="headerlink" title="2、uniq 命令"></a>2、uniq 命令</h2><ul>
<li>用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">uniq [参数] 需要去重的对象</span><br><span class="line"> 参数：</span><br><span class="line">  -c <span class="comment"># 在每列旁边显示该行重复出现的次数</span></span><br><span class="line">  -d <span class="comment"># 仅显示重复出现的行列</span></span><br><span class="line">  -u <span class="comment"># 仅显示出一次的行列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.创建一个file.txt文件:</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat file.txt</span></span><br><span class="line"> abc</span><br><span class="line"> 123</span><br><span class="line"> abc</span><br><span class="line"> 123</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2.uniq需要和sort一起使用, 先使用sort排序, 让重复内容连续在一起</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat file.txt | sort</span></span><br><span class="line"> 123</span><br><span class="line"> 123</span><br><span class="line"> abc</span><br><span class="line"> abc</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 3.使用uniq去除相邻重复的行</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat file.txt |sort|uniq</span></span><br><span class="line"> 123</span><br><span class="line"> abc</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 4.-c参数能统计出文件中每行内容重复的次数</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat file.txt |sort|uniq -c</span></span><br><span class="line">  2 123</span><br><span class="line">  2 abc</span><br></pre></td></tr></table></figure>

<h2 id="3、cut-命令"><a href="#3、cut-命令" class="headerlink" title="3、cut 命令"></a>3、cut 命令</h2><ul>
<li>cut命令用来显示行中的指定部分，删除文件中指定字段</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cut [参数] [操作对象]</span><br><span class="line"> 参数：</span><br><span class="line">  -d <span class="comment"># 指定分隔符</span></span><br><span class="line">  -f <span class="comment"># 指定显示的列；几列的内容，取第几列，-f3,6三列和六列</span></span><br><span class="line">  -c <span class="comment"># 按字符取（空格也算）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#echo &quot;Im xlw, is QQ 552408925&quot; &gt;file.txt   #过滤出文件里 xlw以及552408925</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#实现上述题目几种思路</span></span><br><span class="line"><span class="comment"># cut -d &quot; &quot; -f2,5 file.txt</span></span><br><span class="line"><span class="comment"># cut -d &quot; &quot; -f2,5 file.txt |sed &#x27;s#,##g&#x27;</span></span><br><span class="line"><span class="comment"># sed &#x27;s#,# #g&#x27; file.txt | awk -F &quot; &quot; &#x27;&#123;print $2 &quot; &quot; $5&#125;&#x27;</span></span><br><span class="line"><span class="comment"># awk  &#x27;&#123;print $2,$5&#125;&#x27; file.txt |awk -F &#x27;,&#x27; &#x27;&#123;print $1,$2&#125;&#x27;</span></span><br><span class="line"><span class="comment"># awk -F  &quot;[, ]&quot; &#x27;&#123;print $2,$6&#125;&#x27; file.txt</span></span><br><span class="line"><span class="comment"># awk -F &#x27;[, ]+&#x27; &#x27;&#123;print $2,$5&#125;&#x27; file.txt</span></span><br></pre></td></tr></table></figure>

<h2 id="4、tr命令"><a href="#4、tr命令" class="headerlink" title="4、tr命令"></a>4、tr命令</h2><ul>
<li>tr可以用来删除一段信息当中的文字，或是进行文字信息的替换</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tr  [参数]  [操作对象]</span><br><span class="line">参数：</span><br><span class="line">  -d <span class="comment"># 删除字符</span></span><br><span class="line">  -s <span class="comment"># 替换重复的字符</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># cat /etc/passwd | tr &quot;root&quot; &quot;ROOT&quot;</span></span><br><span class="line"> ROOT:x:0:0:ROOT:/ROOT:/bin/bash</span><br></pre></td></tr></table></figure>

<h2 id="5、wc命令"><a href="#5、wc命令" class="headerlink" title="5、wc命令"></a>5、wc命令</h2><ul>
<li>统计，计算数字</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wc  [参数]  [操作对象]</span><br><span class="line"> 参数：</span><br><span class="line">  -c <span class="comment"># 统计文件的Bytes数</span></span><br><span class="line">  -l <span class="comment"># 统计文件的行数</span></span><br><span class="line">  -w <span class="comment"># 统计文件中单词的个数，默认以空白字符做为分隔符</span></span><br><span class="line"></span><br><span class="line">注：在Linux系统中，一段连续的数字或字母组合为一个词。</span><br><span class="line"></span><br><span class="line"><span class="comment"># wc -l /etc/fstab      #统计/etc/fstab文件有多少行</span></span><br><span class="line"><span class="comment"># wc -l /etc/services   #统计/etc/services 文件行号</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#扩展方法</span></span><br><span class="line"><span class="comment"># grep -n &quot;.*&quot; /etc/services  | tail -1</span></span><br><span class="line"><span class="comment"># awk &#x27;&#123;print NR $0&#125;&#x27; /etc/services | tail -1</span></span><br><span class="line"><span class="comment"># cat -n /etc/services  | tail -1</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux命令总结</title>
    <url>/51ea15a6.html</url>
    <content><![CDATA[<h2 id="帮助相关"><a href="#帮助相关" class="headerlink" title="帮助相关"></a>帮助相关</h2><span id="more"></span>
<ul>
<li>man  查看普通命令的帮助</li>
<li>help  查看内置命令的帮助</li>
<li>info  查看一个命令更多的信息</li>
</ul>
<h2 id="关机重启"><a href="#关机重启" class="headerlink" title="关机重启"></a>关机重启</h2><ul>
<li>shutdown  关机重启<ul>
<li>-r （reboot）重启</li>
<li>-h （halt）关机</li>
</ul>
</li>
<li>halt  关机cpu停止工作</li>
<li>poweroff  关机断电</li>
<li>init  切换运行级别<ul>
<li>init 0  关机</li>
<li>init 6  重启</li>
</ul>
</li>
<li>reboot  重启</li>
<li>systemctl<ul>
<li>reboot  重启</li>
<li>poweroff  关机</li>
</ul>
</li>
<li>sync  把数据从buffer写回磁盘</li>
</ul>
<h2 id="目录相关"><a href="#目录相关" class="headerlink" title="目录相关"></a>目录相关</h2><ul>
<li><p>pwd  打印工作目录</p>
</li>
<li><p>cd  切换工作目录</p>
<ul>
<li><p>-上一次所在目录</p>
</li>
<li><p>.  当前目录</p>
</li>
<li><p>..  上级目录d</p>
</li>
<li><p>~  用户家目录</p>
</li>
</ul>
</li>
<li><p>tree  以树形结构显示目录或文件</p>
<ul>
<li><p>-L （level）指定层数</p>
</li>
<li><p>-d  只显示目录</p>
</li>
</ul>
</li>
<li><p>mkdir  创建目录</p>
<ul>
<li>-p  递归创建目录</li>
</ul>
</li>
<li><p>ls   显示目录下的内容</p>
<ul>
<li><p>-l （long）长格式显示文件属性*</p>
</li>
<li><p>-a  显示所有文件，包含隐藏文件*</p>
</li>
<li><p>-d  只显示目录本身内容*</p>
</li>
<li><p>-i  显示inode节点*</p>
</li>
<li><p>-h （human）人类可读形式显示</p>
</li>
<li><p>-p  目录结尾加斜线，区分目录和文件</p>
</li>
<li><p>-F  不同文件结尾加不同标识，目录结尾加斜线</p>
</li>
<li><p>–color=auto  显示不同文件的颜色</p>
</li>
<li><p>–time-style  显示修改时间的格式</p>
<ul>
<li><p>long-iso  年月日时分</p>
</li>
<li><p>iso  月日时分</p>
</li>
</ul>
</li>
<li><p>-r （reverse）反转排序</p>
</li>
<li><p>-t  按修改时间排序</p>
</li>
</ul>
</li>
<li><p>cp  拷贝  -copy  files  and  directories</p>
<pre><code>            拷贝   文件   和     目录
</code></pre>
<ul>
<li>-r  复制目录</li>
<li>-p  保持文件或目录属性  (属主，属组，所属用户)</li>
<li>-a  相当于dpr</li>
<li>-i  是否覆盖确认</li>
<li>-d  保持文件中软连接的属性</li>
</ul>
</li>
<li><p>rm  删除文件或目录</p>
<ul>
<li>-f  强制删除</li>
<li>-r  递归删除</li>
</ul>
</li>
<li><p>mv  移动文件或目录或改名</p>
</li>
</ul>
<h2 id="文件内容"><a href="#文件内容" class="headerlink" title="文件内容"></a>文件内容</h2><ul>
<li>touch  创建文件或更新文件时间戳</li>
<li>vi/vim  文本编辑器</li>
<li>echo  显示输出文本内容<ul>
<li>-n  不换行输出</li>
<li>-e  支持转义字符输出</li>
</ul>
</li>
<li>printf  格式化打印字符串</li>
<li>cat  查看文件内容<ul>
<li>-n  显示行号</li>
</ul>
</li>
<li>tac  按行翻转文件内容</li>
<li>rev  左右按字符翻转行的内容</li>
<li>more  分页查看文件内容</li>
<li>less  分页查看文件内容<ul>
<li>-N  显示行号</li>
</ul>
</li>
<li>head  显示文件内容头部<ul>
<li>-n  前n行  n可省</li>
</ul>
</li>
<li>tail  显示文件内容尾部<ul>
<li>-n  后n行  n可省</li>
<li>-f  跟踪文件尾部的变化</li>
</ul>
</li>
<li>tr  替换或删除字符</li>
<li>cut     取列<ul>
<li>-d  指定分隔符</li>
<li>-f  指定哪列  连续多列可用-  多列可用，逗号</li>
<li>-c  按字符取内容</li>
</ul>
</li>
<li>diff  文本比较</li>
<li>vimdiff  文本图形化比较</li>
</ul>
<h2 id="文件相关"><a href="#文件相关" class="headerlink" title="文件相关"></a>文件相关</h2><ul>
<li>file  查看文件类型    </li>
<li>ln  创建<ul>
<li>-s （soft）创建软链接</li>
</ul>
</li>
<li>which  查命令所在的路径</li>
<li>whereis  查找命令，源码，帮助等路径<ul>
<li>-b  查二进制命令</li>
</ul>
</li>
<li>locate  查找文件及帮助相关，从updatedb对应的数据库里查</li>
<li>find  查找目录下的文件<ul>
<li>-name  按文件名查找</li>
<li>-type  按类型查找</li>
<li>-exec  对查找的结果在处理</li>
<li>-mtime  按修改时间查找</li>
<li>-perm  查权限</li>
<li>-size  </li>
</ul>
</li>
<li>xargs  从标准输入执行命令<ul>
<li>-n  数字，几个东西在一组</li>
<li>-d  指定分隔符，不指定默认是空格</li>
<li>-i  把{}当做前面查找的结果</li>
</ul>
</li>
<li>stat  查看文件属性<ul>
<li>-c  获取指定文件属性的一部分<ul>
<li>%A  显示字符权限</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><ul>
<li><p>id  查看用户身份</p>
</li>
<li><p>whoami  查看当前登录的用户</p>
</li>
<li><p>w  谁登陆了  干什么了</p>
</li>
<li><p>last  显示登录过的用户信息列表</p>
</li>
<li><p>lastlog  查看最近登录过的用户报告</p>
</li>
<li><p>useradd  添加普通用户</p>
<ul>
<li>-u  指定UID</li>
<li>-s  指定登录的SHELL解释器</li>
<li>-M  不创建家目录</li>
<li>-g  指定所属的组</li>
<li>-c  添加用户说明</li>
<li>-d  指定家目录</li>
<li>-e  设定登录截止日期</li>
</ul>
</li>
<li><p>userdel  删除用户</p>
<ul>
<li><p>-r  递归删除用户目录及下面内容</p>
<p>​    备份或确认家目录下无有用内容</p>
</li>
</ul>
</li>
<li><p>usermod修改用户属性</p>
<ul>
<li>-u  指定UID</li>
<li>-s  指定登录的SHELL解释器</li>
<li>-M  不创建家目录</li>
<li>-g  指定所属的组</li>
<li>-c  添加用户说明</li>
<li>-d  指定家目录</li>
<li>-e  设定登录截止日期</li>
</ul>
</li>
<li><p>passwd 修改密码</p>
<ul>
<li>–stdin  从标准输入接收密码并设置</li>
</ul>
</li>
<li><p>chpasswd  从标准输入批量更改用户密码</p>
</li>
<li><p>groupadd 添加用户组</p>
<ul>
<li>-g  指定组id</li>
</ul>
</li>
<li><p>groupdel  删除用户组</p>
</li>
<li><p>chage  查看和修改密码属性</p>
<ul>
<li>-l  list列表显示用户的密码信息</li>
<li>-E  修改账户过期时间</li>
</ul>
</li>
<li><p>su  用户身份切换</p>
<ul>
<li> -携带环境变量登录</li>
<li> -c  以指定用户身份执行命令</li>
</ul>
</li>
<li><p>sudo  允许指定用户执行某命令期间拥有root角色权限</p>
<ul>
<li>-l  查看获得的权限</li>
</ul>
</li>
<li><p>visudo  编辑sudo配置文件的命令</p>
<ul>
<li>-c  检查配置文件语法</li>
</ul>
</li>
</ul>
<h2 id="其他相关"><a href="#其他相关" class="headerlink" title="其他相关"></a>其他相关</h2><ul>
<li>date  显示系统时间和日期<ul>
<li>-s  修改时间</li>
<li>-d  指定过去或未来格式</li>
</ul>
</li>
<li>alias  查看或设置别名</li>
<li>unalias  取消别名</li>
<li>runlevel  查看运行级别</li>
<li>init  切换运行级别</li>
<li>getenforce  查看selinux状态</li>
<li>setenforce  设置selinux状态</li>
<li>md5sum  给文件设置指纹（计算和检查MD5数字信息）</li>
<li>du  文件或目录大小<ul>
<li>-s  显示总大小</li>
<li>-h  人类可读</li>
</ul>
</li>
</ul>
<h2 id="打包压缩"><a href="#打包压缩" class="headerlink" title="打包压缩"></a>打包压缩</h2><ul>
<li>tar  打包压缩<ul>
<li>-z  压缩</li>
<li>-c  创建</li>
<li>-v  输出打包过程</li>
<li>-f  文件</li>
<li>-t  查看文件</li>
<li>-C  指定解压的路径</li>
<li>-x  解压</li>
<li>-h  跟随软链接</li>
<li>–exclude  排除不打包的文件</li>
<li>-X  从文件中排除不打包的文件</li>
</ul>
</li>
</ul>
<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><ul>
<li>df  查看文件系统<ul>
<li>-i （inode）信息</li>
<li>-h  以人类可读形式查看block信息</li>
<li>-T  查看文件系统</li>
</ul>
</li>
<li>fdisk  MBR磁盘查看和分区工具（小于2T）<ul>
<li>-l  列表</li>
</ul>
</li>
<li>parted  GPT磁盘分区工具（常用于大于2T）</li>
<li>dd  创建一个虚拟文件系统</li>
<li>partprobe  将分区信息通知内核，真正生效</li>
<li>mkfs  格式化（本质创建文件系统）<ul>
<li>-t  指定类型 -t ext4（mkfs.ext4）</li>
<li>-b  指定block大小</li>
<li>-i  指定inode大小</li>
</ul>
</li>
<li>mount  挂载文件系统<ul>
<li>-t  type指定文件类型</li>
<li>-o  挂载的选项 mount -o rw，remount /</li>
<li>-a  all挂载所有磁盘</li>
</ul>
</li>
<li>umount  卸载文件系统<ul>
<li>-lf  强制卸载</li>
</ul>
</li>
<li>blkid  查看块设备属性（UUID,FSTYPE）</li>
<li>dumpe2fs  查看ext文件系统细节</li>
<li>fsck  检查和修复ext文件系统（好的磁盘不能操作），类似e2fsck<ul>
<li>-a  修复磁盘</li>
</ul>
</li>
<li>xfs_info (xfs_一堆) 查看xfs文件系统细节</li>
<li>xfs_repair  检查和修复xfs文件系统</li>
</ul>
<h2 id="三剑客"><a href="#三剑客" class="headerlink" title="三剑客"></a>三剑客</h2><ul>
<li>grep  过滤<ul>
<li>–color=auto  过滤的内容加色</li>
<li>-v （invert）取反</li>
<li>-i （ignore 忽略）不区分大小写</li>
<li>-n （number 数字）对输出的内容显示在源文件中的行号      显示行号</li>
<li>-w （word）按单词为单位过滤</li>
<li>-o  只输出匹配的内容</li>
<li>-E （extend）扩展的grep，即egrep</li>
<li>-A （after）显示过滤的字符串和它之后的多少行</li>
<li>-B （before）显示过滤的字符串和它之前的多少行</li>
<li>-C （context）显示过滤的字符串和它之前之后的多少行</li>
<li>-p  用于过滤Perl兼容正则表达式</li>
</ul>
</li>
<li>sed  流编辑器<ul>
<li>参数<ul>
<li>-n  取消命令的默认输出</li>
<li>-i  直接修改文件内容，而不是输出到终端</li>
<li>-r  支持扩展正则</li>
</ul>
</li>
<li>sed的内置命令字符说明<ul>
<li>s：替换</li>
<li>g：全局</li>
<li>p：打印</li>
<li>d：删除</li>
<li>a：追加</li>
<li>i：插入</li>
</ul>
</li>
</ul>
</li>
<li>awk  是命令操作也可以作为编程语言，处理字符串<ul>
<li>-F  指定分隔符</li>
<li>列表示：$1第一列 $2第二列  以此类推……</li>
<li>$0  整行</li>
<li>$NF  最后一列</li>
<li>$（NF-1）倒数第二列</li>
<li>NR  行号</li>
</ul>
</li>
</ul>
<h2 id="文件属性"><a href="#文件属性" class="headerlink" title="文件属性"></a>文件属性</h2><ul>
<li>chmod 修改文件权限<ul>
<li>-R 递归修改</li>
</ul>
</li>
<li>chown 改变文件用户和组<ul>
<li>-R 递归修改</li>
</ul>
</li>
<li>chgrp 修改用户组</li>
<li>chattr  设置文件属性<ul>
<li>+i  锁定文件</li>
<li>-i  解锁文件</li>
<li>+a  只能追加不能删除文件和内容</li>
<li>-a  解锁</li>
</ul>
</li>
<li>lsattr  查看文件属性</li>
</ul>
<h2 id="网络服务命令"><a href="#网络服务命令" class="headerlink" title="网络服务命令"></a>网络服务命令</h2><ul>
<li>定时任务<ul>
<li>crontab<ul>
<li>-l 列表</li>
<li>-e 编辑定时任务</li>
<li>-u 查看特定用户下的定时任务</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><ul>
<li>rpm  包管理器<br>安装，卸载，升级，查询和验证<ul>
<li>-i  安装install</li>
<li>-v  显示安装过程</li>
<li>-h  用“#”显示安装进度条</li>
<li>-U  升级软件包</li>
<li>-e  卸载软件包</li>
<li>–nodeps  忽略依赖</li>
<li>-q  查询</li>
<li>-a  所有</li>
<li>-l  显示软件包中的所有文件列表</li>
<li>-f  查询文件或命令属于哪个软件包</li>
</ul>
</li>
<li>yum  安装rpm包自动解决依赖工具<ul>
<li>install  安装软件包</li>
<li>list  获取软件包名</li>
<li>search 模糊查找软件包名</li>
<li>groupinstall  安装组包</li>
<li>grouplist  获取组包名称列表</li>
<li>list installed  查已安装软件</li>
<li>provides  根据命令配置查软件包</li>
<li>remove  移除软件包（禁止使用）</li>
<li>repolist  列出启用的yum源</li>
<li>repolist all  列出所有yum，包括禁用的yum源也列出</li>
</ul>
</li>
</ul>
<h2 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h2><ul>
<li>ifconfig  查看设置IP</li>
<li>ip  查看和设置网络和IP</li>
<li>ping  检查网络是否通畅</li>
<li>traceroute  查看到达主机的网络路由信息<ul>
<li>-d  不做反向解析</li>
</ul>
</li>
<li>route  查看设置网关、路由</li>
<li>-host主机路由  -net网络路由  默认网关default gw<ul>
<li>add  添加</li>
<li>del  删除</li>
</ul>
</li>
<li>telnet  检测远程端口是否通畅</li>
<li>lsof<ul>
<li>-d  </li>
<li>-i  查看端口</li>
</ul>
</li>
</ul>
<h2 id="Bash内置命令"><a href="#Bash内置命令" class="headerlink" title="Bash内置命令"></a>Bash内置命令</h2><ul>
<li>history<ul>
<li>-c  清所有</li>
<li>-d  指定数字清</li>
</ul>
</li>
<li>ulimit<ul>
<li>-n  查文件描述符大小</li>
</ul>
</li>
</ul>
<h2 id="主机命令"><a href="#主机命令" class="headerlink" title="主机命令"></a>主机命令</h2><ul>
<li>hostname  查看设置主机名</li>
<li>hostnamectl  设置主机名（C7）</li>
<li>hostname  修改主机名</li>
<li>hostnamectl  CentOS7永久修改主机名</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统优化及定时任务</title>
    <url>/c3540fc.html</url>
    <content><![CDATA[<h1 id="系统安全优化"><a href="#系统安全优化" class="headerlink" title="系统安全优化"></a>系统安全优化</h1><h2 id="关闭-selinux-安全服务"><a href="#关闭-selinux-安全服务" class="headerlink" title="关闭 selinux 安全服务"></a>关闭 selinux 安全服务</h2><p> selinux（Security-Enhanced Linux）是美国国家安全局（NSA）对于强制访问控制的实现，这个功能让系统管理员又爱又恨，这里我们还是把它给关闭了吧，至于安全问题，后面通过其他手段来解决，这也是大多数生产环境的做法，如果非要开启也是可以的。</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#临时关闭</span></span><br><span class="line">[root@localhost ~]<span class="comment"># setenforce  0</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#永久关闭,修改完配置后重启主机</span></span><br><span class="line">[root@localhost ~]<span class="comment"># sed &#x27;s#SELINUX=enforcing#SELINUX=disabled#g&#x27; /etc/selinux/config</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#检查结果</span></span><br><span class="line">[root@localhost ~]<span class="comment"># grep &quot;disabled&quot; /etc/selinux/config</span></span><br></pre></td></tr></table></figure>

<h2 id="关闭-firewalld-防火墙"><a href="#关闭-firewalld-防火墙" class="headerlink" title="关闭 firewalld 防火墙"></a>关闭 firewalld 防火墙</h2><p>  关闭防火墙的目的是为了让初学者学习更方便，将来在学了firewalld技术后可再统一开启。 在企业环境中，<br>  一般只有配置外网IP的linux服务器才需要开启防火墙，但即使是有外网IP，对于高并发高流量的业务服务器<br>  仍是不能开的，因为会有较大性能损失，导致网站访问很慢，这种情况下只能在前端加更好的硬件防火墙了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 临时关闭</span></span><br><span class="line">[root@egon ~]<span class="comment"># systemctl stop firewalld</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 设置开机不启动</span></span><br><span class="line">[root@egon ~]<span class="comment"># systemctl disable firewalld</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">系统优化脚本命令：</span><br><span class="line">yum install wget -y &amp;&amp; wget https://daima.baim0.xyz/init.sh &amp;&amp; chmod +x init.sh &amp;&amp; ./init.sh</span><br><span class="line"></span><br><span class="line">脚本优化内容：</span><br><span class="line"></span><br><span class="line">  删除初始源</span><br><span class="line">  阿里centos7源</span><br><span class="line">  阿里epel源</span><br><span class="line">  nginx官方stable源</span><br><span class="line">  清除缓存</span><br><span class="line">  建立新缓存</span><br><span class="line">  更新软件</span><br><span class="line">  安装常用软件</span><br><span class="line">  关闭selinux</span><br><span class="line">  关闭防火墙</span><br><span class="line">  系统参数优化</span><br><span class="line">  ssh优化</span><br><span class="line">  关闭不常用的东西</span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/image-20211221164241000.png" alt="image-20211221164241000"></p>
<h1 id="防止系统乱码优化"><a href="#防止系统乱码优化" class="headerlink" title="防止系统乱码优化"></a>防止系统乱码优化</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">en_US.UTF-8		: 美式英文，utf-8</span><br><span class="line">zh_CN.UTF-8</span><br><span class="line">zh_HK.UTF-8</span><br><span class="line"><span class="comment"># 查看当前使用的系统语言</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># echo $LANG</span></span><br><span class="line">  zh_CN.UTF-8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看安装的语言包</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># locale</span></span><br><span class="line">  LANG=zh_CN.UTF-8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 临时优化</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># export LANG=zh_CN.UTF-8  #设置编码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 永久优化</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># vim /etc/locale.conf </span></span><br><span class="line">  LANG=<span class="string">&quot;zh_CN.UTF-8&quot;</span>  <span class="comment">#将原来的配置内容修改，注销或重启后，中文的语言环境。</span></span><br></pre></td></tr></table></figure>



<h1 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h1><h2 id="计划任务基本概述"><a href="#计划任务基本概述" class="headerlink" title="计划任务基本概述"></a>计划任务基本概述</h2><h4 id="1-什么是crond"><a href="#1-什么是crond" class="headerlink" title="1.什么是crond"></a>1.什么是crond</h4><ul>
<li>crond就是计划任务，类似于我们平时生活中的闹钟。定点执行。</li>
</ul>
<h4 id="2-为什么要使用crond"><a href="#2-为什么要使用crond" class="headerlink" title="2.为什么要使用crond"></a>2.为什么要使用crond</h4><ul>
<li>crond主要是做一些周期性的任务，比如: 凌晨3点定时备份数据。比如：11点开启网站抢购接口，12点关闭网站抢购接口。</li>
</ul>
<h4 id="3-计划任务主要分为以下两种使用情况"><a href="#3-计划任务主要分为以下两种使用情况" class="headerlink" title="3.计划任务主要分为以下两种使用情况:"></a>3.计划任务主要分为以下两种使用情况:</h4><ul>
<li>1.系统级别的定时任务： 临时文件清理、系统信息采集、日志文件切割</li>
<li>2.用户级别的定时任务： 定时向互联网同步时间、定时备份系统配置文件、定时备份数据库的数据</li>
</ul>
<h2 id="计划任务时间管理"><a href="#计划任务时间管理" class="headerlink" title="计划任务时间管理"></a>计划任务时间管理</h2><h4 id="1-Crontab配置文件记录了时间周期的含义"><a href="#1-Crontab配置文件记录了时间周期的含义" class="headerlink" title="1.Crontab配置文件记录了时间周期的含义"></a>1.Crontab配置文件记录了时间周期的含义</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># vim /etc/crontab</span></span><br><span class="line">SHELL=/bin/bash                     <span class="comment">#执行命令的解释器</span></span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin  <span class="comment">#环境变量</span></span><br><span class="line">MAILTO=root                         <span class="comment">#邮件发给谁</span></span><br><span class="line"><span class="comment"># Example of job definition:</span></span><br><span class="line"><span class="comment"># .---------------- minute (0 - 59) #分钟</span></span><br><span class="line"><span class="comment"># |  .------------- hour (0 - 23)   #小时</span></span><br><span class="line"><span class="comment"># |  |  .---------- day of month (1 - 31)   #日期</span></span><br><span class="line"><span class="comment"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr #月份</span></span><br><span class="line"><span class="comment"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat  #星期</span></span><br><span class="line"><span class="comment"># |  |  |  |  |</span></span><br><span class="line"><span class="comment"># *  *  *  *  *   command to be executed</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># *  表示任意的(分、时、日、月、周)时间都执行</span></span><br><span class="line"><span class="comment"># -  表示一个时间范围段, 如5-7点</span></span><br><span class="line"><span class="comment"># ,  表示分隔时段, 如6,0,4表示周六、日、四</span></span><br><span class="line"><span class="comment"># /1 表示每隔n单位时间, 如*/10 每10分钟</span></span><br></pre></td></tr></table></figure>

<h4 id="2-了解crontab的时间编写规范"><a href="#2-了解crontab的时间编写规范" class="headerlink" title="2.了解crontab的时间编写规范"></a>2.了解crontab的时间编写规范</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">00 02 * * * ls      <span class="comment">#每天的凌晨2点整执行</span></span><br><span class="line">00 02 1 * * ls      <span class="comment">#每月的1日的凌晨2点整执行</span></span><br><span class="line">00 02 14 2 * ls     <span class="comment">#每年的2月14日凌晨2点执行</span></span><br><span class="line">00 02 * * 7 ls      <span class="comment">#每周天的凌晨2点整执行</span></span><br><span class="line">00 02 * 6 5 ls      <span class="comment">#每年的6月周五凌晨2点执行</span></span><br><span class="line">00 02 14 * 7 ls     <span class="comment">#每月14日或每周日的凌晨2点都执行</span></span><br><span class="line">00 02 14 2 7 ls     <span class="comment">#每年的2月14日或每年2月的周天的凌晨2点执行   </span></span><br><span class="line">*/10  02 * * * ls   <span class="comment">#每天凌晨2点，每隔10分钟执行一次</span></span><br><span class="line">* * * * *  ls       <span class="comment">#每分钟都执行</span></span><br><span class="line">00 00 14 2 *  ls    <span class="comment">#每年2月14日的凌晨执行命令 </span></span><br><span class="line">*/5 * * * *  ls     <span class="comment">#每隔5分钟执行一次</span></span><br><span class="line">00 02 * 1,5,8 * ls  <span class="comment">#每年的1月5月8月凌晨2点执行</span></span><br><span class="line">00 02 1-8 * *  ls    <span class="comment">#每月1号到8号凌晨2点执行</span></span><br><span class="line">0 21 * * * ls       <span class="comment">#每天晚上21:00执行</span></span><br><span class="line">45 4 1,10,22 * * ls <span class="comment">#每月1、10、22日的4:45执行</span></span><br><span class="line">45 4 1-10 * * l     <span class="comment">#每月1到10日的4:45执行</span></span><br><span class="line">3,15 8-11 */2 * * ls <span class="comment">#每隔两天的上午8点到11点的第3和第15分钟执行</span></span><br><span class="line">0 23-7/1 * * * ls   <span class="comment">#晚上11点到早上7点之间，每隔一小时执行</span></span><br><span class="line">15 21 * * 1-5 ls    <span class="comment">#周一到周五每天晚上21:15执行</span></span><br></pre></td></tr></table></figure>

<h4 id="3-使用crontab编写cron定时任务"><a href="#3-使用crontab编写cron定时任务" class="headerlink" title="3.使用crontab编写cron定时任务"></a>3.使用crontab编写cron定时任务</h4><table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-e</td>
<td align="left">编辑定时任务</td>
</tr>
<tr>
<td align="left">-l</td>
<td align="left">查看定时任务</td>
</tr>
<tr>
<td align="left">-r</td>
<td align="left">删除定时任务</td>
</tr>
<tr>
<td align="left">-u</td>
<td align="left">指定其他用户</td>
</tr>
</tbody></table>
<h2 id="计划任务编写实践"><a href="#计划任务编写实践" class="headerlink" title="计划任务编写实践"></a>计划任务编写实践</h2><h4 id="1-使用root用户每5分钟执行一次时间同步"><a href="#1-使用root用户每5分钟执行一次时间同步" class="headerlink" title="1.使用root用户每5分钟执行一次时间同步"></a>1.使用root用户每5分钟执行一次时间同步</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.如何同步时间</span></span><br><span class="line">[root@localhost ~]<span class="comment"># ntpdate time.windows.com &amp;&gt;/dev/null</span></span><br><span class="line"><span class="comment">#2.配置定时任务</span></span><br><span class="line">[root@localhost ~]<span class="comment"># crontab -e -u root</span></span><br><span class="line">[root@localhost ~]<span class="comment">#  crontab -l -u root</span></span><br><span class="line">*/5 * * * * ntpdate time.windows.com &amp;&gt;/dev/null</span><br></pre></td></tr></table></figure>

<h4 id="2-每天的下午3-5点，每隔半小时执行一次sync命令"><a href="#2-每天的下午3-5点，每隔半小时执行一次sync命令" class="headerlink" title="2.每天的下午3,5点，每隔半小时执行一次sync命令"></a>2.每天的下午3,5点，每隔半小时执行一次sync命令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># crontab -l</span></span><br><span class="line">*/30 15,17 * * * sync &amp;&gt;/dev/null</span><br></pre></td></tr></table></figure>

<h4 id="3-案例：每天凌晨3点做一次备份？备份-etc-目录到-backup下面"><a href="#3-案例：每天凌晨3点做一次备份？备份-etc-目录到-backup下面" class="headerlink" title="3.案例：每天凌晨3点做一次备份？备份/etc/目录到/backup下面"></a>3.案例：每天凌晨3点做一次备份？备份/etc/目录到/backup下面</h4><p>\1) 将备份命令写入一个脚本中</p>
<p>\2) 每天备份文件名要求格式: 2019-05-01_hostname_etc.tar.gz</p>
<p>\3) 在执行计划任务时，不要输出任务信息</p>
<p>\4) 存放备份内容的目录要求只保留三天的数据*</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.实现如上备份需求</span></span><br><span class="line">[root@localhost ~]<span class="comment"># mkdir /backup</span></span><br><span class="line">[root@localhost ~]<span class="comment"># tar zcf $(date +%F)_$(hostname)_etc.tar.gz /etc</span></span><br><span class="line">[root@localhost ~]<span class="comment"># find /backup -name “*.tar.gz” -mtime +3 -exec rm -f &#123;&#125;\;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.将命令写入至一个文件中</span></span><br><span class="line">[root@localhost ~]<span class="comment"># vim /root/back.sh</span></span><br><span class="line">mkdir /backup</span><br><span class="line">tar zcf $(date +%F)_$(hostname)_etc.tar.gz /etc</span><br><span class="line">find /backup -name “*.tar.gz” -mtime +3 -<span class="built_in">exec</span> rm -f &#123;&#125;\;</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.配置定时任务</span></span><br><span class="line">[root@localhost ~]<span class="comment"># crontab -l</span></span><br><span class="line">00 03 * * * bash /root/back.sh  &amp;&gt;/dev/null</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.备份脚本</span></span><br></pre></td></tr></table></figure>

<h4 id="4-crond注意的事项"><a href="#4-crond注意的事项" class="headerlink" title="4.crond注意的事项"></a>4.crond注意的事项</h4><p>\1) 给定时任务注释</p>
<p>\2) 将需要定期执行的任务写入Shell脚本中，避免直接使用命令无法执行的情况tar date</p>
<p>\3) 定时任务的结尾一定要有&amp;&gt;/dev/null或者将结果追加重定向&gt;&gt;/tmp/date.log文件</p>
<p>\4) 注意有些命令是无法成功执行的 echo “123” &gt;&gt;/tmp/test.log &amp;&gt;/dev/null</p>
<p><strong>如果一定要是用命令，命令必须使用绝对路径</strong></p>
<h4 id="5-crond如何备份"><a href="#5-crond如何备份" class="headerlink" title="5.crond如何备份"></a>5.crond如何备份</h4><p>\1) 通过查找/var/log/cron中执行的记录，去推算任务执行的时间</p>
<p>\2) 定时的备份/var/spool/cron/{usernmae}*</p>
<h4 id="6-crond如何拒绝某个用户使用"><a href="#6-crond如何拒绝某个用户使用" class="headerlink" title="6.crond如何拒绝某个用户使用"></a>6.crond如何拒绝某个用户使用</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1.使用root将需要拒绝的用户加入/etc/cron.deny</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo &quot;xuliangwei&quot; &gt;&gt; /etc/cron.deny</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.登陆该普通用户，测试是否能编写定时任务</span></span><br><span class="line">[<span class="built_in">test</span>@localhost ~]$ crontab -e</span><br><span class="line">You (<span class="built_in">test</span>) are not allowed to use this program (crontab)</span><br><span class="line">See crontab(1) <span class="keyword">for</span> more information</span><br></pre></td></tr></table></figure>

<h2 id="计划任务如何调试"><a href="#计划任务如何调试" class="headerlink" title="计划任务如何调试"></a>计划任务如何调试</h2><h4 id="1-crond调试"><a href="#1-crond调试" class="headerlink" title="1.crond调试"></a>1.crond调试</h4><p>\1) 调整任务每分钟执行的频率, 以便做后续的调试。</p>
<p>\2) 如果使用cron运行脚本，请将脚本执行的结果写入指定日志文件, 观察日志内容是否正常。</p>
<p>\3) 命令使用绝对路径, 防止无法找到命令导致定时任务执行产生故障。</p>
<p>\4) 通过查看/var/log/cron日志，以便检查我们执行的结果，方便进行调试。</p>
<h4 id="2-crond编写思路"><a href="#2-crond编写思路" class="headerlink" title="2.crond编写思路"></a>2.crond编写思路</h4><ul>
<li>1.手动执行命令，然后保留执行成功的结果。</li>
<li>2.编写脚本<ul>
<li>脚本需要统一路径/scripts</li>
<li>脚本内容复制执行成功的命令(减少每个环节出错几率)</li>
<li>脚本内容尽可能的优化, 使用一些变量或使用简单的判断语句</li>
<li>脚本执行的输出信息可以重定向至其他位置保留或写入/dev/null</li>
</ul>
</li>
<li>3.执行脚本<ul>
<li>使用bash命令执行, 防止脚本没有增加执行权限(/usr/bin/bash)</li>
<li>执行脚本成功后，复制该执行的命令，以便写入cron</li>
</ul>
</li>
<li>4.编写计划任务<ul>
<li>加上必要的注释信息, 人、时间、任务</li>
<li>设定计划任务执行的周期</li>
<li>粘贴执行脚本的命令(不要手敲)</li>
</ul>
</li>
<li>5.调试计划任务<ul>
<li>增加任务频率测试</li>
<li>检查环境变量问题</li>
<li>检查crond服务日志</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux包管理及压缩命令</title>
    <url>/891d6bd.html</url>
    <content><![CDATA[<h1 id="Linux中安装软件的三种方式"><a href="#Linux中安装软件的三种方式" class="headerlink" title="Linux中安装软件的三种方式"></a>Linux中安装软件的三种方式</h1><p>与windows类似，在Linux系统上也可以安装各种应用程序，或称之为软件包</p>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.rpm安装</span><br><span class="line">   rpm安装预先编译打包，安装简单，下载下来之后直接安装。</span><br><span class="line">   优点：已经制作好的安装程序</span><br><span class="line">	 缺点：不能自己解决依赖</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">2.yum安装</span><br><span class="line">   yum安装基于rpm安装</span><br><span class="line">   优点：增加了自动解决依赖的功能。</span><br><span class="line">	</span><br><span class="line">  </span><br><span class="line">3.源代码编译安装</span><br><span class="line">   源代码安装通过编译源代码，得到软件包。</span><br><span class="line">   优点：可以自定制软件包。</span><br><span class="line">   缺点：比较复杂   </span><br></pre></td></tr></table></figure>

<h2 id="镜像文件"><a href="#镜像文件" class="headerlink" title="镜像文件"></a>镜像文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 挂载：</span></span><br><span class="line">  mount /dev/sr0 /opt/</span><br><span class="line">  或</span><br><span class="line">  mount /dev/cdrom /munt/</span><br><span class="line">	</span><br><span class="line"><span class="comment"># 卸载：</span></span><br><span class="line">  umount /dev/sr0  <span class="comment">#挂载源</span></span><br><span class="line">  或</span><br><span class="line">  umount /opt  <span class="comment">#挂载点</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制卸载：</span></span><br><span class="line">  umount -l  [挂载源或挂载点]</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 查看挂载信息</span></span><br><span class="line">  df</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看/操作设备内容需要先挂载</span></span><br><span class="line">[root@localhost dev]<span class="comment"># mount /dev/sr0 /opt/</span></span><br><span class="line"> mount: /dev/sr0 写保护，将以只读方式挂载</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看是否挂载成功</span></span><br><span class="line">[root@localhost ~]<span class="comment"># df</span></span><br><span class="line"> 文件系统     1K-块    已用     可用 已用% 挂载点</span><br><span class="line"> /dev/sr0   4480476  4480476   0  100% /opt</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 浏览光盘内容</span></span><br><span class="line">[root@localhost dev]<span class="comment"># ls /opt/  </span></span><br><span class="line"> CentOS_BuildTag  EULA  images    LiveOS repodata     RPM-GPG-KEY-CentOS-Testing-7</span><br><span class="line"> EFI              GPL   isolinux  Packages  RPM-GPG-KEY-CentOS-7  TRANS.TBL</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看光盘上的安装包。格式都是以.rpm结尾的</span></span><br><span class="line">[root@localhost dev]<span class="comment"># ls /opt/Packages/</span></span><br><span class="line"> ......</span><br><span class="line"> zlib-1.2.7-18.el7.x86_64.rpm</span><br><span class="line"> zlib-devel-1.2.7-18.el7.x86_64.rpm</span><br><span class="line"> zsh-5.0.2-31.el7.x86_64.rpm</span><br><span class="line"> zziplib-0.13.62-9.el7.x86_64.rpm</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看自己当前平台</span></span><br><span class="line">[root@localhost ~]<span class="comment"># uname -m</span></span><br><span class="line"> x86_64</span><br><span class="line"><span class="comment"># 查看系统内核信息</span></span><br><span class="line">[root@localhost ~]<span class="comment"># uname -r</span></span><br><span class="line"> 3.10.0-1160.49.1.el7.x86_64</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="1、RPM安装"><a href="#1、RPM安装" class="headerlink" title="1、RPM安装"></a>1、RPM安装</h2><ul>
<li>rpm包来源 <ul>
<li>1、来源网络下载 </li>
<li>2、来源本地：自己的镜像自带的rpm包</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装：rpm -ivh [软件包名称]</span></span><br><span class="line">   -v  <span class="comment">#显示安装过程</span></span><br><span class="line">   -i  <span class="comment">#显示安装包的详细信息</span></span><br><span class="line">   -h  <span class="comment">#安装包哈希标记</span></span><br><span class="line">	</span><br><span class="line"><span class="comment"># 卸载：rpm -e [软件包名称]</span></span><br><span class="line"><span class="comment"># 升级：rpm -Uvh [软件包名称]</span></span><br><span class="line"></span><br><span class="line"> 1、下载安装包</span><br><span class="line">		</span><br><span class="line"> 2、安装</span><br><span class="line">  [root@localhost ~]<span class="comment"># rpm -qip /opt/Packages/zsh-5.0.2-34.el7_8.2.x86_64.rpm  #本地镜像</span></span><br><span class="line">  或</span><br><span class="line">  [root@localhost ~]<span class="comment"># rpm -ivh zsh-5.0.2-34.el7_8.2.x86_64.rpm </span></span><br><span class="line">  Preparing...                    <span class="comment">################################# [100%]</span></span><br><span class="line">  Updating / installing...</span><br><span class="line">  1:zsh-5.0.2-34.el7_8.2          <span class="comment">################################# [100%]</span></span><br><span class="line">	 </span><br><span class="line">	</span><br><span class="line"> 3、卸载</span><br><span class="line">	[root@localhost ~]<span class="comment"># rpm -e zsh</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"> 4、更新</span><br><span class="line">  [root@localhost ~]<span class="comment"># rpm -Uvh zsh-5.0.2-34.el7_8.2.x86_64.rpm </span></span><br><span class="line">  Preparing...                   <span class="comment">################################# [100%]</span></span><br><span class="line">  Updating / installing...</span><br><span class="line">  1:zsh-5.0.2-34.el7_8.2         <span class="comment">################################# [100%]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 5、软件包名称</span><br><span class="line">  zsh-5.0.2-34.el7_8.2.x86_64.rpm </span><br><span class="line">   zsh    <span class="comment">#软件包名称</span></span><br><span class="line">   5.0.2  <span class="comment">#版本号</span></span><br><span class="line">   34     <span class="comment">#第多少次编译</span></span><br><span class="line">   el7_8（CentOS 7）<span class="comment">#适用的平台</span></span><br><span class="line">   x86_64 <span class="comment">#适用的系统位数</span></span><br><span class="line">   rpm    <span class="comment">#扩展名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> 6、查看已安装软件包的使用配置文件</span><br><span class="line">   [root@localhost ~]<span class="comment"># rpm -qc  zsh</span></span><br><span class="line">	</span><br><span class="line"> 7、查看已安装包的描述信息	</span><br><span class="line">   [root@localhost ~]<span class="comment"># rpm -qi zsh</span></span><br><span class="line"></span><br><span class="line"> 8、查看是否安装某软件</span><br><span class="line">   [root@localhost ~]<span class="comment"># rpm -q zsh</span></span><br><span class="line"></span><br><span class="line"> 9、查看当前系统安装了哪些rpm软件</span><br><span class="line">   [root@localhost ~]<span class="comment"># rpm -qa</span></span><br><span class="line">		</span><br><span class="line"> 10、查看软件的安装路径，查看安装了哪些东西</span><br><span class="line">   [root@localhost ~]<span class="comment"># rpm -ql zsh</span></span><br><span class="line"></span><br><span class="line"> 上传与下载：yum install lrzsz -y </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">扩展：</span><br><span class="line"> 1、查看未安装包的软件信息</span><br><span class="line">   [root@localhost ~]<span class="comment"># rpm -qip /opt/Packages/snappy-1.1.0-3.el7.x86_64.rpm </span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2、yum安装"><a href="#2、yum安装" class="headerlink" title="2、yum安装"></a>2、yum安装</h2><ul>
<li>yum是CentOS的软件包管理工具，自动为我们解决软件依赖问题。yum包管理工具必须使用yum源指定软件下载地址去下载需要安装的软件包。<ul>
<li>配置的路径是：/etc/yum.repos.d</li>
</ul>
</li>
<li>要成功的使用 YUM 工具安装更新软件或系统，就需要有一个包含各种 rpm 软件包的repository（软件仓库），这个软件仓库我们习惯称为 yum 源。(可以是本地源、网络源)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">基于rpm安装，自动解决依赖。</span><br><span class="line"><span class="comment"># yum源命令:</span></span><br><span class="line">   <span class="comment"># 查看yum配置文件</span></span><br><span class="line">   [root@localhost ~]<span class="comment"># ls /etc/yum.repos.d</span></span><br><span class="line"></span><br><span class="line">   <span class="comment"># 查看当前的有哪些仓库地址</span></span><br><span class="line">   [root@localhost ~]<span class="comment"># yum repolist </span></span><br><span class="line">    </span><br><span class="line">   <span class="comment"># 查看包括启用或禁用的所有yum仓库</span></span><br><span class="line">   [root@localhost ~]<span class="comment"># yum repolist all</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment"># 清空yum缓存</span></span><br><span class="line">   [root@localhost ~]<span class="comment"># yum clean all </span></span><br><span class="line">      </span><br><span class="line">   <span class="comment"># 生成yum缓存</span></span><br><span class="line">	 [root@localhost ~]<span class="comment">#yum makecache</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment"># yum常用的基础命令： </span></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 1、安装软件包的命令</span></span><br><span class="line">   yum install [软件包的名称] 	</span><br><span class="line">   参数：</span><br><span class="line">    -y : 免交互安装</span><br><span class="line">    --nogpgcheck : 忽略公钥认证</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 2、卸载软件（直接将软件的依赖包一起删除）</span></span><br><span class="line">   yum remove [软件包名称] </span><br><span class="line">   参数：</span><br><span class="line">    -y : 免交互移除</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment"># 3、更新软件</span></span><br><span class="line">   yum update [软件包名称]   </span><br><span class="line">   参数：</span><br><span class="line">    -y : 免交互更新</span><br><span class="line">	</span><br><span class="line"> ps：如果跟具体的软件包名称，就会更新指定软件包；如果没有指定，则更新系统所有的需要更新的软件包。</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"> <span class="comment"># 4、查看当前系统需要更新软件</span></span><br><span class="line">   yum check-update	</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"> <span class="comment"># 5、重装软件</span></span><br><span class="line">   yum reinstall [软件包名称]	</span><br><span class="line">   </span><br><span class="line">	</span><br><span class="line"> <span class="comment"># 6、搜索软件包</span></span><br><span class="line">   yum search [软件包名称]	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">yum安装的生命周期：</span><br><span class="line"> 1、执行yum install zsh -y</span><br><span class="line"> 2、去 /etc/yum.repos.d/ 找以 .repo 结尾的文件</span><br><span class="line"> 3、通过 .repo 文件中的链接，找到对应的软件仓库</span><br><span class="line"> 4、在对应的软件仓库中下载指定的软件包</span><br><span class="line"> 5、缓存至 /var/cache/yum/</span><br><span class="line"> 6、根据缓存，安装软件包</span><br><span class="line"> 7、删除软件包（keepcache 是否保存缓存，0 代表不保存 ， 1 代表保存）</span><br></pre></td></tr></table></figure>

<p>知识储备：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># wget:下载文件</span></span><br><span class="line">如果系统中没有wget,执行如下命令：yum install wget -y</span><br><span class="line">  wget url</span><br><span class="line">   参数：</span><br><span class="line">    -O  <span class="comment">#指定下载文件的路径及名称</span></span><br><span class="line">		</span><br><span class="line">    </span><br><span class="line"><span class="comment"># curl:读取文件</span></span><br><span class="line">  curl ：读取文件</span><br><span class="line">   参数:</span><br><span class="line">    -o  <span class="comment">#指定下载文件的路径及名称</span></span><br><span class="line">    -k  <span class="comment">#免证书认证</span></span><br><span class="line">	</span><br><span class="line">curl命令是⼀个利⽤URL规则在命令⾏下⼯作的⽂件传输⼯具。它⽀持⽂件的上传和下载，所以是综合传输⼯具，</span><br><span class="line">但按传统，习惯称curl为下载⼯具。作为⼀款强⼒⼯具，curl⽀持包括HTTP、HTTPS、[ftp]等众多协议，还⽀</span><br><span class="line">持POST、cookies、认证、从指定偏移处下载部分⽂件、⽤户代理字符串、限速、⽂件⼤⼩、进度条等特征。做⽹</span><br><span class="line">⻚处理流程和数据检索⾃动化，curl可以祝⼀臂之⼒。</span><br><span class="line"></span><br><span class="line"> [root@localhost ~]<span class="comment"># curl -o 123.png https://www.xxx.com/img/hello.png</span></span><br><span class="line"> <span class="comment"># ps: 如果遇到下载提示⽆法简历SSL链接，使⽤-k选项或者--insecure</span></span><br><span class="line">  curl -k -o 123.png https://www.xxx.com/img/hello.png</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># sz下载文件与rz上传文件</span></span><br><span class="line"> ps:  yum install lrzsz -y</span><br><span class="line"></span><br><span class="line">sz : 下载文件（从linux系统下载文件到windows）</span><br><span class="line">系统默认没有该命令，需要下载:yum install lrzsz -y</span><br><span class="line">将服务器上选定的⽂件下载/发送到本机，</span><br><span class="line"></span><br><span class="line"><span class="comment"># rz : 上传文件(将windows文件上传至Linux)</span></span><br><span class="line"></span><br><span class="line">  rz [文件路径]</span><br><span class="line">	<span class="comment"># 系统默认没有该命令，需要下载：yum install lrzsz -y</span></span><br><span class="line">  <span class="comment"># 运⾏该命令会弹出⼀个⽂件选择窗⼝，从本地选择⽂件上传到服务器。</span></span><br><span class="line">  [root@localhost opt]<span class="comment"># rz # 如果⽂件已经存，则上传失败，可以⽤-E选项解决</span></span><br><span class="line">  [root@localhost opt]<span class="comment"># rz -E # -E如果⽬标⽂件名已经存在，则重命名传⼊⽂件。新⽂件名将添加⼀个点和⼀个数字(0..999）</span></span><br><span class="line">        </span><br><span class="line"> rz 回车即可选择上传文件</span><br><span class="line"> 也可以进入都某个路径下将文件直接拖入~ （人性化）  </span><br></pre></td></tr></table></figure>

<h3 id="本地-amp-远程仓库搭建"><a href="#本地-amp-远程仓库搭建" class="headerlink" title="本地&amp;远程仓库搭建"></a>本地&amp;远程仓库搭建</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">本地仓库：</span><br><span class="line">  <span class="comment"># 1、下载安装必须的软件包yum-utils，createrepo</span></span><br><span class="line">    yum install yum-utils createrepo -y</span><br><span class="line">		</span><br><span class="line">  <span class="comment"># 2、创建软件包目录，存放软件包的</span></span><br><span class="line">    mkdir -p /opt/repos</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 3、下载对应的软件</span></span><br><span class="line">    mkdir -p /opt/repos/Packages</span><br><span class="line">			</span><br><span class="line">    把对应的软件包复制到 Packages 目录中</span><br><span class="line">			</span><br><span class="line">  <span class="comment"># 4、初始化软件仓库</span></span><br><span class="line">		 createrepo /opt/repos</span><br><span class="line">	</span><br><span class="line">  <span class="comment"># 5、添加yum源，将软件包复制到yum仓库目录</span></span><br><span class="line">     <span class="built_in">cd</span> /etc/yum.repos.d/</span><br><span class="line">     mkdir backup</span><br><span class="line">     mv *.repo backup/</span><br><span class="line">     [root@localhost ~]<span class="comment"># yum-config-manager --add-repo=file:///opt/repos</span></span><br><span class="line"></span><br><span class="line">     [root@localhost /etc/yum.repos.d]<span class="comment"># cat opt_repos.repo </span></span><br><span class="line"></span><br><span class="line">     [opt_repos]	<span class="comment">#源的名称</span></span><br><span class="line">      name=added from: file:///opt/repos	 <span class="comment">#源的简介</span></span><br><span class="line">      baseurl=file:///opt/repos	<span class="comment">#源的下载地址</span></span><br><span class="line">      enabled=1	<span class="comment">#是否启用：1启用 ，0不启用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 6、清空yum缓存</span></span><br><span class="line">     yum clean all </span><br><span class="line">      </span><br><span class="line">  <span class="comment"># 7、生成yum缓存</span></span><br><span class="line">     yum makecache</span><br><span class="line">		</span><br><span class="line">  <span class="comment"># 8、测试</span></span><br><span class="line">     yum install zsh</span><br><span class="line">	</span><br><span class="line">	远程仓库</span><br><span class="line">		参考本地版前7步</span><br><span class="line">		</span><br><span class="line">    <span class="comment"># 1、安装远程访问软件（Nginx）</span></span><br><span class="line">      <span class="comment"># ① 配备CentOS-7 源</span></span><br><span class="line">      [root@localhost ~]<span class="comment"># curl -o /etc/yum.repos.d/CentOS-Base.repohttps://repo.huaweicloud.com/repository/conf/CentOS-7-reg.repo</span></span><br><span class="line">			<span class="comment"># ② 配备EPEL源</span></span><br><span class="line">      [root@localhost ~]<span class="comment"># yum-config-manager --add-repo=https://repo.huaweicloud.com/epel/7/x86_64/</span></span><br><span class="line">			<span class="comment"># ③ 安装nginx</span></span><br><span class="line">      [root@localhost ~]<span class="comment"># yum install nginx --nogpgcheck</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 2、修改nginx的配置文件</span></span><br><span class="line">      https://nginx.org/en/docs/http/ngx_http_autoindex_module.html</span><br><span class="line">			</span><br><span class="line">      [root@localhost ~]<span class="comment"># vim /etc/nginx/nginx.conf</span></span><br><span class="line">      <span class="comment"># include /etc/nginx/conf.d/*.conf;</span></span><br><span class="line">      root         /opt/repos;</span><br><span class="line">      autoindex on;</span><br><span class="line">			</span><br><span class="line">      <span class="comment"># 测试更改是否成功</span></span><br><span class="line">      [root@localhost ~]<span class="comment"># nginx -t</span></span><br><span class="line">			</span><br><span class="line">      <span class="comment"># 启动nginx</span></span><br><span class="line">      [root@localhost ~]<span class="comment"># systemctl start nginx</span></span><br><span class="line">			</span><br><span class="line">      <span class="comment"># 关闭selinux和firewalld</span></span><br><span class="line">      [root@localhost ~]<span class="comment"># systemctl disable --now firewalld</span></span><br><span class="line">      [root@localhost ~]<span class="comment"># setenforce 0</span></span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">    <span class="comment"># 3、在测试机</span></span><br><span class="line">      [root@localhost yum.repos.d]<span class="comment"># yum install yum-utils -y</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 备份源</span></span><br><span class="line">      [root@localhost yum.repos.d]<span class="comment"># mkdir backup</span></span><br><span class="line">      [root@localhost yum.repos.d]<span class="comment"># mv *.repo backup/</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 添加源</span></span><br><span class="line">      [root@localhost yum.repos.d]<span class="comment"># yum-config-manager --add-repo=http://192.168.15.101/</span></span><br><span class="line"></span><br><span class="line">      <span class="comment"># 刷新缓存</span></span><br><span class="line">      [root@localhost yum.repos.d]<span class="comment"># yum clean all </span></span><br><span class="line">      [root@localhost yum.repos.d]<span class="comment"># yum makecache</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 4、测试</span></span><br><span class="line">      [root@localhost ~]<span class="comment"># yum install zsh -y</span></span><br></pre></td></tr></table></figure>

<h2 id="3、源码包安装（编译安装）"><a href="#3、源码包安装（编译安装）" class="headerlink" title="3、源码包安装（编译安装）"></a>3、源码包安装（编译安装）</h2><ul>
<li><p><strong>1.源码包是什么</strong></p>
<ul>
<li>源码包指的是开发编写好的程序源代码，但并没有将其编译为一个能正常使用的工具。-</li>
</ul>
</li>
<li><p><strong>2.为什么要学习源码包</strong></p>
<ul>
<li>1、部分软件官网仅提供源码包，需要自行编译并安装。</li>
<li>2、部分软件在新版本有一些特性还没来得及制作成rpm包时，可以自行编译软件使用其新特性。</li>
</ul>
</li>
<li><p><strong>3.源码包的优缺点</strong></p>
<ul>
<li>优点是：<ul>
<li>可以自行修改源代码</li>
<li>可以定制需要的相关功能</li>
<li>新版软件优先更新源码</li>
</ul>
</li>
<li>缺点是: <ul>
<li>相对yum安装软件会复杂很多。</li>
<li>标准化实施困难，自动化就无法落地。</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>4.源码包如何获取</strong></p>
<ul>
<li>常见的软件包都可以在官网获取源码包，比如 apache、nginx、mysql等等</li>
</ul>
</li>
<li><p><strong>5.将源码包编译为二进制可执行文件步骤如下，简称安装三步曲</strong></p>
</li>
</ul>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B.png" alt="编译安装过程"></p>
<p>注意: 此方法不是百分百通用于所有源码包，建议拿到源码包解压后，进入到目录找相关的README帮助文档</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">编译安装</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、基础环境准备</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># yum install -y gcc make wget</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、下载源码包</span></span><br><span class="line">	[root@localhost ~]<span class="comment"># wget https://nginx.org/download/nginx-1.20.2.tar.gz</span></span><br><span class="line">		</span><br><span class="line"><span class="comment"># 2、解压源码包, 并进入相应目录</span></span><br><span class="line">	[root@localhost ~]<span class="comment"># tar -xf nginx-1.20.2.tar.gz</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># cd nginx-1.20.2</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 3、配置相关的选项，并生成Makefile</span></span><br><span class="line">  [root@localhost nginx-1.20.2]<span class="comment"># ./configure </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4、将Makefile文件编译可执行二进制程序</span></span><br><span class="line">	[root@localhost nginx-1.20.2]<span class="comment"># make</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5、将二进制文件拷贝至对应的目录中</span></span><br><span class="line">	[root@localhost nginx-1.20.2]<span class="comment"># make install</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6、启动</span></span><br><span class="line">	[root@localhost ~]<span class="comment"># /usr/local/nginx/sbin/nginx</span></span><br><span class="line">  <span class="comment"># 启动后浏览器访问ip地址即可查看是否安装成功</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 7、关闭</span></span><br><span class="line">	[root@localhost ~]<span class="comment"># /usr/local/nginx/sbin/nginx -s stop</span></span><br><span class="line"></span><br><span class="line">知识储备：</span><br><span class="line">	tar -xf [压缩包名称]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">知识拓展：</span><br><span class="line">  自定制安装，修改源代码包名以 nginx 为例</span><br><span class="line">  <span class="comment"># 1、关闭nginx服务后，删除源代码包，目录</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># rm -rf nginx-1.20.2</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># rm -rf /usr/local/nginx/</span></span><br><span class="line">  <span class="comment"># 2、重新解压源码包, 并进入相应目录</span></span><br><span class="line">	[root@localhost ~]<span class="comment"># tar -xf nginx-1.20.2.tar.gz</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># cd nginx-1.20.2</span></span><br><span class="line">  <span class="comment"># 3、找到对应的版本，版本号</span></span><br><span class="line">  [root@localhost nginx-1.20.2]<span class="comment"># grep -R &#x27;nginx&#x27; ./</span></span><br><span class="line">  [root@localhost nginx-1.20.2]<span class="comment"># grep -R &#x27;1.20.2&#x27; ./</span></span><br><span class="line">    ./src/core/nginx.h:<span class="comment">#define NGINX_VERSION   &quot;1.20.2&quot;  #可以看到版本的路径</span></span><br><span class="line">  <span class="comment"># 修改文件，修改完后:wq退出</span></span><br><span class="line">  [root@localhost nginx-1.20.2]<span class="comment"># vim ./src/core/nginx.h</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;</span><span class="string">&#x27;</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">   /*</span></span><br><span class="line"><span class="string">    * Copyright (C) Igor Sysoev</span></span><br><span class="line"><span class="string">    * Copyright (C) Nginx, Inc.</span></span><br><span class="line"><span class="string">    */</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    #ifndef _NGINX_H_INCLUDED_</span></span><br><span class="line"><span class="string">    #define _NGINX_H_INCLUDED_</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    #define nginx_version      1020002</span></span><br><span class="line"><span class="string">    #define NGINX_VERSION      &quot;1.0&quot; # 修改版本</span></span><br><span class="line"><span class="string">    #define NGINX_VER          &quot;GengFeng/&quot; NGINX_VERSION  #修改名称</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    #ifdef NGX_BUILD</span></span><br><span class="line"><span class="string">     &#x27;</span><span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="comment"># 配置相关的选项，并生成Makefile</span></span><br><span class="line">  [root@localhost nginx-1.20.2]<span class="comment"># ./configure </span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 将Makefile文件编译可执行二进制程序</span></span><br><span class="line">  [root@localhost nginx-1.20.2]<span class="comment"># make</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 将二进制文件拷贝至对应的目录中</span></span><br><span class="line">  [root@localhost nginx-1.20.2]<span class="comment"># make install</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 启动</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># /usr/local/nginx/sbin/nginx</span></span><br><span class="line">  <span class="comment"># 启动后浏览器访问ip地址即可查看是否安装成功</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 修改后看到的是已改过的名称和版本，以 http://192.168.15.100/sdasdas 为例</span></span><br><span class="line">     404 Not Found</span><br><span class="line">     GengFeng/1.0</span><br></pre></td></tr></table></figure>

<h1 id="压缩打包"><a href="#压缩打包" class="headerlink" title="压缩打包"></a>压缩打包</h1><h4 id="1、-什么是打包压缩"><a href="#1、-什么是打包压缩" class="headerlink" title="1、 什么是打包压缩"></a><strong>1、</strong> <strong>什么是打包压缩</strong></h4><p>打包指的是将多个⽂件和⽬录合并为⼀个特殊⽂件，然后将该特殊⽂件进⾏压缩，最终得到⼀个压缩包</p>
<h4 id="2、为什么使⽤压缩包"><a href="#2、为什么使⽤压缩包" class="headerlink" title="2、为什么使⽤压缩包"></a><strong>2、为什么使⽤压缩包</strong></h4><ul>
<li><p>1.减少占⽤的体积</p>
</li>
<li><p>2.加快⽹络的传输</p>
</li>
</ul>
<h4 id="3、Windows的压缩和Linux的有什么不同"><a href="#3、Windows的压缩和Linux的有什么不同" class="headerlink" title="3、Windows的压缩和Linux的有什么不同"></a>3、Windows的压缩和Linux的有什么不同</h4><ul>
<li><strong>windows: zip rar(linux不⽀持rar)</strong></li>
<li><strong>linux: zip tar.gz tar.bz2 .gz</strong></li>
</ul>
<p>如果希望windows的软件能被linux解压，或者linux的软件包被windows能识别，选择zip.</p>
<p>PS: 压缩包的后缀不重要，但⼀定要携带.</p>
<h4 id="4、Linux下常⻅的压缩包类型"><a href="#4、Linux下常⻅的压缩包类型" class="headerlink" title="4、Linux下常⻅的压缩包类型"></a>4、Linux下常⻅的压缩包类型</h4><table>
<thead>
<tr>
<th>格式</th>
<th>压缩工具</th>
</tr>
</thead>
<tbody><tr>
<td><code>.zip</code></td>
<td><strong>zip</strong> 压缩工具</td>
</tr>
<tr>
<td><code>.gz</code></td>
<td><strong>gzip</strong> 压缩工具，只能压缩文件，会删除源文件（通常配合<strong>tar</strong>使用）</td>
</tr>
<tr>
<td><code>.bz2</code></td>
<td><strong>bzip2</strong> 压缩工具，只能压缩文件，会删除源文件（通常配合<strong>tar</strong>使用）</td>
</tr>
<tr>
<td><code>.tar.gz</code></td>
<td>先使用<strong>tar</strong> 命令归档打包，然后使用 <strong>gzip</strong> 压缩</td>
</tr>
<tr>
<td><code>.tar.bz2</code></td>
<td>先使用<strong>tar</strong> 命令归档打包，然后使用 <strong>bzip</strong> 压缩</td>
</tr>
</tbody></table>
<p>Linux常见的压缩包有哪些？</p>
<ul>
<li>gzip</li>
<li>bzip2</li>
</ul>
<h2 id="gzip打包与压缩"><a href="#gzip打包与压缩" class="headerlink" title="gzip打包与压缩"></a>gzip打包与压缩</h2><ul>
<li>使用gzip方式进行压缩文件</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 压缩命令：gzip [压缩文件]</span></span><br><span class="line"><span class="comment"># 解压命令：gzip -d [压缩包]</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># gzip file       #对文件进行压缩</span></span><br><span class="line">[root@localhost ~]<span class="comment"># zcat file.gz    #查看gz压缩后的文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># gzip -d file.gz #解压gzip的压缩包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#使用场景:当需要让某个文件不生效时</span></span><br><span class="line">[root@localhost ~]<span class="comment"># gzip CentOS-Vault.repo --&gt; CentOS-Vault.repo.gz</span></span><br><span class="line">[root@localhost ~]<span class="comment"># zcat CentOS-Vault.repo.gz --&gt; 查看不想解压的压缩包文件内容</span></span><br></pre></td></tr></table></figure>

<h2 id="bzip2打包与压缩"><a href="#bzip2打包与压缩" class="headerlink" title="bzip2打包与压缩"></a>bzip2打包与压缩</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 压缩命令：bzip2 [压缩文件]</span></span><br><span class="line"><span class="comment"># 解压命令：bzip2 -d [压缩包]</span></span><br><span class="line"> </span><br><span class="line">[root@localhost ~]<span class="comment"># bzip2 file        #对文件进行压缩</span></span><br><span class="line">[root@localhost ~]<span class="comment"># bzmore file.bz2   #查看bz2压缩后的文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># bzip2 -d file.bz2 #解压bzip2的压缩包 </span></span><br></pre></td></tr></table></figure>

<h2 id="tar打包与压缩"><a href="#tar打包与压缩" class="headerlink" title="tar打包与压缩"></a>tar打包与压缩</h2><ul>
<li>tar是linux下最常用的压缩与解压缩, 支持文件和目录的压缩归档</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar : 打包的命令</span><br><span class="line">  参数：</span><br><span class="line">    -f  <span class="comment">#指定包文件名称，多参数f写最后</span></span><br><span class="line">    -c  <span class="comment">#打包</span></span><br><span class="line">    -v  <span class="comment">#输出命令的打包或解包的过程</span></span><br><span class="line">    -x  <span class="comment">#解压（解压不需要指定压缩类型）</span></span><br><span class="line">    -t  <span class="comment">#查看压缩包内部的内容</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    -z  <span class="comment">#使用gzip压缩压缩包</span></span><br><span class="line">    -j  <span class="comment">#使用bzip2压缩压缩包</span></span><br><span class="line">    -J  <span class="comment">#使用xz压缩归档后的文件(tar.xz)</span></span><br><span class="line">    -C  <span class="comment">#指定解压目录位置</span></span><br><span class="line">    -P  <span class="comment">#忽略使用绝对路径时报出的错误</span></span><br><span class="line">    -X  <span class="comment">#排除多个文件(写入需要排除的文件名称)</span></span><br><span class="line">    -h  <span class="comment">#打包软链接		</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    --hard-dereference  <span class="comment">#打包硬链接</span></span><br><span class="line">    --exclude   <span class="comment">#在打包的时候写入需要排除文件或目录		</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#常用打包与压缩组合</span></span><br><span class="line">czf    <span class="comment">#打包tar.gz格式</span></span><br><span class="line">cjf    <span class="comment">#打包tar.bz格式</span></span><br><span class="line">cJf    <span class="comment">#打包tar.xz格式</span></span><br><span class="line"></span><br><span class="line">zxf    <span class="comment">#解压tar.gz格式</span></span><br><span class="line">jxf    <span class="comment">#解压tar.bz格式</span></span><br><span class="line">xf     <span class="comment">#自动选择解压模式</span></span><br><span class="line">tf     <span class="comment">#查看压缩包内容    </span></span><br><span class="line">		</span><br><span class="line">  注意：</span><br><span class="line">     1、压缩时是什么路径，解压缩时就是什么路径，所以为了安全不要使用绝对路径压缩。</span><br><span class="line">     2、-f参数后面永远跟压缩包名称</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="comment"># tar命令练习     </span></span><br><span class="line">  <span class="comment">#1.环境准备</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># yum install mariadb-server</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># systemctl start mariadb</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># mkdir /backup</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#案例1.mysql备份及恢复</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># tar cJf /backup/mysql.tar.xz /var/lib/mysql</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># tar xf /backup/mysql.tar.xz -C /</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#案例2 mysql备份及恢复</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># cd /var/lib/mysql</span></span><br><span class="line">  [root@localhost mysql]<span class="comment"># tar cJf /backup/mysql.tar.xz *</span></span><br><span class="line">  [root@localhost mysql]<span class="comment"># tar tf /backup/mysql.tar.xz</span></span><br><span class="line">  [root@localhost mysql]<span class="comment"># tar xf /backup/mysql.tar.xz -C /var/lib/mysql     </span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux用户管理</title>
    <url>/ef277b25.html</url>
    <content><![CDATA[<h1 id="用户和用户组"><a href="#用户和用户组" class="headerlink" title="用户和用户组"></a>用户和用户组</h1><p><img src="https://gitee.com/gengff/blogimage/raw/master/images/1583571865_ab05a7218d58cc85bbfc02fbec2d730f.png" alt="1583571865_ab05a7218d58cc85bbfc02fbec2d730f"></p>
<span id="more"></span>
<ul>
<li><p>用户</p>
<ul>
<li>用户对硬件资源的操作都需要通过操作系统，比如用户要读取硬盘中的一份关键数据。出于安全考虑，操作系统的开发者们都专门开发了安全机制，要使用操作系统必须事先输入正确的用户名与密码，根据用户给相应权限，这便是用户的由来</li>
<li>用户是权限的化身，通常在公司是使用普通用户管理服务器，因为root权限过大，容易出问题</li>
<li>每启动一个进程都会与一个用户关联<ul>
<li>进程===》用户===》权限（作用在文件身上）</li>
</ul>
</li>
</ul>
</li>
<li><p>用户组</p>
<ul>
<li>主组：用户本身所在的组</li>
<li>附属组：为用户添加的组</li>
</ul>
<p>用户与组的关系</p>
<ul>
<li>一对一：一个用户可以属于一个组，用户默认就在自己的主组下</li>
<li>一对多：一个用户可以属于多个组，用户只有一个主组，但可以为用户添加多个附加组</li>
<li>多对多：多个用户可以属于多个组</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linux系统中用户角色划分			</span></span><br><span class="line">  系统用户：uid在 0-999 之间的是系统用户</span><br><span class="line">		系统用户一般用在启动应用程序上，一般不需要登录系统。</span><br><span class="line">		</span><br><span class="line">  普通用户：uid在 1000及以上的是普通用户</span><br><span class="line">		一般用在登录上。</span><br></pre></td></tr></table></figure>

<h2 id="用户与组相关文件"><a href="#用户与组相关文件" class="headerlink" title="用户与组相关文件"></a>用户与组相关文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用户详情的文件</span></span><br><span class="line"><span class="comment"># 文件信息：/etc/passwd</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat /etc/passwd</span></span><br><span class="line"> tony:x:1004:1004::/home/tony:/bin/bash</span><br><span class="line">  tony    <span class="comment">#用户名 </span></span><br><span class="line">  x       <span class="comment">#密码占位符</span></span><br><span class="line">  1001    <span class="comment">#用户uid</span></span><br><span class="line">  1001		<span class="comment">#用户组gid</span></span><br><span class="line">  /home/tony <span class="comment">#家目录</span></span><br><span class="line">  /bin/bash	 <span class="comment">#默认的解析器</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户密码的文件</span></span><br><span class="line"><span class="comment"># 文件信息：/etc/shadow</span></span><br><span class="line">[root@localhost /]<span class="comment"># cat /etc/shadow</span></span><br><span class="line"> tony:!!:18978:0:99999:7:::  <span class="comment">#用户密码</span></span><br><span class="line">  tony  <span class="comment">#用户名</span></span><br><span class="line">  !!    <span class="comment">#密码是一长串的字符串，!!表示没有密码</span></span><br><span class="line">  18978 <span class="comment">#最近一次变更密码，距离1970年到现在过了多少天</span></span><br><span class="line">  0     <span class="comment">#密码最少使用天数，0表示无限制</span></span><br><span class="line">  99999 <span class="comment">#密码最长使用天数，99999表示无限制</span></span><br><span class="line">  7     <span class="comment">#密码过期预警天数</span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 用户组配置文件</span></span><br><span class="line"><span class="comment"># 文件信息：/etc/group</span></span><br><span class="line">[root@localhost /]<span class="comment"># cat /etc/group</span></span><br><span class="line"> tony:x:1004:</span><br><span class="line">  tony  <span class="comment"># 用户组名</span></span><br><span class="line">  x     <span class="comment"># 用户组密码占位符</span></span><br><span class="line">  1004  <span class="comment"># 用户组id</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment"># 用户组密码文件</span></span><br><span class="line"><span class="comment"># 文件信息：/etc/gshadow</span></span><br><span class="line">[root@localhost /]<span class="comment"># cat /etc/gshadow</span></span><br><span class="line"> tony:!::</span><br><span class="line">  tony  <span class="comment">#用户组名</span></span><br><span class="line">  !     <span class="comment">#用户组密码，!或空表示没有密码</span></span><br><span class="line">  :     <span class="comment">#用户组管理者，可以为空，多个管理用，分割</span></span><br><span class="line">  :     <span class="comment">#显示用户组为哪个用户的附加组，多个用，分割 </span></span><br></pre></td></tr></table></figure>



<h2 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">用户：相当于账号</span><br><span class="line">  root  <span class="comment">#root用户拥有最高权限  </span></span><br><span class="line">  <span class="built_in">test</span></span><br><span class="line">	</span><br><span class="line"><span class="comment"># 创建用户的命令：</span></span><br><span class="line">	useradd [用户名]</span><br><span class="line">	</span><br><span class="line">  参数：</span><br><span class="line">	 -g  <span class="comment">#指定用户组（用户必须存在）</span></span><br><span class="line">	 -r  <span class="comment">#创建系统用户</span></span><br><span class="line">	 -M  <span class="comment">#不创建家目录</span></span><br><span class="line">	 -u  <span class="comment">#指定创建用户的ID的</span></span><br><span class="line">	 -s  <span class="comment">#指定解析器</span></span><br><span class="line">	 </span><br><span class="line">  [root@localhost /]<span class="comment"># useradd tony  #默认将用户写进了/etc/passwd 这个文件</span></span><br><span class="line">	ps：每创建一个用户都会创建一个该用户的主组，组名与用户名相同</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换用户的命令：</span></span><br><span class="line">	su - [用户名]</span><br><span class="line">	su [用户名]</span><br><span class="line">	</span><br><span class="line">	   </span><br><span class="line"><span class="comment"># 查看用户相关信息</span></span><br><span class="line">  [root@localhost /]<span class="comment"># id  #查看当前用户</span></span><br><span class="line">   uid=0(root) gid=0(root) 组=0(root)</span><br><span class="line">   </span><br><span class="line">  [root@localhost /]<span class="comment"># id test  #id [用户名] 查看指定用户信息</span></span><br><span class="line">   uid=1001(<span class="built_in">test</span>) gid=1001(<span class="built_in">test</span>) 组=1001(<span class="built_in">test</span>)</span><br><span class="line"></span><br><span class="line">  [root@localhost /]<span class="comment"># whoami  # 查看当前用户是谁</span></span><br><span class="line">   root</span><br><span class="line">   </span><br><span class="line">  [root@localhost /]<span class="comment"># who  #查看所有登录的用户</span></span><br><span class="line">   root   pts/0    2021-12-17 19:37 (192.168.15.1)</span><br><span class="line">   root   pts/1    2021-12-17 19:37 (192.168.15.1)</span><br><span class="line">   </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 修改用户的命令：</span></span><br><span class="line">  usermod [用户名]</span><br><span class="line">  </span><br><span class="line">  参数：</span><br><span class="line">   -u  <span class="comment">#修改用户的UID</span></span><br><span class="line">	 –g  <span class="comment">#指定⽤户所属的GID </span></span><br><span class="line">	 </span><br><span class="line"> <span class="comment"># 修改用户的UID</span></span><br><span class="line">	[root@localhost ~]<span class="comment"># tail -1 /etc/passwd</span></span><br><span class="line">   user:x:1005:1005::/home/user:/bin/bash</span><br><span class="line">  [root@localhost /]<span class="comment"># usermod -u 1006 user  #显示无法修改</span></span><br><span class="line">   usermod: user user is currently used by process 9001</span><br><span class="line">  [root@localhost /]<span class="comment"># kill -9 9001  #需要杀死正在使用用户的进程</span></span><br><span class="line">  [root@localhost /]<span class="comment"># 已杀死</span></span><br><span class="line">  <span class="comment">#这时候可以修改了</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># usermod -u 1006 user</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># tail -1 /etc/passwd  #修改成功</span></span><br><span class="line">   user:x:1006:1005::/home/user:/bin/bash</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment"># 用户组必须是已经存在的，否则无法修改</span></span><br><span class="line">  [root@localhost /]<span class="comment"># usermod user -g 1001</span></span><br><span class="line">  [root@localhost /]<span class="comment"># tail -1 /etc/passwd</span></span><br><span class="line">    user:x:1006:1001::/home/user:/bin/bash</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除用户的命令：</span></span><br><span class="line"> userdel [用户名]</span><br><span class="line">   参数：-r</span><br><span class="line">  <span class="comment">#删除⽤户test1，但不删除⽤户家⽬录和mail</span></span><br><span class="line">  [root@localhost /]<span class="comment"># userdel test1    </span></span><br><span class="line">  </span><br><span class="line">  [root@localhost /]<span class="comment"># ll /home   #查看并没有删掉test1的家目录</span></span><br><span class="line">   drwx------ 3 1003 1003 92 12月 17 21:02 test1 </span><br><span class="line">  [root@localhost /]<span class="comment"># ll /var/spool/mail/  #查看并没有删掉test1的mail</span></span><br><span class="line">   -rw-rw---- 1 1003 mail 0 12月 17 21:02 test1</span><br><span class="line">  [root@localhost /]<span class="comment"># rm -rf /home/test1  #手动删除家目录</span></span><br><span class="line">  [root@localhost /]<span class="comment"># rm -rf /var/spool/mail/test1 #手动删除mail  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  <span class="comment">#要想删彻底，加-r选项，其实是做了上面所有的操作</span></span><br><span class="line">  [root@localhost /]<span class="comment"># userdel -r test1 </span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h3 id="手动创建用户"><a href="#手动创建用户" class="headerlink" title="手动创建用户"></a>手动创建用户</h3><ul>
<li>不使用 useradd 创建用户</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建用户家目录</span></span><br><span class="line">[root@localhost opt]<span class="comment"># mkdir -p /home/test  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看用户信息配置文件</span></span><br><span class="line">[root@localhost opt]<span class="comment"># cat /etc/passwd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建test用户并写入用户信息配置文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo &#x27;test:x:1001:1001::/home/test/:/bin/bash&#x27; &gt;&gt; /etc/passwd</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 再次查看用户信息配置文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat /etc/passwd</span></span><br><span class="line"><span class="built_in">test</span>:x:1001:1001::/home/<span class="built_in">test</span>/:/bin/bash  <span class="comment">#可以发现新增的用户</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给用户添加属组</span></span><br><span class="line">[root@localhost ~]<span class="comment"># echo &#x27;test:x:1001&#x27; &gt;&gt; /etc/group</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给用户添加密码</span></span><br><span class="line">[root@localhost /]<span class="comment"># vim /etc/shadow</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 给用户家目录配置环境变量</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cp /etc/skel/.bashrc  /home/test</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cp /etc/skel/.bash_profile   /home/test</span></span><br><span class="line">或</span><br><span class="line">[root@localhost ~]<span class="comment"># cp /etc/skel/.bash*  /home/test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改用户家目录权限</span></span><br><span class="line">[root@localhost home]<span class="comment"># chown test.test test/  # 用户.用户组 用户家路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换用户</span></span><br><span class="line">[root@localhost ~]<span class="comment"># su - test</span></span><br><span class="line"></span><br><span class="line">上一次登录：二 12月 14 19:05:50 CST 2021pts/0 上</span><br><span class="line"></span><br><span class="line"><span class="comment"># 成功切换用户</span></span><br><span class="line">[<span class="built_in">test</span>@localhost ~]$   </span><br></pre></td></tr></table></figure>

<h3 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h3><ul>
<li>修改或添加Linux普通用户的密码。直接影响的文件是/etc/shado</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> 参数</span><br><span class="line">  -d	<span class="comment">#删除密码</span></span><br><span class="line">  -l	<span class="comment">#锁定用户密码，无法被用户自行修改</span></span><br><span class="line">  -u	<span class="comment">#解开已锁定用户密码，允许用户自行修改</span></span><br><span class="line">  -e	<span class="comment">#密码立即过期，下次登陆强制修改密码</span></span><br><span class="line">  -k	<span class="comment">#保留即将过期的用户在期满后能仍能使用</span></span><br><span class="line">  -S	<span class="comment">#查询密码状态</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加或修改密码</span></span><br><span class="line">当用户密码不存在的时候即为增加密码，当用户密码存在时即为修改密码。</span><br><span class="line"></span><br><span class="line"> [root@localhost home]<span class="comment"># useradd user</span></span><br><span class="line"> [root@localhost home]<span class="comment"># tail -1 /etc/passwd</span></span><br><span class="line">   user:x:1005:1005::/home/user:/bin/bash</span><br><span class="line"> [root@localhost home]<span class="comment"># tail -1 /etc/shadow</span></span><br><span class="line">   user:!!:18701:0:99999:7:::</span><br><span class="line">   </span><br><span class="line"> [root@localhost home]<span class="comment"># passwd user</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># passwd user</span></span><br><span class="line">   更改用户 user 的密码 。</span><br><span class="line">   新的 密码：</span><br><span class="line">   重新输入新的 密码：</span><br><span class="line">   passwd：所有的身份验证令牌已经成功更新。</span><br><span class="line"> [root@localhost home]<span class="comment"># tail -1 /etc/passwd</span></span><br><span class="line">   user:x:1005:1005::/home/user:/bin/bash</span><br><span class="line"> [root@localhost home]<span class="comment"># tail -1 /etc/shadow</span></span><br><span class="line"> user:$6$RApJMwf1<span class="variable">$jytlisorvavpdDmuZ4RGyuFLZaHd5C0uMqXJU0dFt</span>/Vn7Oj8tSiN7/RswvXc3LIBh6JuDOq73u2K1Uf4up476/:18979:0:99999:7:::</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 免交互修改密码</span></span><br><span class="line">[root@localhost /]<span class="comment"># echo &#x27;123&#x27; | passwd --stdin user</span></span><br><span class="line">Changing password <span class="keyword">for</span> user user.</span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/yhz.png" alt="yhz"></p>
<h2 id="用户组管理命令"><a href="#用户组管理命令" class="headerlink" title="用户组管理命令"></a>用户组管理命令</h2><p>每个用户都有一个用户组，这样系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">用户组：某些具有相同属性的账号的集合</span><br><span class="line">	root</span><br><span class="line"><span class="comment"># 创建用户组的命令：</span></span><br><span class="line">	groupadd </span><br><span class="line">	</span><br><span class="line">	参数：</span><br><span class="line">		-g  <span class="comment">#指定用户组的GID</span></span><br><span class="line">	  -r  <span class="comment">#创建系统工作组，系统工作组的组ID小于1000</span></span><br><span class="line">    -K  <span class="comment">#覆盖配置文件“/ect/login.defs”</span></span><br><span class="line">    -o  <span class="comment">#允许添加组ID号不唯一的工作组</span></span><br><span class="line">    </span><br><span class="line">  <span class="comment">#创建组  </span></span><br><span class="line">   [root@localhost /]<span class="comment"># groupadd group1</span></span><br><span class="line">   [root@localhost /]<span class="comment"># cat /etc/group   #查看组信息</span></span><br><span class="line">    group1:x:1005:</span><br><span class="line">    </span><br><span class="line">  <span class="comment">#指定GID创建组</span></span><br><span class="line">   [root@localhost /]<span class="comment"># groupadd -g 2001 group2</span></span><br><span class="line">   [root@localhost /]<span class="comment"># tail -1 /etc/group  #查看文件最后一行的内容</span></span><br><span class="line">    group2:x:2001:</span><br><span class="line"></span><br><span class="line">  <span class="comment">#创建系统组</span></span><br><span class="line">   [root@localhost /]<span class="comment"># groupadd -r group4</span></span><br><span class="line">   [root@localhost /]<span class="comment"># tail -1 /etc/group</span></span><br><span class="line">    group4:x:996:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改组的命令：</span></span><br><span class="line">  groupmod</span><br><span class="line"></span><br><span class="line">  参数：</span><br><span class="line">   -g  <span class="comment">#设置欲使用的组GID</span></span><br><span class="line">   -n  <span class="comment">#设置欲使用的群组名称</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">#修改组GID</span></span><br><span class="line">   [root@localhost /]<span class="comment"># groupmod -g 2222 group1  #将group1的组GID改为2222</span></span><br><span class="line">   [root@localhost /]<span class="comment"># tail -1 /etc/group</span></span><br><span class="line">    group1:x:2222:</span><br><span class="line"></span><br><span class="line">  <span class="comment">#修改组名</span></span><br><span class="line">   [root@localhost /]<span class="comment"># groupmod -n new_group group1 #将组group1改名为new_group</span></span><br><span class="line">   [root@localhost /]<span class="comment"># tail -1 /etc/group  </span></span><br><span class="line">    new_group:x:2222:</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 删除组的命令：</span></span><br><span class="line"> groupdel</span><br><span class="line"> </span><br><span class="line">  [root@localhost /]<span class="comment"># groupdel group2</span></span><br><span class="line">  [root@localhost /]<span class="comment"># tail -5 /etc/group #已经删除了</span></span><br><span class="line">   mysql:x:27:</span><br><span class="line">   tony:x:1004:</span><br><span class="line">   group3:x:2005:</span><br><span class="line">   group4:x:996:</span><br><span class="line">   new_group:x:2222:</span><br><span class="line">   </span><br><span class="line">ps：用户组在系统中删除，如果一个组被用户占用则不能删除。用户被删除，用户基本组也会被删除</span><br><span class="line"></span><br><span class="line">知识储备：</span><br><span class="line">  tail  <span class="comment">#tail 命令可用于查看文件的内容</span></span><br><span class="line">	-f  <span class="comment">#循环读取</span></span><br><span class="line">  -q  <span class="comment">#不显示处理信息</span></span><br><span class="line">  -v  <span class="comment">#显示详细的处理信息</span></span><br><span class="line">  -c&lt;数目&gt;  <span class="comment">#显示的字节数</span></span><br><span class="line">  -n&lt;行数&gt;  <span class="comment">#显示文件的尾部 n 行内容</span></span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/WechatIMG1411-20211218004252145.png" alt="WechatIMG1411"></p>
<h2 id="SUDO提权"><a href="#SUDO提权" class="headerlink" title="SUDO提权"></a>SUDO提权</h2><blockquote>
<p>用于普通用提升权限的。</p>
</blockquote>
<ul>
<li><p>相关的文件：<code>/etc/sudoers</code></p>
</li>
<li><p>检查<code>/etc/sudoers</code>是否修改正确：visudo -c</p>
</li>
<li><p>sudoers文件格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tom       ALL=           (ALL)          ALL</span><br><span class="line">用户名称   所有机器可登陆    所有IP或主机名   所有的指令</span><br></pre></td></tr></table></figure></li>
<li><p>指令编写格式</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 必须写全路径：which查看命令全路径</span><br><span class="line"></span><br><span class="line"># 只支持vim命令提权</span><br><span class="line">xianchen ALL=(ALL)  /usr/bin/vim</span><br><span class="line"></span><br><span class="line"># 支持所有的命令提权</span><br><span class="line">tom ALL=(ALL)  ALL</span><br><span class="line"></span><br><span class="line"># 不支持某个命令提权</span><br><span class="line">tom ALL=(ALL) ALL, !/usr/bin/vim</span><br><span class="line"></span><br><span class="line"># 不支持某个命令的部分功能</span><br><span class="line">xiaochen ALL=(ALL)   ALL, !/usr/bin/vim /root/123.txt</span><br></pre></td></tr></table></figure></li>
</ul>
<p><a href="https://img2020.cnblogs.com/blog/2251663/202103/2251663-20210316184607539-1301650386.png"><img src="https://gitee.com/gengff/blogimage/raw/master/images/2251663-20210316184607539-1301650386.png" alt="img"></a></p>
<p><a href="https://img2020.cnblogs.com/blog/2251663/202103/2251663-20210316184619104-256801431.png"><img src="https://img2020.cnblogs.com/blog/2251663/202103/2251663-20210316184619104-256801431.png" alt="img"></a></p>
<p>*<strong>4*</strong>|***0***<strong>su</strong></p>
<ul>
<li><p>su - xxx 和 su xxx之间区别</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1、su - xxx ：相当于切换一个窗口，su xxx 仅仅切换了用户</span><br><span class="line"></span><br><span class="line">2、su - xxx ： 切换用户执行的系统文件要多于 su xxx</span><br><span class="line"></span><br><span class="line">3、su - xxx 是登录</span><br><span class="line">   su  xxx  切换用户</span><br></pre></td></tr></table></figure></li>
<li><p>Linux中的shell可以分为两类</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">登陆shell，需要输⼊⽤户名和密码才能进⼊Shell，⽇常接触的最多的⼀种</span><br><span class="line">⾮登陆shell，不需要输⼊⽤户和密码就能进⼊Shell,⽐如运⾏bash会开启⼀个新的会话窗⼝</span><br></pre></td></tr></table></figure>

<p>*<strong>4*</strong>|***1***<strong>bash shell配置文件介绍</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局配置⽂件：</span><br><span class="line"> /etc/profile</span><br><span class="line"> /etc/profile.d/*.sh</span><br><span class="line"> /etc/bashrc</span><br><span class="line">个⼈配置⽂件：</span><br><span class="line"> ~/.bash_profile</span><br><span class="line"> ~/.bashrc</span><br><span class="line">profile类⽂件, 设定环境变量, 登陆前运⾏的脚本和命令。</span><br><span class="line">bashrc类⽂件, 设定本地变量, 定义命令别名</span><br><span class="line">PS: 如果全局配置和个⼈配置产⽣冲突，以个⼈配置为准。</span><br></pre></td></tr></table></figure>

<p>*<strong>4*</strong>|***2***<strong>配置文件的执行顺序</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果执⾏的是登录式shell，那么配置⽂件执⾏顺序是: </span><br><span class="line">/etc/profile -&gt; /etc/profile.d/*.sh -&gt; ~/.bash_profile -&gt; ~/.bashrc -&gt; /etc/bashrc</span><br><span class="line">如果执⾏的是⾮登录式shell，那么配置⽂件执⾏顺序是:</span><br><span class="line">~/.bashrc -&gt; /etc/bashrc -&gt; /etc/profile.d/*.sh</span><br><span class="line">PS: 验证使⽤echo在每⾏添加⼀个输出即可，注意，要把输出放在⽂件的第⼀⾏。如果说要写登录执行脚本，可以配置在/.bashrc当中。</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件权限管理</title>
    <url>/ad5612ad.html</url>
    <content><![CDATA[<h1 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h1><p><strong>把⼀个⽤户加⼊了⼀个组，该⽤户就拥有了该组的权限，当⼀个⽤户要操作某个⽂件时，系统会依次检索该⽤户是否是该⽂件的(属主)拥有者，其次是(数组)组成员，最后是其他⼈，如果扫描到是拥有者，则具备拥有者的权限，不必往后扫描，以此类推</strong></p>
<span id="more"></span>
<h2 id="权限类型"><a href="#权限类型" class="headerlink" title="权限类型"></a>权限类型</h2><p>每一个权限拥有一个数字编号</p>
<ul>
<li><p><strong>r：可读(read)—&gt; 4</strong></p>
</li>
<li><p><strong>w：可写(write)—&gt; 2</strong></p>
</li>
<li><p><strong>x：可执⾏(execute)—&gt; 1</strong></p>
</li>
<li><p><strong>-：没有对应权限</strong></p>
<p><strong>执行脚本 == 运行脚本</strong></p>
</li>
</ul>
<h4 id="权限的归属"><a href="#权限的归属" class="headerlink" title="权限的归属"></a>权限的归属</h4><ul>
<li><strong>属主：u</strong></li>
<li><strong>属组：g</strong></li>
<li><strong>其他人：o</strong></li>
</ul>
<h2 id="权限位"><a href="#权限位" class="headerlink" title="权限位"></a>权限位</h2><p><img src="https://gitee.com/gengff/blogimage/raw/master/images/image-20211218190929438.png" alt="image-20211218190929438"></p>
<p>权限位主要分为三个部分，分别是属主、属组以及其他人</p>
<h4 id="rwx-：-属主—-gt-可读可写可执行"><a href="#rwx-：-属主—-gt-可读可写可执行" class="headerlink" title="rwx ： 属主—&gt;可读可写可执行"></a>rwx ： 属主—&gt;可读可写可执行</h4><h4 id="r-x-：-属组—-gt-可读可执行"><a href="#r-x-：-属组—-gt-可读可执行" class="headerlink" title="r-x    ： 属组—&gt;可读可执行"></a>r-x    ： 属组—&gt;可读可执行</h4><h4 id="rw-：-其他人—-gt-可读可写"><a href="#rw-：-其他人—-gt-可读可写" class="headerlink" title="rw-    ： 其他人—&gt;可读可写"></a>rw-    ： 其他人—&gt;可读可写</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">使用ll命令查看文件详情，在每个文件详情最前方，有10个字符来表示文件类型和权限</span><br><span class="line">  [root@localhost ~]<span class="comment"># ll</span></span><br><span class="line">  -rw-r--r-- 1 root root    0 12月 14 19:11 1</span><br><span class="line">  drwxr-xr-x 2 root root    6 12月 18 15:51 a</span><br><span class="line">  -rwxr-xr-x 1 root root 4609 11月 21 11:43 init.sh</span><br><span class="line"></span><br><span class="line">在Linux 系统中权限是区分用户的，即属主(用户)、属组(组用户)、其他用户，第一位表示文件的类型，-代表文件，d代表目录，其他每个用户占三个字符，这里-rwxr-xr-x对应如下关系</span><br><span class="line">-    <span class="comment">#文件</span></span><br><span class="line">rwx  <span class="comment">#属主：可读可写可执行</span></span><br><span class="line">r-x  <span class="comment">#属组：可读可执行</span></span><br><span class="line">r-x  <span class="comment">#其他：可读可执行</span></span><br><span class="line"></span><br><span class="line">含义解释</span><br><span class="line">第一位：-代表文件，d代表目录</span><br><span class="line">用户、组用户、其他用户都未rwx形式，其中r表示读、w表示写、x表示可执行，-表示没有权限，拿用户组举例，r只能出现在第一个位置、w只能出现在第二个位置、x只能出现在第三位。</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/1327924-20191106101057159-461417569.png" alt="1327924-20191106101057159-461417569"></p>
<p>如果我们将出现字符（可以是r、w、x）表示为1，出现-表示为0，那么对应二进制如下，r - - = 100、- w - = 010、- - x = 001、再转换成10进制，那么读=4、写=2、可执行=1，将转换为以下关系</p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/1327924-20191106101454753-1175152316.png" alt="1327924-20191106101454753-1175152316"></p>
<p>也就是说这里的数字简写了用户权限，我们也可以用数字反推权限，比如数据6，我们转换为为二进制：110，转换为：rw-，具有可读、可写权限。</p>
<p>现在我们已经明白了：-rwxr-xr-x权限含义了，这里用数字简写就是-755，这里还需要改写成0755，这里的0可以简单理解成10进制</p>
<h2 id="设置权限"><a href="#设置权限" class="headerlink" title="设置权限"></a>设置权限</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod </span><br><span class="line"> 	格式：</span><br><span class="line"> 		chmod [参数] [权限表达式] [操作对象] 	</span><br><span class="line"> 	参数：</span><br><span class="line"> 		-R  : 递归增加权限</span><br><span class="line"> 		</span><br><span class="line"> 		</span><br><span class="line"> [root@localhost ~]<span class="comment"># ll /root/1.txt</span></span><br><span class="line">  -rw-r--r-- 1 root root 0 12月 18 16:42 /root/1.txt</span><br><span class="line">		</span><br><span class="line"><span class="comment"># 1、加减法：+、- 在原来的权限基础上增减</span></span><br><span class="line"> <span class="comment">#给属主增加执行权限，属组增加执行权限，其他增加写权限</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># chmod u+x,g+x,o+w /root/1.txt</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># ll /root/1.txt</span></span><br><span class="line">   -rwxr-xrw- 1 root root 0 12月 18 16:42 /root/1.txt</span><br><span class="line">   </span><br><span class="line"> <span class="comment">#取消属主写权限，权限属组读权限，取消其他读权限</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># chmod u-w,g-r,o-r /root/1.txt</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># ll /root/1.txt</span></span><br><span class="line">  -r-x--x-w- 1 root root 0 12月 18 16:42 /root/1.txt</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 2、赋值：= 不管原来是什么权限就直接覆盖了</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># chmod u=rwx,g=rw,o=rx /root/1.txt</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># ll /root/1.txt </span></span><br><span class="line">  -rwxrw-r-x 1 root root 0 12月 18 16:42 /root/1.txt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3、数字：不能单独设置一个，必须全部设置</span></span><br><span class="line"> <span class="comment">#给属主设置读写执行权限，属组设置读执行权限，其他设置读写权限</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># chmod 756 /root/1.txt </span></span><br><span class="line"> [root@localhost ~]<span class="comment"># ll /root/1.txt </span></span><br><span class="line">  -rwxr-xrw- 1 root root 0 12月 18 16:42 /root/1.txt</span><br><span class="line">  </span><br><span class="line"> <span class="comment">#全部设置读写执行权限</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># chmod 777 /root/1.txt </span></span><br><span class="line"> [root@localhost ~]<span class="comment"># ll /root/1.txt </span></span><br><span class="line">  -rwxrwxrwx 1 root root 0 12月 18 16:42 /root/1.txt</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># 4、-R:递归设置权限</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># mkdir -p /a/b/c</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># touch /a/b/c/d.txt</span></span><br><span class="line"> </span><br><span class="line"> [root@localhost ~]<span class="comment"># chomd -R 777 /a</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># ll /a/b</span></span><br><span class="line">  drwxrwxrwx 2 root root 19 12月 18 17:13 c</span><br><span class="line"></span><br><span class="line"> [root@localhost ~]<span class="comment"># ll /a/b/c/d.txt</span></span><br><span class="line">  -rwxrwxrwx 1 root root 0 12月 18 17:13 /a/b/c/d.txt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 置空权限：=-</span></span><br><span class="line">[root@localhost ~]<span class="comment"># chmod 000 /root/1.txt </span></span><br><span class="line">或</span><br><span class="line">[root@localhost ~]<span class="comment"># chmod u=-,g=-,o=- /root/1.txt </span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ll /root/1.txt </span></span><br><span class="line"> ---------- 1 root root 0 12月 18 16:42 /root/1.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="权限的作用"><a href="#权限的作用" class="headerlink" title="权限的作用"></a>权限的作用</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、权限对于用户的意义</span><br><span class="line">  1、普通用户是严格遵守权限的</span><br><span class="line">  2、root用户是高于权限</span><br><span class="line">  3、权限需要重新登才生效（su和su - 都可以）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">2、权限对于文件的意义</span><br><span class="line">  1、r：读取文件内容</span><br><span class="line">  2、w：修改文件内容</span><br><span class="line">  3、x：可以把文件当成一个命令/程序运行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">3、权限对于目录的意义</span><br><span class="line">  1、r：可以浏览该目录下子目录名和子文件名（路径的最小权限是必须拥有可执行权限）</span><br><span class="line">  2、w：创建、删除、移动（同上）</span><br><span class="line">  3、x：可以进入该目录（同上）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1、在目录下，只有可读权限，无法查看文件内容（因为你无法操作目录）</span></span><br><span class="line"><span class="comment"># 2、在目录下，只有可读可写权限，无法查看文件内容（理由同上）</span></span><br><span class="line"><span class="comment"># 3、要想查看文件夹下的文件，文件夹必须至少拥有可执行权限；同时文件必须拥有可读权限</span></span><br></pre></td></tr></table></figure>

<h2 id="权限之特殊权限"><a href="#权限之特殊权限" class="headerlink" title="权限之特殊权限"></a>权限之特殊权限</h2><h3 id="SUID"><a href="#SUID" class="headerlink" title="SUID"></a>SUID</h3><ul>
<li>作用对象必须是二进制文件（cat出来是乱码的文件）</li>
<li>该文件必须拥有可执行权限</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 4xxx [文件名]	</span><br><span class="line">or</span><br><span class="line">chmod	u+s	[文件名]</span><br><span class="line"></span><br><span class="line"> [root@localhost ~]<span class="comment"># ll `which passwd`</span></span><br><span class="line">  -rwsr-xr-x 1 root root 27856 4月   1 2020 /usr/bin/passwd</span><br><span class="line"></span><br><span class="line">查看passwd命令的权限，我们可以看到一个不曾见到过的权限 s  </span><br><span class="line"></span><br><span class="line">而 S 权限是一个特殊权限</span><br><span class="line">	SUID 权限仅对⼆进制可执⾏⽂件有效	</span><br><span class="line">    如果执⾏者对于该⼆进制可执⾏⽂件具有 s 的权限，执⾏者将具有该⽂件的所有者的权限   </span><br><span class="line">    本权限仅在执⾏该⼆进制可执⾏⽂件的过程中有效</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 示例：    </span></span><br><span class="line">[root@localhost ~]<span class="comment"># su - user  # 切换到普通用户user10</span></span><br><span class="line"></span><br><span class="line">[user@localhost ~]$ cat /etc/shadow  <span class="comment"># 查看用户密码文件</span></span><br><span class="line">cat: /etc/shadow: 权限不够   <span class="comment"># 显示权限不够，没办法访问 </span></span><br><span class="line"></span><br><span class="line">[user@localhost ~]$ ll /etc/shadow  <span class="comment"># 查看/etc/shadow 可以看出只有root用户才可以查看</span></span><br><span class="line">----------. 1 root root 997 6月  20 18:02 /etc/shadow</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ll `which cat`  # 登录root用户，查看cat命令</span></span><br><span class="line">-rwxr-xr-x. 1 root root 54160 10⽉ 31 2018 /usr/bin/cat</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># chmod 4755 `which cat` # 或者 chmod u+s `which cat` 修改权限</span></span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ll `which cat`  # 现在cat命令的权限已经改成了s</span></span><br><span class="line">-rwsr-xr-x. 1 root root 54160 10⽉ 31 2018 /usr/bin/cat</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># su - user		# 再次切换到user10用户</span></span><br><span class="line">[user@localhost ~]$ cat /etc/shadow <span class="comment"># 可以看到用户密码文件的内容了    </span></span><br></pre></td></tr></table></figure>

<h3 id="SBIT"><a href="#SBIT" class="headerlink" title="SBIT"></a>SBIT</h3><p>SBIT 是 the restricted deletion flag or sticky bit 的简称，有时也称为Sticky。</p>
<ul>
<li>只对目录有效，用来阻止非文件的所有者删除文件，比较常见的就是/tmp目录</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod o+t [文件名] </span><br><span class="line">or</span><br><span class="line">chmod 1xxx [文件名]</span><br><span class="line"></span><br><span class="line">[root@localhost ~]<span class="comment"># ls -dl /tmp/ # -d 参数表示不查看目录下文件信息，就查看这个目录的信息</span></span><br><span class="line">  drwxrwxrwt. 13 root root 4096 8⽉ 11 17:09 /tmp/ </span><br><span class="line"></span><br><span class="line">权限信息中最后⼀位 t 表明该⽬录被设置了 SBIT 权限。</span><br><span class="line"></span><br><span class="line">SBIT 对⽬录的作⽤是：</span><br><span class="line">  当⽤户在该⽬录下创建新⽂件或⽬录时，仅有⾃⼰和 root 才有权⼒删除，主要作⽤于⼀个共享的⽂件夹。</span><br></pre></td></tr></table></figure>

<h3 id="SGID"><a href="#SGID" class="headerlink" title="SGID"></a>SGID</h3><ul>
<li>用户对某一目录具有写和执行权限，该用户就可以在该目录下建立文件，如果该目录被SGID修饰，则该用户在这个目录下建立的文件都是属于这个目录所属的组</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod g+s [文件名] </span><br><span class="line">or</span><br><span class="line">chmod 2xxx [文件名]</span><br><span class="line"></span><br><span class="line">ps:当 SGID 作⽤于普通⽂件时，和 SUID 类似，在执⾏该⽂件时，⽤户将获得该⽂件所属组的权限。  </span><br></pre></td></tr></table></figure>

<h2 id="Umask"><a href="#Umask" class="headerlink" title="Umask"></a>Umask</h2><h4 id="新建的文件、目录的默认权限是由umask决定的"><a href="#新建的文件、目录的默认权限是由umask决定的" class="headerlink" title="新建的文件、目录的默认权限是由umask决定的"></a>新建的文件、目录的默认权限是由umask决定的</h4><ul>
<li><p>uid &gt; 199并且属主与数组相等的⽤户下比如test ，umask: 0002    </p>
<ul>
<li>文件权限：664</li>
<li>目录权限：775</li>
</ul>
</li>
<li><p>除1之外的其他⽤户下，⽐如root⽤户，umask: 0022</p>
<ul>
<li>文件权限：644</li>
<li>目录权限：755</li>
</ul>
<p><strong>在Linux中，常用的文件的权限是666，目录的权限是777</strong></p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、文件权限计算方法：</span><br><span class="line">    文件的权限是跟 <span class="built_in">umask</span> 值相减，遇到奇数加一；遇到偶数则不变。</span><br><span class="line">2、目录权限计算方法：</span><br><span class="line">    目录的权限只要跟 <span class="built_in">umask</span> 值相减即可。</span><br><span class="line">    </span><br><span class="line">总结：<span class="built_in">umask</span>设置的越小，权限就越大，慎用	</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 默认权限</span></span><br><span class="line">  默认文件权限：644</span><br><span class="line">	默认的目录权限：755</span><br><span class="line">   </span><br><span class="line">   [root@localhost ~]<span class="comment"># touch a.txt  #创建文件</span></span><br><span class="line">   [root@localhost ~]<span class="comment"># ll a.txt</span></span><br><span class="line">    -rw-r--r-- 1 root root 0 12月 18 20:55 a.txt  <span class="comment">#默认权限644</span></span><br><span class="line">    </span><br><span class="line">	 [root@localhost ~]<span class="comment"># mkdir b  #创建目录</span></span><br><span class="line">   [root@localhost ~]<span class="comment"># ll -d b</span></span><br><span class="line">    drwxr-xr-x 2 root root 6 12月 18 20:57 b  <span class="comment">#默认权限755</span></span><br><span class="line">   [root@localhost ~]<span class="comment"># umask </span></span><br><span class="line">    0022</span><br><span class="line"></span><br><span class="line">		</span><br><span class="line"><span class="comment"># 临时设置umask</span></span><br><span class="line">[root@localhost ~]<span class="comment"># umask 000   #设置umask权限</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 永久设置umask</span></span><br><span class="line"><span class="comment">#更改配置文件</span></span><br><span class="line">[root@localhost tmp]<span class="comment"># vim /etc/profile # 或者/etc/bashrc内容⼀样</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$UID</span> -gt 199 ] &amp;&amp; [ <span class="string">&quot;`id -gn`&quot;</span> = <span class="string">&quot;`id -un`&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"> <span class="built_in">umask</span> 002 <span class="comment">#表示uid⼤于等于199的默认umask值，表示普通⽤户</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"> <span class="built_in">umask</span> 022 <span class="comment">#表示uid⼩于199的默认umask值，表示root</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">需求：</span><br><span class="line">		要求把1个月之前修改过的日志文件删除。</span><br><span class="line"></span><br><span class="line">案例:</span><br><span class="line">	案例1：将index文件添加属主 : 可读可写可执行、属组 ：可读可写、其他人：没有任何权限</span><br><span class="line">		chmod 760 index</span><br><span class="line"></span><br><span class="line"> 	案例2：将baidu下的所有文件设置rwxr--r--</span><br><span class="line"> 		chmod -R  744  baidu/</span><br><span class="line"></span><br><span class="line"> 	案例3：将index这个文件的属组增加一个可执行权限。</span><br><span class="line"> 		chmod g+x index</span><br><span class="line"> 		chmod g+x,o-r index</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux文件管理</title>
    <url>/117ba17a.html</url>
    <content><![CDATA[<h1 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h1><h4 id="Linux-系统的单根⽬录结构"><a href="#Linux-系统的单根⽬录结构" class="headerlink" title="Linux  系统的单根⽬录结构"></a><strong>Linux  系统的单根⽬录结构</strong></h4><p>linux与windows的⽬录结构对⽐</p>
<span id="more"></span>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/2321466-20210620230259931-1963226798.png" alt=" "></p>
<h4 id="⽂件的时间"><a href="#⽂件的时间" class="headerlink" title="⽂件的时间"></a><strong>⽂件的时间</strong></h4><figure class="highlight d"><table><tr><td class="code"><pre><span class="line">ls -l ⽂件名 仅看的是⽂件的修改时间</span><br><span class="line">Linux⽂件有三种时间,⽤stat查看</span><br><span class="line">    </span><br><span class="line">例如：stat anaconda-ks.cfg</span><br><span class="line">    </span><br><span class="line">访问时间：atime，查看内容，⽤cat检测</span><br><span class="line">修改时间：mtime，修改内容</span><br><span class="line">改变时间：ctime，修改内容，修改权限等属性，凡是有改动都会变</span><br></pre></td></tr></table></figure>



<h2 id="文件类型概念说明"><a href="#文件类型概念说明" class="headerlink" title="文件类型概念说明"></a>文件类型概念说明</h2><p><strong>1、文件详细信息详解</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]<span class="comment"># ls -lhi</span></span><br><span class="line"> 总用量 8K</span><br><span class="line"> 134319695 -rw-------. 1 root root 1.7K Dec 8 12:08 anaconda-ks.cfg</span><br><span class="line"> 134319707 -rw-r--r--  1 root root  12 Dec 13 11:48 index</span><br></pre></td></tr></table></figure>

<p>文件属性信息详述图</p>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/image-20211216191817853.png" alt="image-20211216191817853"></p>
<p><strong>2、inode编号</strong></p>
<ul>
<li>Linux系统中文件的唯一编号，就相当于身份证号。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Linux系统内部不使用文件名，而使用inode编号来识别文件</span><br><span class="line">  对于系统来说，文件名只是inode编号便于识别的别称或者绰号，表面上用户通过文件名打开文件</span><br><span class="line">  实际上系统内部这个过程分成立三步：</span><br><span class="line">  		首先：系统找到这个文件名对应的inode编号</span><br><span class="line">  		其次：通过ionde编号获取inode信息</span><br><span class="line">  		最后：根据ionde信息找到文件数据所在的block，读出数据</span><br><span class="line">  		</span><br><span class="line">  使用ls -i命令可以看到文件对应额inode编号</span><br><span class="line">   [root@localhost data]<span class="comment"># ls -i</span></span><br><span class="line">    16781387 <span class="built_in">test</span></span><br></pre></td></tr></table></figure>



<h2 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h2><p>  <strong>1、什么是硬链接</strong></p>
<ul>
<li>硬链接：不具有完整的文件结构，它的文件名直接指向文件节点，它和源文件节点一致。<ul>
<li>硬链接用来指向(保存)inode编号。</li>
</ul>
</li>
</ul>
<p><strong>2、什么是软链接</strong></p>
<ul>
<li>软链接：具有完整的文件结构，最后指向的是目标文件名，它和源文件节点不一致。<ul>
<li>相当于Windows中的快捷方式，主要用来指向(保存)对应文件的路径。    </li>
</ul>
</li>
</ul>
<p><strong>3、创建命令</strong></p>
<ul>
<li><strong>ln</strong>  默认创建的就是硬链接<ul>
<li>参数： <strong>-s</strong>  创建的就是软链接      </li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 硬链接示例：ln [源文件] [链接文件名]  </span></span><br><span class="line"> [root@localhost <span class="built_in">test</span>]<span class="comment"># echo &#x27;hello world&#x27; &gt;&gt; a.txt  #创建源文件添加数据</span></span><br><span class="line">    </span><br><span class="line"> [root@localhost <span class="built_in">test</span>]<span class="comment"># ls -i 1.txt  #查看的inode编号</span></span><br><span class="line">  16781390 1.txt </span><br><span class="line">     </span><br><span class="line"> [root@localhost <span class="built_in">test</span>]<span class="comment"># ln 1.txt 2.txt   #创建硬链接</span></span><br><span class="line"> [root@localhost <span class="built_in">test</span>]<span class="comment"># ls -i 1.txt</span></span><br><span class="line">  16781390 1.txt</span><br><span class="line"> [root@localhost <span class="built_in">test</span>]<span class="comment"># ls -i 2.txt  #两个文件的inode编号一模一样，数据也一样</span></span><br><span class="line">  16781390 2.txt</span><br><span class="line">     </span><br><span class="line"><span class="comment"># 软链接示例：ln -s [源文件] [链接文件名] </span></span><br><span class="line"> [root@localhost haha]<span class="comment"># echo &#x27;123&#x27; &gt;&gt; a.txt  #创建源文件添加数据</span></span><br><span class="line">    </span><br><span class="line"> [root@localhost haha]<span class="comment"># ls -i a.txt  #查看的inode编号</span></span><br><span class="line">  33712451 a.txt</span><br><span class="line">     </span><br><span class="line"> [root@localhost haha]<span class="comment"># ln -s a.txt b.txt  #创建软链接</span></span><br><span class="line"> [root@localhost haha]<span class="comment"># ls -i a.txt  </span></span><br><span class="line">  33712451 a.txt</span><br><span class="line"> [root@localhost haha]<span class="comment"># ls -i b.txt  #两个文件的inode编号不一样，数据也一样</span></span><br><span class="line">  33712452 b.txt</span><br><span class="line">  </span><br><span class="line">			</span><br><span class="line"><span class="comment"># 删除文件的底层逻辑</span></span><br><span class="line">   1、删除的是硬链接</span><br><span class="line">   2、判断该文件硬链接数是否为0</span><br><span class="line">   3、如果为0，则在磁盘中将其删除</span><br><span class="line">   4、如果不为0，则只删除一个硬链接</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="comment"># 删除源文件软链接和硬链接的影响</span></span><br><span class="line">查看软链接文件，查看的文件不存在。和windows一样，删除源文件，快捷方式也用不了。但是删除源文件，为什么硬链接文件还可以查看呢？</span><br><span class="line">这里要简单说下i节点了。i节点是文件和目录的唯一标识，每个文件和目录必有i节点，不然操作系统就无法识别该文件或系统，就像没有上户口的黑户。linux操作系统是不识别些字母的。</span><br><span class="line"></span><br><span class="line">通俗理解：</span><br><span class="line">硬链接文件相当于文件硬链接数+1，在windows里没这个概念，删除文件删除的是硬链接数，硬链接数为0时，数据就没了</span><br><span class="line">软连接就是指向文件的路径，文件删除了，路径就不存在了，所以软连接找不到了  </span><br></pre></td></tr></table></figure>

<h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Linux⽂件没有扩展名！！！</span><br><span class="line"></span><br><span class="line"><span class="comment">#⽅法⼀：</span></span><br><span class="line"> ls -l ⽂件名  <span class="comment">#看第⼀个字符</span></span><br><span class="line">- <span class="comment">#普通⽂件（⽂本⽂件，⼆进制，压缩⽂件，电影，图⽚。。。）,例如：/bin/ls</span></span><br><span class="line">   [root@localhost ~]<span class="comment"># ls -l</span></span><br><span class="line">   -rw-r--r-- 1 root root   0 12月 14 19:11 1</span><br><span class="line"></span><br><span class="line">d <span class="comment">#⽬录⽂件，例如/home/ </span></span><br><span class="line">   [root@localhost home]<span class="comment"># ls -l</span></span><br><span class="line">   drwx------ 2 <span class="built_in">test</span> <span class="built_in">test</span> 63 12月 14 19:13 <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">b <span class="comment">#设备⽂件（块设备）存储设备硬盘，U盘，例如：/dev/sda   </span></span><br><span class="line">   [root@localhost dev]<span class="comment"># ll</span></span><br><span class="line">   brw-rw---- 1 root disk    8,   0 12月 16 19:39 sda</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c <span class="comment">#设备⽂件（字符设备）打印机，例如：/dev/ttycc</span></span><br><span class="line">   [root@localhost dev]<span class="comment"># ll</span></span><br><span class="line">   crw-rw-rw- 1 root tty     5,   0 12月 16 19:39 tty</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s <span class="comment">#套接字⽂件（socket），例如： /var/lib/mysql/</span></span><br><span class="line">   [root@localhost mysql]<span class="comment"># ll</span></span><br><span class="line">   srwxrwxrwx 1 mysql mysql   0 12月 16 21:52 mysql.sock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p <span class="comment">#管道⽂件，例如：/run/systemd/initctl/fifo</span></span><br><span class="line">   [root@localhost initctl]<span class="comment"># ll</span></span><br><span class="line">   prw------- 1 root root 0 12月 16 19:39 fifo</span><br><span class="line"></span><br><span class="line">l <span class="comment">#链接⽂件，例如：/bin</span></span><br><span class="line">   [root@localhost bin]<span class="comment"># ll</span></span><br><span class="line">   lrwxrwxrwx.   1 root root   6 12月 13 11:40 apropos -&gt; whatis</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">ps:通过颜⾊判断⽂件的类型是错误的！！！</span><br><span class="line"></span><br><span class="line"><span class="comment"># 准备套接字文件</span></span><br><span class="line">  <span class="comment">#安装mysql数据库</span></span><br><span class="line">	 [root@localhost run]<span class="comment"># yum install mariadb* -y</span></span><br><span class="line">	<span class="comment">#启动</span></span><br><span class="line">   [root@localhost run]<span class="comment"># systemctl start mariadb    </span></span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line"><span class="comment"># ⽅法⼆：大致判断文件的类型</span></span><br><span class="line">[root@xxx ~]<span class="comment"># file /etc/krb5.conf</span></span><br><span class="line">  /etc/krb5.conf: ASCII text</span><br><span class="line"></span><br><span class="line">.conf <span class="comment">#配置文件</span></span><br><span class="line">.<span class="built_in">log</span>  <span class="comment">#日志文件</span></span><br><span class="line">.sh   <span class="comment">#脚本文件</span></span><br><span class="line">.py   <span class="comment">#脚本文件 </span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统目录结构</title>
    <url>/684b776b.html</url>
    <content><![CDATA[<h1 id="重要目录文件"><a href="#重要目录文件" class="headerlink" title="重要目录文件"></a>重要目录文件</h1><h2 id="网卡配置文件"><a href="#网卡配置文件" class="headerlink" title="网卡配置文件"></a>网卡配置文件</h2><span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">文件信息：/etc/sysconfig/network-scripts/ifcfg-eth0  </span><br><span class="line">ip a</span><br><span class="line">作用：</span><br><span class="line">1、查看网卡配置</span><br><span class="line">  [root@localhost ~]<span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-eth0</span></span><br><span class="line"></span><br><span class="line">  [root@localhost ~]<span class="comment"># cat /etc/sysconfig/network-scripts/ifcfg-ens32</span></span><br><span class="line"></span><br><span class="line">  或</span><br><span class="line">  ip address show 或 nmtui</span><br><span class="line">2、重载网卡信息</span><br><span class="line">  <span class="comment"># 方式一</span></span><br><span class="line">  [root@localhost ~]<span class="comment"># systemctl restart network</span></span><br><span class="line">  <span class="comment"># 方式二</span></span><br><span class="line">	ifdown [网卡名称] &amp;&amp; ifup [网卡名称]</span><br><span class="line">		</span><br><span class="line">  关闭网络管理器（因为已经有了network）</span><br><span class="line">		systemctl  stop NetworkManager</span><br><span class="line">		systemctl  <span class="built_in">disable</span> NetworkManager</span><br><span class="line">		或</span><br><span class="line">		systemctl  <span class="built_in">disable</span> --now  NetworkManager</span><br><span class="line">		</span><br><span class="line">3、判断SSH服务是否开启</span><br><span class="line">   [root@localhost ~]<span class="comment"># systemctl status sshd</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/1113510-20170614182256790-1747672277-20211214152247352-20211214171846597.png" alt="1113510-20170614182256790-1747672277"></p>
<h2 id="解析配置文件"><a href="#解析配置文件" class="headerlink" title="解析配置文件"></a>解析配置文件</h2> <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">文件信息：/etc/resolv.conf</span><br><span class="line">作用：用于设置DNS解析地址，网卡中配置优于此文件配置</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看DNS信息</span></span><br><span class="line">  [root@test1 data]<span class="comment"># cat /etc/reslov.conf  #临时dns配置文件</span></span><br><span class="line">  nameserver 114.114.114.114  <span class="comment">#中国电信</span></span><br><span class="line"></span><br><span class="line">   223.5.5.5/223.6.6.6	 <span class="comment">#中国阿里云</span></span><br><span class="line">   8.8.8.8 谷歌</span><br></pre></td></tr></table></figure>

<h2 id="解析映射文件"><a href="#解析映射文件" class="headerlink" title="解析映射文件"></a>解析映射文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">文件信息：/etc/hosts</span><br><span class="line">作用：用于设置DNS域名与IP地址对应关系</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看解析映射文件（dns解析）</span></span><br><span class="line">   [root@localhost ~]<span class="comment"># cat /etc/hosts</span></span><br><span class="line">   127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">   ::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看系统版本</span></span><br><span class="line">   [root@localhost ~]<span class="comment"># cat /etc/redhat-release</span></span><br><span class="line">   CentOS Linux release 7.6.1810 (Core) </span><br></pre></td></tr></table></figure>

<h2 id="主机名称文件"><a href="#主机名称文件" class="headerlink" title="主机名称文件"></a>主机名称文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">文件信息：/etc/sysconfig/network</span><br><span class="line">作用：配置主机名称信息</span><br><span class="line"></span><br><span class="line">  修改主机名</span><br><span class="line">   <span class="comment">#查看主机名：</span></span><br><span class="line">    [root@localhost ~]<span class="comment"># ehco $HOSTNAME</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">#临时修改</span></span><br><span class="line">    [root@localhost ~]<span class="comment"># hostname baidu</span></span><br><span class="line">    </span><br><span class="line">   <span class="comment">#永久修改</span></span><br><span class="line">    [root@baidu ~]<span class="comment"># vim /etc/hostname	  #需要重启生效</span></span><br><span class="line">    [root@baidu ~]<span class="comment"># hostnamectl set-hostname admin	#立即生效</span></span><br></pre></td></tr></table></figure>

<h2 id="磁盘挂载文件"><a href="#磁盘挂载文件" class="headerlink" title="磁盘挂载文件"></a>磁盘挂载文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">文件信息：/etc/fstab</span><br><span class="line">作用：实现指定设备文件信息，进行开机自动挂载</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看磁盘挂载文件</span></span><br><span class="line">[root@localhost ~]<span class="comment"># cat /etc/fstab </span></span><br><span class="line"></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># /etc/fstab</span></span><br><span class="line"><span class="comment"># Created by anaconda on Mon Dec 13 11:38:54 2021</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Accessible filesystems, by reference, are maintained under &#x27;/dev/disk&#x27;</span></span><br><span class="line"><span class="comment"># See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">/dev/mapper/centos-root /        xfs     defaults    0 0  <span class="comment">#挂载在根(/)目录</span></span><br><span class="line">UUID=9f8a98b0-805c-4adf-b9ef-517a2b527f89 /boot      xfs     defaults   0 0 <span class="comment">#挂载在/boot目录</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="开机加载脚本"><a href="#开机加载脚本" class="headerlink" title="开机加载脚本"></a>开机加载脚本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">文件信息：/etc/rc.local</span><br><span class="line">作用：开启开机自启动脚本</span><br><span class="line"></span><br><span class="line">1、编辑开机自启动脚本</span><br><span class="line">	vim /etc/rc.local</span><br><span class="line">	 <span class="comment">#写入</span></span><br><span class="line">	 <span class="built_in">echo</span> <span class="string">&#x27;hello worl&#x27;</span></span><br><span class="line">2、设置开机自启动权限</span><br><span class="line">	chmod +x /etc/rc.d/rc.local</span><br><span class="line">3、重启系统</span><br></pre></td></tr></table></figure>

<h2 id="系统启动级别文件"><a href="#系统启动级别文件" class="headerlink" title="系统启动级别文件"></a>系统启动级别文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">文件信息：/etc/inittab</span><br><span class="line"></span><br><span class="line">作用：设置系统启动级别</span><br><span class="line"> 0、关机</span><br><span class="line"> 1、单用户模式(无法通过xshell的方式使用)</span><br><span class="line"> 2、多用户无网络模式</span><br><span class="line"> 3、完全多用户模式</span><br><span class="line"> 4、待定</span><br><span class="line"> 5、桌面模式</span><br><span class="line"> 6、reboot (Do NOT <span class="built_in">set</span> initdefault to this) 重启</span><br><span class="line"></span><br><span class="line">设置系统级别：</span><br><span class="line"> init [编号]	<span class="comment">#临时设置</span></span><br><span class="line"> systemctl set-default [系统启动级别]</span><br><span class="line"></span><br><span class="line">通过单用户模式修改密码</span><br><span class="line"> 1、重启</span><br><span class="line"> 2、在启动选择系统内核界面，按 e 键进入单用户模式</span><br><span class="line"> 3、找到 linux16 开头行，删除 ro ，并且在 ro 处添加 rw init=/sysroot/bin/sh</span><br><span class="line"> 4、按 ctrl + x 进行系统重新引导</span><br><span class="line"> 5、执行 chroot /sysroot</span><br><span class="line"> 6、执行 passwd root</span><br><span class="line"> 7、执行 touch /.autorelabel</span><br><span class="line"> 8、执行 Ctrl + D 重启系统</span><br></pre></td></tr></table></figure>

<h2 id="变量加载文件"><a href="#变量加载文件" class="headerlink" title="变量加载文件"></a>变量加载文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在Linux中添加环境变量怎么添加呢？</span></span><br><span class="line"></span><br><span class="line">文件信息：/etc/profile</span><br><span class="line">作用：配置环境变量和别名文件</span><br><span class="line">  文件</span><br><span class="line">    /etc/profile</span><br><span class="line">    /etc/bashrc</span><br><span class="line">    ~/.bash_profile</span><br><span class="line">    ~/.bash_rc</span><br><span class="line">  文件夹</span><br><span class="line">   /etc/profile.d/</span><br><span class="line"></span><br><span class="line">增加环境变量有两种方式：</span><br><span class="line">  1、临时添加</span><br><span class="line">  2、永久添加</span><br><span class="line"></span><br><span class="line">增加环境变量的格式：</span><br><span class="line"> <span class="built_in">export</span> PYTHON_HOME=<span class="string">&#x27;D:/python&#x27;</span></span><br><span class="line">	</span><br><span class="line">查看本机的环境变量：</span><br><span class="line">  <span class="built_in">echo</span> <span class="variable">$PYTHON_HOME</span>  <span class="comment">#查看某一个环境变量</span></span><br><span class="line">  printenv           <span class="comment">#查看所有的环境变量</span></span><br><span class="line"></span><br><span class="line">读取环境变量的几种情况，并且测试出使用文件的先后顺序</span><br><span class="line"> 1、重启</span><br><span class="line">  /etc/profile.d --&gt; /etc/profile --&gt; /etc/bashrc --&gt; ~/.bashrc --&gt; ~/.bash_profile</span><br><span class="line"> 2、切换用户</span><br><span class="line">  /etc/profile.d --&gt; /etc/bashrc --&gt; ~/.bashrc</span><br><span class="line">  知识储备</span><br><span class="line">    创建用户：</span><br><span class="line">      useradd [用户名]</span><br><span class="line">    切换用户：</span><br><span class="line">      su [用户名]</span><br><span class="line"> 3、重新登录用户</span><br><span class="line">  1、su - [用户名]</span><br><span class="line">   /etc/profile.d --&gt; /etc/profile --&gt; /etc/bashrc --&gt; ~/.bashrc --&gt; ~/.bash_profile</span><br><span class="line">			</span><br><span class="line">  2、ssh root@192.168.15.101</span><br><span class="line">   /etc/profile.d --&gt; /etc/profile --&gt; /etc/bashrc --&gt; ~/.bashrc --&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure>

<h2 id="登录提示文件"><a href="#登录提示文件" class="headerlink" title="登录提示文件"></a>登录提示文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">文件信息：/etc/motd</span><br><span class="line"></span><br><span class="line">作用：登录成功之后显示的信息。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">文件信息：/etc/issue</span><br><span class="line"></span><br><span class="line">作用：登录系统之前显示的信息。</span><br></pre></td></tr></table></figure>

<h2 id="编译安装目录"><a href="#编译安装目录" class="headerlink" title="编译安装目录"></a>编译安装目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">文件信息：/usr/<span class="built_in">local</span>  <span class="comment">#安装第三方软件的目录</span></span><br><span class="line"></span><br><span class="line">作用：编译安装软件的默认目录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">下载rpm安装包</span><br><span class="line">  <span class="comment"># yum安装python</span></span><br><span class="line">    [root@localhost ~]<span class="comment"># yum install python3</span></span><br><span class="line">  <span class="comment"># 查看软件安装路径</span></span><br><span class="line">    [root@localhost ~]<span class="comment"># which python3</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">知识储备：当前为DVD镜像需要设置阿里云的源</span><br><span class="line"> <span class="comment">#第一步：把之前的源备份换个位置</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># mv /etc/yum.repos.d/* /etc/yum.repos.d/bak</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">#第二步：下载阿里云源repo文件</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">#第三步：下载阿里云源的epel文件</span></span><br><span class="line"> [root@localhost ~]<span class="comment"># curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span></span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/image-20211214173804157.png" alt="image-20211214173804157"></p>
<h2 id="重要日志文件"><a href="#重要日志文件" class="headerlink" title="重要日志文件"></a>重要日志文件</h2><ul>
<li>系统日志目录：**/var**<ul>
<li>绝大部分的日志都存放在该目录下</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">系统日志文件</span><br><span class="line">文件信息：/var/<span class="built_in">log</span>/messages</span><br><span class="line">作用：软件安装运行以及系统运行异常日志文件</span><br><span class="line"></span><br><span class="line">  <span class="comment">#查看日志</span></span><br><span class="line">  [root@localhost /]<span class="comment"># cat /var/log/messages</span></span><br></pre></td></tr></table></figure>

<h2 id="重要信息文件"><a href="#重要信息文件" class="headerlink" title="重要信息文件"></a>重要信息文件</h2><ul>
<li>保存系统运行状态的目录：**/proc**</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">保存CPU信息情况的文件</span><br><span class="line">文件信息：：/proc/cpuinfo</span><br><span class="line">相关命令：lscpu</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">保存内存信息情况的文件</span><br><span class="line">文件信息：/proc/meminfo</span><br><span class="line">相关命令：free </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">保存系统负载信息情况的文件，用于衡量系统繁忙程度</span><br><span class="line">文件信息：/proc/loadavg</span><br><span class="line">相关命令：w</span><br><span class="line">  [root@localhost /]<span class="comment"># cat /proc/loadavg  #查看CPU负载</span></span><br><span class="line">    0.00  <span class="comment">#1分钟内的CPU负载</span></span><br><span class="line">    0.01  <span class="comment">#5分钟内的CPU负载</span></span><br><span class="line">    0.05  <span class="comment">#15分钟内的CPU负载</span></span><br><span class="line"></span><br><span class="line"> 负载：当前系统的所有进程占用CPU的时间比</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">保存系统挂载信息文件</span><br><span class="line">文件信息：/proc/mounts</span><br><span class="line">  mount</span><br><span class="line">  umount</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>vim的使用</title>
    <url>/627226e0.html</url>
    <content><![CDATA[<h1 id="系统快捷键"><a href="#系统快捷键" class="headerlink" title="系统快捷键"></a>系统快捷键</h1><span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、历史命令信息：上下键</span><br><span class="line">2、清屏命令：ctrl + l | clear</span><br><span class="line">3、中断取消命令执行过程 ： ctrl + c</span><br><span class="line">4、快速移动光标到行首尾：ctrl + a/e</span><br><span class="line">5、将光标到行首信息剪切：ctrl + u</span><br><span class="line">6、将剪切的内容进行粘贴：ctrl + y</span><br><span class="line">7、将光标到行尾信息剪切：ctrl + k</span><br><span class="line">8、锁定系统窗口信息状态：ctrl + s</span><br><span class="line">9、解锁系统窗口信息状态：ctrl + q</span><br><span class="line">10、搜索最近执行过的指令：ctrl + r</span><br><span class="line">11、命令行中快速移动光标：ctrl + 方向键</span><br><span class="line">12、退出当前的登录，相当于<span class="built_in">logout</span>：ctrl+d</span><br><span class="line">13、删除当前光标向前一组字符串，以空格为分隔符：ctrl+w</span><br><span class="line">14、杀死当前进程：ctrl+z </span><br><span class="line">15、系统命令信息补全功能：tab</span><br></pre></td></tr></table></figure>



<h1 id="文件管理基础命令"><a href="#文件管理基础命令" class="headerlink" title="文件管理基础命令"></a>文件管理基础命令</h1><h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><p>复制文件：主要可以起到数据备份的作用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">copy的缩写cp。主要作用就是复制、拷贝，没有-f选项，强制覆盖只能转义</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">	cp [参数] [被复制文件的路径] [复制到的新路径]</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">	-r : 递归复制，复制目录时所使用的</span><br><span class="line">	-p : 保持属性（时间戳、大小等）</span><br><span class="line">  -d : 复制的时候保证软连接</span><br><span class="line">  -a : 保证某些属性不变。相当于-rpd，上面三种</span><br><span class="line">  -t : 把源文件的位置与目标目录的位置进行交换，在批量拷贝文件时使用</span><br><span class="line">  -i : 默认执行，当拷贝的文件在目标目录已经存在时，提示是否覆盖</span><br><span class="line">	</span><br><span class="line">案例：</span><br><span class="line">   案例1：将/root目录下anaconda-ks.cfg复制到/tmp目录</span><br><span class="line">    [root@localhost ~]<span class="comment"># cp /root/anaconda-ks.cfg /tmp</span></span><br><span class="line">	</span><br><span class="line">   案例2：将/root目录下的<span class="built_in">test</span>文件夹及其内部的文件复制到/tmp中</span><br><span class="line">    [root@localhost ~]<span class="comment"># cp -r /root/test /tmp</span></span><br><span class="line">		</span><br><span class="line">     补充：在linux中，文件夹是不可以直接复制。</span><br><span class="line">	</span><br><span class="line">   案例3：将/etc/hosts和/etc/resolv.conf 复制到/tmp目录中</span><br><span class="line">    [root@localhost ~]<span class="comment"># cp /etc/hosts /etc/resolv.conf  /tmp</span></span><br><span class="line"></span><br><span class="line">注意：在linux没有提示就是做好的结果</span><br><span class="line"></span><br><span class="line">补充：Esc + . : 上一条命令的最后一个元素</span><br><span class="line">	 ls -l 等价于 ll</span><br><span class="line"></span><br><span class="line">知识储备：</span><br><span class="line">   linux中的链接相当于快捷方式。</span><br><span class="line">   <span class="built_in">stat</span> : 查看文件详细属性。</span><br></pre></td></tr></table></figure>

<h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p>移动文件：移动文件相当于剪切</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">负责移动或者重命名，移动目录的时候最好是加/避免改名操作</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">	mv [移动文件的原路径] [移动文件的新路径]</span><br><span class="line">	</span><br><span class="line">案例：</span><br><span class="line">	案例1：将/root目录下的1.txt移动到/opt目录中</span><br><span class="line">    [root@localhost ~]<span class="comment"># mv /root/1.txt /opt</span></span><br><span class="line"></span><br><span class="line">		<span class="comment"># 移动文件夹</span></span><br><span class="line">    [root@localhost ~]<span class="comment"># mv test/ /mnt/</span></span><br></pre></td></tr></table></figure>

<h2 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h2><p>删除文件：rm 是一个物理删除的命令，系统中的危险命令</p>
<p>删除文件有两种方式：</p>
<ul>
<li>1、物理删除：直接删除文件。</li>
<li>2、逻辑删除：将文件隐藏，没有直接删除。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	rm [参数] [需要删除文件的路径]</span><br><span class="line">参数：</span><br><span class="line">	-f : 不提示强制删除</span><br><span class="line">	-r : 递归删除目录及其内容</span><br><span class="line">	-i : 每次删除前提示是否确认删除</span><br><span class="line">	</span><br><span class="line">案例：</span><br><span class="line">	案例1：将/root目录下的1.txt删除</span><br><span class="line">		[root@localhost ~]<span class="comment"># rm 1.txt </span></span><br><span class="line">		[root@localhost ~]<span class="comment"># rm -f 1.txt </span></span><br><span class="line">	</span><br><span class="line">	案例2：删除/root目录下的<span class="built_in">test</span>文件夹及其内部所有的文件</span><br><span class="line">		[root@localhost ~]<span class="comment"># rm -r /root/test/</span></span><br><span class="line">		[root@localhost ~]<span class="comment"># rm -rf /root/test/</span></span><br><span class="line"></span><br><span class="line">补充：</span><br><span class="line">   在linux系统中，不能够直接删除文件夹。</span><br><span class="line">   linux系统中禁止使用：</span><br><span class="line">      rm -rf /* <span class="comment"># 表示删除目录下的所有文件</span></span><br><span class="line"></span><br><span class="line">解决rm命令误操作</span><br><span class="line">  将rm命令改一个名称。</span><br><span class="line">	</span><br><span class="line">知识储备：</span><br><span class="line">  查看命令存放路径：<span class="built_in">which</span></span><br></pre></td></tr></table></figure>

<h2 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h2><p>系统别名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	<span class="built_in">alias</span> xxx=<span class="string">&#x27;命令&#x27;</span></span><br><span class="line">	</span><br><span class="line">	<span class="built_in">alias</span>  ： 查看系统别名</span><br><span class="line">	<span class="built_in">alias</span> rm=<span class="string">&#x27;xxx&#x27;</span> ： 设置系统别名</span><br><span class="line"></span><br><span class="line">不使用别名，就在命令之前增加\ </span><br><span class="line">	[root@localhost ~]<span class="comment"># \rm 1.txt</span></span><br></pre></td></tr></table></figure>

<h2 id="vi-vim编辑器"><a href="#vi-vim编辑器" class="headerlink" title="vi/vim编辑器"></a>vi/vim编辑器</h2><p><strong>什么是vim</strong></p>
<p>vi和vim是Linux常用文本编辑工具，具有很强大的编辑功能，vim是vi的升级版编辑器</p>
<p><strong>为什么要使用VIM</strong><br>因为Linux系统一切皆为文件，而我们工作最多的就是修改某个服务的配置(其实就是修改文件内容)。<br>也就是说如果没有vi/vim，我们很多工作都无法完成。PS: vim是学习linux最重要的命令之一</p>
<p><strong>VI与VIM有什么区别</strong><br>vi和vim都是文本编辑器，只不过vim是vi的增强版，比vi多了语法高亮显示，其他编辑功能几乎无差，所以使用vi还是vim取决个人习惯。(相当于windows系统下的文本编辑软件“记事本”与”notepad++”的区别)</p>
<p>PS：因为前期最小化安装CentOS系统，所以默认情况下没有vim命令，但可以使用yum install vim -y</p>
<p><strong>如何使用VIM编辑器</strong></p>
<ul>
<li>vim编辑器中有三种模式<ul>
<li>命令模式：主要是使用各种快捷键，进入修改文件的第一个模式</li>
<li>末行模式：主要用于保存或退出文本。</li>
<li>编辑模式：主要进行文本内容编辑和修改</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/vim%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F.png" alt="vim三种模式"></p>
<p>小结: vim编辑打开文件整体流程如下:<br>1.默认打开文件处于普通模式<br>2.从普通模式切换至编辑模式需要使用a、i、o<br>3.编辑模式修改完毕后需要先使用ECS返回普通模式<br>4.在普通模式输入”:”或”/“进入命令模式，可实现文件的保存与退出。<br>PS: 在vim中，无法直接从编辑模式切换到命令模式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、安装vim </span><br><span class="line">	yum install vim -y</span><br><span class="line">	</span><br><span class="line">2、打开编辑文件</span><br><span class="line">	[root@localhost ~]<span class="comment"># vim 1.txt</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">3、普通模式：命令光标快速移动快捷方式</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.命令光标跳转</span></span><br><span class="line">G     <span class="comment">#快速切换光标到底行  </span></span><br><span class="line">gg    <span class="comment">#快速切换光标到首行  </span></span><br><span class="line">ngg   <span class="comment">#光标跳转至当前文件内的N行</span></span><br><span class="line">$     <span class="comment">#快速跳转到行尾</span></span><br><span class="line">^|0   <span class="comment">#快速跳转到行首</span></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.快速跳转到指定行</span></span><br><span class="line">		1、进入末行模式</span><br><span class="line">		2、输入跳转的行数</span><br><span class="line">		3、回车</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.快速复制文本内容信息</span></span><br><span class="line">yy    <span class="comment">#复制当前光标所在的行</span></span><br><span class="line">nyy   <span class="comment">#复制当前光标及光标向下的n行</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="comment">#4.快速粘贴文本内容</span></span><br><span class="line">p(小)	<span class="comment">#在当前光标的下一行粘贴</span></span><br><span class="line">P(大)  <span class="comment">#在当前光标的上一行粘贴</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#5. 删除文本内容</span></span><br><span class="line">dd    <span class="comment">#删除当前光标所在行</span></span><br><span class="line">ndd   <span class="comment">#删除当前光标所在行以及向下的n行</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="comment">#6.回撤</span></span><br><span class="line">u         <span class="comment">#撤销上一次的操作</span></span><br><span class="line">ctrl + r	<span class="comment">#退回上一次回撤</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4、进入编辑模式(从普通模式进入到编辑模式)</span><br><span class="line">	i	   <span class="comment">#在光标之前输入</span></span><br><span class="line">	o	   <span class="comment">#在光标下新创建一行空白内容</span></span><br><span class="line">	a	   <span class="comment">#在光标之后输入</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">5.文件保存与退出</span><br><span class="line"><span class="comment">#1、进入末行模式:</span></span><br><span class="line"><span class="comment">#2、操作</span></span><br><span class="line">:w      <span class="comment">#保存当前状态</span></span><br><span class="line">:w!     <span class="comment">#强制保存当前状态</span></span><br><span class="line">:q      <span class="comment">#退出当前文档(文档必须保存才能退出)</span></span><br><span class="line">:q!     <span class="comment">#强制退出文档不会修改当前内容</span></span><br><span class="line">:wq     <span class="comment">#先保存，在退出</span></span><br><span class="line">:wq!    <span class="comment">#强制保存并退出</span></span><br><span class="line">:x      <span class="comment">#先保存，在退出</span></span><br><span class="line">ZZ      <span class="comment">#保存退出, shfit+zz</span></span><br><span class="line">:number <span class="comment">#跳转至对应的行号  </span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">6.显示行号</span><br><span class="line"><span class="comment">#1、进入末行模式:</span></span><br><span class="line"><span class="comment">#2、输入:set nu</span></span><br><span class="line"><span class="comment">#3、回车</span></span><br><span class="line">	</span><br><span class="line">  </span><br><span class="line">7.取消行号</span><br><span class="line"><span class="comment">#1、进入末行模式</span></span><br><span class="line"><span class="comment">#2、输入:set nonu</span></span><br><span class="line"><span class="comment">#3、回车</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8.文件内容查找</span><br><span class="line"><span class="comment">#1、进入命令模式</span></span><br><span class="line"><span class="comment">#2、输入/</span></span><br><span class="line"><span class="comment">#3、输入搜索的内容</span></span><br><span class="line"><span class="comment">#4、回车</span></span><br><span class="line">		</span><br><span class="line">n    <span class="comment">#下一个，按搜索到的内容依次往下进行查找</span></span><br><span class="line">N    <span class="comment">#上一个，按搜索到的内容依次往上进行查找</span></span><br><span class="line"></span><br><span class="line">:<span class="built_in">set</span> ic   <span class="comment">#忽略大小写，在搜索的时候有用</span></span><br><span class="line">:<span class="built_in">set</span> ai   <span class="comment">#自动缩进</span></span><br><span class="line">:<span class="built_in">set</span> list <span class="comment">#显示制表符(空行、tab键)</span></span><br><span class="line"></span><br><span class="line">9.可视化编辑</span><br><span class="line"><span class="comment">#1、ctrl + v </span></span><br><span class="line"><span class="comment">#2、编辑：Shift + i</span></span><br><span class="line"><span class="comment">#3、按 Esc键退出即可</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">10、解决vim编辑异常</span><br><span class="line">	1、删除.1.txt.swp</span><br><span class="line">	2、继续编辑（-r）</span><br><span class="line">		[root@localhost ~]<span class="comment"># vim -r 1.txt</span></span><br><span class="line">	3、放弃编辑（-n）</span><br><span class="line">		[root@localhost ~]<span class="comment"># vim -n 1.txt</span></span><br><span class="line">		</span><br><span class="line">知识储备</span><br><span class="line">  实时监控文件内容变化：</span><br><span class="line">		tail -f [要监控的文件]</span><br><span class="line">	</span><br><span class="line">  演示vim编辑异常</span><br><span class="line">		1、查看vim进程</span><br><span class="line">      [root@localhost ~]<span class="comment"># ps -ef | grep vim</span></span><br><span class="line">		2、杀死vim进程</span><br><span class="line">      [root@localhost ~]<span class="comment"># kill -9 pid</span></span><br><span class="line">			</span><br><span class="line">  批量复制</span><br><span class="line">		[root@localhost ~]<span class="comment"># while true;do echo &quot;Hello World&quot; &gt;&gt; 1.txt; done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/vim%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="vim生命周期"></p>
<h2 id="cp-1"><a href="#cp-1" class="headerlink" title="cp"></a>cp</h2><p>复制文件：主要可以起到数据备份的作用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">copy的缩写cp。主要作用就是复制、拷贝，没有-f选项，强制覆盖只能转义</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">	cp [参数] [被复制文件的路径] [复制到的新路径]</span><br><span class="line"></span><br><span class="line">参数：</span><br><span class="line">	-r : 递归复制，复制目录时所使用的</span><br><span class="line">	-p : 保持属性（时间戳、大小等）</span><br><span class="line">  -d : 复制的时候保证软连接</span><br><span class="line">  -a : 保证某些属性不变。相当于-rpd，上面三种</span><br><span class="line">  -t : 把源文件的位置与目标目录的位置进行交换，在批量拷贝文件时使用</span><br><span class="line">  -i : 默认执行，当拷贝的文件在目标目录已经存在时，提示是否覆盖</span><br><span class="line">	</span><br><span class="line">案例：</span><br><span class="line">   案例1：将/root目录下anaconda-ks.cfg复制到/tmp目录</span><br><span class="line">    [root@localhost ~]<span class="comment"># cp /root/anaconda-ks.cfg /tmp</span></span><br><span class="line">	</span><br><span class="line">   案例2：将/root目录下的<span class="built_in">test</span>文件夹及其内部的文件复制到/tmp中</span><br><span class="line">    [root@localhost ~]<span class="comment"># cp -r /root/test /tmp</span></span><br><span class="line">		</span><br><span class="line">     补充：在linux中，文件夹是不可以直接复制。</span><br><span class="line">	</span><br><span class="line">   案例3：将/etc/hosts和/etc/resolv.conf 复制到/tmp目录中</span><br><span class="line">    [root@localhost ~]<span class="comment"># cp /etc/hosts /etc/resolv.conf  /tmp</span></span><br><span class="line"></span><br><span class="line">注意：在linux没有提示就是做好的结果</span><br><span class="line"></span><br><span class="line">补充：Esc + . : 上一条命令的最后一个元素</span><br><span class="line">	 ls -l 等价于 ll</span><br><span class="line"></span><br><span class="line">知识储备：</span><br><span class="line">   linux中的链接相当于快捷方式。</span><br><span class="line">   <span class="built_in">stat</span> : 查看文件详细属性。</span><br></pre></td></tr></table></figure>

<h2 id="mv-1"><a href="#mv-1" class="headerlink" title="mv"></a>mv</h2><p>移动文件：移动文件相当于剪切</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">负责移动或者重命名，移动目录的时候最好是加/避免改名操作</span><br><span class="line"></span><br><span class="line">格式：</span><br><span class="line">	mv [移动文件的原路径] [移动文件的新路径]</span><br><span class="line">	</span><br><span class="line">案例：</span><br><span class="line">	案例1：将/root目录下的1.txt移动到/opt目录中</span><br><span class="line">    [root@localhost ~]<span class="comment"># mv /root/1.txt /opt</span></span><br><span class="line"></span><br><span class="line">		<span class="comment"># 移动文件夹</span></span><br><span class="line">    [root@localhost ~]<span class="comment"># mv test/ /mnt/</span></span><br></pre></td></tr></table></figure>

<h2 id="rm-1"><a href="#rm-1" class="headerlink" title="rm"></a>rm</h2><p>删除文件：rm 是一个物理删除的命令，系统中的危险命令</p>
<p>删除文件有两种方式：</p>
<ul>
<li>1、物理删除：直接删除文件。</li>
<li>2、逻辑删除：将文件隐藏，没有直接删除。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">格式：</span><br><span class="line">	rm [参数] [需要删除文件的路径]</span><br><span class="line">参数：</span><br><span class="line">	-f : 不提示强制删除</span><br><span class="line">	-r : 递归删除目录及其内容</span><br><span class="line">	-i : 每次删除前提示是否确认删除</span><br><span class="line">	</span><br><span class="line">案例：</span><br><span class="line">	案例1：将/root目录下的1.txt删除</span><br><span class="line">		[root@localhost ~]<span class="comment"># rm 1.txt </span></span><br><span class="line">		[root@localhost ~]<span class="comment"># rm -f 1.txt </span></span><br><span class="line">	</span><br><span class="line">	案例2：删除/root目录下的<span class="built_in">test</span>文件夹及其内部所有的文件</span><br><span class="line">		[root@localhost ~]<span class="comment"># rm -r /root/test/</span></span><br><span class="line">		[root@localhost ~]<span class="comment"># rm -rf /root/test/</span></span><br><span class="line"></span><br><span class="line">补充：</span><br><span class="line">   在linux系统中，不能够直接删除文件夹。</span><br><span class="line">   linux系统中禁止使用：</span><br><span class="line">      rm -rf /* <span class="comment"># 表示删除目录下的所有文件</span></span><br><span class="line"></span><br><span class="line">解决rm命令误操作</span><br><span class="line">  将rm命令改一个名称。</span><br><span class="line">	</span><br><span class="line">知识储备：</span><br><span class="line">  查看命令存放路径：<span class="built_in">which</span></span><br></pre></td></tr></table></figure>

<h2 id="vi-vim编辑器-1"><a href="#vi-vim编辑器-1" class="headerlink" title="vi/vim编辑器"></a>vi/vim编辑器</h2><p><strong>什么是vim</strong></p>
<p>vi和vim是Linux常用文本编辑工具，具有很强大的编辑功能，vim是vi的升级版编辑器</p>
<p><strong>为什么要使用VIM</strong><br>因为Linux系统一切皆为文件，而我们工作最多的就是修改某个服务的配置(其实就是修改文件内容)。<br>也就是说如果没有vi/vim，我们很多工作都无法完成。PS: vim是学习linux最重要的命令之一</p>
<p><strong>VI与VIM有什么区别</strong><br>vi和vim都是文本编辑器，只不过vim是vi的增强版，比vi多了语法高亮显示，其他编辑功能几乎无差，所以使用vi还是vim取决个人习惯。(相当于windows系统下的文本编辑软件“记事本”与”notepad++”的区别)</p>
<p>PS：因为前期最小化安装CentOS系统，所以默认情况下没有vim命令，但可以使用yum install vim -y</p>
<p><strong>如何使用VIM编辑器</strong></p>
<ul>
<li>vim编辑器中有三种模式<ul>
<li>命令模式：主要是使用各种快捷键，进入修改文件的第一个模式</li>
<li>末行模式：主要用于保存或退出文本。</li>
<li>编辑模式：主要进行文本内容编辑和修改</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/vim%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F.png" alt="vim三种模式"></p>
<p>小结: vim编辑打开文件整体流程如下:<br>1.默认打开文件处于普通模式<br>2.从普通模式切换至编辑模式需要使用a、i、o<br>3.编辑模式修改完毕后需要先使用ECS返回普通模式<br>4.在普通模式输入”:”或”/“进入命令模式，可实现文件的保存与退出。<br>PS: 在vim中，无法直接从编辑模式切换到命令模式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1、安装vim </span><br><span class="line">	yum install vim -y</span><br><span class="line">	</span><br><span class="line">2、打开编辑文件</span><br><span class="line">	[root@localhost ~]<span class="comment"># vim 1.txt</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">3、普通模式：命令光标快速移动快捷方式</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.命令光标跳转</span></span><br><span class="line">G     <span class="comment">#快速切换光标到底行  </span></span><br><span class="line">gg    <span class="comment">#快速切换光标到首行  </span></span><br><span class="line">ngg   <span class="comment">#光标跳转至当前文件内的N行</span></span><br><span class="line">$     <span class="comment">#快速跳转到行尾</span></span><br><span class="line">^|0   <span class="comment">#快速跳转到行首</span></span><br><span class="line">		</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.快速跳转到指定行</span></span><br><span class="line">		1、进入末行模式</span><br><span class="line">		2、输入跳转的行数</span><br><span class="line">		3、回车</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.快速复制文本内容信息</span></span><br><span class="line">yy    <span class="comment">#复制当前光标所在的行</span></span><br><span class="line">nyy   <span class="comment">#复制当前光标及光标向下的n行</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="comment">#4.快速粘贴文本内容</span></span><br><span class="line">p(小)	<span class="comment">#在当前光标的下一行粘贴</span></span><br><span class="line">P(大)  <span class="comment">#在当前光标的上一行粘贴</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#5. 删除文本内容</span></span><br><span class="line">dd    <span class="comment">#删除当前光标所在行</span></span><br><span class="line">ndd   <span class="comment">#删除当前光标所在行以及向下的n行</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="comment">#6.回撤</span></span><br><span class="line">u         <span class="comment">#撤销上一次的操作</span></span><br><span class="line">ctrl + r	<span class="comment">#退回上一次回撤</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">4、进入编辑模式(从普通模式进入到编辑模式)</span><br><span class="line">	i	   <span class="comment">#在光标之前输入</span></span><br><span class="line">	o	   <span class="comment">#在光标下新创建一行空白内容</span></span><br><span class="line">	a	   <span class="comment">#在光标之后输入</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">5.文件保存与退出</span><br><span class="line"><span class="comment">#1、进入末行模式:</span></span><br><span class="line"><span class="comment">#2、操作</span></span><br><span class="line">:w      <span class="comment">#保存当前状态</span></span><br><span class="line">:w!     <span class="comment">#强制保存当前状态</span></span><br><span class="line">:q      <span class="comment">#退出当前文档(文档必须保存才能退出)</span></span><br><span class="line">:q!     <span class="comment">#强制退出文档不会修改当前内容</span></span><br><span class="line">:wq     <span class="comment">#先保存，在退出</span></span><br><span class="line">:wq!    <span class="comment">#强制保存并退出</span></span><br><span class="line">:x      <span class="comment">#先保存，在退出</span></span><br><span class="line">ZZ      <span class="comment">#保存退出, shfit+zz</span></span><br><span class="line">:number <span class="comment">#跳转至对应的行号  </span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">6.显示行号</span><br><span class="line"><span class="comment">#1、进入末行模式:</span></span><br><span class="line"><span class="comment">#2、输入:set nu</span></span><br><span class="line"><span class="comment">#3、回车</span></span><br><span class="line">	</span><br><span class="line">  </span><br><span class="line">7.取消行号</span><br><span class="line"><span class="comment">#1、进入末行模式</span></span><br><span class="line"><span class="comment">#2、输入:set nonu</span></span><br><span class="line"><span class="comment">#3、回车</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">8.文件内容查找</span><br><span class="line"><span class="comment">#1、进入命令模式</span></span><br><span class="line"><span class="comment">#2、输入/</span></span><br><span class="line"><span class="comment">#3、输入搜索的内容</span></span><br><span class="line"><span class="comment">#4、回车</span></span><br><span class="line">		</span><br><span class="line">n    <span class="comment">#下一个，按搜索到的内容依次往下进行查找</span></span><br><span class="line">N    <span class="comment">#上一个，按搜索到的内容依次往上进行查找</span></span><br><span class="line"></span><br><span class="line">:<span class="built_in">set</span> ic   <span class="comment">#忽略大小写，在搜索的时候有用</span></span><br><span class="line">:<span class="built_in">set</span> ai   <span class="comment">#自动缩进</span></span><br><span class="line">:<span class="built_in">set</span> list <span class="comment">#显示制表符(空行、tab键)</span></span><br><span class="line"></span><br><span class="line">9.可视化编辑</span><br><span class="line"><span class="comment">#1、ctrl + v </span></span><br><span class="line"><span class="comment">#2、编辑：Shift + i</span></span><br><span class="line"><span class="comment">#3、按 Esc键退出即可</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">10、解决vim编辑异常</span><br><span class="line">	1、删除.1.txt.swp</span><br><span class="line">	2、继续编辑（-r）</span><br><span class="line">		[root@localhost ~]<span class="comment"># vim -r 1.txt</span></span><br><span class="line">	3、放弃编辑（-n）</span><br><span class="line">		[root@localhost ~]<span class="comment"># vim -n 1.txt</span></span><br><span class="line">		</span><br><span class="line">知识储备</span><br><span class="line">  实时监控文件内容变化：</span><br><span class="line">		tail -f [要监控的文件]</span><br><span class="line">	</span><br><span class="line">  演示vim编辑异常</span><br><span class="line">		1、查看vim进程</span><br><span class="line">      [root@localhost ~]<span class="comment"># ps -ef | grep vim</span></span><br><span class="line">		2、杀死vim进程</span><br><span class="line">      [root@localhost ~]<span class="comment"># kill -9 pid</span></span><br><span class="line">			</span><br><span class="line">  批量复制</span><br><span class="line">		[root@localhost ~]<span class="comment"># while true;do echo &quot;Hello World&quot; &gt;&gt; 1.txt; done</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><img src="https://gitee.com/gengff/blogimage/raw/master/images/vim%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="vim生命周期"></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>python-并发编程</title>
    <url>/59b85335.html</url>
    <content><![CDATA[<h2 id="操作系统相关"><a href="#操作系统相关" class="headerlink" title="操作系统相关"></a>操作系统相关</h2><blockquote>
<p>操作系统就是一个协调、管理和控制计算机硬件资源和软件资源的控制程序</p>
</blockquote>
<span id="more"></span>
<h3 id="多道技术"><a href="#多道技术" class="headerlink" title="多道技术"></a>多道技术</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">一 操作系统的作用：</span><br><span class="line">    <span class="number">1</span>：隐藏丑陋复杂的硬件接口，提供良好的抽象接口</span><br><span class="line">    <span class="number">2</span>：管理、调度进程，并且将多个进程对硬件的竞争变得有序</span><br><span class="line"></span><br><span class="line">二 多道技术：</span><br><span class="line">    <span class="number">1.</span>产生背景：针对单核，实现并发</span><br><span class="line">    ps：</span><br><span class="line">    现在的主机一般是多核，那么每个核都会利用多道技术</span><br><span class="line">    有<span class="number">4</span>个cpu，运行于cpu1的某个程序遇到io阻塞，会等到io结束再重新调度，会被调度到<span class="number">4</span>个</span><br><span class="line">    cpu中的任意一个，具体由操作系统调度算法决定。</span><br><span class="line"></span><br><span class="line">    <span class="number">2.</span>空间上的复用：如内存中同时有多道程序</span><br><span class="line">    <span class="number">3.</span>时间上的复用：复用一个cpu的时间片</span><br><span class="line">    </span><br><span class="line">强调：CPU遇到I/O切，占用CPU时间过长也切，核心在于切之前将进程的状态保存下来，这样</span><br><span class="line">     才能保证下次切换回来时，能基于上次切走的位置继续运行</span><br></pre></td></tr></table></figure>

<h3 id="进程相关"><a href="#进程相关" class="headerlink" title="进程相关"></a>进程相关</h3><ul>
<li>进程:程序运行的过程，是一个动态的概念</li>
<li>程序:是一系列的代码文件，是一个静态的概念</li>
</ul>
<h3 id="并发、并行和串行"><a href="#并发、并行和串行" class="headerlink" title="并发、并行和串行"></a>并发、并行和串行</h3><ul>
<li>并发:是伪并行，多个任务看起来同时运行，单个CPU+多道技术就可以实现并发(并行也属于并发)</li>
<li>并行:多个任务真正意义上的同时运行，只有具备多个CPU才能实现并行</li>
<li>串行:一个任务运行完毕后才能开启下一个任务</li>
</ul>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/9Ihf9e.jpg" alt="9Ihf9e"></p>
<h3 id="提交任务的两种方式"><a href="#提交任务的两种方式" class="headerlink" title="提交任务的两种方式"></a>提交任务的两种方式</h3><ul>
<li><p>同步:发出一个功能调用时，在没有得到结果之前，该调用就不会返回</p>
</li>
<li><p>异步:当一个异步功能调用发出之后,调用者不能立刻得到结果，当该异步功能完成后，通过状态、通知或回调来通知调用者</p>
</li>
</ul>
<h3 id="一个任务运行的三种状态"><a href="#一个任务运行的三种状态" class="headerlink" title="一个任务运行的三种状态"></a>一个任务运行的三种状态</h3><ul>
<li><p>运行态:当前进程正在被CPU执行</p>
</li>
<li><p>阻塞态:正在执行的进程，由于等待某个事件而无法执行时，如遇到I/O</p>
</li>
<li><p>就绪态:当前进程没有被CPU执行</p>
</li>
</ul>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/RqtvS8.jpg" alt="RqtvS8"></p>
<h2 id="multiprocessing模块"><a href="#multiprocessing模块" class="headerlink" title="multiprocessing模块"></a>multiprocessing模块</h2><p>python中的多线程无法利用多核优势(<code>os.cpu_count()</code>查看)，在python大部分情况使用多进程，python提供了multipprocessing模块</p>
<p>multiprocess模块功能众多，支持子进程、通信和共享数据、执行不同形式的同步，提供了Process、Queue、Pipe、Lock等组件</p>
<p>与线程不同，进程没有任何共享状态，进程修改的数据，改动仅限于该进程内</p>
<h3 id="Process类"><a href="#Process类" class="headerlink" title="Process类"></a>Process类</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><h5 id="创建进程的类"><a href="#创建进程的类" class="headerlink" title="创建进程的类"></a>创建进程的类</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由改类实例化的对象，表示一个子进程中的任务，还没有启动</span></span><br><span class="line">Process([group [,target [, name [, args [, kwargs]]]]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 需要使用关键字的方式来指定参数</span></span><br><span class="line"><span class="comment"># 2. args指定的为传给target函数的位置参数，是一个元组形式，必须有逗号</span></span><br></pre></td></tr></table></figure>

<h5 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">group  参数未使用，值始终为<span class="literal">None</span></span><br><span class="line"></span><br><span class="line">target  表示调用对象，即子进程要执行的任务</span><br><span class="line"></span><br><span class="line">agrs  表示调用对象位置参数，是一个元组，agrs=(<span class="number">1</span>,)</span><br><span class="line"></span><br><span class="line">kwargs  表示调用对象的字典，kwargs=&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line">name  表示子进程的名称</span><br></pre></td></tr></table></figure>

<h5 id="方法介绍"><a href="#方法介绍" class="headerlink" title="方法介绍"></a>方法介绍</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.start()  启动进程</span><br><span class="line">  </span><br><span class="line">p.run()  进程启动时的运行方法，正是它去调用target指定的函数，我们自定义类的类中一定要实现该方法 </span><br><span class="line"></span><br><span class="line">p.terminate()  强制终止进程p，不会进行任何清理操作，如果p创建了子进程，该子进程就成了僵尸进程，</span><br><span class="line">    		  使用该方法需要特别小心这种情况。如果p还保存了一个锁那么也将不会被释放，进而导致死锁</span><br><span class="line"></span><br><span class="line">p.is_alive()  判断是否运行，值为<span class="literal">True</span>或<span class="literal">False</span></span><br><span class="line"></span><br><span class="line">p.join([timeout])  主线程等待p终止（强调：是主线程处于等的状态，而p是处于运行的状态）。timeout是</span><br><span class="line">      可选的 超时时间，需要强调的是，p.join只能join住start开启的进程，而不能join住run开启的进程</span><br></pre></td></tr></table></figure>

<h5 id="属性介绍"><a href="#属性介绍" class="headerlink" title="属性介绍"></a>属性介绍</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.daemon  默认值为<span class="literal">False</span>，如果设为<span class="literal">True</span>，代表p为后台运行的守护进程，当p的父进程终止时，p也随之终止，并且此时					p不能创建自己的新进程，必须在p.start()之前设置</span><br><span class="line"></span><br><span class="line">p.name  进程名称</span><br><span class="line"></span><br><span class="line">p.pid  进程的pid</span><br><span class="line"></span><br><span class="line">p.exitcode  进程在运行时为<span class="literal">None</span>、如果为–N，表示被信号N结束</span><br><span class="line"></span><br><span class="line">p.authkey  进程的身份验证键,默认是由os.urandom()随机生成的<span class="number">32</span>字符的字符串。这个键的用途是为涉及网络连接的        底层进程间通信提供安全性，这类连接只有在具有相同的身份验证键时才能成功</span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><blockquote>
<p>在Windows中<code>Process()</code>必须放到<code>if name == &#39;main&#39;:</code>下</p>
</blockquote>
<h5 id="开启进程方式一"><a href="#开启进程方式一" class="headerlink" title="开启进程方式一"></a>开启进程方式一</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程: %s , 自己进程 %s 正在运行&#x27;</span> % (os.getppid(), os.getpid()))</span><br><span class="line">    time.sleep(n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;父进程: %s , 自己进程 %s 正在运行&#x27;</span> % (os.getppid(), os.getpid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target=task, args=(<span class="number">3</span>,))</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主进程 %s &#x27;</span> % os.getpid())</span><br></pre></td></tr></table></figure>

<h5 id="开启进程方式二"><a href="#开启进程方式二" class="headerlink" title="开启进程方式二"></a>开启进程方式二</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span>(<span class="params">Process</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;父进程 %s , 自己 %s 正在运行&#x27;</span> % (os.getppid(), os.getpid()))</span><br><span class="line">        time.sleep(self.n)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;父进程 %s , 自己 %s 正在运行&#x27;</span> % (os.getppid(), os.getpid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = MyProcess(<span class="number">3</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主进程 %s &#x27;</span> % os.getpid())</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>os.getpid()</code>获取当前进程pid</p>
<p><code>os.getppid()</code>获取当前进程的父进程pid</p>
</blockquote>
<h5 id="进程之间的内存空间是隔离的"><a href="#进程之间的内存空间是隔离的" class="headerlink" title="进程之间的内存空间是隔离的"></a>进程之间的内存空间是隔离的</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">count = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;自己&#x27;</span>, count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target=task)</span><br><span class="line">    p.start()</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主 %s&#x27;</span> % count)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 100</span></span><br></pre></td></tr></table></figure>

<h5 id="进程对象的方法"><a href="#进程对象的方法" class="headerlink" title="进程对象的方法"></a>进程对象的方法</h5><ul>
<li><p><code>join() </code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span>(<span class="params">Process</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 正在运行, 进程号是 %s&#x27;</span> % (self.name, os.getpid()))</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 运行结束, 进程号是 %s &#x27;</span> % (self.name, os.getpid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = MyProcess(<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join()  <span class="comment"># 保证子进程结束后才会向下执行，当前主线程处于等的状态，而p是处于运行的状态</span></span><br><span class="line">    <span class="comment"># p.join(2)  # 指定等待p子进程的时间，如果子进程p运行完直接往下执行，如果等了2s之后还没执行完也会向下执行</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;开始 主进程 %s &#x27;</span> % os.getpid())</span><br></pre></td></tr></table></figure>

<p>该方法并不是串行：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span>(<span class="params">Process</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 正在运行, 进程号是 %s&#x27;</span> % (self.name, os.getpid()))</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 运行结束, 进程号是 %s &#x27;</span> % (self.name, os.getpid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p1 = MyProcess(<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">    p2 = MyProcess(<span class="string">&#x27;p2&#x27;</span>)</span><br><span class="line">    p3 = MyProcess(<span class="string">&#x27;p3&#x27;</span>)</span><br><span class="line">    p4 = MyProcess(<span class="string">&#x27;p4&#x27;</span>)</span><br><span class="line">    p5 = MyProcess(<span class="string">&#x27;p5&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 这几个进程是差不多一起一起的,并不是启动一个执行完之后再运行第二个进程,是让主进程等,而不是让后面的子进程等</span></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line">    p4.start()</span><br><span class="line">    p5.start()</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># p_list = [p1, p2, p3, p4, p5]</span></span><br><span class="line">    <span class="comment"># for p in p_list:</span></span><br><span class="line">    <span class="comment">#     p.start()</span></span><br><span class="line">		</span><br><span class="line">    <span class="comment"># 但是当 p1 执行完成后确实要等后面的 p2-p5 进程执行完成后才能继续往后</span></span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    p3.join()</span><br><span class="line">    p4.join()</span><br><span class="line">    p5.join()</span><br><span class="line">    </span><br><span class="line">		<span class="comment">#for p in p_list:</span></span><br><span class="line">    <span class="comment">#    p.join()</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主进程 %s &#x27;</span> % os.getpid())</span><br></pre></td></tr></table></figure></li>
<li><p><code>terminate()和is_alive()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is run, task is %s &#x27;</span> % (name, os.getppid()))</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is end,task is %s &#x27;</span> % (name, os.getpid()))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target=task, args=(<span class="string">&#x27;test&#x27;</span>,))</span><br><span class="line">    p.start()</span><br><span class="line">    p.terminate()  <span class="comment"># 关闭进程，不会立即关闭</span></span><br><span class="line">    <span class="built_in">print</span>(p.is_alive())  <span class="comment"># 所以此时查看进程是否存活时为True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main is start &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(p.is_alive())  <span class="comment"># 子进程已经关闭了，此时为False</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>name和pid</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span>(<span class="params">Process</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">      </span><br><span class="line">        <span class="comment"># self.name=name</span></span><br><span class="line">        <span class="comment"># super().__init__() #Process的__init__方法会执行self.name=Piao-1,</span></span><br><span class="line">        <span class="comment">#                    #所以加到这里,会覆盖我们的self.name=name</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#为我们开启的进程设置名字的做法</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is run&#x27;</span> % self.name)</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is end&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = MyProcess(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line">    p.start()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;main is run&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(p.pid)  <span class="comment"># 查看pid</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="进程相关-1"><a href="#进程相关-1" class="headerlink" title="进程相关"></a>进程相关</h2><blockquote>
<p>参考: <a href="https://www.cnblogs.com/Anker/p/3271773.html">https://www.cnblogs.com/Anker/p/3271773.html</a></p>
</blockquote>
<h3 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程</span><br><span class="line">僵尸进程虽然不会占用内存CPU等系统资源，但是PID号如果过多之后，操作系统也无法创建新PID号</span><br></pre></td></tr></table></figure>

<ul>
<li><p>产生僵尸进程</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子&#x27;</span>, os.getpid())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p = Process(target=run)</span><br><span class="line">    p.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主&#x27;</span>, os.getpid())</span><br><span class="line">    time.sleep(<span class="number">1000</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>查看僵尸进程<br><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/sfHAIh.png" alt="sfHAIh"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps aux|grep Z  <span class="comment"># SATA 显示 Z 就是僵尸进程</span></span><br></pre></td></tr></table></figure></li>
<li><p>解决办法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 杀死父进程  </span><br><span class="line">			kill -CHLD 父进程的pid  </span><br><span class="line">  		kill -<span class="number">9</span> 父进程的pid</span><br><span class="line"><span class="number">2.</span> 对开启的子进程应该记得使用join，join会回收僵尸进程</span><br><span class="line"><span class="number">3.</span> https://blog.csdn.net/u010571844/article/details/<span class="number">50419798</span></span><br></pre></td></tr></table></figure></li>
<li><p>问题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time,os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is running&#x27;</span> %os.getpid())</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p=Process(target=task)</span><br><span class="line">    p.start()</span><br><span class="line">    p.join() <span class="comment"># 等待进程p结束后，join函数内部会发送系统调用wait，去告诉操作系统回收掉进程p的id号</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(p.pid) <span class="comment">#？？？此时能否看到子进程p的id号</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># p.join()是像操作系统发送请求，告知操作系统p的id号不需要再占用了，回收就可以，</span></span><br><span class="line"><span class="comment"># 此时在父进程内还可以看到p.pid,但此时的p.pid是一个无意义的id号，因为操作系统已经将该编号回收</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">当父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程，由于进程不可能脱离进程树而独立存在，孤儿进程将被PID为<span class="number">1</span>的init进程所收养，并由init进程对它们完成状态收集工作。孤儿进程被收养后进行正常的释放，没有危害</span><br></pre></td></tr></table></figure>

<ul>
<li><p>演示代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;子&#x27;</span>, os.getpid())</span><br><span class="line">    time.sleep(<span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    p1 = Process(target=run)</span><br><span class="line">    p2 = Process(target=run)</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主&#x27;</span>, os.getpid())</span><br></pre></td></tr></table></figure></li>
<li><p>现象</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20211216191021094.png" alt="image-20211216191021094"></p>
<p>两个子进程并没有退出，此时两个子进程的父进程由 1 接管，当时间久了之后会被释放掉</p>
</li>
</ul>
<h3 id="守护进程"><a href="#守护进程" class="headerlink" title="守护进程"></a>守护进程</h3><p>主进程创建守护进程</p>
<ol>
<li>守护进程会在主进程代码执行结束后就终止</li>
<li>守护进程内无法再开启子进程，否则抛出异常: AssertionError: daemonic processes are not allowed to have children</li>
</ol>
<p>注意：进程之间是互相独立的，主进程代码运行结束，守护进程随即终止</p>
<ul>
<li><p>实例代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span>(<span class="params">Process</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is run&#x27;</span> % self.name)</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is end &#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = MyProcess(<span class="string">&#x27;p1&#x27;</span>)</span><br><span class="line">p1.daemon = <span class="literal">True</span>  <span class="comment"># 一定要在p.start()前设置,设置p为守护进程,禁止p创建子进程,并且父进程代码执行结束,p即终止运行</span></span><br><span class="line"></span><br><span class="line">p1.start()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;main is run&#x27;</span>, os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 结果：main is run 可以看到子线程没有执行 </span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><blockquote>
<p>进程之间数据不共享,但是共享同一套文件系统,所以访问同一个文件,或同一个打印终端,是没有问题的</p>
<p>而共享带来的是竞争，竞争带来的结果就是错乱，如何控制，就是加锁处理</p>
</blockquote>
<h4 id="代码一"><a href="#代码一" class="headerlink" title="代码一"></a>代码一</h4><p> 没加锁的情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os, time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is run &#x27;</span> % os.getpid())</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is end &#x27;</span> % os.getpid())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        p = Process(target=work)</span><br><span class="line">        p.start()</span><br><span class="line"><span class="comment"># 并发运行,效率高,但竞争同一打印终端,带来了打印错乱</span></span><br></pre></td></tr></table></figure>



<p>加锁之后的情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#由并发变成了串行,牺牲了运行效率,但避免了竞争</span></span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Lock</span><br><span class="line"><span class="keyword">import</span> os, time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span>(<span class="params">lock</span>):</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is run &#x27;</span> % os.getpid())</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is end &#x27;</span> % os.getpid())</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lock = Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        p = Process(target=work, args=(lock,))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>



<h4 id="代码二"><a href="#代码二" class="headerlink" title="代码二"></a>代码二</h4><p>文件当数据库,模拟抢票</p>
<p>不加锁的情况</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 并发运行，效率高，但是在竞争一个文件，数据写入错乱</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>():</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;db.json&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        dic = json.load(f)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\033[43m剩余票数%s\033[0m&#x27;</span> % dic[<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>():</span></span><br><span class="line">    dic = json.load(<span class="built_in">open</span>(<span class="string">&#x27;db.json&#x27;</span>))</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">if</span> dic[<span class="string">&#x27;count&#x27;</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        dic[<span class="string">&#x27;count&#x27;</span>] -= <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        json.dump(dic, <span class="built_in">open</span>(<span class="string">&#x27;db.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\033[43m购票成功\033[0m&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">lock</span>):</span></span><br><span class="line">    search()</span><br><span class="line">    get()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lock = Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        p = Process(target=task, args=(lock,))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<p>加锁之后</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查票还是并发，但是在购票的时候由并发变成了串行，牺牲了运行效率，但保证了数据安全</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span>():</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;db.json&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        dic = json.load(f)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;\033[43m剩余票数%s\033[0m&#x27;</span> % dic[<span class="string">&#x27;count&#x27;</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span>():</span></span><br><span class="line">    dic = json.load(<span class="built_in">open</span>(<span class="string">&#x27;db.json&#x27;</span>))</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    <span class="keyword">if</span> dic[<span class="string">&#x27;count&#x27;</span>] &gt; <span class="number">0</span>:</span><br><span class="line">        dic[<span class="string">&#x27;count&#x27;</span>] -= <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">0.2</span>)</span><br><span class="line">        json.dump(dic, <span class="built_in">open</span>(<span class="string">&#x27;db.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;\033[43m购票成功\033[0m&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;没票了&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">lock</span>):</span></span><br><span class="line">    search()</span><br><span class="line">    lock.acquire()</span><br><span class="line">    get()</span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lock = Lock()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        p = Process(target=task, args=(lock,))</span><br><span class="line">        p.start()</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#加锁可以保证多个进程修改同一块数据时，同一时间只能有一个任务可以进行修改，即串行的修改，没错，速度是慢了，但牺牲了速度却保证了数据安全。</span></span><br><span class="line">虽然可以用文件共享数据实现进程间通信，但问题是：</span><br><span class="line"><span class="number">1.</span>效率低（共享数据基于文件，而文件是硬盘上的数据）</span><br><span class="line"><span class="number">2.</span>需要自己加锁处理</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#因此我们最好找寻一种解决方案能够兼顾：1、效率高（多个进程共享一块内存的数据）2、帮我们处理好锁问题。这就是mutiprocessing模块为我们提供的基于消息的IPC通信机制：队列和管道。</span></span><br><span class="line"><span class="number">1</span> 队列和管道都是将数据存放于内存中</span><br><span class="line"><span class="number">2</span> 队列又是基于（管道+锁）实现的，可以让我们从复杂的锁问题中解脱出来，</span><br><span class="line">我们应该尽量避免使用共享数据，尽可能使用消息传递和队列，避免处理复杂的同步和锁问题，而且在进程数目增多时，往往可以获得更好的可获展性。</span><br></pre></td></tr></table></figure>

<h3 id="IPC机制"><a href="#IPC机制" class="headerlink" title="IPC机制"></a>IPC机制</h3><p>进程彼此之间互相隔离，要实现进程之间通信（IPC），multiprocessing模块支持两种形式：队列和管道，这两种方式都是使用消息传递的</p>
<ul>
<li><p>管道</p>
<p>ps -ef |grep xx  前面的进程产生的数据交给后面的进程</p>
</li>
</ul>
<h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><blockquote>
<p>底层就是以管道和锁定的方式实现</p>
</blockquote>
<p>创建队列的类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Queue([maxsize]):创建共享的进程队列，Queue是多进程安全的队列，可以使用Queue实现多进程之间的数据传递</span><br><span class="line">maxsize是队列中允许最大项数，省略则无大小限制</span><br></pre></td></tr></table></figure>

<p>主要方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">q.put方法用以插入数据到队列中，put方法还有两个可选参数：blocked和timeout。blocked为<span class="literal">True</span>（默认值）如果</span><br><span class="line">队列满了就锁住了并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。如果超时，会</span><br><span class="line">抛出Queue.Full异常。如果blocked为<span class="literal">False</span>，但该Queue已满，会立即抛出Queue.Full异常。</span><br><span class="line"></span><br><span class="line">q.get方法可以从队列读取并且删除一个元素。同样，get方法有两个可选参数：blocked和timeout。如果blocked</span><br><span class="line">为<span class="literal">True</span>（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。如果</span><br><span class="line">blocked为<span class="literal">False</span>有两种情况存在，如果Queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出</span><br><span class="line">Queue.Empty异常.</span><br><span class="line"></span><br><span class="line">q.get_nowait():同q.get(<span class="literal">False</span>)</span><br><span class="line">    </span><br><span class="line">q.put_nowait():同q.put(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line">q.empty():调用此方法时q为空则返回<span class="literal">True</span>，该结果不可靠，比如在返回<span class="literal">True</span>的过程中，如果队列中又加入了项目。</span><br><span class="line">    </span><br><span class="line">q.full()：调用此方法时q已满则返回<span class="literal">True</span>，该结果不可靠，比如在返回<span class="literal">True</span>的过程中，如果队列中的项目被取走。</span><br><span class="line"></span><br><span class="line">q.qsize():返回队列中目前项目的正确数量，结果也不可靠，理由同q.empty()和q.full()一样</span><br></pre></td></tr></table></figure>

<p>其他方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">q.cancel_join_thread():不会在进程退出时自动连接后台线程。可以防止join_thread()方法阻塞</span><br><span class="line">    </span><br><span class="line">q.close():关闭队列，防止队列中加入更多数据。调用此方法，后台线程将继续写入那些已经入队列但尚未写入的</span><br><span class="line">          数据，但将在此方法完成时马上关闭。如果q被垃圾收集，将调用此方法。关闭队列不会在队列使用者中</span><br><span class="line">          产生任何类型的数据结束信号或异常。例如，如果某个使用者正在被阻塞在get()操作上，关闭生产者中</span><br><span class="line">          的队列不会导致get()方法返回错误。</span><br><span class="line">        </span><br><span class="line">q.join_thread()：连接队列的后台线程。此方法用于在调用q.close()方法之后，等待所有队列项被消耗。默认</span><br><span class="line">                 情况下，此方法由不是q的原始创建者的所有进程调用。调用q.cancel_join_thread方法可</span><br><span class="line">                 以禁 止这种行为</span><br></pre></td></tr></table></figure>

<p>应用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">q = Queue(<span class="number">3</span>)  <span class="comment"># 创建共享的进程队列，指定队列长度为3，最多放三个值，超过3个无法放入</span></span><br><span class="line">q.put(<span class="number">1</span>)</span><br><span class="line">q.put(<span class="number">2</span>)</span><br><span class="line">q.put(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(q.full())</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"><span class="built_in">print</span>(q.empty())</span><br><span class="line"><span class="comment"># print(q.get())  # 超值取不到q.get()默认为 q.get(block=True,timeout=None)</span></span><br><span class="line"><span class="comment"># print(q.get(block=True,timeout=3)) # 取不到三秒抛出异常</span></span><br><span class="line"><span class="built_in">print</span>(q.get(block=<span class="literal">False</span>))  <span class="comment"># 取不到值立马抛异常</span></span><br></pre></td></tr></table></figure>

<h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><blockquote>
<p>在并发编程中使用生产者和消费者模式能够解决绝大多数并发问题。该模式通过平衡生产线程和消费线程的工作能力来提高程序的整体处理数据的速度</p>
</blockquote>
<ul>
<li><p>为什么要使用生产者和消费者模式</p>
<ul>
<li>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这个问题于是引入了生产者和消费者模式</li>
</ul>
</li>
<li><p>什么是生产者消费者模式</p>
<ul>
<li>生产者消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力</li>
</ul>
</li>
<li><p>总结</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#程序中有两类角色</span></span><br><span class="line">    一类负责生产数据（生产者）</span><br><span class="line">    一类负责处理数据（消费者）</span><br><span class="line">    </span><br><span class="line"><span class="comment">#引入生产者消费者模型为了解决的问题是</span></span><br><span class="line">    平衡生产者与消费者之间的工作能力，从而提高程序整体处理数据的速度</span><br><span class="line">    </span><br><span class="line"><span class="comment">#如何实现</span></span><br><span class="line">    生产者&lt;--&gt;队列&lt;——&gt;消费者</span><br><span class="line"><span class="comment">#生产者消费者模型实现类程序的解耦和</span></span><br></pre></td></tr></table></figure>

<p>基于队列实现生产者消费者模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"><span class="keyword">import</span> time, os, random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">q, name, courier</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        res = <span class="string">&#x27;%s  %s &#x27;</span> % (courier, i)</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        q.put(res)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 送来 %s &#x27;</span> % (name, res))</span><br><span class="line">    q.put(<span class="literal">None</span>)  <span class="comment"># 结束之后发送None信息到队里里面，有几个消费者就发几个None</span></span><br><span class="line">    q.put(<span class="literal">None</span>) </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">q, name</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = q.get()</span><br><span class="line">        <span class="keyword">if</span> res <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 拿到了 %s&#x27;</span> % (name, res))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = Queue()</span><br><span class="line"></span><br><span class="line">    p1 = Process(target=producer, args=(q, <span class="string">&#x27;快递员1&#x27;</span>, <span class="string">&#x27;sf&#x27;</span>))</span><br><span class="line">    p2 = Process(target=producer, args=(q, <span class="string">&#x27;快递员2&#x27;</span>, <span class="string">&#x27;yz&#x27;</span>))</span><br><span class="line">    p3 = Process(target=producer, args=(q, <span class="string">&#x27;快递员3&#x27;</span>, <span class="string">&#x27;jd&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    c1 = Process(target=consumer, args=(q, <span class="string">&#x27;拿货人1&#x27;</span>))</span><br><span class="line">    c2 = Process(target=consumer, args=(q, <span class="string">&#x27;拿货人2&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    p3.start()</span><br><span class="line"></span><br><span class="line">    c1.start()</span><br><span class="line">    c2.start()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is run &#x27;</span> % os.getpid())</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>JoinableQueue([maxsize])`</strong></p>
<blockquote>
<p>这就像是一个Queue对象，但队列允许项目的使用者通知生成者项目已经被成功处理。通知进程是使用共享的信号和条件变量来实现的。</p>
</blockquote>
<p>  介绍</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#参数介绍：</span></span><br><span class="line">   maxsize是队列中允许最大项数，省略则无大小限制。    </span><br><span class="line">  　 <span class="comment">#方法介绍：</span></span><br><span class="line">  JoinableQueue的实例p除了与Queue对象相同的方法之外还具有：</span><br><span class="line">  q.task_done()：使用者使用此方法发出信号，表示q.get()的返回项目已经被处理。如果调用此方法的次数大于从队列中删除项目的数量，将引发ValueError异常</span><br><span class="line">  q.join():生产者调用此方法进行阻塞，直到队列中所有的项目均被处理。阻塞将持续到队列中的每个项目均调用q.task_done（）方法为止</span><br></pre></td></tr></table></figure>

<p>优化上面队列代码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, JoinableQueue</span><br><span class="line"><span class="keyword">import</span> time, os, random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span>(<span class="params">q, name, courier</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">        res = <span class="string">&#x27;%s  %s &#x27;</span> % (courier, i)</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        q.put(res)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 送来 %s &#x27;</span> % (name, res))</span><br><span class="line">    q.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span>(<span class="params">q, name</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        res = q.get()</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 拿到了 %s&#x27;</span> % (name, res))</span><br><span class="line">        q.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    q = JoinableQueue()</span><br><span class="line"></span><br><span class="line">    p1 = Process(target=producer, args=(q, <span class="string">&#x27;快递员1&#x27;</span>, <span class="string">&#x27;sf&#x27;</span>))</span><br><span class="line">    p2 = Process(target=producer, args=(q, <span class="string">&#x27;快递员2&#x27;</span>, <span class="string">&#x27;yz&#x27;</span>))</span><br><span class="line">    p3 = Process(target=producer, args=(q, <span class="string">&#x27;快递员3&#x27;</span>, <span class="string">&#x27;jd&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    c1 = Process(target=consumer, args=(q, <span class="string">&#x27;拿货人1&#x27;</span>))</span><br><span class="line">    c2 = Process(target=consumer, args=(q, <span class="string">&#x27;拿货人2&#x27;</span>))</span><br><span class="line">    c1.daemon = <span class="literal">True</span>  <span class="comment"># 主进程结束顺便带走了守护进程</span></span><br><span class="line">    c2.daemon = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    p_l = [p1, p2, p3, c1, c2]</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> p_l:</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">    p1.join()</span><br><span class="line">    p2.join()</span><br><span class="line">    p3.join()  <span class="comment"># p1、p2、p3都结束，代表队列一定被取空</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is run &#x27;</span> % os.getpid())</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#主进程等---&gt;p1,p2,p3等----&gt;c1,c2</span></span><br><span class="line"><span class="comment">#p1,p2,p3结束了,证明c1,c2肯定全都收完了p1,p2,p3发到队列的数据</span></span><br><span class="line"><span class="comment">#因而c1,c2也没有存在的价值了,应该随着主进程的结束而结束,所以设置成守护进程</span></span><br></pre></td></tr></table></figure>

<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><blockquote>
<p>互斥锁 同时只允许一个线程更改数据，而Semaphore是同时允许一定数量的线程更改数据 ，比如厕所有3个坑，那最多只允许3个人上厕所，后面的人只能等里面有人出来了才能再进去，如果指定信号量为3，那么来一个人获得一把锁，计数加1，当计数等于3时，后面的人均需要等待。一旦释放，就有人可以获得一把锁</p>
<p>信号量与进程池的概念很像，但是要区分开，信号量涉及到加锁的概念</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Semaphore</span><br><span class="line"><span class="keyword">import</span> os, time, random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">go_wc</span>(<span class="params">sem, user</span>):</span></span><br><span class="line">    sem.acquire()  <span class="comment"># 运行的时候都会抢这把锁</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s 占到一个茅坑&#x27;</span> % user)</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>, <span class="number">3</span>))</span><br><span class="line">    sem.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sem = Semaphore(<span class="number">5</span>)  <span class="comment"># 创建信号量，自定义为5，相当于5把钥匙得到信号量对象</span></span><br><span class="line">    p_l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        p = Process(target=go_wc, args=(sem,<span class="string">&#x27;user%s&#x27;</span> % i,))</span><br><span class="line">        p.start()</span><br><span class="line">        p_l.append(p)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> p_l:</span><br><span class="line">        i.join()</span><br><span class="line">        </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">ps：互斥锁只能acquire一次，再有人来执行acquire，如果没有释放，下一个来拿的人就只能阻在原地无法拿到acquire。而信号量一把锁可以acquire指定5次（Semaphore(5)），如果第6个来在</span></span><br><span class="line"><span class="string">acquire的时候就没有了，相当于没有钥匙了，就只能在原地等着，只要5个人里面有人释放后面的人就</span></span><br><span class="line"><span class="string">可以拿到钥匙</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span>     </span><br></pre></td></tr></table></figure>

<h2 id="线程相关"><a href="#线程相关" class="headerlink" title="线程相关"></a>线程相关</h2><p>线程是进程内代码运行的过程，线程是一个执行单位，CPU执行的就是线程。进程是一个资源单位</p>
<p>线程和进程的区别</p>
<ol>
<li>同一进程下的多个线程共享该进程的内存资源，线程之间可以互相通信</li>
<li>开启子线程的开销要远远小于开启子线程</li>
</ol>
<p><strong>线程相关的方法</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Thread实例对象的方法</span><br><span class="line">  <span class="comment"># isAlive(): 返回线程是否活动的。</span></span><br><span class="line">  <span class="comment"># getName(): 返回线程名。</span></span><br><span class="line">  <span class="comment"># setName(): 设置线程名。</span></span><br><span class="line"></span><br><span class="line">threading模块提供的一些方法：</span><br><span class="line">  <span class="comment"># threading.currentThread(): 返回当前的线程变量。</span></span><br><span class="line">  <span class="comment"># threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</span></span><br><span class="line">  <span class="comment"># threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</span></span><br></pre></td></tr></table></figure>



<h3 id="开启线程的两种方式"><a href="#开启线程的两种方式" class="headerlink" title="开启线程的两种方式"></a>开启线程的两种方式</h3><ul>
<li><p>方式一</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, current_thread</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is running &#x27;</span> % current_thread().name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = Thread(target=task)</span><br><span class="line">    t.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主线程&#x27;</span>, current_thread().name)</span><br></pre></td></tr></table></figure></li>
<li><p>方式二</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, current_thread</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="params">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s is running &#x27;</span> % current_thread().name)  <span class="comment"># 打印当前线程名</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = MyThread()</span><br><span class="line">    t.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主线程&#x27;</span>, current_thread().name)</span><br></pre></td></tr></table></figure></li>
</ul>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/ggLKKR.jpg" alt="ggLKKR"></p>
<ul>
<li>线程之间数据相互影响</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, current_thread</span><br><span class="line">n = <span class="number">100</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = Thread(target=task)</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()  <span class="comment"># 让线程运行完成，避免有可能出现主线程先打印 n 的情况</span></span><br><span class="line">    <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure>



<h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><blockquote>
<p><strong>无论是进程还是线程，都遵循：守护xxx会等待主xxx运行完毕后被销毁</strong></p>
<p><strong>需要强调的是：运行完毕并非终止运行</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 对主进程来说，运行完毕指的是主进程代码运行完毕</span><br><span class="line">2. 对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才算运行完毕</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 主进程在其代码结束后就已经算运行完毕了（守护进程在此时就被回收）,然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源(否则会产生僵尸进程)，才会结束</span><br><span class="line">2. 主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束</span><br></pre></td></tr></table></figure>



<p>代码案例</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, current_thread</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is running&#x27;</span> % current_thread().name)</span><br><span class="line">    time.sleep(n)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is end&#x27;</span> % current_thread().name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = Thread(target=task, args=(<span class="number">2</span>,))</span><br><span class="line">    t2 = Thread(target=task, args=(<span class="number">3</span>,))</span><br><span class="line">    t3 = Thread(target=task, args=(<span class="number">300</span>,))</span><br><span class="line">    t3.daemon = <span class="literal">True</span>  <span class="comment"># t3最后的end并没有执行</span></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t3.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主&#x27;</span>)  <span class="comment"># 主线程要等子线程执行完后才结束</span></span><br></pre></td></tr></table></figure>

<h3 id="互斥锁-1"><a href="#互斥锁-1" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>现象: </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, current_thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">n = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    temp = n</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)  <span class="comment"># 线程速度太快了，如果不加sleep能减完，但是处理速度如果慢的情况下就会数据错乱</span></span><br><span class="line">    n = temp - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    thread_l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        t = Thread(target=task)</span><br><span class="line">        thread_l.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> thread_l:</span><br><span class="line">        obj.join()</span><br><span class="line">    <span class="built_in">print</span>(n)  <span class="comment"># 99</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>加锁</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, current_thread,Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">n = <span class="number">100</span></span><br><span class="line">mutex = Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    <span class="keyword">with</span> mutex:</span><br><span class="line">        temp = n</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line">        n = temp - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    thread_l = []</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        t = Thread(target=task)</span><br><span class="line">        thread_l.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> thread_l:</span><br><span class="line">        obj.join()</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;结果是 %s, 运行时间: %s &#x27;</span> % (n, end_time - start_time))  <span class="comment"># 结果是 0, 运行时间: 10.33482813835144 </span></span><br></pre></td></tr></table></figure>

<h3 id="信号量-1"><a href="#信号量-1" class="headerlink" title="信号量"></a>信号量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Semaphore</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    sm.acquire()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s get sm&#x27;</span> % threading.current_thread().getName())</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    sm.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    sm = Semaphore(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">23</span>):</span><br><span class="line">        t = Thread(target=func)</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure>

<h3 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h3><p>同进程的一样</p>
<p>线程的一个关键特性是每个线程都是独立运行且状态不可预测。如果程序中的其 他线程需要通过判断某个线程的状态来确定自己下一步的操作,这时线程同步问题就会变得非常棘手。为了解决这些问题,我们需要使用threading库中的Event对象。 对象包含一个可由线程设置的信号标志,它允许线程等待某些事件的发生。在 初始情况下,Event对象中的信号标志被设置为假。如果有线程等待一个Event对象, 而这个Event对象的标志为假,那么这个线程将会被一直阻塞直至该标志为真。一个线程如果将一个Event对象的信号标志设置为真,它将唤醒所有等待这个Event对象的线程。如果一个线程等待一个已经被设置为真的Event对象,那么它将忽略这个事件, 继续执行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">event.isSet()：返回event的状态值；</span><br><span class="line"></span><br><span class="line">event.wait()：如果 event.isSet()==<span class="literal">False</span>将阻塞线程；</span><br><span class="line"></span><br><span class="line">event.<span class="built_in">set</span>()： 设置event的状态值为<span class="literal">True</span>，所有阻塞池的线程激活进入就绪状态， 等待操作系统调度；</span><br><span class="line"></span><br><span class="line">event.clear()：恢复event的状态值为<span class="literal">False</span></span><br></pre></td></tr></table></figure>



<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/yFh1Wi.jpg" alt="yFh1Wi"></p>
<p><strong>案例代码一</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Event, Thread, current_thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">e = Event()  <span class="comment"># 全局变量为False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is running &#x27;</span> % current_thread().name)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    e.<span class="built_in">set</span>()  <span class="comment"># 全局变量为True</span></span><br><span class="line">    <span class="comment"># e.clear()  # 全局变量 = False</span></span><br><span class="line">    <span class="comment"># e.is_set()  # 判断是否set过</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">    e.wait()  <span class="comment"># 等全局变量变为True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is running &#x27;</span> % current_thread().name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = Thread(target=f1)</span><br><span class="line">    t2 = Thread(target=f2)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure>

<p><strong>模拟红绿灯</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Event, Thread, current_thread</span><br><span class="line"><span class="keyword">import</span> time, random</span><br><span class="line">e = Event()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task1</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        e.clear()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;红灯亮了&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        e.<span class="built_in">set</span>()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;绿灯亮了&#x27;</span>)</span><br><span class="line">        time.sleep(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task2</span>():</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> e.is_set():</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;可以走了 %s&#x27;</span> % current_thread().name)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;正在等待 %s&#x27;</span> % current_thread().name)</span><br><span class="line">            e.wait()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    Thread(target=task1).start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        time.sleep(random.randint(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">        Thread(target=task2).start()</span><br></pre></td></tr></table></figure>

<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><blockquote>
<p>定时器Timer类是Thread的派生类，用于在指定时间后调用一个方法。</p>
</blockquote>
<p>指定n秒后执行某操作</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>,n)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t = Timer(<span class="number">3</span>, hello, args=(<span class="number">1111</span>,))  <span class="comment"># 3秒之后执行</span></span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure>

<h3 id="线程queue"><a href="#线程queue" class="headerlink" title="线程queue"></a>线程queue</h3><blockquote>
<p>queue队列 ：使用import queue，用法与进程Queue一样</p>
<p>当信息必须在多个线程之间安全交换时，队列在线程编程中特别有用</p>
</blockquote>
<ul>
<li><p>基本方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">put 往线程队列里防止,超过队列长度,直接阻塞</span><br><span class="line">get 从队列中取值,如果获取不到,直接阻塞</span><br><span class="line">put_nowait: 如果放入的值超过队列长度,直接报错（linux）</span><br><span class="line">get_nowait: 如果获取的值已经没有了,直接报错</span><br></pre></td></tr></table></figure></li>
<li><p>用法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line"><span class="comment"># 队列：先进先出</span></span><br><span class="line">q = queue.Queue(<span class="number">3</span>) <span class="comment"># 指定队列的大小</span></span><br><span class="line">q.put(<span class="number">111</span>)  <span class="comment"># 整型</span></span><br><span class="line">q.put(<span class="string">&quot;aaa&quot;</span>) <span class="comment"># 字符串</span></span><br><span class="line">q.put((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)) <span class="comment"># 元组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">111</span></span><br><span class="line"><span class="string">aaa</span></span><br><span class="line"><span class="string">(1, 2, 3)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆栈：后进先出</span></span><br><span class="line">q = queue.LifoQueue(<span class="number">3</span>)</span><br><span class="line">q.put(<span class="number">111</span>)</span><br><span class="line">q.put(<span class="string">&quot;aaa&quot;</span>)</span><br><span class="line">q.put((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(1, 2, 3)</span></span><br><span class="line"><span class="string">aaa</span></span><br><span class="line"><span class="string">111</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 优先级队列：</span></span><br><span class="line"><span class="comment"># 1.默认按照数字大小排序,然后会按照ascii编码在从小到大排序</span></span><br><span class="line"><span class="comment"># 2.先写先排,后写后排</span></span><br><span class="line">q = queue.PriorityQueue(<span class="number">3</span>)</span><br><span class="line">q.put((<span class="number">10</span>,<span class="number">111</span>))  <span class="comment"># 第一个值是优先级，第二值才是要放的元素</span></span><br><span class="line">q.put((<span class="number">11</span>,<span class="string">&quot;aaa&quot;</span>))</span><br><span class="line">q.put((-<span class="number">1</span>,(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"><span class="built_in">print</span>(q.get())</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(-1, (1, 2, 3))  # 数越小优先级越高</span></span><br><span class="line"><span class="string">(10, 111)</span></span><br><span class="line"><span class="string">(11, &#x27;aaa&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="死锁和递归锁"><a href="#死锁和递归锁" class="headerlink" title="死锁和递归锁"></a>死锁和递归锁</h3><blockquote>
<p>死锁是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程</p>
</blockquote>
<ul>
<li><p>代码演示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">mutexA = Lock()</span><br><span class="line">mutexB = Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="params">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 抢到了A锁 &#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 抢到了B锁 &#x27;</span> % self.name)</span><br><span class="line">        mutexB.release()</span><br><span class="line"></span><br><span class="line">        mutexA.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">self</span>):</span></span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 抢到了B锁 &#x27;</span> % self.name)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 抢到了A锁 &#x27;</span> % self.name)</span><br><span class="line">        mutexA.release()</span><br><span class="line"></span><br><span class="line">        mutexB.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.f1()</span><br><span class="line">        self.f2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = MyThread(<span class="string">&#x27;线程1&#x27;</span>)</span><br><span class="line">    t2 = MyThread(<span class="string">&#x27;线程2&#x27;</span>)</span><br><span class="line">    t3 = MyThread(<span class="string">&#x27;线程3&#x27;</span>)</span><br><span class="line">    t4 = MyThread(<span class="string">&#x27;线程4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t3.start()</span><br><span class="line">    t4.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主线程&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 线程1 抢到了A锁 </span></span><br><span class="line"><span class="comment"># 线程1 抢到了B锁 </span></span><br><span class="line"><span class="comment"># 线程1 抢到了B锁 </span></span><br><span class="line"><span class="comment"># 线程2 抢到了A锁 </span></span><br><span class="line"><span class="comment"># 主线程</span></span><br><span class="line"><span class="comment"># 此时卡在这了</span></span><br></pre></td></tr></table></figure></li>
<li><p>解决方法</p>
<blockquote>
<p>递归锁，在Python中为了支持在同一线程中多次请求同一资源，python提供了可重入锁RLock</p>
<p> 这个RLock内部维护着一个Lock和一个计数（counter）变量，计数记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生死锁</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock, RLock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">mutexA = mutexB = RLock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span>(<span class="params">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f1</span>(<span class="params">self</span>):</span></span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 抢到了A锁 &#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 抢到了B锁 &#x27;</span> % self.name)</span><br><span class="line">        mutexB.release()</span><br><span class="line"></span><br><span class="line">        mutexA.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>(<span class="params">self</span>):</span></span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 抢到了B锁 &#x27;</span> % self.name)</span><br><span class="line">        time.sleep(<span class="number">0.1</span>)</span><br><span class="line"></span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 抢到了A锁 &#x27;</span> % self.name)</span><br><span class="line">        mutexA.release()</span><br><span class="line"></span><br><span class="line">        mutexB.release()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.f1()</span><br><span class="line">        self.f2()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t1 = MyThread(<span class="string">&#x27;线程1&#x27;</span>)</span><br><span class="line">    t2 = MyThread(<span class="string">&#x27;线程2&#x27;</span>)</span><br><span class="line">    t3 = MyThread(<span class="string">&#x27;线程3&#x27;</span>)</span><br><span class="line">    t4 = MyThread(<span class="string">&#x27;线程4&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t3.start()</span><br><span class="line">    t4.start()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;主线程&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="GIL全局解释器锁"><a href="#GIL全局解释器锁" class="headerlink" title="GIL全局解释器锁"></a>GIL全局解释器锁</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><blockquote>
<p><strong>GIL的全称是：Global Interpreter Lock,意思就是全局解释器锁</strong></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">定义：</span><br><span class="line">In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple </span><br><span class="line">native threads from executing Python bytecodes at once. This lock is necessary mainly </span><br><span class="line">because CPython’s memory management is not thread-safe. (However, since the GIL </span><br><span class="line">exists, other features have grown to depend on the guarantees that it enforces.)</span><br><span class="line">&#x27;&#x27;&#x27;</span><br><span class="line">结论：在Cpython解释器中，同一个进程下开启的多线程，同一时刻只能有一个线程执行，无法利用多核优势</span><br></pre></td></tr></table></figure>



<p>首先需要明确的一点是<code>GIL</code>并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念。就好比C++是一套语言（语法）标准，但是可以用不同的编译器来编译成可执行代码。有名的编译器例如GCC，INTEL C++，Visual C++等。Python也一样，同样一段代码可以通过CPython，PyPy，Psyco等不同的Python执行环境来执行。像其中的JPython就没有GIL。然而因为CPython是大部分环境下默认的Python执行环境。所以在很多人的概念里CPython就是Python，也就想当然的把<code>GIL</code>归结为Python语言的缺陷。所以这里要先明确一点：GIL并不是Python的特性，Python完全可以不依赖于GIL</p>
<p>GIL本质就是一把互斥锁，既然是互斥锁，所有互斥锁的本质都一样，都是将并发运行变成串行，以此来控制同一时间内共享数据只能被一个任务所修改，进而保证数据安全</p>
<p>综上：</p>
<p>如果多个线程的target=work，那么执行流程是</p>
<p>多个线程先访问到解释器的代码，即拿到执行权限，然后将target的代码交给解释器的代码去执行</p>
<p>解释器的代码是所有线程共享的，所以垃圾回收线程也可能访问到解释器的代码而去执行，这就导致了一个问题:对于同一个数据100，可能线程1执行x=100的同时，而垃圾回收执行的是回收100的操作，解决这种问题没有什么高明的方法，就是加锁处理，如下图的GIL，保证python解释器同一时间只能执行一个任务的代码</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/WK4tt1.jpg" alt="WK4tt1"></p>
<h3 id="GIL与Lock"><a href="#GIL与Lock" class="headerlink" title="GIL与Lock"></a>GIL与Lock</h3><p>只要在一个进程里就一定有GIL锁的存在，GIL锁不能保证python数据的安全，它保证的是解释器级别（内存管理）的安全，也可以说是背后存在的一种机制。可以肯定的一点是：保护不同的数据的安全，就应该加不同的锁。</p>
<p>GIL保护的是解释器级的数据，保护用户自己的数据则需要自己加锁处理，如下图：</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/dRjCYL.jpg" alt="dRjCYL"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">mutex = Lock()</span><br><span class="line">n = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line"></span><br><span class="line">    mutex.acquire()</span><br><span class="line">    temp = n</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    n = temp - <span class="number">1</span></span><br><span class="line">    mutex.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        t = Thread(target=task)</span><br><span class="line">        l.append(t)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> obj <span class="keyword">in</span> l:</span><br><span class="line">        obj.join()</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(n)  <span class="comment"># 结果肯定为0，由原来的并发执行变成串行，牺牲了执行效率保证了数据安全</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;  </span></span><br><span class="line"><span class="string">分析：</span></span><br><span class="line"><span class="string">1. 100个线程去抢GIL锁，即抢执行权限</span></span><br><span class="line"><span class="string">2. 肯定有一个线程先抢到GIL（暂且称为线程1），然后开始执行，一旦执行就会mutex.acquire()</span></span><br><span class="line"><span class="string">3. 极有可能线程1还未运行完毕，就有另外一个线程2抢到GIL，然后开始运行，但线程2发现互斥锁   	  lock还未被线程1释放，于是阻塞，被迫交出执行权限，即释放GIL</span></span><br><span class="line"><span class="string">4. 直到线程1重新抢到GIL，开始从上次暂停的位置继续执行，直到正常释放互斥锁lock，然后其他的</span></span><br><span class="line"><span class="string">   线程再重复2 3 4的过程</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>



<h3 id="GIL与多线程"><a href="#GIL与多线程" class="headerlink" title="GIL与多线程"></a>GIL与多线程</h3><p>对计算来说，cpu越多越好，但是对于I/O来说，再多的cpu也没用</p>
<p>对运行一个程序来说，随着cpu的增多执行效率肯定会有所提高（不管提高幅度多大，总会有所提高），这是因为一个程序基本上不会是纯计算或者纯I/O，所以我们只能相对的去看一个程序到底是计算密集型还是I/O密集型，从而进一步分析python的多线程到底有无用武之地</p>
<p>场景：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">分析：</span><br><span class="line">我们有四个任务需要处理，处理方式肯定是要玩出并发的效果，解决方案可以是：</span><br><span class="line">方案一：开启四个进程</span><br><span class="line">方案二：一个进程下，开启四个线程</span><br><span class="line"></span><br><span class="line">单核情况下，分析结果: </span><br><span class="line">　　如果四个任务是计算密集型，没有多核来并行计算，方案一徒增了创建进程的开销，方案二胜</span><br><span class="line">　　如果四个任务是I/O密集型，方案一创建进程的开销大，且进程的切换速度远不如线程，方案二胜</span><br><span class="line"></span><br><span class="line">多核情况下，分析结果：</span><br><span class="line">　　如果四个任务是计算密集型，多核意味着并行计算，在python中一个进程中同一时刻只有一个线</span><br><span class="line">　　程执行用不上多核，方案一胜</span><br><span class="line">　　如果四个任务是I/O密集型，再多的核也解决不了I/O问题，方案二胜</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">结论：现在的计算机基本上都是多核，python对于计算密集型的任务开多线程的效率并不能带来多</span><br><span class="line">大性能上的提升，甚至不如串行(没有大量切换)，但是，对于IO密集型的任务效率还是有显著提升的。</span><br></pre></td></tr></table></figure>

<h3 id="多线程性能测试"><a href="#多线程性能测试" class="headerlink" title="多线程性能测试"></a>多线程性能测试</h3><ul>
<li><p>计算密集型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> os, time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span>():</span></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000000</span>):</span><br><span class="line">        res *= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    l = []</span><br><span class="line">    <span class="built_in">print</span>(os.cpu_count())  <span class="comment"># 查看cpu核数</span></span><br><span class="line">    start_time = time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">8</span>):</span><br><span class="line">        p = Process(target=work)  <span class="comment"># 进程 7.7s多</span></span><br><span class="line">        <span class="comment"># p = Thread(target=work)  # 线程 28s多</span></span><br><span class="line">        l.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> l:</span><br><span class="line">        p.join()</span><br><span class="line">    stop_time = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;run time is %s &#x27;</span> % (stop_time - start_time))</span><br></pre></td></tr></table></figure></li>
<li><p>I/O密集型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> os, time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span>():</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    l = []</span><br><span class="line">    <span class="comment"># print(os.cpu_count()) # 查看CPU核数</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1000</span>):</span><br><span class="line">        p=Process(target=work)  <span class="comment"># 使用进程</span></span><br><span class="line">        <span class="comment"># p = Thread(target=work)  # 使用线程比进程效率稍高</span></span><br><span class="line">        l.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> l:</span><br><span class="line">        p.join()</span><br><span class="line">    stop = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;run time is %s&#x27;</span> % (stop - start))</span><br></pre></td></tr></table></figure></li>
<li><p>结论</p>
<p>多线程用于IO密集型，如socket，爬虫，web</p>
<p>多进程用于计算密集型，如金融分</p>
</li>
</ul>
<h2 id="进程池与线程池"><a href="#进程池与线程池" class="headerlink" title="进程池与线程池"></a>进程池与线程池</h2><p>​    在刚开始接触多进程或多线程时，我们迫不及待地基于多进程或多线程实现并发的套接字通信，然而这种实现方式的致命缺陷是：<strong>服务的开启的进程数或线程数都会随着并发的客户端数目地增多而增多，这会对服务端主机带来巨大的压力，甚至于不堪重负而瘫痪。</strong>于是我们必须对服务端开启的进程数或线程数加以控制，让机器在一个自己可以承受的范围内运行，这就是进程池或线程池的用途，例如进程池，就是用来存放进程的池子，本质还是基于多进程，只不过是对开启进程的数目加上了限制</p>
<ul>
<li><p>Python标准模块concurrent.futures</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1、介绍</span></span><br><span class="line">concurrent.futures模块是用来创建并行的任务，提供了高度封装的异步调用接口</span><br><span class="line">concurent.future这个模块用起来非常方便，它的接口也封装的非常简单，既可以实现进程池，也可以实现线程池</span><br><span class="line">ThreadPoolExecutor：线程池，提供异步调用</span><br><span class="line">ProcessPoolExecutor: 进程池，提供异步调用</span><br><span class="line">两者都实现了同一个接口，这个接口是由抽象Executor类定义的。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、基本方法</span></span><br><span class="line">submit(fn, *args, **kwargs)</span><br><span class="line">异步提交任务</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>(func, *iterables, timeout=<span class="literal">None</span>, chunksize=<span class="number">1</span>) </span><br><span class="line">取代<span class="keyword">for</span>循环submit的操作</span><br><span class="line"></span><br><span class="line">shutdown(wait=<span class="literal">True</span>) </span><br><span class="line">相当于进程池的pool.close()+pool.join()操作</span><br><span class="line">wait=<span class="literal">True</span>，等待池内所有任务执行完毕回收完资源后才继续</span><br><span class="line">wait=<span class="literal">False</span>，立即返回，并不会等待池内的任务执行完毕</span><br><span class="line">但不管wait参数为何值，整个程序都会等到所有任务执行完毕</span><br><span class="line">submit和<span class="built_in">map</span>必须在shutdown之前</span><br><span class="line"></span><br><span class="line">result(timeout=<span class="literal">None</span>)</span><br><span class="line">取得结果</span><br><span class="line"></span><br><span class="line">add_done_callback(fn)</span><br><span class="line">回调函数</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="进程池"><a href="#进程池" class="headerlink" title="进程池"></a>进程池</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># 介绍：</span></span><br><span class="line"><span class="string">ProcessPoolExecutor类是Executor的子类，它使用一个进程池来异步执行调用。ProcessPoolExecutor</span></span><br><span class="line"><span class="string">使用多处理模块，这允许它避免全局解释器锁，但也意味着只能执行和返回可pickle的对象。</span></span><br><span class="line"><span class="string">类concurrent.futures。ProcessPoolExecutor (max_workers = None, mp_context =没有)</span></span><br><span class="line"><span class="string">使用最多max_workers进程池异步执行调用的Executor子类。如果max_workers为None或未给出，则默认值为</span></span><br><span class="line"><span class="string">机器上的处理器数。如果max_workers小于或等于0，则会引发ValueError。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 用法：异步执行</span></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ProcessPoolExecutor</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> current_thread</span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">n</span>):</span>  <span class="comment"># 定一个任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is runing&#x27;</span> %os.getpid()) <span class="comment"># 任务启动先打印任务的进程pid</span></span><br><span class="line">    <span class="comment"># I/O密集型的，一般用线程，用进程开销大耗时长</span></span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))  <span class="comment"># 随机睡1-3秒</span></span><br><span class="line">    <span class="keyword">return</span> n**<span class="number">2</span>   <span class="comment"># 返回值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">futrue</span>):</span> <span class="comment"># 处理任务的函数，拿到futrue对象</span></span><br><span class="line">    res = futrue.result() <span class="comment"># 拿到返回结果，一个任务运行完就会触发回调函数，所以不会阻塞</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s 正在处理结果：%s&quot;</span> %(os.getpid(),res))</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = ProcessPoolExecutor(max_workers=<span class="number">4</span>) <span class="comment"># 对于进程池如果不写max_works：默认的是cpu的数量是4个</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">19</span>):  <span class="comment"># 现在开了19个任务，如果是上百个任务，就不能无限开进程，就要考虑控制</span></span><br><span class="line">        pool.submit(task,i).add_done_callback(handle) <span class="comment"># 异步的方式提交任务</span></span><br><span class="line"></span><br><span class="line">    pool.shutdown(wait=<span class="literal">True</span>)  </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27; </span></span><br><span class="line"><span class="string">解析:</span></span><br><span class="line"><span class="string">pool.submit(task,i)会返回一个futrue对象，这个任务对象可以调出add_done_callback()方法，</span></span><br><span class="line"><span class="string">叫回调函数，里面就一个参数handle，也就是说每提交一个任务捆绑一个函数，一旦一个任务运行完就会立</span></span><br><span class="line"><span class="string">马触发这个回调函数的运行,并且会自动的把任务对象当做第一个参数传给回调函数。</span></span><br><span class="line"><span class="string">在回调函数里处理任务，先拿到结果，一个任务运行完就会触发这个回调函数，所以不会阻塞在原地。打印</span></span><br><span class="line"><span class="string">一边在运行一边就会有人在处理结果，一边在运行着一边结果正在被处理，这个运行效率并不慢，一直都是</span></span><br><span class="line"><span class="string">主进程在处理任务，这就是回调函数的概念。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># 介绍：</span></span><br><span class="line"><span class="string">ThreadPoolExecutor是Executor的子类，它使用一个线程池来异步执行调用。</span></span><br><span class="line"><span class="string">类concurrent.futures。ThreadPoolExecutor (max_workers = None, thread_name_prefix = &quot;)</span></span><br><span class="line"><span class="string">一个Executor子类，使用最多max_workers线程池来异步执行调用。</span></span><br><span class="line"><span class="string">3.5版本的变化:如果max_workers没有或没有,它将默认为处理器的机器上,乘以5,假设ThreadPoolExecutor通常</span></span><br><span class="line"><span class="string">   用于重叠I / O而不是CPU工作和工人的数量应该为ProcessPoolExecutor高于工人的数量。</span></span><br><span class="line"><span class="string">3.6新版功能:添加了thread_name_prefix参数，允许用户控制线程。由池创建的工作线程的线程名，以便于调试。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 用法：</span></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> current_thread</span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s is runing&#x27;</span> %current_thread().name)</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">return</span> n**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">futrue</span>):</span></span><br><span class="line">    res = futrue.result()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;%s 正在处理结果：%s&quot;</span> %(current_thread().name,res))</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pool = ThreadPoolExecutor(max_workers=<span class="number">10</span>) <span class="comment"># 对于线程池如果不写max_works：默认的是cpu的数目*5</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">19</span>): <span class="comment"># 同样是19个任务，线程池效率高了</span></span><br><span class="line">        pool.submit(task,i).add_done_callback(handle)</span><br><span class="line"></span><br><span class="line">    pool.shutdown(wait=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>

<h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>​    协程是单线程下实现的并发,协程是一种用户态的轻量级线程，即协程是由用户程序自己控制调度的</p>
<p>​    对于单线程下，我们不可避免程序中出现io操作，但如果我们能在自己的程序中（即用户程序级别，而非操作系统级别）控制单线程下的多个任务能在一个任务遇到io阻塞时就切换到另外一个任务去计算，这样就保证了该线程能够最大限度地处于就绪态，即随时都可以被cpu执行的状态，相当于我们在用户程序级别将自己的io操作最大限度地隐藏起来，从而可以迷惑操作系统，让其看到：该线程好像是一直在计算，io比较少，从而更多的将cpu的执行权限分配给我们的线程。</p>
<p>​    python的线程属于内核级别的，即由操作系统控制调度（如单线程遇到io或执行时间过长就会被迫交出cpu执行权限，切换其他线程运行）</p>
<p>​    单线程内开启协程，一旦遇到io，就会从应用程序级别（而非操作系统）控制切换，以此来提升效率（！！！非io操作的切换与效率无关）</p>
<p>​    对比操作系统控制线程的切换，用户在单线程内控制协程的切换</p>
<ul>
<li><p>特点: 自己的应用程序实现多个人的调度</p>
<p>遇到I/O切换，可以将单线程的I/O降到最低，因此可以将单线程的威力发挥到最大</p>
</li>
<li><p>缺点: 不能实现并行</p>
<p>单线程下的多个任务一旦遇到I/O，整个线程都会阻塞，所有的任务都停滞</p>
</li>
<li><p>总结</p>
<ul>
<li>必须在只有一个单线程里实现并发</li>
<li>修改共享数据不需加锁</li>
<li>用户程序里自己保存多个控制流的上下文栈</li>
<li>附加：一个协程遇到IO操作自动切换到其它协程（如何实现检测IO，yield、greenlet都无法实现，就用到了gevent模块（select机制））**</li>
</ul>
<p><strong>yiled</strong>可以保存状态，<strong>yield</strong>的状态保存与操作系统的保存线程状态很像，但是<strong>yield是代码级别控制</strong>的，更轻量级send可以把一个函数的结果传给另外一个函数，以此实现<strong>单线程内程序之间的切换</strong></p>
</li>
</ul>
<h3 id="Gevent模块"><a href="#Gevent模块" class="headerlink" title="Gevent模块"></a>Gevent模块</h3><p>​        <strong>Gevent</strong>是一个第三方库，可以轻松通过gevent实现并发同步或异步编程，在gevent中用到的主要模式是Greenlet, 它是以C扩展模块形式接入Python的轻量级协程。 Greenlet全部运行在主程序操作系统进程的内部，但它们被协作式地调度。</p>
<p>Gevent内部会用到greenlet这个模块，这个模块就是多个任务之间来回的切，切走之前把一个任务的状态保留下来，它们的底层都会用到yield，其实就是层层帮我们封装好了。greenlet内部会封装yield，Gevent就是对greenlet进行了进一步的封装，封装后greenlet会帮忙检测I/O，实现遇到I/O切换，这个才是我们所追求的协程</p>
<ul>
<li><p>使用方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">g1=gevent.spawn(func,<span class="number">1</span>,,<span class="number">2</span>,<span class="number">3</span>,x=<span class="number">4</span>,y=<span class="number">5</span>)创建一个协程对象g1，spawn括号内第一个参数是函数名，</span><br><span class="line">                如eat，后面可以有多个参数，可以是位置实参或关键字实参，都是传给函数eat的</span><br><span class="line"></span><br><span class="line">g2=gevent.spawn(func2)</span><br><span class="line"></span><br><span class="line">g1.join()  等待g1结束</span><br><span class="line"></span><br><span class="line">g2.join()  等待g2结束</span><br><span class="line"></span><br><span class="line">或者上述两步合作一步：gevent.joinall([g1,g2])</span><br><span class="line"></span><br><span class="line">g1.value<span class="comment">#拿到func1的返回值</span></span><br></pre></td></tr></table></figure>

<p>遇到IO阻塞时自动切换任务</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s eat 1&#x27;</span> %name) <span class="comment"># 1.吃了一口饭</span></span><br><span class="line">    gevent.sleep(<span class="number">2</span>)  <span class="comment"># 2.原地睡了2秒，相当于模拟遇到I/O了</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s eat 2&#x27;</span> %name) <span class="comment"># 6.接着打印又回来吃了一口饭</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s play 1&#x27;</span> %name)  <span class="comment"># 3.遇到I/O以后就切到了另外一个任务，玩了一下</span></span><br><span class="line">    gevent.sleep(<span class="number">1</span>)  <span class="comment"># 4.又遇到I/O了，睡了1秒，它先睡完</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;%s play 2&#x27;</span> %name) <span class="comment"># 5.接着又玩了一下，原本应该切到eat 2，但是仍在阻塞中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g1=gevent.spawn(eat,<span class="string">&#x27;egon&#x27;</span>) <span class="comment"># spawn提交eat任务，然后提交一个人名。协程1</span></span><br><span class="line">g2=gevent.spawn(play,name=<span class="string">&#x27;egon&#x27;</span>)<span class="comment"># spawn提交playt任务。协程2</span></span><br><span class="line">g1.join() <span class="comment"># 等着协程对象g1结束</span></span><br><span class="line">g2.join() <span class="comment"># 等着协程对象g2结束</span></span><br><span class="line"><span class="comment">#或者gevent.joinall([g1,g2])</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;主&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">上例gevent.sleep(2)模拟的是gevent可以识别的io阻塞,而time.sleep(2)或其他的阻塞,gevent是不能直接识别的需要用下面一行代码,打补丁,就可以识别了</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></li>
<li><p>打补丁</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">from gevent import monkey;monkey.patch_all()必须放到被打补丁者的前面，如time，socket模块之前或者我们干脆记忆成：要用gevent，需要将from gevent import monkey;monkey.patch_all()放到文件的开头</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey;monkey.patch_all()</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;eat food 1&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;eat food 2&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;play 1&#x27;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;play 2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">g1=gevent.spawn(eat)</span><br><span class="line">g2=gevent.spawn(play_phone)</span><br><span class="line">gevent.joinall([g1,g2])</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;主&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">单线程下能抗住的并发已经非常非常高了，因为现在接触的软件大部分都是I/O密集型的</span></span><br><span class="line"><span class="string">其实单线程下完全可以一个任务运行完以后（它真正运行完花的时间是非常短的，大量时间都在做I/O）</span></span><br><span class="line"><span class="string">可以利用运行一段时间遇到I/O操作了就快速切换另一个任务再运行，在多任务之间快速的切</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>基于协程实现并发</p>
<p>  <strong>通过gevent实现单线程下的socket并发（from gevent import monkey;monkey.patch_all()一定要放到导入socket模块之前，否则gevent无法识别socket的阻塞）</strong></p>
<ul>
<li><p>服务端</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 首先导了猴子补丁，打了补丁保证下面所有模块的I/O行为都能监测到</span></span><br><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey;monkey.patch_all() </span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *   <span class="comment"># 然后导了socket模块，准备写套接字</span></span><br><span class="line"><span class="keyword">import</span> gevent <span class="comment"># 最后导入gevent模块， 用来单线程下实现并发</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span>(<span class="params">server_ip,port</span>):</span> <span class="comment"># 套接字服务端任务1：建链接</span></span><br><span class="line">    s=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">    s.setsockopt(SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>)</span><br><span class="line">    s.bind((server_ip,port)) <span class="comment"># 绑定ip和端口</span></span><br><span class="line">    s.listen(<span class="number">5</span>)  <span class="comment"># 监听</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn,addr=s.accept() <span class="comment"># 等待链接请求</span></span><br><span class="line">        <span class="comment"># 每建成一个链接，就提交一个协程对象进行通信，异步提交</span></span><br><span class="line">        gevent.spawn(talk,conn,addr) </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">talk</span>(<span class="params">conn,addr</span>):</span>  <span class="comment"># 套接字服务端任务2：建通信</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            res=conn.recv(<span class="number">1024</span>) <span class="comment"># 收消息</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;client %s:%s msg: %s&#x27;</span> %(addr[<span class="number">0</span>],addr[<span class="number">1</span>],res))</span><br><span class="line">            conn.send(res.upper()) <span class="comment"># 回消息，大写回</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    server(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>) <span class="comment"># 把ip和端口传进去</span></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 注：没必要join在原地等了，因为服务端在启动运行起来后，服务端函数是一个死循环，</span></span><br><span class="line"><span class="comment"># 不会结束，既然主进程不会结束那就不用再等了</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">整体逻辑：就一个线程server，没有多线程也没有多进程，这个线程每建成一个链接就提交</span></span><br><span class="line"><span class="string">一个协程对象，gevent会帮你在多个任务之间遇到I/O来回快速的切换，从而实现并发效果</span></span><br><span class="line"><span class="string">如何证明并发的效果？</span></span><br><span class="line"><span class="string">服务端启动起来后，同时多个客户端连接过去，如果多个客户端能同时得到结果，并发效果</span></span><br><span class="line"><span class="string">就实现了</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
<li><p>客户端</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 可同时开多个客户端(客户端1、客户端2、客户端3)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">client=socket(AF_INET,SOCK_STREAM)</span><br><span class="line">client.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    client.send(<span class="string">&quot;hello&quot;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)) <span class="comment"># 在不停的向服务端发送“hello”</span></span><br><span class="line">    msg=client.recv(<span class="number">1024</span>) <span class="comment"># 收消息，在不停的收HELLO</span></span><br><span class="line">    <span class="built_in">print</span>(msg.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">解析：</span></span><br><span class="line"><span class="string">三个客户端都能同时不停的发消息和收消息，都有并发效果，但服务端没有开多线程，事实上</span></span><br><span class="line"><span class="string">就是服务端在多个任务之间来回的切换</span></span><br><span class="line"><span class="string">其实就是给第一个客户端执行一个seed来发送I/O请求，只要seed发出之后运行完就是操作</span></span><br><span class="line"><span class="string">系统的任务了，seed负责发消息，操作系统负责做I/O。gevent模块会利用你seed的过程</span></span><br><span class="line"><span class="string">直接切到下一个任务，再切到下下一个任务，一直往下切，给客户端的感觉就是每一个客户端</span></span><br><span class="line"><span class="string">都能被服务，并发就实现了</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac上VMware的NAT网络设置</title>
    <url>/2ba065a.html</url>
    <content><![CDATA[<h3 id="NAT网络设置"><a href="#NAT网络设置" class="headerlink" title="NAT网络设置"></a>NAT网络设置</h3><h4 id="创建一个NAT网络"><a href="#创建一个NAT网络" class="headerlink" title="创建一个NAT网络"></a>创建一个NAT网络</h4><span id="more"></span>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/4vNGH4.png" alt="4vNGH4"></p>
<h4 id="修改子网段"><a href="#修改子网段" class="headerlink" title="修改子网段"></a>修改子网段</h4><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20211214144606331.png" alt="image-20211214144606331"></p>
<h4 id="Mac上查看该子网段的网关"><a href="#Mac上查看该子网段的网关" class="headerlink" title="Mac上查看该子网段的网关"></a>Mac上查看该子网段的网关</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mac上查自己的</span></span><br><span class="line">cat /Library/Preferences/VMware\ Fusion/vmnet3/nat.conf | grep gateway -A 2</span><br><span class="line"></span><br><span class="line"><span class="comment"># NAT gateway address</span></span><br><span class="line">ip = 192.168.100.1</span><br><span class="line">netmask = 255.255.255.0</span><br></pre></td></tr></table></figure>

<h4 id="设置虚拟机网络"><a href="#设置虚拟机网络" class="headerlink" title="设置虚拟机网络"></a>设置虚拟机网络</h4><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20211214144722670.png" alt="image-20211214144722670"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20211214144745643.png" alt="image-20211214144745643"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/image-20211214144802455.png" alt="image-20211214144802455"></p>
<h4 id="Centos镜像源设置"><a href="#Centos镜像源设置" class="headerlink" title="Centos镜像源设置"></a>Centos镜像源设置</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># centos更换阿里云源</span></span><br><span class="line">mkdir -p /etc/yum.repos.d/bak </span><br><span class="line">mv /etc/yum.repos.d/* /etc/yum.repos.d/bak</span><br><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo</span><br><span class="line">curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo</span><br><span class="line">yum install vim net-tools gcc make -y</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>python-网络编程</title>
    <url>/e67db240.html</url>
    <content><![CDATA[<h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/g3kSJQ.jpg" alt="g3kSJQ"></p>
<span id="more"></span>
<h4 id="每层运行常见物理设备"><a href="#每层运行常见物理设备" class="headerlink" title="每层运行常见物理设备"></a>每层运行常见物理设备</h4><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/bevfsC.jpg" alt="bevfsC"></p>
<h4 id="七层协议数据传输的封包与解包过程"><a href="#七层协议数据传输的封包与解包过程" class="headerlink" title="七层协议数据传输的封包与解包过程"></a>七层协议数据传输的封包与解包过程</h4><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/1036857-20200415215541847-564448301.gif" alt="1036857-20200415215541847-564448301"></p>
<h4 id="TCP三握四挥"><a href="#TCP三握四挥" class="headerlink" title="TCP三握四挥"></a>TCP三握四挥</h4><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/nj8EEE.jpg" alt="nj8EEE"></p>
<h3 id="socket层"><a href="#socket层" class="headerlink" title="socket层"></a>socket层</h3><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/lrLyh3.jpg" alt="lrLyh3"><br><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/ek2QPk.jpg" alt="ek2QPk"></p>
<p><strong>数据传输动图如下：</strong><br><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/1036857-20200415220004538-1827984001.gif" alt="1036857-20200415220004538-1827984001"></p>
<h4 id="socket工作流程"><a href="#socket工作流程" class="headerlink" title="socket工作流程"></a><code>socket</code>工作流程</h4><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/krzj1m.jpg" alt="krzj1m"></p>
<h4 id="socker-模块用法"><a href="#socker-模块用法" class="headerlink" title="socker()模块用法"></a><code>socker()</code>模块用法</h4><p><strong>简单版本</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个socket</span></span><br><span class="line">server_test = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绑定地址</span></span><br><span class="line">server_test.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始监听, 半连接池数量</span></span><br><span class="line">server_test.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接收连接请求,得到客户端连接信息和客户端地址</span></span><br><span class="line">conn, client_address = server_test.accept()</span><br><span class="line"><span class="built_in">print</span>(client_address)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 收消息</span></span><br><span class="line">data = conn.recv(<span class="number">1024</span>)  <span class="comment"># 最大接收字节</span></span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发消息</span></span><br><span class="line">conn.send(data.upper())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭连接</span></span><br><span class="line">conn.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭服务</span></span><br><span class="line">server_test.close()</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">client_test = socket.socket(sockrt.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">client_test.connect((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line">client_test.send(<span class="string">&#x27;hello&#x27;</span>.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">data = client_test.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(data.decode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">client_test.close()</span><br></pre></td></tr></table></figure>



<p><strong>处理服务端连接不断</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">server_test = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">server_test.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line">server_test.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个循环连接的</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, client_address = server_test.accept()</span><br><span class="line">    <span class="built_in">print</span>(client_address)</span><br><span class="line">    <span class="comment"># 这个循环处理连接内容</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            data = conn.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="built_in">print</span>(data)</span><br><span class="line">            conn.send(data.upper())</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    conn.close()</span><br><span class="line">server_test.close()</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">client_test = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">client_test.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = <span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;&gt;:&#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(msg) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    client_test.send(msg.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    data = client_test.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">client_test.close()</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端套接字函数</span></span><br><span class="line">s.bind()    绑定(主机,端口号)到套接字</span><br><span class="line">s.listen()  开始TCP监听</span><br><span class="line">s.accept()  被动接受TCP客户的连接,(阻塞式)等待连接的到来</span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端套接字函数</span></span><br><span class="line">s.connect()     主动初始化TCP服务器连接</span><br><span class="line">s.connect_ex()  connect()函数的扩展版本,出错时返回出错码,而不是抛出异常</span><br><span class="line"></span><br><span class="line"><span class="comment"># 公共用途的套接字函数</span></span><br><span class="line">s.recv()            接收TCP数据</span><br><span class="line">s.send()            发送TCP数据(send在待发送数据量大于己端缓存区剩余空间时,数据丢失,不会发完)</span><br><span class="line">s.sendall()         发送完整的TCP数据(本质就是循环调用send,sendall在待发送数据量大于己端缓存区剩余空间时,数据不丢失,循环调用send直到发完)</span><br><span class="line">s.recvfrom()        接收UDP数据</span><br><span class="line">s.sendto()          发送UDP数据</span><br><span class="line">s.getpeername()     连接到当前套接字的远端的地址</span><br><span class="line">s.getsockname()     当前套接字的地址</span><br><span class="line">s.getsockopt()      返回指定套接字的参数</span><br><span class="line">s.setsockopt()      设置指定套接字的参数</span><br><span class="line">s.close()           关闭套接字</span><br><span class="line"></span><br><span class="line"><span class="comment"># 面向锁的套接字方法</span></span><br><span class="line">s.setblocking()     设置套接字的阻塞与非阻塞模式</span><br><span class="line">s.settimeout()      设置阻塞套接字操作的超时时间</span><br><span class="line">s.gettimeout()      得到阻塞套接字操作的超时时间</span><br><span class="line"></span><br><span class="line"><span class="comment"># 面向文件的套接字的函数</span></span><br><span class="line">s.fileno()          套接字的文件描述符</span><br><span class="line">s.makefile()        创建一个与该套接字相关的文件</span><br></pre></td></tr></table></figure>



<h3 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h3><p>远程执行shell命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">server_test = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">server_test.bind((<span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line">server_test.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个循环连接的</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, client_address = server_test.accept()</span><br><span class="line">    <span class="built_in">print</span>(client_address)</span><br><span class="line">    <span class="comment"># 这个循环处理连接内容</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cmd = conn.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cmd) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            res = subprocess.Popen(cmd,</span><br><span class="line">                                   shell=<span class="literal">True</span>,</span><br><span class="line">                                   stdout=subprocess.PIPE,</span><br><span class="line">                                   stderr=subprocess.PIPE)</span><br><span class="line">            res1 = res.stdout.read()</span><br><span class="line">            res2 = res.stderr.read()</span><br><span class="line">            conn.send(res1 + res2)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    conn.close()</span><br><span class="line">server_test.close()</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">client_test = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">client_test.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = <span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;&gt;:&#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(msg) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    client_test.send(msg.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    data = client_test.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&#x27;utf8&#x27;</span>))  <span class="comment"># windows编码是gbk</span></span><br><span class="line">client_test.close()</span><br></pre></td></tr></table></figure>

<p>客户端执行命令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;:ps -ef</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 结果发现并没有接收全，还有残留</span></span><br><span class="line"><span class="comment"># 再次输入</span></span><br><span class="line">&gt;&gt;&gt;:ls</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 发现还是上次遗留的</span></span><br></pre></td></tr></table></figure>

<h4 id="粘包现象"><a href="#粘包现象" class="headerlink" title="粘包现象"></a>粘包现象</h4><blockquote>
<p>只有TCP有粘包现象，UDP永远不会粘包<br>粘包问题主要还是因为接收方不知道消息之间的界限，不知道一次性提取多少字节的数据所造成的</p>
</blockquote>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/gXSqAs.jpg" alt="gXSqAs"></p>
<p><strong>两种粘包情况</strong></p>
<ol>
<li>发送端需要等缓冲区满才发送出去，造成粘包（发送数据时间间隔很短，数据了很小，会合到一起，产生粘包）</li>
<li>接收方不及时接收缓冲区的包，造成多个包接收（客户端发送了一段数据，服务端只收了一小部分，服务端下次再收的时候还是从缓冲区拿上次遗留的数据，产生粘包） </li>
</ol>
<h4 id="解决粘包"><a href="#解决粘包" class="headerlink" title="解决粘包"></a>解决粘包</h4><blockquote>
<p>为字节流加上自定义固定长度报头，报头中包含字节流长度，然后一次send到对端，对端在接收时，先从缓存中取出定长的报头，然后再取真实数据</p>
</blockquote>
<p><strong><code>struct</code>模块</strong> </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> struct, json</span><br><span class="line"></span><br><span class="line">header_dic = &#123;<span class="string">&#x27;total_size&#x27;</span>: <span class="number">10241321431312</span>&#125;  <span class="comment"># 用字典存入服务端发送的头信息</span></span><br><span class="line">header_json = json.dumps(header_dic)  <span class="comment"># 将信息序列</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(header_json)  <span class="comment"># &#123;&quot;total_size&quot;: 10241321431312&#125;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(header_json))  <span class="comment"># 30  记录序列化信息后的长度</span></span><br><span class="line"></span><br><span class="line">header_total_size = struct.pack(<span class="string">&#x27;i&#x27;</span>, <span class="built_in">len</span>(header_json))  <span class="comment"># 将这个长度转化成固定为 4 的长度</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(header_total_size))  <span class="comment"># 4 此时就是固定长度</span></span><br><span class="line"><span class="comment"># 客户端处就先接收4字节信息</span></span><br><span class="line"></span><br><span class="line">header_upk = struct.unpack(<span class="string">&#x27;i&#x27;</span>, header_total_size)</span><br><span class="line"><span class="built_in">print</span>(header_upk)  <span class="comment"># (30,)  # 将接收到的4字节固定长度继续接收到了30字节信息,继续再拿30字节的信息</span></span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/QodwhX.jpg" alt="QodwhX"></p>
<p>实现:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端</span></span><br><span class="line"><span class="keyword">import</span> socket, struct, json</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    conn, address = s.accept()</span><br><span class="line">    <span class="built_in">print</span>(address)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            cmd = conn.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(cmd) == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            res = subprocess.Popen(cmd, shell=<span class="literal">True</span>,</span><br><span class="line">                                   stdout=subprocess.PIPE,</span><br><span class="line">                                   stderr=subprocess.PIPE)</span><br><span class="line">            res1 = res.stdout.read()</span><br><span class="line">            res2 = res.stderr.read()</span><br><span class="line"></span><br><span class="line">            header_dic = &#123;<span class="string">&#x27;total_size&#x27;</span>: <span class="built_in">len</span>(res1) + <span class="built_in">len</span>(res2)&#125;  <span class="comment"># 可以将内容记录到字典内,报头</span></span><br><span class="line">            header_json = json.dumps(header_dic)  <span class="comment"># 序列化字典</span></span><br><span class="line">            header_bytes = header_json.encode(<span class="string">&#x27;utf8&#x27;</span>)  <span class="comment"># 转为bytes类型</span></span><br><span class="line">            header = struct.pack(<span class="string">&#x27;i&#x27;</span>, <span class="built_in">len</span>(header_bytes))  <span class="comment"># 得到字典的固定字节长度</span></span><br><span class="line"></span><br><span class="line">            conn.send(header)</span><br><span class="line">            conn.send(header_bytes)  <span class="comment"># 发送bytes类型的序列化字典</span></span><br><span class="line"></span><br><span class="line">            conn.send(res1)</span><br><span class="line">            conn.send(res2)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> socket, struct, json</span><br><span class="line"></span><br><span class="line">c = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">c.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = <span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(msg) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    c.send(msg.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    header_bytes_len = struct.unpack(<span class="string">&#x27;i&#x27;</span>, c.recv(<span class="number">4</span>))[<span class="number">0</span>]  <span class="comment"># 获取序列化后的字典的长度</span></span><br><span class="line"></span><br><span class="line">    header_bytes = c.recv(header_bytes_len)  <span class="comment"># 按照序列化后字典的长度接收到序列化的字典</span></span><br><span class="line">    header_json = header_bytes.decode(<span class="string">&#x27;utf8&#x27;</span>)  <span class="comment"># 将序列化后的字典解码</span></span><br><span class="line">    header_dic = json.loads(header_json)  <span class="comment"># 发序化得到记录了信息的字典</span></span><br><span class="line">    total_size = header_dic[<span class="string">&#x27;total_size&#x27;</span>]  <span class="comment"># 此时就拿到了后面要具体接收多少字节的数</span></span><br><span class="line"></span><br><span class="line">    recv_size = <span class="number">0</span></span><br><span class="line">    res = <span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> recv_size &lt; total_size:</span><br><span class="line">        data = c.recv(<span class="number">1024</span>)  <span class="comment"># 每次接收1024字节</span></span><br><span class="line">        recv_size += <span class="built_in">len</span>(data)</span><br><span class="line">        res += data  <span class="comment"># 最后拼接到 res</span></span><br><span class="line">    <span class="built_in">print</span>(res.decode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">c.close()</span><br></pre></td></tr></table></figure>



<h3 id="UDP协议套接字"><a href="#UDP协议套接字" class="headerlink" title="UDP协议套接字"></a>UDP协议套接字</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line">s.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    data, address = s.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(data, address)</span><br><span class="line">    s.sendto(data.upper(), address)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">c = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = <span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    c.sendto(msg.encode(<span class="string">&#x27;utf8&#x27;</span>), (<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">9999</span>))</span><br><span class="line">    res, s_address = c.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(res.decode(<span class="string">&#x27;utf8&#x27;</span>), s_address)</span><br></pre></td></tr></table></figure>

<h3 id="socketserver模块实现并发"><a href="#socketserver模块实现并发" class="headerlink" title="socketserver模块实现并发"></a><code>socketserver模块</code>实现并发</h3><blockquote>
<p>基于tcp的套接字，关键就是两个循环，一个链接循环，一个通信循环</p>
<p>socketserver模块中分两大类：server类（解决链接问题）和request类（解决通信问题）</p>
</blockquote>
<p>server类:<br><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/phJIzv.jpg" alt="phJIzv"></p>
<p>request类：<br><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/nFGdy6.jpg" alt="nFGdy6"></p>
<p>TCP并发</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端</span></span><br><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRequestHandler</span>(<span class="params">socketserver.BaseRequestHandler</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data = self.request.recv(<span class="number">1024</span>)</span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(data) == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                <span class="built_in">print</span>(data)</span><br><span class="line">                self.request.send(data.upper())</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        self.request.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server = socketserver.ThreadingTCPServer((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>), MyRequestHandler, bind_and_activate=<span class="literal">True</span>)</span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">c = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"></span><br><span class="line">c.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = <span class="built_in">input</span>(<span class="string">&#x27;&gt;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(msg) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    c.send(msg.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    data = c.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(data.decode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">c.close()</span><br></pre></td></tr></table></figure>

<p>UDP并发</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 服务端.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRequesthanlder</span>(<span class="params">socketserver.BaseRequestHandler</span>):</span></span><br><span class="line">    <span class="comment"># 必须要写一个函数，叫handle的方法，里面放通信循环</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span>(<span class="params">self</span>):</span> </span><br><span class="line">        <span class="comment"># 收到消息，进行解压。第一个值是客户端发来的数据。第二个值是套接字对象，用它来回消息</span></span><br><span class="line">        data,server = self.request       </span><br><span class="line">        <span class="comment"># 将收到的消息转大写回复，所有套接字信息都封装进self里了</span></span><br><span class="line">        server.sendto(data.upper(),self.client_address)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server = socketserver.ThreadingUDPServer((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9999</span>),MyRequesthanlder)</span><br><span class="line"></span><br><span class="line">server.serve_forever()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整体逻辑同上面TCP协议一样</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 客户端.py</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">client = socket(AF_INET,SOCK_DGRAM)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg = <span class="built_in">input</span>(<span class="string">&quot;&gt;&gt;&gt;&gt;:&quot;</span>).strip()</span><br><span class="line">    client.sendto(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>),(<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">9999</span>))</span><br><span class="line">    res,server_addr = client.recvfrom(<span class="number">1024</span>)</span><br><span class="line">    <span class="built_in">print</span>(res.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-面向对象(一)</title>
    <url>/832cc1e6.html</url>
    <content><![CDATA[<h3 id="1-面向对象由来"><a href="#1-面向对象由来" class="headerlink" title="1. 面向对象由来"></a>1. 面向对象由来</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>面向过程编程:定义变量,定义函数</span><br><span class="line">    优点：复杂的问题流程化，进而简单化</span><br><span class="line">    缺点：牵一发而动全身，扩展性差，可维护性差</span><br><span class="line">    应用场景：对扩展性要求不高的地方</span><br><span class="line"><span class="number">2.</span>面向对象编程:定义一个类,类有属性(变量、特征),有方法(函数，技能)</span><br><span class="line">		优点:扩展性强，可维护性强</span><br><span class="line">    缺点：编程复杂度高</span><br><span class="line">    应用场景：对扩展性要求较高的地方</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="2-面向对象编程"><a href="#2-面向对象编程" class="headerlink" title="2. 面向对象编程"></a>2. 面向对象编程</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> 面向过程变成的核心是过程二字,过程指的是解决问题的步骤,即先干什么再干什么然后干什么</span><br><span class="line"><span class="number">2</span> 面向对象编程的核心是对象二字,对象是特征与技能的结合体,盛放数据和函数的容器</span><br></pre></td></tr></table></figure>

<h3 id="3-类和对象"><a href="#3-类和对象" class="headerlink" title="3. 类和对象"></a>3. 类和对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 必须先定义类，然后调用类产生对象</span></span><br><span class="line"><span class="comment"># 定义了类 Person</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>():</span>  <span class="comment"># 类名首字母一般情况大写，使用大驼峰法命名</span></span><br><span class="line">    <span class="comment"># 定义属性</span></span><br><span class="line">    weight = <span class="number">90</span></span><br><span class="line">    height = <span class="number">180</span></span><br><span class="line">		</span><br><span class="line">    <span class="comment"># 定义技能(函数)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep1</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;睡觉&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">定义类:</span></span><br><span class="line"><span class="string">        1. 立即执行类体代码</span></span><br><span class="line"><span class="string">        2. 产生一个类的名称空间，把类体里面执行的名字都扔到名称空间中(大字典)</span></span><br><span class="line"><span class="string">        3. 把类的名称空间绑定给__dict__, 类名.__dict__</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">      </span><br><span class="line"><span class="comment"># 查看类的名称空间</span></span><br><span class="line"><span class="built_in">print</span>(Person.__dict__)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用类产生对象，默认产生的就是一个空对象&#123;&#125;</span></span><br><span class="line">zhangsan = Person()  <span class="comment"># 类的实例化,得到对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用对象</span></span><br><span class="line">zhangsan.sleep1()  <span class="comment"># 睡觉</span></span><br><span class="line"><span class="built_in">print</span>(zhangsan.height)  <span class="comment"># 180</span></span><br></pre></td></tr></table></figure>

<h3 id="4-定制对象独有特征"><a href="#4-定制对象独有特征" class="headerlink" title="4. 定制对象独有特征"></a>4. 定制对象独有特征</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>():</span></span><br><span class="line">    weight = <span class="number">90</span></span><br><span class="line">    height = <span class="number">180</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep1</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;睡觉&#x27;</span>)</span><br><span class="line">zhangsan = Person()</span><br><span class="line">zhangsan.city = <span class="string">&#x27;BJ&#x27;</span>  <span class="comment"># 给shangsan对象定制独有的特征</span></span><br><span class="line"><span class="built_in">print</span>(zhangsan.city)  <span class="comment"># BJ</span></span><br></pre></td></tr></table></figure>

<h3 id="5-init-方法"><a href="#5-init-方法" class="headerlink" title="5. __init__方法"></a>5. <code>__init__</code>方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对象在实例化的时候，赋初值（给对象一些属性）</span></span><br><span class="line"><span class="comment"># 老方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_course</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;选课&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = Student()</span><br><span class="line">s1.name = <span class="string">&#x27;json&#x27;</span></span><br><span class="line">s1.age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(s1.name)  <span class="comment"># json</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># __init__的使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_course</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;选课&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = Student(<span class="string">&#x27;tom&#x27;</span>, <span class="number">18</span>)  <span class="comment"># 这种初始化方式会触发类的__init__的执行，并把参数传入</span></span><br><span class="line"><span class="built_in">print</span>(s1.name)</span><br></pre></td></tr></table></figure>

<h3 id="6-属性的查找顺序"><a href="#6-属性的查找顺序" class="headerlink" title="6. 属性的查找顺序"></a>6. 属性的查找顺序</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 属性的查找：先从自己的对象中查找，然后在去产生对象的类中取找</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>():</span></span><br><span class="line">    school = <span class="string">&#x27;Harvard University&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, age, gender, course=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="keyword">if</span> course <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            course = []</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">        self.gender = gender</span><br><span class="line">        self.course = course</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">choose_course</span>(<span class="params">self, course</span>):</span></span><br><span class="line">        self.course.append(course)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s 选课成功 %s &#x27;</span> % (self.name, self.course))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = Student(<span class="string">&#x27;bob&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;male&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(s1.__dict__)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;bob&#x27;, &#x27;age&#x27;: 18, &#x27;gender&#x27;: &#x27;male&#x27;, &#x27;course&#x27;: []&#125;</span></span><br><span class="line">s1.choose_course(<span class="string">&#x27;python&#x27;</span>)  <span class="comment"># bob 选课成功 [&#x27;python&#x27;] </span></span><br><span class="line"><span class="built_in">print</span>(s1.__dict__)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;bob&#x27;, &#x27;age&#x27;: 18, &#x27;gender&#x27;: &#x27;male&#x27;, &#x27;course&#x27;: [&#x27;python&#x27;]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">属性的查找：</span></span><br><span class="line"><span class="string">	1. 类属性: 在类中写的属性就称为类属性</span></span><br><span class="line"><span class="string">	2. 对象属性：在对象自己的名称空间中的属性就是对象属性</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.类属性的查找</span></span><br><span class="line"><span class="comment"># 查</span></span><br><span class="line"><span class="built_in">print</span>(Student.school)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增</span></span><br><span class="line">Student.country = <span class="string">&#x27;USA&#x27;</span>  <span class="comment"># 后面实例化的新对象才会有</span></span><br><span class="line"><span class="built_in">print</span>(Student.country)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删</span></span><br><span class="line"><span class="keyword">del</span> Student.school</span><br><span class="line"><span class="built_in">print</span>(Student.__dict__)  <span class="comment"># 删除了school属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改</span></span><br><span class="line">Student.school = <span class="string">&#x27;Oxford&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(Student.school)  <span class="comment"># Oxford</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.对象的属性查找</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查</span></span><br><span class="line"><span class="built_in">print</span>(s1.name)  <span class="comment"># bob</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增</span></span><br><span class="line">s1.height = <span class="number">180</span></span><br><span class="line"><span class="built_in">print</span>(s1.__dict__)  <span class="comment"># 多了height</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删</span></span><br><span class="line"><span class="keyword">del</span> s1.age</span><br><span class="line"><span class="built_in">print</span>(s1.__dict__)  <span class="comment"># age 没有了</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 改</span></span><br><span class="line">s1.name = <span class="string">&#x27;tony&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s1.name)  <span class="comment"># tony</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断对象是否是某个类实例化的</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(s1, Student))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">isinstance</span>(s1, Teacher))  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-模块(四)</title>
    <url>/779eb679.html</url>
    <content><![CDATA[<h3 id="1-hashlib模块"><a href="#1-hashlib模块" class="headerlink" title="1. hashlib模块"></a>1. <code>hashlib</code>模块</h3><blockquote>
<p>加密模块</p>
<p>加密: 将明文数据通过一些列算法变成密文，为了数据安全</p>
<p>加密算法: md5、sha、 base、hmac等</p>
</blockquote>
<span id="more"></span>
<h4 id="1-1-基本使用"><a href="#1-1-基本使用" class="headerlink" title="1.1 基本使用"></a>1.1 基本使用</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line">md51 = hashlib.md5()  <span class="comment"># 先决定算法类型,md5普遍使用</span></span><br><span class="line">md51.update(<span class="string">&#x27;哈喽&#x27;</span>.encode(<span class="string">&#x27;utf8&#x27;</span>))  <span class="comment"># 将明文数据传递给md5算法,update只能接受bytes类型数据</span></span><br><span class="line"><span class="comment"># md51.update(b&#x27;hello word&#x27;)  # 当数据是英文和数字的时候可以在前面加 b</span></span><br><span class="line">rest1 = md51.hexdigest()  <span class="comment"># 获取加密之后的密文数据</span></span><br><span class="line"><span class="built_in">print</span>(rest1)  <span class="comment"># 492389292f5e200f6d1518055b0b1755  (一串随机的字符串)</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1.加密之后的密文数据是没有办法反解密成明文数据的</span></span><br><span class="line"><span class="string">    市面上所谓的破解 其实就是提前算出一系列明文对应的密文</span></span><br><span class="line"><span class="string">    之后比对密文再获取明文</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-特性一"><a href="#1-2-特性一" class="headerlink" title="1.2 特性一"></a>1.2 特性一</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 明文数据只要是相同的 那么无论如何传递加密结果肯定是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">md52 = hashlib.md5()</span><br><span class="line">md52.update(<span class="string">b&#x27;admin123&#x27;</span>)</span><br><span class="line">rest2 = md52.hexdigest()</span><br><span class="line"><span class="built_in">print</span>(rest2)  <span class="comment"># 0192023a7bbd73250516f069df18b500</span></span><br><span class="line"></span><br><span class="line">md53 = hashlib.md5()</span><br><span class="line">md53.update(<span class="string">b&#x27;admin&#x27;</span>)</span><br><span class="line">md53.update(<span class="string">b&#x27;123&#x27;</span>)</span><br><span class="line">rest3 = md53.hexdigest()</span><br><span class="line"><span class="built_in">print</span>(rest3)  <span class="comment"># 0192023a7bbd73250516f069df18b500</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-特性二"><a href="#1-3-特性二" class="headerlink" title="1.3 特性二"></a>1.3 特性二</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 密文数据越长表示内部对应的算法越复杂 越难被正向破解</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">sha1 = hashlib.sha256()</span><br><span class="line">sha1.update(<span class="string">b&#x27;admin123&#x27;</span>)</span><br><span class="line">rest = sha1.hexdigest()</span><br><span class="line"><span class="built_in">print</span>(rest)  <span class="comment"># 240be518fabd2724ddb6f04eeb1da5967448d7e831c08c8fa822809f74c720a9</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">密文越长表示算法越复杂 对应的破解算法的难度越高</span></span><br><span class="line"><span class="string">但是越复杂的算法所需要消耗的资源也就越多 密文越长基于网络发送需要占据的数据也就越大</span></span><br><span class="line"><span class="string">具体使用什么算法取决于项目要求 一般情况下md5足够了</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-特性三"><a href="#1-4-特性三" class="headerlink" title="1.4 特性三"></a>1.4 特性三</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 涉及到用户密码存储,都是密文,只要用户自己知道明文是什么</span></span><br><span class="line"><span class="comment"># 内部程序员无法得知明文数据</span></span><br><span class="line"><span class="comment"># 数据泄露也无法得知明文数据</span></span><br></pre></td></tr></table></figure>

<h4 id="1-5-加盐处理"><a href="#1-5-加盐处理" class="headerlink" title="1.5 加盐处理"></a>1.5 加盐处理</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在对明文数据做加密处理过程前添加一些干扰项</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">md54 = hashlib.md5()</span><br><span class="line">md54.update(<span class="string">b&#x27;Add salt&#x27;</span>)  <span class="comment"># 此处是自己加的干扰项</span></span><br><span class="line">md54.update(<span class="string">b&#x27;passwordadmin123&#x27;</span>)  <span class="comment"># 此处就是用户传入的数据</span></span><br><span class="line">rest4 = md54.hexdigest()</span><br><span class="line"><span class="built_in">print</span>(rest4)</span><br></pre></td></tr></table></figure>
<h4 id="1-6-动态加盐处理"><a href="#1-6-动态加盐处理" class="headerlink" title="1.6 动态加盐处理"></a>1.6 动态加盐处理</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在对明文数据做加密处理过程前添加一些变化的干扰项</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">password = <span class="string">&#x27;admin123&#x27;</span></span><br><span class="line">md55 = hashlib.md5()</span><br><span class="line"><span class="comment"># 动态加盐(干扰项)  当前时间 用户名的部分 uuid(随机字符串(永远不会重复))</span></span><br><span class="line">md55.update(password[::-<span class="number">1</span>].encode(<span class="string">&#x27;utf8&#x27;</span>))  <span class="comment"># 此时的变化量为用户输入的密码字符串取反的值</span></span><br><span class="line">md55.update(password.encode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">rest5 = md55.hexdigest()</span><br><span class="line"><span class="built_in">print</span>(rest5)  <span class="comment"># 658056dbefa3427fe4dddfbf28d4d54d</span></span><br></pre></td></tr></table></figure>
<h4 id="1-7-校验文件一致性"><a href="#1-7-校验文件一致性" class="headerlink" title="1.7 校验文件一致性"></a>1.7 校验文件一致性</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">文件不是很大的情况下,可以将所有文件内部全部加密处理</span></span><br><span class="line"><span class="string">但是如果文件特别大,全部加密处理相当的耗时好资源,针对大文件可以使用切片读取的方式 </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 方式一: 分开读</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">file_md5</span>(<span class="params">path</span>):</span></span><br><span class="line">    path_size = os.path.getsize(path)  <span class="comment"># 获取文件的大小</span></span><br><span class="line">    md5 = hashlib.md5()</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">while</span> path_size &gt;= <span class="number">4096</span>:  <span class="comment"># 如果文件大于4096</span></span><br><span class="line">            cont = f.read(<span class="number">4096</span>)  <span class="comment"># 每次读取文件4096个字节</span></span><br><span class="line">            md5.update(cont)</span><br><span class="line">            path_size -= <span class="number">4096</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cont = f.read()  <span class="comment"># 文件小于4096一次性读取</span></span><br><span class="line">            <span class="keyword">if</span> cont:</span><br><span class="line">                md5.update(cont)</span><br><span class="line">    <span class="keyword">return</span> md5.hexdigest()  <span class="comment"># 返回加密值</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="comment"># print(file_md5(&#x27;a.log&#x27;))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 校验两个文件</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">diff_file</span>(<span class="params">path1, path2</span>):</span></span><br><span class="line">    <span class="keyword">return</span> file_md5([path1]) == file_md5([path2])</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 方式二:</span></span><br><span class="line"><span class="comment"># 指定分片读取策略(读几段 每段几个字节)  10  f.seek()</span></span><br></pre></td></tr></table></figure>
<h3 id="2-logging模块"><a href="#2-logging模块" class="headerlink" title="2. logging模块"></a>2. <code>logging</code>模块</h3><h4 id="2-1-基本使用"><a href="#2-1-基本使用" class="headerlink" title="2.1 基本使用"></a>2.1 基本使用</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 日志有五个等级(从上往下重要程度不一样)</span></span><br><span class="line"><span class="comment"># logging.debug(&#x27;debug级别&#x27;)  # 10</span></span><br><span class="line"><span class="comment"># logging.info(&#x27;info级别&#x27;)  # 20</span></span><br><span class="line"><span class="comment"># logging.warning(&#x27;warning级别&#x27;)  # 30</span></span><br><span class="line"><span class="comment"># logging.error(&#x27;error级别&#x27;)  # 40</span></span><br><span class="line"><span class="comment"># logging.critical(&#x27;critical级别&#x27;)  # 50</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;默认记录的级别在30及以上&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单使用</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line">file_handler = logging.FileHandler(filename=<span class="string">&#x27;x1.log&#x27;</span>, mode=<span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>,)</span><br><span class="line">logging.basicConfig(</span><br><span class="line">    <span class="built_in">format</span>=<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s -%(module)s:  %(message)s&#x27;</span>,</span><br><span class="line">    datefmt=<span class="string">&#x27;%Y-%m-%d %H:%M:%S %p&#x27;</span>,</span><br><span class="line">    handlers=[file_handler,],</span><br><span class="line">    level=logging.ERROR</span><br><span class="line">)</span><br><span class="line">logging.error(<span class="string">&#x27;日志模块很好学 不要自己吓自己&#x27;</span>)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1.如何控制日志输入的位置</span></span><br><span class="line"><span class="string">    想在文件和终端中同时打印</span></span><br><span class="line"><span class="string">2.不同位置如何做到不同的日志格式</span></span><br><span class="line"><span class="string">    文件详细一些 终端简单一些</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-详细介绍"><a href="#2-2-详细介绍" class="headerlink" title="2.2 详细介绍"></a>2.2 详细介绍</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.logger对象:负责产生日志</span></span><br><span class="line">logger = logging.getLogger(<span class="string">&#x27;转账记录&#x27;</span>)</span><br><span class="line"><span class="comment"># 2.filter对象:负责过滤日志(直接忽略)</span></span><br><span class="line"><span class="comment"># 3.handler对象:负责日志产生的位置</span></span><br><span class="line">hd1 = logging.FileHandler(<span class="string">&#x27;a1.log&#x27;</span>,encoding=<span class="string">&#x27;utf8&#x27;</span>)  <span class="comment"># 产生到文件的</span></span><br><span class="line">hd2 = logging.FileHandler(<span class="string">&#x27;a2.log&#x27;</span>,encoding=<span class="string">&#x27;utf8&#x27;</span>)  <span class="comment"># 产生到文件的</span></span><br><span class="line">hd3 = logging.StreamHandler()  <span class="comment"># 产生在终端的</span></span><br><span class="line"><span class="comment"># 4.formatter对象:负责日志的格式</span></span><br><span class="line">fm1 = logging.Formatter(</span><br><span class="line">    fmt=<span class="string">&#x27;%(asctime)s - %(name)s - %(levelname)s -%(module)s:  %(message)s&#x27;</span>,</span><br><span class="line">    datefmt=<span class="string">&#x27;%Y-%m-%d %H:%M:%S %p&#x27;</span>,</span><br><span class="line">)</span><br><span class="line">fm2 = logging.Formatter(</span><br><span class="line">    fmt=<span class="string">&#x27;%(asctime)s - %(name)s %(message)s&#x27;</span>,</span><br><span class="line">    datefmt=<span class="string">&#x27;%Y-%m-%d&#x27;</span>,</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 5.绑定handler对象</span></span><br><span class="line">logger.addHandler(hd1)</span><br><span class="line">logger.addHandler(hd2)</span><br><span class="line">logger.addHandler(hd3)</span><br><span class="line"><span class="comment"># 6.绑定formatter对象</span></span><br><span class="line">hd1.setFormatter(fm1)</span><br><span class="line">hd2.setFormatter(fm2)</span><br><span class="line">hd3.setFormatter(fm1)</span><br><span class="line"><span class="comment"># 7.设置日志等级</span></span><br><span class="line">logger.setLevel(<span class="number">30</span>)</span><br><span class="line"><span class="comment"># 8.记录日志</span></span><br><span class="line">logger.debug(<span class="string">&#x27;写了半天 好累啊&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-3-配置字典"><a href="#2-3-配置字典" class="headerlink" title="2.3 配置字典"></a>2.3 配置字典</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 核心就在于CV</span></span><br><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"><span class="keyword">import</span> logging.config</span><br><span class="line"></span><br><span class="line">standard_format = <span class="string">&#x27;[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]&#x27;</span> \</span><br><span class="line">                  <span class="string">&#x27;[%(levelname)s][%(message)s]&#x27;</span> <span class="comment">#其中name为getlogger指定的名字</span></span><br><span class="line"></span><br><span class="line">simple_format = <span class="string">&#x27;[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s&#x27;</span></span><br><span class="line"></span><br><span class="line">logfile_path = <span class="string">&#x27;a3.log&#x27;</span></span><br><span class="line"><span class="comment"># log配置字典</span></span><br><span class="line">LOGGING_DIC = &#123;</span><br><span class="line">    <span class="string">&#x27;version&#x27;</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">&#x27;disable_existing_loggers&#x27;</span>: <span class="literal">False</span>,</span><br><span class="line">    <span class="string">&#x27;formatters&#x27;</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;standard&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: standard_format</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&#x27;simple&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;format&#x27;</span>: simple_format</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;filters&#x27;</span>: &#123;&#125;,  <span class="comment"># 过滤日志</span></span><br><span class="line">    <span class="string">&#x27;handlers&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment">#打印到终端的日志</span></span><br><span class="line">        <span class="string">&#x27;console&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.StreamHandler&#x27;</span>,  <span class="comment"># 打印到屏幕</span></span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;simple&#x27;</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">#打印到文件的日志,收集info及以上的日志</span></span><br><span class="line">        <span class="string">&#x27;default&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;class&#x27;</span>: <span class="string">&#x27;logging.handlers.RotatingFileHandler&#x27;</span>,  <span class="comment"># 保存到文件</span></span><br><span class="line">            <span class="string">&#x27;formatter&#x27;</span>: <span class="string">&#x27;standard&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;filename&#x27;</span>: logfile_path,  <span class="comment"># 日志文件</span></span><br><span class="line">            <span class="string">&#x27;maxBytes&#x27;</span>: <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">5</span>,  <span class="comment"># 日志大小 5M</span></span><br><span class="line">            <span class="string">&#x27;backupCount&#x27;</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">&#x27;encoding&#x27;</span>: <span class="string">&#x27;utf-8&#x27;</span>,  <span class="comment"># 日志文件的编码，再也不用担心中文log乱码了</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">&#x27;loggers&#x27;</span>: &#123;</span><br><span class="line">        <span class="comment">#logging.getLogger(__name__)拿到的logger配置  空字符串作为键 能够兼容所有的日志</span></span><br><span class="line">        <span class="string">&#x27;&#x27;</span>: &#123;</span><br><span class="line">            <span class="string">&#x27;handlers&#x27;</span>: [<span class="string">&#x27;default&#x27;</span>, <span class="string">&#x27;console&#x27;</span>],  <span class="comment"># 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕</span></span><br><span class="line">            <span class="string">&#x27;level&#x27;</span>: <span class="string">&#x27;DEBUG&#x27;</span>,</span><br><span class="line">            <span class="string">&#x27;propagate&#x27;</span>: <span class="literal">True</span>,  <span class="comment"># 向上（更高level的logger）传递</span></span><br><span class="line">        &#125;,  <span class="comment"># 当键不存在的情况下 (key设为空字符串)默认都会使用该k:v配置</span></span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用配置字典</span></span><br><span class="line">logging.config.dictConfig(LOGGING_DIC)  <span class="comment"># 自动加载字典中的配置</span></span><br><span class="line">logger1 = logging.getLogger(<span class="string">&#x27;xxx&#x27;</span>)</span><br><span class="line">logger1.debug(<span class="string">&#x27;测试&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="3-第三方模块"><a href="#3-第三方模块" class="headerlink" title="3. 第三方模块"></a>3. 第三方模块</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 并不是python自带的 需要基于网络下载!!!</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;pip所在的路径添加环境变量&#x27;&#x27;&#x27;</span></span><br><span class="line">下载第三方模块的方式</span><br><span class="line">    方式<span class="number">1</span>:命令行借助于pip工具</span><br><span class="line">        pip3 install 模块名  <span class="comment"># 不知道版本默认是最新版</span></span><br><span class="line">        pip3 install 模块名==版本号  <span class="comment"># 指定版本下载</span></span><br><span class="line">        pip3 install 模块名 -i 仓库地址  <span class="comment"># 临时切换</span></span><br><span class="line">        <span class="string">&#x27;&#x27;&#x27;命令行形式永久修改需要修改python解释器源文件&#x27;&#x27;&#x27;</span></span><br><span class="line">    方式<span class="number">2</span>:pycharm快捷方式</span><br><span class="line">        settings </span><br><span class="line">        	project </span><br><span class="line">            	project interprter</span><br><span class="line">                	双击或者加号</span><br><span class="line">        点击右下方manage管理添加源地址即可</span><br><span class="line"><span class="comment"># 下载完第三方模块之后 还是使用import或from import句式导入使用</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">pip命令默认下载的渠道是国外的python官网(有时候会非常的慢)</span></span><br><span class="line"><span class="string">我们可以切换下载的源(仓库)</span></span><br><span class="line"><span class="string">    (1) 阿里云 http://mirrors.aliyun.com/pypi/simple/</span></span><br><span class="line"><span class="string">    (2) 豆瓣 http://pypi.douban.com/simple/</span></span><br><span class="line"><span class="string">    (3) 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/</span></span><br><span class="line"><span class="string">    (4) 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/</span></span><br><span class="line"><span class="string">    (5) 华中科技大学http://pypi.hustunique.com/</span></span><br><span class="line"><span class="string">  </span></span><br><span class="line"><span class="string">pip3 install openpyxl -i http://mirrors.aliyun.com/pypi/simple/</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">下载第三方模块可能报错的情况及解决措施</span></span><br><span class="line"><span class="string">	1.报错的提示信息中含有关键字timeout</span></span><br><span class="line"><span class="string">		原因:网络不稳定</span></span><br><span class="line"><span class="string">		措施:再次尝试 或者切换更加稳定的网络</span></span><br><span class="line"><span class="string">	2.找不到pip命令</span></span><br><span class="line"><span class="string">		环境变量问题</span></span><br><span class="line"><span class="string">	3.没有任何的关键字 不同的模块报不同的错</span></span><br><span class="line"><span class="string">		原因:模块需要特定的计算机环境</span></span><br><span class="line"><span class="string">		措施:拷贝报错信息 打开浏览器 百度搜索即可</span></span><br><span class="line"><span class="string">			pip下载某个模块报错错误信息</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>linux全局配置pip源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir ~/.pip</span><br><span class="line"></span><br><span class="line">cat ~/.pip/pip.conf</span><br><span class="line">[global]</span><br><span class="line">timeout = 6000</span><br><span class="line">index-url = https://pypi.douban.com/simple/</span><br><span class="line">[install]</span><br><span class="line">use-mirrors = <span class="literal">true</span></span><br><span class="line">mirrors = https://pypi.douban.com/simple/</span><br><span class="line">trusted-host = pypi.douban.com</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-模块(三)</title>
    <url>/8ddd5976.html</url>
    <content><![CDATA[<h3 id="random模块"><a href="#random模块" class="headerlink" title="random模块"></a>random模块</h3><ul>
<li><p><code>random()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="built_in">print</span>(random.random())  <span class="comment"># 随机产生一个0-1之间的小数</span></span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
<li><p><code>randint()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="built_in">print</span>(random.radint(<span class="number">1</span>, <span class="number">6</span>))  <span class="comment"># 随机产生一个1-6之间的整数</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>uniform()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="built_in">print</span>(random.uniform(<span class="number">1</span>, <span class="number">6</span>)) <span class="comment"># 随机产生一个1-6之间的小数</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>choice()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="built_in">print</span>(random.choice([<span class="string">&#x27;一等奖&#x27;</span>, <span class="string">&#x27;二等奖&#x27;</span>, <span class="string">&#x27;三等奖&#x27;</span>, <span class="string">&#x27;谢谢惠顾&#x27;</span>]))  <span class="comment"># 随机抽取其中一个</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>sample()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="built_in">print</span>(random.sample([<span class="string">&#x27;安徽省&#x27;</span>, <span class="string">&#x27;江苏省&#x27;</span>, <span class="string">&#x27;山东省&#x27;</span>, <span class="string">&#x27;广东省&#x27;</span>],<span class="number">2</span>))  <span class="comment"># 随机出去指定样本数量</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>shuffle()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">l = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;A&#x27;</span>]</span><br><span class="line">random.shuffle(l)  <span class="comment"># 随机打乱容器类型中的元素</span></span><br><span class="line"><span class="built_in">print</span>(l)</span><br></pre></td></tr></table></figure></li>
<li><p><code>randrange()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="built_in">print</span>(random.randrange(<span class="number">1</span>, <span class="number">10</span>, <span class="number">2</span>))  <span class="comment"># 随机产生1到10之间的奇数,2 步长</span></span><br></pre></td></tr></table></figure></li>
<li><p>验证码生成</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get_code</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="comment"># 提前定义一个存储验证码的变量</span></span><br><span class="line">    code = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment"># 由于需要产生五位 每一位的操作都是一样的 所以肯定需要使用循环</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="comment"># 随机产生一个数字</span></span><br><span class="line">        random_int = <span class="built_in">str</span>(random.randint(<span class="number">0</span>, <span class="number">9</span>))</span><br><span class="line">        <span class="comment"># 随机产生一个大写字母</span></span><br><span class="line">        random_upper = <span class="built_in">chr</span>(random.randint(<span class="number">65</span>, <span class="number">90</span>))</span><br><span class="line">        <span class="comment"># 随机产生一个小写字母</span></span><br><span class="line">        random_lower = <span class="built_in">chr</span>(random.randint(<span class="number">97</span>, <span class="number">122</span>))</span><br><span class="line">        <span class="comment"># 随机选取一个</span></span><br><span class="line">        temp = random.choice([random_int, random_upper, random_lower])</span><br><span class="line">        <span class="comment"># 拼接到字符串中</span></span><br><span class="line">        code += temp</span><br><span class="line">    <span class="keyword">return</span> code</span><br><span class="line">code1 = get_code(<span class="number">5</span>)</span><br><span class="line">code2 = get_code(<span class="number">10</span>)</span><br><span class="line">code3 = get_code(<span class="number">8</span>)</span><br><span class="line"><span class="built_in">print</span>(code1,code2,code3)</span><br></pre></td></tr></table></figure>
<h3 id="os模块"><a href="#os模块" class="headerlink" title="os模块"></a>os模块</h3></li>
<li><p><code>mkdir()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line">os.mkdir(<span class="string">&#x27;test&#x27;</span>)  <span class="comment"># 只能创建单级目录</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>makedirs()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line">os.makesdirs(<span class="string">&#x27;test/tes1&#x27;</span>)  <span class="comment"># 创建test目录和下级目录test1(当前斜线表示Linux系统内)  </span></span><br><span class="line"><span class="comment"># 和 linux命令 mkdir -p test/test1 结果一样</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>rmdir()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line">os.rmdir(<span class="string">&#x27;test&#x27;</span>)  <span class="comment"># 只能删除空目录,否则会报错</span></span><br></pre></td></tr></table></figure></li>
<li><p>获取当前文件所在路径</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">path = os.path.dirname(__file__)</span><br><span class="line"><span class="built_in">print</span>(path)</span><br></pre></td></tr></table></figure></li>
<li><p>路劲拼接</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">path = os.path.dirname(__file__)</span><br><span class="line">db_path = os.path.join(path, <span class="string">&#x27;db&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(db_path)  <span class="comment"># 返回当前路径加db</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>listdir()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列举出指定路径下的文件名称(任意类型文件) 返回的是一个列表</span></span><br><span class="line"><span class="comment"># 相当于Linux命令的 ls</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.listdir()) </span><br><span class="line"><span class="built_in">print</span>(os.listdir(<span class="string">&#x27;/tmp&#x27;</span>))</span><br></pre></td></tr></table></figure></li>
<li><p><code>remove()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.remove(<span class="string">&#x27;a.txt&#x27;</span>)  <span class="comment"># 删除当前a.txt</span></span><br><span class="line"><span class="comment"># 删除文件不能是目录  相当于 rm -f </span></span><br></pre></td></tr></table></figure></li>
<li><p><code>rename()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.rename(<span class="string">&#x27;a.txt&#x27;</span>, <span class="string">&#x27;b.txt&#x27;</span>)  <span class="comment"># 将a.txt 改名为 b.txt</span></span><br><span class="line">os.rename(<span class="string">&#x27;test&#x27;</span>, <span class="string">&#x27;test1&#x27;</span>)  <span class="comment"># 将test目录改为test1目录</span></span><br><span class="line"><span class="comment"># 可以改文件或者目录名字 类似Linux命令的 mv</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>getcwd()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="built_in">print</span>(os.getcwd())  <span class="comment"># 获取当前工作路径  Linux --&gt; pwd </span></span><br></pre></td></tr></table></figure></li>
<li><p><code>chdir()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os </span><br><span class="line">os.chdir(<span class="string">&#x27;/mnt&#x27;</span>)  <span class="comment"># 切换工作路径到/mnt目录  Linux --&gt; cd</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>exists()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断目录或者文件是否存在 存在返回Treu 不存在返回False</span></span><br><span class="line"><span class="keyword">import</span> os </span><br><span class="line"><span class="built_in">print</span>(os.path.exists(<span class="string">&#x27;/tmp&#x27;</span>))  <span class="comment"># 存在目录/tmp返回True 不存在返回False</span></span><br><span class="line"><span class="built_in">print</span>(os.path.exists(<span class="string">&#x27;/tmp/test.txt&#x27;</span>))  <span class="comment"># 存在文件test.txt 返回True 不存在返回False</span></span><br><span class="line"><span class="built_in">print</span>(os.path.exists(<span class="string">&#x27;/tmp/test&#x27;</span>))  <span class="comment"># 存在目录/tmp/test返回True 不存在返回False</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>isfile()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断是否是文件,是文件返回True,是目录返回False</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span>(os.path.isfile(<span class="string">&#x27;/tmp/test.txt&#x27;</span>))  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(os.path.isfile(<span class="string">&#x27;/tmp/&#x27;</span>))  <span class="comment"># Fales</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>isdir()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断是否是目录,是目录返回True,是文件返回False</span></span><br><span class="line"><span class="built_in">print</span>(os.path.exists(<span class="string">&#x27;/tmp/test.txt&#x27;</span>))  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(os.path.isfile(<span class="string">&#x27;/tmp/&#x27;</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>getsize()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取文件大小(字节数)</span></span><br><span class="line"><span class="built_in">print</span>(os.path.getsize(<span class="string">r&#x27;a.txt&#x27;</span>))</span><br></pre></td></tr></table></figure></li>
<li><p>获取目录文件内的文件并按选择读取</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">basic_path = os.path.dirname(__file__)  <span class="comment"># 获取当前文件的路径</span></span><br><span class="line">log_path = os.path.join(basic_path, <span class="string">&#x27;test1&#x27;</span>)  <span class="comment"># 拼接路径,得到 当前路径/test1</span></span><br><span class="line">file_list = os.listdir(log_path)  <span class="comment"># 得到 test1路径下的文件列表</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(file_list,<span class="number">1</span>):  <span class="comment"># 1 file_list[0], 2 file_list[1], 3 file_list[2]</span></span><br><span class="line">        <span class="built_in">print</span>(i,j)</span><br><span class="line">    choice = <span class="built_in">input</span>(<span class="string">&#x27;请输入想查看的日志: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> choice.isdigit():</span><br><span class="line">        choice = <span class="built_in">int</span>(choice)</span><br><span class="line">        <span class="keyword">if</span> choice <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(file_list) + <span class="number">1</span>):  <span class="comment"># range顾头不顾尾所以 加一</span></span><br><span class="line">            file_name = file_list[choice - <span class="number">1</span>]  <span class="comment"># choice是从1开始的,所以取列表索引时需要 减一</span></span><br><span class="line">            file_path = os.path.join(log_path,file_name)  <span class="comment"># 拼接选择的文件绝对路径</span></span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                <span class="built_in">print</span>(f.read())  <span class="comment"># 打印文件内容</span></span><br></pre></td></tr></table></figure>
<h3 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h3></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.path)  <span class="comment"># 搜索模块的路径集</span></span><br><span class="line"><span class="built_in">print</span>(sys.version)  <span class="comment"># 返回python解释器版本以及所处的平台</span></span><br><span class="line"><span class="built_in">print</span>(sys.platform)  <span class="comment"># 返回当前操作系统类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(sys.argv)  <span class="comment"># 获取当前执行文件的绝对路径</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># sys.argv 第二种用法,类似shell脚本的外部传参</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    username = sys.argv[<span class="number">1</span>]  <span class="comment"># 相当于shell脚本中 $1</span></span><br><span class="line">    password = sys.argv[<span class="number">2</span>]  <span class="comment"># 相当于shell脚本中 $2</span></span><br><span class="line">    <span class="keyword">if</span> username == <span class="string">&#x27;jason&#x27;</span> <span class="keyword">and</span> password == <span class="string">&#x27;123&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;正常执行文件内容&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;用户名或密码错误&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;请输入用户名和密码&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;目前只能让你体验一下(游客模式)&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">sys.exit(<span class="number">1</span>)  <span class="comment">#  执行python执行脚本后抛出的异常信息默认为0,在shell中可以使用  echo $?  命令可以捕获到 一般认为0是正常执行，如果抛出其他数值则出现异常,如果python脚本中找到确切的数字就可以找到指定位置</span></span><br></pre></td></tr></table></figure>

<h3 id="序列化模块"><a href="#序列化模块" class="headerlink" title="序列化模块"></a>序列化模块</h3><blockquote>
<p>json格式化数据: 跨语言传输</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line">d = &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;pwd&#x27;</span>: <span class="number">123</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(d,<span class="built_in">type</span>(d))  <span class="comment"># &#123;&#x27;username&#x27;: &#x27;jason&#x27;, &#x27;pwd&#x27;: 123&#125; &lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字典转为json格式的字符串(序列化), 此时是 str 类型, 但是是json的格式</span></span><br><span class="line">res1 = json.dumps(d)</span><br><span class="line"><span class="built_in">print</span>(res1, <span class="built_in">type</span>(res1))  <span class="comment"># &#123;&quot;username&quot;: &quot;jason&quot;, &quot;pwd&quot;: 123&#125; &lt;class &#x27;str&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将json格式字符串转成当前语言对应的某个数据类型(反序列化)</span></span><br><span class="line">res2 = json.loads(res1)</span><br><span class="line"><span class="built_in">print</span>(res2, <span class="built_in">type</span>(res2))  <span class="comment"># &#123;&#x27;username&#x27;: &#x27;jason&#x27;, &#x27;pwd&#x27;: 123&#125; &lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># bytes的</span></span><br><span class="line">bytes_data = <span class="string">b&#x27;&#123;&quot;username&quot;: &quot;jason&quot;, &quot;pwd&quot;: 123&#125;&#x27;</span></span><br><span class="line">bytes_str = bytes_data.decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">bytes_dict = json.loads(bytes_str)</span><br><span class="line"><span class="built_in">print</span>(bytes_dict, <span class="built_in">type</span>(bytes_dict))  <span class="comment"># &#123;&#x27;username&#x27;: &#x27;jason&#x27;, &#x27;pwd&#x27;: 123&#125; &lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字典以json格式写入文件(序列化)</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;a.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(json.dumps(d))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将字典取出来(反序列化)</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;a.json&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line">res = json.loads(data)</span><br><span class="line"><span class="built_in">print</span>(res, <span class="built_in">type</span>(res))  <span class="comment"># &#123;&#x27;username&#x27;: &#x27;jason&#x27;, &#x27;pwd&#x27;: 123&#125; &lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不用write 可以使用dump直接将 字典d 以json格式写入文件(序列化)</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;b.json&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    json.dump(d, f)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 不用read 使用load 将字典d 从文件中去出来,直接转为字典(反序列化)</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;b.json&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    rest = json.load(f)</span><br><span class="line"><span class="built_in">print</span>(rest, <span class="built_in">type</span>(rest))  <span class="comment"># &#123;&#x27;username&#x27;: &#x27;jason&#x27;, &#x27;pwd&#x27;: 123&#125; &lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">暂且可以简单的理解为</span></span><br><span class="line"><span class="string">    序列化就是将其他数据类型转换成字符串过程</span></span><br><span class="line"><span class="string">        json.dumps()</span></span><br><span class="line"><span class="string">    反序列化就是将字符串转换成其他数据类型</span></span><br><span class="line"><span class="string">        json.loads()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="subprocess模块"><a href="#subprocess模块" class="headerlink" title="subprocess模块"></a>subprocess模块</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = subprocess.Popen(<span class="string">&#x27;ps -ef&#x27;</span>,  <span class="comment"># 在终端运行的命令</span></span><br><span class="line">                       shell=<span class="literal">True</span>,  <span class="comment"># 新开一个端口</span></span><br><span class="line">                       stdout=subprocess.PIPE,  <span class="comment"># 执行完命令, 将正确输出放到一个管道里</span></span><br><span class="line">                       stderr=subprocess.PIPE  <span class="comment"># 将错误输出放到一个管道里</span></span><br><span class="line">                       )</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stdout&#x27;</span>,res.stdout.read().decode(<span class="string">&#x27;utf8&#x27;</span>))  <span class="comment"># 获取正确命令执行之后的结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;stderr&#x27;</span>,res.stderr.read().decode(<span class="string">&#x27;utf8&#x27;</span>))  <span class="comment"># 获取错误命令执行之后的结果</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-模块(二)</title>
    <url>/f32e795d.html</url>
    <content><![CDATA[<h3 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h3><blockquote>
<p>在python中使用正则必须借助于模块，re是其中之一</p>
</blockquote>
<ul>
<li><p><code>re.findall()</code></p>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据正则匹配所有符合条件的内容</span></span><br><span class="line"></span><br><span class="line">res = re.findall(<span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;test adsa dcxzawqd &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># [&#x27;t&#x27;, &#x27;t&#x27;] 匹配到有元素时结果是一个列表，没有匹配到时是一个空列表</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>re.search()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据正则匹配到一个符合条件的结束</span></span><br><span class="line"></span><br><span class="line">res = re.search(<span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;test adsa dcxzawqd &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># &lt;_sre.SRE_Match object; span=(6, 7), match=&#x27;d&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(res.group())  <span class="comment"># d</span></span><br><span class="line"><span class="comment"># 返回的是一个结果对象,想要获取值需要通过 group() </span></span><br><span class="line"></span><br><span class="line">res = re.search(<span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;test adsa dcxzawqd &#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(res.group())  <span class="comment"># 当没有匹配到值时用 group() 取值会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以使用判断是否取到值</span></span><br><span class="line"><span class="keyword">if</span> res:</span><br><span class="line">  	<span class="built_in">print</span>(<span class="string">&#x27;res.group()&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  	<span class="built_in">print</span>(<span class="string">&#x27;没匹配到值&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p><code>re.match()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 根据正则从头开始匹配,开头匹配上了就停止匹配 </span></span><br><span class="line"></span><br><span class="line">res = re.match(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;abacad&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># &lt;_sre.SRE_Match object; span=(0, 1), match=&#x27;a&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(res.group())  <span class="comment"># a</span></span><br><span class="line"><span class="comment"># 返回的也是一个结果对象,想获取值需要 group() </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = re.match(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;bbacad&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># None</span></span><br><span class="line"><span class="built_in">print</span>(res.group())  <span class="comment"># 报错</span></span><br><span class="line"><span class="comment"># 当没有匹配到时也会报错</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>re.split()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 先用 a 分割得到 &#x27;&#x27; 和 &#x27;bbcdd&#x27;</span></span><br><span class="line"><span class="comment"># 再用 b 分割得到 &#x27;&#x27; &#x27;&#x27; 和 &#x27;bcdd&#x27;</span></span><br><span class="line"><span class="comment"># 再用 b 分割得到 &#x27;&#x27; &#x27;&#x27; &#x27;&#x27; &#x27;cdd&#x27;</span></span><br><span class="line">res = re.split(<span class="string">&#x27;[ab]&#x27;</span>,<span class="string">&#x27;abbcdd&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># [&#x27;&#x27;, &#x27;&#x27;, &#x27;&#x27;, &#x27;cdd&#x27;]</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>re.sub()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#类似于字符串类型的replace方法</span></span><br><span class="line">res1 = re.sub(<span class="string">&#x27;\d&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;eva3jason4yuan4&#x27;</span>,<span class="number">1</span>)  <span class="comment"># 替换正则匹配到的内容</span></span><br><span class="line">res2 = re.sub(<span class="string">&#x27;\d&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;eva3jason4yuan4&#x27;</span>)  <span class="comment"># 不写默认替换所有</span></span><br><span class="line"><span class="built_in">print</span>(res1)  <span class="comment"># evaHjason4yuan4</span></span><br><span class="line"><span class="built_in">print</span>(res2)  <span class="comment"># evaHjasonHyuanH</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>re.subn()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 返回元组 并提示替换了几处</span></span><br><span class="line">res = re.subn(<span class="string">&#x27;\d&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;eva3jason4yuan4&#x27;</span>,<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># (&#x27;evaHjason4yuan4&#x27;, 1)</span></span><br><span class="line">res = re.subn(<span class="string">&#x27;\d&#x27;</span>,<span class="string">&#x27;H&#x27;</span>,<span class="string">&#x27;eva3jason4yuan4&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># (&#x27;evaHjasonHyuanH&#x27;, 3)</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>re.compile()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将正则表达式生成一个Pattern对象</span></span><br><span class="line">regexp_obj = re.<span class="built_in">compile</span>(<span class="string">&#x27;\d+&#x27;</span>)</span><br><span class="line">res1 = regexp_obj.search(<span class="string">&#x27;absd213j1hjj213jk&#x27;</span>)</span><br><span class="line">res2 = regexp_obj.match(<span class="string">&#x27;123hhkj2h1j3123&#x27;</span>)</span><br><span class="line">res3 = regexp_obj.findall(<span class="string">&#x27;1213k1j2jhj21j3123hh&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res1, res2, res3)  <span class="comment"># &lt;_sre.SRE_Match object; span=(4, 7), match=&#x27;213&#x27;&gt; &lt;_sre.SRE_Match object; span=(0, 3), match=&#x27;123&#x27;&gt; [&#x27;1213&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;21&#x27;, &#x27;3123&#x27;]</span></span><br><span class="line"><span class="built_in">print</span>(res1.group(), res2.group())  <span class="comment"># 213 123</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>re.finditer()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将匹配到的内容存为一个迭代对象</span></span><br><span class="line">res = re.finditer(<span class="string">&#x27;\d+&#x27;</span>, <span class="string">&#x27;ashdklah21h23kj12jk3klj112312121kl131&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>([i.group() <span class="keyword">for</span> i <span class="keyword">in</span> res]) <span class="comment"># [&#x27;21&#x27;, &#x27;23&#x27;, &#x27;12&#x27;, &#x27;3&#x27;, &#x27;112312121&#x27;, &#x27;131&#x27;]</span></span><br></pre></td></tr></table></figure></li>
<li><p>分组优先展示</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 无名分组</span></span><br><span class="line"><span class="comment"># findall针对分组优先展示</span></span><br><span class="line">res = re.findall(<span class="string">&quot;^[1-9]\d&#123;14&#125;(\d&#123;2&#125;[0-9x])?$&quot;</span>,<span class="string">&#x27;110105199812067023&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># [&#x27;023&#x27;]</span></span><br><span class="line"><span class="comment"># 取消分组优先展示</span></span><br><span class="line">res1 = re.findall(<span class="string">&quot;^[1-9](?:\d&#123;14&#125;)(?:\d&#123;2&#125;[0-9x])?$&quot;</span>,<span class="string">&#x27;110105199812067023&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res1)  <span class="comment"># [&#x27;110105199812067023&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有名分组</span></span><br><span class="line">res = re.search(<span class="string">&#x27;^[1-9](?P&lt;xxx&gt;\d&#123;14&#125;)(?P&lt;ooo&gt;\d&#123;2&#125;[0-9x])?$&#x27;</span>,<span class="string">&#x27;110105199812067023&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"><span class="built_in">print</span>(res.group())  <span class="comment"># 110105199812067023</span></span><br><span class="line"><span class="built_in">print</span>(res.group(<span class="number">1</span>))  <span class="comment"># 10105199812067  无名分组的取值方式(索引取)</span></span><br><span class="line"><span class="built_in">print</span>(res.group(<span class="string">&#x27;xxx&#x27;</span>))  <span class="comment"># 10105199812067</span></span><br><span class="line"><span class="built_in">print</span>(res.group(<span class="string">&#x27;ooo&#x27;</span>))  <span class="comment"># 023</span></span><br></pre></td></tr></table></figure></li>
<li><p>通过正则获取网页信息</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">res = requests.get(<span class="string">&#x27;http://www.redbull.com.cn/about/branch&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;index.html&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(res.content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;index.html&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = f.read()</span><br><span class="line"></span><br><span class="line">title_list = re.findall(<span class="string">&#x27;&lt;h2&gt;(.*?)&lt;/h2&gt;&#x27;</span>, data)</span><br><span class="line">address_list = re.findall(<span class="string">&quot;&lt;p class=&#x27;mapIco&#x27;&gt;(.*?)&lt;/p&gt;&quot;</span>, data)</span><br><span class="line">zip_code_list = re.findall(<span class="string">&quot;&lt;p class=&#x27;mailIco&#x27;&gt;(.*?)&lt;/p&gt;&quot;</span>, data)</span><br><span class="line">phone_list = re.findall(<span class="string">&quot;&lt;p class=&#x27;telIco&#x27;&gt;(.*?)&lt;/p&gt;&quot;</span>, data)</span><br><span class="line"></span><br><span class="line">res = <span class="built_in">zip</span>(title_list, address_list, zip_code_list, phone_list)</span><br><span class="line"><span class="comment"># print(list(res))</span></span><br><span class="line"><span class="keyword">for</span> data <span class="keyword">in</span> res:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        公司名称: %s</span></span><br><span class="line"><span class="string">        公司地址: %s</span></span><br><span class="line"><span class="string">        公司邮编: %s</span></span><br><span class="line"><span class="string">        公司电话: %s</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span> % (data[<span class="number">0</span>], data[<span class="number">1</span>], data[<span class="number">2</span>], data[<span class="number">3</span>]))</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="collections模块"><a href="#collections模块" class="headerlink" title="collections模块"></a>collections模块</h3><blockquote>
<p>该模块内部提供了一些高阶的数据类型</p>
</blockquote>
<ul>
<li><p><code> namedtuple()</code></p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 具名元组</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">point = namedtuple(<span class="string">&#x27;坐标&#x27;</span>, [<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>])</span><br><span class="line">res = point(<span class="number">11</span>, <span class="number">22</span>)</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># 坐标(x=11, y=22)</span></span><br><span class="line"><span class="built_in">print</span>(res.x)  <span class="comment"># 11</span></span><br><span class="line"><span class="built_in">print</span>(res.y)  <span class="comment"># 12</span></span><br><span class="line"></span><br><span class="line">card = namedtuple(<span class="string">&#x27;扑克&#x27;</span>, <span class="string">&#x27;花色 点数&#x27;</span>)</span><br><span class="line">card1 = card(<span class="string">&#x27;♠&#x27;</span>, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">card2 = card(<span class="string">&#x27;♥&#x27;</span>, <span class="string">&#x27;K&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(card1)  <span class="comment"># 扑克(花色=&#x27;♠&#x27;, 点数=&#x27;A&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(card2)  <span class="comment"># 扑克(花色=&#x27;♥&#x27;, 点数=&#x27;K&#x27;)</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>deque()</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 双端队列</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 队列模块</span></span><br><span class="line">    <span class="keyword">import</span> queue  <span class="comment"># 内置队列模块:FIFO</span></span><br><span class="line">    <span class="comment"># 初始化队列</span></span><br><span class="line">    <span class="comment"># q = queue.Queue()</span></span><br><span class="line">    <span class="comment"># 往队列中添加元素</span></span><br><span class="line">    q.put(<span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">    q.put(<span class="string">&#x27;second&#x27;</span>)</span><br><span class="line">    q.put(<span class="string">&#x27;third&#x27;</span>)</span><br><span class="line">    <span class="comment"># 从队列中获取元素</span></span><br><span class="line">    <span class="built_in">print</span>(q.get())</span><br><span class="line">    <span class="built_in">print</span>(q.get())</span><br><span class="line">    <span class="built_in">print</span>(q.get())</span><br><span class="line">    <span class="built_in">print</span>(q.get())  <span class="comment"># 值去没了就会原地等待</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># deque()</span></span><br><span class="line">		<span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line">    q = deque([<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>])</span><br><span class="line">    q.append(<span class="number">44</span>)  <span class="comment"># 从右边添加</span></span><br><span class="line">    q.appendleft(<span class="number">55</span>)  <span class="comment"># 从左边添加</span></span><br><span class="line">    <span class="built_in">print</span>(q.pop())  <span class="comment"># 从右边取值</span></span><br><span class="line">    <span class="built_in">print</span>(q.popleft())  <span class="comment"># 从做边取值</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>OrderedDict()</code></p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 有序字典</span></span><br><span class="line">    <span class="comment"># 无序的字典</span></span><br><span class="line">    normal_dict = <span class="built_in">dict</span>([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jason&#x27;</span>), (<span class="string">&#x27;pwd&#x27;</span>, <span class="number">123</span>), (<span class="string">&#x27;hobby&#x27;</span>, <span class="string">&#x27;study&#x27;</span>)])</span><br><span class="line">    <span class="built_in">print</span>(normal_dict)  <span class="comment"># &#123;&#x27;hobby&#x27;: &#x27;study&#x27;, &#x27;pwd&#x27;: 123, &#x27;name&#x27;: &#x27;jason&#x27;&#125; 每次打印出来顺序都不一样</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># </span></span><br><span class="line">    order_dict = OrderedDict([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jason&#x27;</span>), (<span class="string">&#x27;pwd&#x27;</span>, <span class="number">123</span>), (<span class="string">&#x27;hobby&#x27;</span>, <span class="string">&#x27;study&#x27;</span>)])</span><br><span class="line">    <span class="built_in">print</span>(order_dict)  <span class="comment"># 打印结果顺序不变</span></span><br><span class="line"></span><br><span class="line">    OrderedDict([(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;jason&#x27;</span>), (<span class="string">&#x27;pwd&#x27;</span>, <span class="number">123</span>), (<span class="string">&#x27;hobby&#x27;</span>, <span class="string">&#x27;study&#x27;</span>)])</span><br><span class="line">    order_dict[<span class="string">&#x27;xxx&#x27;</span>] = <span class="number">111</span></span><br><span class="line">    <span class="built_in">print</span>(order_dict)  <span class="comment"># 添加的值在最后面</span></span><br><span class="line">   </span><br></pre></td></tr></table></figure></li>
<li><p><code>defaultdict()</code></p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 默认字典</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">values = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>,<span class="number">90</span>]</span><br><span class="line">d = defaultdict(<span class="built_in">list</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> values:</span><br><span class="line">    <span class="keyword">if</span> i &gt; <span class="number">60</span>:</span><br><span class="line">        d[<span class="string">&#x27;k1&#x27;</span>].append(i)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        d[<span class="string">&#x27;k2&#x27;</span>].append(i)</span><br><span class="line"><span class="built_in">print</span>(d)  <span class="comment"># defaultdict(&lt;class &#x27;list&#x27;&gt;, &#123;&#x27;k2&#x27;: [11, 22, 33, 44, 55], &#x27;k1&#x27;: [66, 77, 88, 99, 90]&#125;)</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>Counter()</code></p>
 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 统计字符出现的次数</span></span><br><span class="line">res = <span class="string">&#x27;abcdeabcdabcaba&#x27;</span></span><br><span class="line">new_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> res:</span><br><span class="line">    <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> new_dict:</span><br><span class="line">        new_dict[i] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        new_dict[i] += <span class="number">1</span></span><br><span class="line"><span class="built_in">print</span>(new_dict)  <span class="comment"># &#123;&#x27;a&#x27;: 5, &#x27;b&#x27;: 4, &#x27;c&#x27;: 3, &#x27;d&#x27;: 2, &#x27;e&#x27;: 1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用Counter()</span></span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">ret = Counter(res)</span><br><span class="line"><span class="built_in">print</span>(ret)  <span class="comment"># Counter(&#123;&#x27;a&#x27;: 5, &#x27;b&#x27;: 4, &#x27;c&#x27;: 3, &#x27;d&#x27;: 2, &#x27;e&#x27;: 1&#125;)</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="time模块"><a href="#time模块" class="headerlink" title="time模块"></a>time模块</h3><p>时间的三种表现形式:</p>
<ul>
<li>时间戳: 时间戳表示的是从1970年1月1日00:00:00开始按秒计算的偏移量</li>
<li>结构化时间: 元组(struct_time) 共九个元素:(年，月，日，时，分，秒，一年中第几周，一年中第几天等）</li>
<li>格式化时间: 格式化的时间字符串(Format String)： ‘1999-12-06’</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 常用方法</span></span><br><span class="line">time.sleep()  <span class="comment"># 原地阻塞指定秒数</span></span><br><span class="line">time.time()  <span class="comment"># 获取当前时间戳</span></span><br></pre></td></tr></table></figure>

<p><strong>python中时间日期格式化符号</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python中时间日期格式化符号：</span><br><span class="line">%y 两位数的年份表示（<span class="number">00</span>-<span class="number">99</span>）</span><br><span class="line">%Y 四位数的年份表示（<span class="number">000</span>-<span class="number">9999</span>）</span><br><span class="line">%m 月份（01-<span class="number">12</span>）</span><br><span class="line">%d 月内中的一天（<span class="number">0</span>-<span class="number">31</span>）</span><br><span class="line">%H <span class="number">24</span>小时制小时数（<span class="number">0</span>-<span class="number">23</span>）</span><br><span class="line">%I <span class="number">12</span>小时制小时数（01-<span class="number">12</span>）</span><br><span class="line">%M 分钟数（<span class="number">00</span>=<span class="number">59</span>）</span><br><span class="line">%S 秒（<span class="number">00</span>-<span class="number">59</span>）</span><br><span class="line">%a 本地简化星期名称</span><br><span class="line">%A 本地完整星期名称</span><br><span class="line">%b 本地简化的月份名称</span><br><span class="line">%B 本地完整的月份名称</span><br><span class="line">%c 本地相应的日期表示和时间表示</span><br><span class="line">%j 年内的一天（001-<span class="number">366</span>）</span><br><span class="line">%p 本地A.M.或P.M.的等价符</span><br><span class="line">%U 一年中的星期数（<span class="number">00</span>-<span class="number">53</span>）星期天为星期的开始</span><br><span class="line">%w 星期（<span class="number">0</span>-<span class="number">6</span>），星期天为星期的开始</span><br><span class="line">%W 一年中的星期数（<span class="number">00</span>-<span class="number">53</span>）星期一为星期的开始</span><br><span class="line">%x 本地相应的日期表示</span><br><span class="line">%X 本地相应的时间表示</span><br><span class="line">%Z 当前时区的名称</span><br><span class="line">%% %号本身</span><br></pre></td></tr></table></figure>

<p><strong>python中结构化时间</strong></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/cI9gOu.png" alt="cI9gOu"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> time</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.time()</span><br><span class="line"><span class="number">1637840852.839533</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.strftime(<span class="string">&#x27;%Y-%m-%d %X&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;2021-11-25 19:47:34&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.strftime(<span class="string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)</span><br><span class="line"><span class="string">&#x27;2021-11-25 19:47:56&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>time.localtime()</span><br><span class="line">time.struct_time(tm_year=<span class="number">2021</span>, tm_mon=<span class="number">11</span>, tm_mday=<span class="number">25</span>, tm_hour=<span class="number">19</span>, tm_min=<span class="number">50</span>, tm_sec=<span class="number">35</span>, tm_wday=<span class="number">3</span>, tm_yday=<span class="number">329</span>, tm_isdst=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>几种格式之间的转换</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/bEbO8P.jpg" alt="bEbO8P"></p>
<h3 id="datetime模块"><a href="#datetime模块" class="headerlink" title="datetime模块"></a>datetime模块</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(datetime.date.today())  <span class="comment"># 当前年月日</span></span><br><span class="line"><span class="built_in">print</span>(datetime.datetime.today())  <span class="comment"># 当前年月日时分秒</span></span><br><span class="line"></span><br><span class="line">res = datetime.datetime.today()</span><br><span class="line"><span class="built_in">print</span>(res.year)  <span class="comment"># 返回当前年</span></span><br><span class="line"><span class="built_in">print</span>(res.month)  <span class="comment"># 返回当前月</span></span><br><span class="line"><span class="built_in">print</span>(res.day)  <span class="comment"># 返回当前日</span></span><br><span class="line"><span class="built_in">print</span>(res.weekday())  <span class="comment"># 返回星期(0-6) 0代表周一</span></span><br><span class="line"><span class="built_in">print</span>(res.isoweekday())   <span class="comment"># 返回星期(1-7) 1代表周一</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间差</span></span><br><span class="line">ctime = datetime.datetime.today()</span><br><span class="line">time_tel = datetime.timedelta(days=<span class="number">3</span>)</span><br><span class="line"><span class="built_in">print</span>(ctime)  <span class="comment"># 返回当前年月日时分秒</span></span><br><span class="line"><span class="built_in">print</span>(ctime - time_tel)  <span class="comment"># 当前年月日时分秒往后推三天</span></span><br><span class="line"><span class="built_in">print</span>(ctime + time_tel)  <span class="comment"># 当前年月日时分秒往前推三天</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">日期对象 = 日期对象 +/- timedelta对象</span></span><br><span class="line"><span class="string">timedelta对象 = 日期对象 +/- 日期对象</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">ret = ctime + time_tel</span><br><span class="line"><span class="built_in">print</span>(ret - ctime)  <span class="comment"># 3 days, 0:00:00</span></span><br><span class="line"><span class="built_in">print</span>(ctime - ret)  <span class="comment"># -3 days, 0:00:00</span></span><br></pre></td></tr></table></figure>



<p>python标准库：<a href="https://docs.python.org/zh-cn/3.6/library/">https://docs.python.org/zh-cn/3.6/library/</a></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装NVIDIA驱动</title>
    <url>/b9c60b23.html</url>
    <content><![CDATA[<h3 id="安装NVIDIA驱动"><a href="#安装NVIDIA驱动" class="headerlink" title="安装NVIDIA驱动"></a>安装NVIDIA驱动</h3><h4 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#关闭桌面</span></span><br><span class="line">systemctl <span class="built_in">disable</span> gdm3</span><br><span class="line"></span><br><span class="line"><span class="comment">#禁用nouveau</span></span><br><span class="line">sudo <span class="built_in">echo</span> <span class="string">&quot;blacklist nouveau&quot;</span> &gt;&gt;  /etc/modprobe.d/blacklist.conf</span><br><span class="line">sudo <span class="built_in">echo</span> <span class="string">&quot;options nouveau modeset=0&quot;</span> &gt;&gt;  /etc/modprobe.d/blacklist.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 官网下载Linux版驱动 https://www.nvidia.cn/Download/index.aspx</span></span><br><span class="line"></span><br><span class="line">chmod +x NVIDIA-Linux-x86_64-440.100.run</span><br><span class="line">apt install curl make gcc g++ wget pkg-config --reinstall -y</span><br><span class="line"></span><br><span class="line">./NVIDIA-Linux-x86_64-440.100.run  -a -q -s -z -Z</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#关闭桌面</span></span><br><span class="line">systemctl <span class="built_in">disable</span> gdm3</span><br><span class="line"></span><br><span class="line"><span class="comment">#禁用nouveau</span></span><br><span class="line">sudo <span class="built_in">echo</span> <span class="string">&quot;blacklist nouveau&quot;</span> &gt;&gt;  /etc/modprobe.d/blacklist.conf</span><br><span class="line">sudo <span class="built_in">echo</span> <span class="string">&quot;options nouveau modeset=0&quot;</span> &gt;&gt;  /etc/modprobe.d/blacklist.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找内核版本</span></span><br><span class="line">cat /proc/driver/nvidia/version</span><br><span class="line"></span><br><span class="line"><span class="comment"># 卸载显卡残留依赖</span></span><br><span class="line">sudo apt-get --purge remove nvidia* -y</span><br><span class="line">sudo apt-get --purge remove <span class="string">&quot;*nvidia*&quot;</span> -y</span><br><span class="line">sudo apt-get --purge remove <span class="string">&quot;*cublas*&quot;</span> <span class="string">&quot;cuda*&quot;</span> -y</span><br><span class="line">sudo apt autoremove -y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装驱动460版本</span></span><br><span class="line">apt install nvidia-headless-460 -y</span><br><span class="line">apt install nvidia-utils-460</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装驱动455版本</span></span><br><span class="line">apt install -y nvidia-driver-455 nvidia-utils-455 nvidia-cuda-dev nvidia-cuda-toolkit nvidia-opencl-dev</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查显卡驱动</span></span><br><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>
<h3 id="禁止Ubuntuz自动更新软件包"><a href="#禁止Ubuntuz自动更新软件包" class="headerlink" title="禁止Ubuntuz自动更新软件包"></a>禁止Ubuntuz自动更新软件包</h3><ul>
<li>防止自动更新依赖之后驱动无法正常使用</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sed -i <span class="string">&#x27;s#1#0#g&#x27;</span> /etc/apt/apt.conf.d/20auto-upgrades 1&gt;/dev/null 2&gt;&amp;1</span><br><span class="line">sed -i <span class="string">&#x27;s#1#0#g&#x27;</span> /etc/apt/apt.conf.d/10periodic 1&gt;/dev/null 2&gt;&amp;1</span><br><span class="line">systemctl stop apt-daily.service 1&gt;/dev/null 2&gt;&amp;1</span><br><span class="line">systemctl stop apt-daily.timer 1&gt;/dev/null 2&gt;&amp;1</span><br><span class="line">systemctl stop apt-daily-upgrade.service 1&gt;/dev/null 2&gt;&amp;1</span><br><span class="line">systemctl stop apt-daily-upgrade.timer 1&gt;/dev/null 2&gt;&amp;1</span><br><span class="line">systemctl <span class="built_in">disable</span> apt-daily.service 1&gt;/dev/null 2&gt;&amp;1</span><br><span class="line">systemctl <span class="built_in">disable</span> apt-daily.timer 1&gt;/dev/null 2&gt;&amp;1</span><br><span class="line">systemctl <span class="built_in">disable</span> apt-daily-upgrade.service 1&gt;/dev/null 2&gt;&amp;1</span><br><span class="line">systemctl <span class="built_in">disable</span> apt-daily-upgrade.timer 1&gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Ubuntu</tag>
        <tag>NVIDIA</tag>
      </tags>
  </entry>
  <entry>
    <title>python-软件目录规范和正则表达式</title>
    <url>/26f31071.html</url>
    <content><![CDATA[<h3 id="1-软件开发目录规范"><a href="#1-软件开发目录规范" class="headerlink" title="1. 软件开发目录规范"></a>1. 软件开发目录规范</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">demo</span><br><span class="line">├── <span class="built_in">bin</span>  <span class="comment"># 存放一系列启动文件,当启动文件很少或者只有一个时也可以直接放外面</span></span><br><span class="line">│   └── start.py</span><br><span class="line">├── conf  <span class="comment"># 存放一系列配置文件</span></span><br><span class="line">│   └── settings.py  <span class="comment"># 一般情况下该文件的变量名都大写</span></span><br><span class="line">├── core  <span class="comment"># 存放项目核心代码文件</span></span><br><span class="line">│   └── src.py</span><br><span class="line">├── db  <span class="comment"># 存放数据相关文件</span></span><br><span class="line">│   └── userinfo.txt</span><br><span class="line">├── lib  <span class="comment"># 存放公共的功能</span></span><br><span class="line">│   └── common.py</span><br><span class="line">├── log  <span class="comment"># 存放日志的目录</span></span><br><span class="line">│   └── log.txt</span><br><span class="line">├── readme  <span class="comment"># 存放相关信息(使用说明等)</span></span><br><span class="line">└── requirements.txt  <span class="comment"># 存放项目所需的第三方模块及版本号</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h3 id="2-正则表达式"><a href="#2-正则表达式" class="headerlink" title="2. 正则表达式"></a>2. 正则表达式</h3><ul>
<li><p>正则表达式是利用一些特殊符号的组合去字符串中筛选出符合条件的数据</p>
</li>
<li><p>工具 <a href="https://tool.chinaz.com/regex">https://tool.chinaz.com/regex</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断输入的数字组合是否是合法的手机号</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1.必须是11位</span></span><br><span class="line"><span class="string">2.必须是纯数字</span></span><br><span class="line"><span class="string">3.必须符合手机号的排布  15 16 18 19</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># phone = input(&#x27;请输入你的手机号&gt;&gt;&gt;:&#x27;).strip()</span></span><br><span class="line"><span class="comment"># if len(phone) == 11:</span></span><br><span class="line"><span class="comment">#     if phone.isdigit():</span></span><br><span class="line"><span class="comment">#         if phone.startswith(&#x27;15&#x27;) or phone.startswith(&#x27;16&#x27;) or phone.startswith(&#x27;18&#x27;) or phone.startswith(&#x27;19&#x27;):</span></span><br><span class="line"><span class="comment">#             print(&#x27;手机号正确&#x27;)</span></span><br><span class="line"><span class="comment">#         else:</span></span><br><span class="line"><span class="comment">#             print(&#x27;格式不对&#x27;)</span></span><br><span class="line"><span class="comment">#     else:</span></span><br><span class="line"><span class="comment">#         print(&#x27;手机号必须是纯数字&#x27;)</span></span><br><span class="line"><span class="comment"># else:</span></span><br><span class="line"><span class="comment">#     print(&#x27;必须是11位&#x27;)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line">phone_number = <span class="built_in">input</span>(<span class="string">&#x27;please input your phone number ： &#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> re.match(<span class="string">&#x27;^(13|14|15|18)[0-9]&#123;9&#125;$&#x27;</span>,phone_number):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;是合法的手机号码&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;不是合法的手机号码&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-1-字符组"><a href="#2-1-字符组" class="headerlink" title="2.1 字符组"></a>2.1 字符组</h4><ul>
<li>特征是使用中括号括起来的 ，字符串默认只能单个单个字符匹配</li>
</ul>
<table>
<thead>
<tr>
<th align="left">字符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[123456789]简写[0-9]</td>
<td align="left">匹配数字0-9之间任何一个数字</td>
</tr>
<tr>
<td align="left">[a-z]</td>
<td align="left">匹配小写字母a-z其中任意一个字母</td>
</tr>
<tr>
<td align="left">[A-Z]</td>
<td align="left">匹配大写字母a-z其中任意一个字母</td>
</tr>
<tr>
<td align="left">[a-zA-Z0-9]</td>
<td align="left">匹配所有数字、大写字母、小写字母</td>
</tr>
</tbody></table>
<h4 id="2-2-特殊符号"><a href="#2-2-特殊符号" class="headerlink" title="2.2 特殊符号"></a>2.2 特殊符号</h4><ul>
<li>特殊符号默认也只能匹配单个字符</li>
</ul>
<table>
<thead>
<tr>
<th align="center">字符</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">.</td>
<td align="left">匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td align="center">\d</td>
<td align="left">匹配数字</td>
</tr>
<tr>
<td align="center">^</td>
<td align="left">匹配字符串的开始</td>
</tr>
<tr>
<td align="center">$</td>
<td align="left">匹配字符串的结尾</td>
</tr>
<tr>
<td align="center">a|b</td>
<td align="left">匹配字符a或b</td>
</tr>
<tr>
<td align="center">()</td>
<td align="left">匹配括号内的表达式也表示一个组</td>
</tr>
<tr>
<td align="center">[…]</td>
<td align="left">匹配字符组中的字符</td>
</tr>
<tr>
<td align="center">[^…]</td>
<td align="left">匹配除了字符组中字符的所有字符</td>
</tr>
</tbody></table>
<ul>
<li><code>^</code>与<code>$</code>组合使用可以精准限制要查找的数据</li>
</ul>
<h4 id="2-3-量词"><a href="#2-3-量词" class="headerlink" title="2.3 量词"></a>2.3 量词</h4><ul>
<li>表达式在没有量词的修饰情况下都是单个匹配</li>
<li>量词必须结合(字符串、特殊符号等)一起使用，不能单独出现</li>
<li>量词只能影响前面的一个表达式(ab+ 只能影响b)</li>
<li>正则表达式中的量词默认都是‘贪婪匹配’</li>
</ul>
<table>
<thead>
<tr>
<th>字符</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>重复零次或者更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或者更多次</td>
</tr>
<tr>
<td>？</td>
<td>重复零次或者一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或者更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody></table>
<h4 id="2-4-贪婪匹配与非贪婪匹配"><a href="#2-4-贪婪匹配与非贪婪匹配" class="headerlink" title="2.4 贪婪匹配与非贪婪匹配"></a>2.4 贪婪匹配与非贪婪匹配</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;<span class="number">123</span>&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认贪婪匹配,尽可能的多匹配</span></span><br><span class="line">&lt;.*&gt; 匹配结果是&lt;script&gt;<span class="number">123</span>&lt;/script&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 非贪婪匹配,尽可能的少匹配,结束条件由左右两边决定</span></span><br><span class="line">&lt;.*?&gt; 匹配结果是&lt;script&gt;和&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="取消转义"><a href="#取消转义" class="headerlink" title="取消转义"></a>取消转义</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">在原生的正则表达式中取消转义推荐使用\(每个\只能取消一个字符的转义)</span><br><span class="line">在python中取消转义推荐使用<span class="string">r&#x27;\n\a\t&#x27;</span>(也可以使用\)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-模块(一)</title>
    <url>/5c1fe23f.html</url>
    <content><![CDATA[<h3 id="1-面向过程编程"><a href="#1-面向过程编程" class="headerlink" title="1. 面向过程编程"></a>1. 面向过程编程</h3><p>面向过程编程，核心是过程二字，过程指的是解决问题的步骤，即先干什么、后干什么、再干什么、然后干什么……</p>
<p>基于该思想编写程序就好比在设计一条流水线，面向对称编程其实是一种机械式的思维方式</p>
<p>优点: 复杂的问题流程化，进而简单化</p>
<p>缺点: 一旦要修改功能 那么需要整体改造(牵一发而动全身)</p>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 用户注册功能</span></span><br><span class="line"><span class="comment"># 1.获取用户名和密码</span></span><br><span class="line"><span class="comment"># 2.组织成固定的格式</span></span><br><span class="line"><span class="comment"># 3.文件操作写入文件</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_info</span>():</span></span><br><span class="line">    username = <span class="built_in">input</span>(<span class="string">&#x27;请输入用户名: &#x27;</span>).strip()</span><br><span class="line">    passwd = <span class="built_in">input</span>(<span class="string">&#x27;请输入密码: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(username) == <span class="number">0</span> <span class="keyword">or</span> <span class="built_in">len</span>(passwd) == <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;用户名密码不能为空&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    id_msg = &#123;<span class="string">&#x27;1&#x27;</span>: <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">              <span class="string">&#x27;2&#x27;</span>: <span class="string">&#x27;user&#x27;</span>&#125;</span><br><span class="line">    u_id = <span class="built_in">input</span>(<span class="string">&#x27;%s\n请输入身份: &#x27;</span> % id_msg).strip()</span><br><span class="line">    <span class="keyword">if</span> u_id <span class="keyword">in</span> id_msg:</span><br><span class="line">        user_id = id_msg.get(u_id)</span><br><span class="line">        <span class="keyword">return</span> deal_data(username, passwd, user_id)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;输入的信息不合法&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deal_data</span>(<span class="params">username, passwd, u_id</span>):</span></span><br><span class="line">    msg = <span class="string">&#x27;%s|%s|%s\n&#x27;</span> % (username, passwd, u_id)</span><br><span class="line">    <span class="keyword">return</span> save_data(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">save_data</span>(<span class="params">msg</span>):</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;info.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">get_info()</span><br></pre></td></tr></table></figure>



<h3 id="2-模块简介"><a href="#2-模块简介" class="headerlink" title="2. 模块简介"></a>2. 模块简介</h3><ol>
<li><p><strong>什么是模块</strong></p>
<p>模块是一系列功能的结合体</p>
</li>
<li><p><strong>为什么要用模块</strong></p>
<p>为了提升开发效率</p>
</li>
<li><p><strong>模块的三种来源</strong></p>
<ol>
<li>内置: Python解释器自带的，能直接导入使用</li>
<li>第三方: 别人已经写好的，下载后可以直接拿来用</li>
<li>自定义: 自己写的模块</li>
</ol>
</li>
<li><p><strong>模块的四种表现形式</strong></p>
<ol>
<li>使用Python编写的代码(.py文件)</li>
<li>已被编译为共享库活DLL或C++扩展</li>
<li>包好一组模块的包(文件夹)，其实是多个py文件的集合，包内通常用<code>__init__.py</code>文件</li>
<li>使用C编写并链接到Python解释器的内置模块</li>
</ol>
</li>
</ol>
<p>PS: 在编写大型项目的时候，遇到一些复杂的功能可以先考虑是否有相应的模块可以调用</p>
<h3 id="3-模块的导入"><a href="#3-模块的导入" class="headerlink" title="3. 模块的导入"></a>3. 模块的导入</h3><h4 id="3-1-import"><a href="#3-1-import" class="headerlink" title="3.1 import"></a>3.1 import</h4><ul>
<li><p>在同级目录下创建两个.py文件</p>
<p> mod-imp.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> imtest</span><br><span class="line"></span><br><span class="line">money = <span class="number">999</span></span><br><span class="line"><span class="built_in">print</span>(imtest.money)  <span class="comment"># 1000</span></span><br><span class="line"><span class="built_in">print</span>(imtest.func1())  <span class="comment"># from func1</span></span><br><span class="line">imtest.change()  </span><br><span class="line"><span class="built_in">print</span>(imtest.money)  <span class="comment"># 10</span></span><br><span class="line"><span class="built_in">print</span>(money)  <span class="comment"># 999</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行该文件时会首先打印 imtest模块</span></span><br></pre></td></tr></table></figure>

<p>imtest.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;imtest模块&#x27;</span>)</span><br><span class="line">money = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;from func1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>():</span></span><br><span class="line">    <span class="keyword">global</span> money</span><br><span class="line">    money = <span class="number">10</span></span><br></pre></td></tr></table></figure></li>
<li><p>结论</p>
<ol>
<li>多次导入相同模块时，只会执行一次</li>
<li>首次导入<code>imtest</code>模块的过程<ol>
<li>运行导入文件(import句式.py)产生该文件的全局名称空间</li>
<li>运行<code>imtest.py</code>文件</li>
<li>运行<code>imtest.py</code>内代码，将产生的名字全部存档于<code>imtest.py</code>名称空间</li>
<li>在导入文件名称空间产生一个<code>imtest</code>的名字指向<code>imtest.py</code>全局名称空间</li>
</ol>
</li>
<li>import句式导入模块之后<ol>
<li>通过<code>模块名.</code>的方式可以使用模块内所有的名字，并且肯定不会产生冲突</li>
</ol>
</li>
</ol>
</li>
</ul>
<h4 id="3-2-from…import…"><a href="#3-2-from…import…" class="headerlink" title="3.2 from…import…"></a>3.2 from…import…</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> imtest <span class="keyword">import</span> money, func1, change</span><br></pre></td></tr></table></figure>

<ol>
<li>多次导入相同模块是，只会执行一次</li>
<li>导入发生的过程<ol>
<li>先产生执行文件的全局名称空间</li>
<li>执行模块文件，产生模块的全局名称空间</li>
<li>将模块中执行之后产生的名字全部存档于模块名称空间中</li>
<li>在执行文件中有一个<code>money</code>执行模块名称空间中<code>money</code>指向的值</li>
</ol>
</li>
<li>导入之后<ol>
<li>在使用的时候直接写名字即可，但是当当前名称空间有相同名字的时候，就会产生冲突，使用的就变成了当前名称空间</li>
</ol>
</li>
</ol>
<h4 id="3-3-导入模块扩展用法"><a href="#3-3-导入模块扩展用法" class="headerlink" title="3.3 导入模块扩展用法"></a>3.3 导入模块扩展用法</h4><ol>
<li><p>起别名</p>
<p>既可以给模块起别名也可以给模块中的某个起别名</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> modisverylonglong  <span class="keyword">as</span> m</span><br><span class="line"><span class="keyword">from</span> modisverylonglong <span class="keyword">import</span> name <span class="keyword">as</span> n</span><br></pre></td></tr></table></figure></li>
<li><p>连续导入</p>
<p>可以连续导入多个模块，但是只有当多个模块功能相似或属于同一系列，否则推荐分行导入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> mod1, mod2</span><br><span class="line"><span class="keyword">from</span> mod1 <span class="keyword">import</span> name1, name2</span><br></pre></td></tr></table></figure></li>
<li><p>通用导入</p>
<p>将模块中所有名字全部导入</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> mod <span class="keyword">import</span> *  <span class="comment"># * 表示所有</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__all__ = [<span class="string">&#x27;name1&#x27;</span>, <span class="string">&#x27;name2&#x27;</span>]  <span class="comment"># 在被导入的模块文件中可以使用该方法指定可以被导入的名字,限制的是 * </span></span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="3-4-判断文件类型"><a href="#3-4-判断文件类型" class="headerlink" title="3.4 判断文件类型"></a>3.4 判断文件类型</h4><ul>
<li><p>判断py文件是作为模块文件还是执行文件</p>
<p><code>__name__</code>当文件是执行文件时会返回<code>__main__</code></p>
<p>文件被当做模块导入则返回文件名(模块名)</p>
<p>执行mod-imp.py时</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> imtest</span><br><span class="line"><span class="built_in">print</span>(__name__)  <span class="comment"># __main__</span></span><br><span class="line"><span class="built_in">print</span>(imtest.__name__)  <span class="comment"># imtest</span></span><br></pre></td></tr></table></figure>

<p>执行imtest.py时</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;imtest模块&#x27;</span>)</span><br><span class="line">money = <span class="number">1000</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;from func1&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span>():</span></span><br><span class="line">    <span class="keyword">global</span> money</span><br><span class="line">    money = <span class="number">10</span></span><br><span class="line"><span class="built_in">print</span>(__name__)  <span class="comment"># __main__</span></span><br></pre></td></tr></table></figure></li>
<li><p>应用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">  func1()  <span class="comment"># 可以在这里放测试代码，避免在别模块导入之后执行</span></span><br></pre></td></tr></table></figure>

<p>ps: 在Pycharm中打出main之后按tab自动补全</p>
</li>
</ul>
<h4 id="3-5-循环导入"><a href="#3-5-循环导入" class="headerlink" title="3.5 循环导入"></a>3.5 循环导入</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">当出现循环导入的情况时，程序设计不合理。所以在编写程序时不能出现循环导入现象</span><br></pre></td></tr></table></figure>

<ul>
<li>现象:</li>
</ul>
<p>a.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> b <span class="keyword">import</span> num_b</span><br><span class="line">num_a = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>b.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> a <span class="keyword">import</span> num_a</span><br><span class="line">num_b = <span class="number">20</span></span><br></pre></td></tr></table></figure>

<p>mod-imp.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> a <span class="keyword">import</span> num_a  <span class="comment"># 此时会出现异常</span></span><br></pre></td></tr></table></figure>

<ul>
<li>解决方案:<ol>
<li>调换顺序，将彼此调用的句式放在代码的最后</li>
<li>函数形式，将导入的句式放入到函数体代码，等待所有的名字加载完毕之后再调用(本质等同于调换顺序)</li>
</ol>
</li>
</ul>
<h4 id="3-6-模块导入的顺序"><a href="#3-6-模块导入的顺序" class="headerlink" title="3.6 模块导入的顺序"></a>3.6 模块导入的顺序</h4><ul>
<li><p>查找顺序</p>
<ol>
<li><p>先从内存中查找</p>
</li>
<li><p>再去内置模块中查找</p>
</li>
<li><p>最后去<code>sys.path</code>系统路劲中查找(自定义模块)</p>
<p>如果都没找到就会报错</p>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="built_in">print</span>(sys.path)  <span class="comment"># 结果中你的第一个元素永远是当前执行文件的路径</span></span><br></pre></td></tr></table></figure></li>
<li><p>当自定义模块查找不到的时候解决方案</p>
<ol>
<li><p>手动将该模块的路径添加到<code>sys.path</code>中</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">r&#x27;path&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>from...import...</code></p>
<ol>
<li><code>from</code>    文件夹名称.文件夹名称  <code>import</code>   模块名</li>
<li><code>from</code>    文件夹名称.模块名称     <code>import </code>       名字</li>
</ol>
</li>
</ol>
</li>
</ul>
<h4 id="3-7-绝对导入与相对导入"><a href="#3-7-绝对导入与相对导入" class="headerlink" title="3.7 绝对导入与相对导入"></a>3.7 绝对导入与相对导入</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;在程序中涉及到多个文件之间导入模块的情况 一律按照执行文件所在的路径为准&quot;&quot;&quot;</span></span><br><span class="line">绝对导入</span><br><span class="line">	始终按照执行文件所在的sys.path查找模块</span><br><span class="line">相对导入</span><br><span class="line">	<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">	句点符(.)</span></span><br><span class="line"><span class="string">		.表示当前文件路径</span></span><br><span class="line"><span class="string">		..表示上一层文件路径</span></span><br><span class="line"><span class="string">	&quot;&quot;&quot;</span></span><br><span class="line">    能够打破始终以执行文件为准的规则 只考虑两个文件之间的位置</span><br><span class="line">    <span class="comment"># 相对导入只能用在模块文件中 不能在执行文件中使用</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>CGroups和Namespace</title>
    <url>/4a318272.html</url>
    <content><![CDATA[<h2 id="CGroup"><a href="#CGroup" class="headerlink" title="CGroup"></a>CGroup</h2><h3 id="CGroups概述"><a href="#CGroups概述" class="headerlink" title="CGroups概述"></a>CGroups概述</h3><p><code>CGroups</code> 全称为 <code>Linux Control Group</code>，其作用是限制一组进程使用的资源（CPU、内存等）上限，<code>CGroups</code> 也是 Containerd 容器技术的核心实现原理之一</p>
<span id="more"></span>
<ul>
<li>Task: 在 cgroup 中，task 可以理解为一个进程，但这里的进程和一般意义上的操作系统进程不太一样，实际上是进程 ID 和线程 ID 列表。</li>
<li>CGroup: 即控制组，一个控制组就是一组按照某种标准划分的 Tasks，可以理解为资源限制是以进程组为单位实现的，一个进程加入到某个控制组后，就会受到相应配置的资源限制。</li>
<li>Hierarchy: cgroup 的层级组织关系，cgroup 以树形层级组织，每个 cgroup 子节点默认继承其父 cgroup 节点的配置属性，这样每个 Hierarchy 在初始化会有 root cgroup。</li>
<li>Subsystem: 即子系统，子系统表示具体的资源配置，如CPU使用，内存占用等，Subsystem附加到Hierarchy上后可用。</li>
</ul>
<ul>
<li>查看当前系统支持的CGroups子系统</li>
</ul>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/n6YGX3.png" alt="n6YGX3"></p>
<p>查看cgroup</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">df -h |grep cgroup</span><br></pre></td></tr></table></figure>

<p>查看当前系统挂载了哪些 cgroup</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/fARleD.png" alt="fARleD"></p>
<p><code>/sys/fs/cgroup</code> 目录下的每个子目录就对应着一个子系统，cgroup 是以目录形式组织的，<code>/</code> 是 cgroup 的根目录，但是这个根目录可以被挂载到任意目录，例如 CGroups 的 memory 子系统的挂载点是 <code>/sys/fs/cgroup/memory</code>，那么 <code>/sys/fs/cgroup/memory/</code> 对应 memory 子系统的根目录</p>
<h3 id="CGroups测试"><a href="#CGroups测试" class="headerlink" title="CGroups测试"></a>CGroups测试</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir -p /sys/fsc</span><br><span class="line">ls /sys/fs/cgroup/cpu/klcc.test</span><br><span class="line">cat /sys/fs/cgroup/cpu/klcc.test/cpu.cfs_period_us </span><br><span class="line">cat /sys/fs/cgroup/cpu/klcc.test/cpu.cfs_quota_us </span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/hdIO6e.png" alt="hdIO6e"></p>
<p>目录创建完成后，下面就会已经自动创建 cgroup 的相关文件</p>
<p><code>cpu.cfs_period_us</code> 文件，用来配置 CPU 时间周期长度的，默认为 <code>100000us</code></p>
<p>cpu.cfs_quota_us文件，用来设置在此时间周期长度内所能使用的 CPU 时间数，默认值为-1，表示不受时间限制。</p>
<p>编写一个简单的python脚本消耗cpu</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>直接运行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python cgroup.py &amp;</span><br><span class="line">[1] 8288</span><br></pre></td></tr></table></figure>
<p>此时用top命令查看到 8288 进程已经达到了100%</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/hv8Mr8.png" alt="hv8Mr8"></p>
<p>现在我们将这个进程ID写入到 <code>/sys/fs/cgroup/cpu/klcc.test/tasks</code> 文件下面去，然后设置 <code>/sys/fs/cgroup/cpu/ydzs.test/cpu.cfs_quota_us</code> 为 <code>10000us</code>，因为 <code>cpu.cfs_period_us</code> 默认值为 <code>100000us</code>，所以这表示我们要限制 CPU 使用率为10%：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 8288 &gt;  /sys/fs/cgroup/cpu/klcc.test/tasks</span><br><span class="line"><span class="built_in">echo</span> 10000 &gt; /sys/fs/cgroup/cpu/klcc.test/cpu.cfs_quota_us</span><br></pre></td></tr></table></figure>

<p> 此时使用<code>top</code>命令查看是就是被限制在10%左右了</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/Cw8YLg.png" alt="Cw8YLg"></p>
<p>如果要限制内存等其他资源的话，同样去对应的子系统下面设置资源，并将进程 ID 加入 tasks 中即可。如果要删除这个 cgroup，直接删除文件夹是不行的，需要使用 <code>libcgroup</code> 工具：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install libcgroup libcgroup-tools</span><br><span class="line">cgdelete cpu:klcc.test</span><br></pre></td></tr></table></figure>

<h3 id="容器中CGroup的使用"><a href="#容器中CGroup的使用" class="headerlink" title="容器中CGroup的使用"></a>容器中CGroup的使用</h3><p>创建一个加<code>-m</code>参数限制容器内存</p>
<p>此时启动完成后容器的cgroup会出现在<code>/sys/fs/cgroup/memory/docker</code>下</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/1Sc8kM.png" alt="1Sc8kM"></p>
<p>可以看到很多和内存相关的配置文件</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/Xdpq7i.png" alt="Xdpq7i"></p>
<p>查看<code>memory.limit_in_bytes</code> 结果是创建时设置的内存大小</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat  /sys/fs/cgroup/memory/docker/3f1a79a1ef6d613d36d32a5b7216068ef008d59cce879475b3ce5ad7ee131263/memory.limit_in_bytes </span><br><span class="line">52428800</span><br></pre></td></tr></table></figure>
<p>容器的进程ID也会在task文件中</p>
<p>![image-20211124165322290](/Users/zhijinliu/Library/Application Support/typora-user-images/image-20211124165322290.png)</p>
<p>当删除这个容器之后，相应的容器ID也会被删除</p>
<h2 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h2><p><code>namespace</code> 也称命名空间，是 Linux 为我们提供的用于隔离进程树、网络接口、挂载点以及进程间通信等资源的方法。在日常使用个人 PC 时，我们并没有运行多个完全分离的服务器的需求，但是如果我们在服务器上启动了多个服务，这些服务其实会相互影响的，每一个服务都能看到其他服务的进程，也可以访问宿主机器上的任意文件，一旦服务器上的某一个服务被入侵，那么入侵者就能够访问当前机器上的所有服务和文件，这是我们不愿意看到的，我们更希望运行在同一台机器上的不同服务能做到完全隔离，就像运行在多台不同的机器上一样。而我们这里的容器其实就通过 Linux 的 Namespaces 技术来实现的对不同的容器进行隔离。</p>
<p>linux 共有6(7)种命名空间:</p>
<ul>
<li><code>ipc namespace</code>: 管理对 IPC 资源（进程间通信（信号量、消息队列和共享内存）的访问</li>
<li><code>net namespace</code>: 网络设备、网络栈、端口等隔离</li>
<li><code>mnt namespace</code>: 文件系统挂载点隔离</li>
<li><code>pid namespace</code>: 用于进程隔离</li>
<li><code>user namespace</code>: 用户和用户组隔离（3.8以后的内核才支持）</li>
<li><code>uts namespace</code>: 主机和域名隔离</li>
<li><code>cgroup namespace</code>：用于 cgroup 根目录隔离（4.6以后版本的内核才支持）</li>
</ul>
<p>通过lsns查看当前系统已经创建的名称空间</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/jxos29.png" alt="jxos29"></p>
<p>要查看一个进程所属的命名空间信息，可以到 <code>/proc/&lt;pid&gt;/ns</code> 目录下查看，</p>
<p>这些 namespace 都是链接文件, 格式为 <code>namespaceType:[inode number]</code>，<code>inode number</code> 用来标识一个 namespace，可以理解为 namespace id，如果两个进程的某个命名空间的链接文件指向同一个，那么其相关资源在同一个命名空间中，也就没有隔离了</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/snZVnb.png" alt="snZVnb"></p>
<p>可以看出 nginx 容器启动后，已经为该容器自动创建了单独的 <code>mtn</code>、<code>uts</code>、<code>ipc</code>、<code>pid</code>、<code>net</code> 命名空间，也就是这个容器在这些方面是独立隔离的，其他容器想要和该容器共享某一个命名空间，那么就需要指向同一个命名空间</p>
<p>白嫖地址: <a href="https://www.qikqiak.com/k3s/runtime/cgroups-namespaces/">https://www.qikqiak.com/k3s/runtime/cgroups-namespaces/</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>python-生成器和常见内置函数</title>
    <url>/ae4233d7.html</url>
    <content><![CDATA[<h3 id="异常捕获-二"><a href="#异常捕获-二" class="headerlink" title="异常捕获(二)"></a>异常捕获(二)</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    name</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;代码错误&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;代码正常才会执行了&#x27;</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;代码不管是否异常都会运行&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 断言</span></span><br><span class="line">name = <span class="string">&#x27;jason&#x27;</span></span><br><span class="line"><span class="keyword">assert</span> <span class="built_in">isinstance</span>(name, <span class="built_in">str</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 主动抛出异常</span></span><br><span class="line"><span class="keyword">raise</span> ZeroDivisionError(<span class="string">&#x27;除数不能为0&#x27;</span>)</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="for循环本质"><a href="#for循环本质" class="headerlink" title="for循环本质"></a>for循环本质</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;</span><br><span class="line">res = d.__iter__()  <span class="comment"># StopIteration的异常,该异常是在循环对象穷尽所有元素时的报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># while实现循环打印</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span>(res.__next__())</span><br><span class="line">    <span class="keyword">except</span> StopIteration <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># for循环打印</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> d:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<h3 id="迭代取值与索引取值对比"><a href="#迭代取值与索引取值对比" class="headerlink" title="迭代取值与索引取值对比"></a>迭代取值与索引取值对比</h3><ul>
<li><p>迭代取值</p>
<ol>
<li>不依赖索引进行取值</li>
<li>取值的顺序都是固定的从左到右，无法重复获取</li>
</ol>
</li>
<li><p>索引取值</p>
<ol>
<li>可以重复取值</li>
<li>需要提供有序容器类型才可取值(不是通用方式)</li>
</ol>
</li>
</ul>
<h3 id="生成器对象"><a href="#生成器对象" class="headerlink" title="生成器对象"></a>生成器对象</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">生成器其实就是自定义迭代器</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义阶段就是一个普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_generator</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">11</span> </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;second&#x27;</span>)</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">22</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">当函数体内含有yield关键字 那么在第一次调用函数的时候</span></span><br><span class="line"><span class="string">并不会执行函数体代码 而是将函数变成了生成器(迭代器)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">res = my_generator()  <span class="comment"># 调用函数不执行函数体代码，而是将函数变成生成器(迭代器)</span></span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># &lt;generator object my_generator at 0x7fcc5f7d3888&gt;</span></span><br><span class="line">ret = res.__next__()  <span class="comment"># 每执行一个__next__代码往下运行到yield停止 返回后面的数据</span></span><br><span class="line"><span class="built_in">print</span>(ret)  <span class="comment"># first \n 11</span></span><br><span class="line">ret = res.__next__()  <span class="comment"># 再次执行__next__接着上次停止的地方继续往后 遇到yield再停止</span></span><br><span class="line"><span class="built_in">print</span>(ret)  <span class="comment"># second \n 22</span></span><br></pre></td></tr></table></figure>

<h3 id="自定义range功能"><a href="#自定义range功能" class="headerlink" title="自定义range功能"></a>自定义range功能</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_range</span>(<span class="params">start, stop=<span class="literal">None</span>, step=<span class="number">1</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> stop:</span><br><span class="line">        stop, start = start, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> start &lt; stop:</span><br><span class="line">        <span class="keyword">yield</span> start</span><br><span class="line">        start += step</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> my_range(<span class="number">2</span>, <span class="number">10</span>, <span class="number">2</span>):</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<h3 id="yield传值"><a href="#yield传值" class="headerlink" title="yield传值"></a>yield传值</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_func1</span>(<span class="params">age</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;age is %s &#x27;</span> % age)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        name = <span class="keyword">yield</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s NB&#x27;</span> % name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = generator_func1(<span class="number">18</span>)  <span class="comment"># 不会执行函数体代码，而是转换成生成器</span></span><br><span class="line">res.__next__()</span><br><span class="line">res.send(<span class="string">&#x27;json&#x27;</span>)  <span class="comment"># 给yield传值</span></span><br><span class="line">res.send(<span class="string">&#x27;xxx&#x27;</span>)  <span class="comment"># 再次给yield传值</span></span><br></pre></td></tr></table></figure>

<h3 id="yeild与return对比"><a href="#yeild与return对比" class="headerlink" title="yeild与return对比"></a>yeild与return对比</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">相同点:可以返回值,支持多个并且组织成元组</span><br><span class="line">不同点:</span><br><span class="line">    <span class="keyword">yield</span>:</span><br><span class="line">      <span class="number">1.</span> 函数体代码遇到<span class="keyword">yield</span>不会结束,会<span class="string">&#x27;停住&#x27;</span></span><br><span class="line">      <span class="number">2.</span> <span class="keyword">yield</span>可以将函数变成生成器,并且支持外界传值</span><br><span class="line">    <span class="keyword">return</span>:</span><br><span class="line">      <span class="number">1.</span> 函数体代码遇到<span class="keyword">return</span>直接结束</span><br></pre></td></tr></table></figure>

<h3 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 列表生成式</span></span><br><span class="line">l1 = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>, <span class="number">66</span>]</span><br><span class="line">res = [i + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> l1 <span class="keyword">if</span> i != <span class="number">44</span>]</span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># [12, 23, 34, 56, 67]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成器表达式</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;生成器表达式内部的代码只有在迭代取值的时候才会执行&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">res1 = (i + <span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> l1 <span class="keyword">if</span> i != <span class="number">44</span>)  </span><br><span class="line"><span class="built_in">print</span>(res1)  <span class="comment"># &lt;generator object &lt;genexpr&gt; at 0x7fbbb7e96ca8&gt;</span></span><br><span class="line"><span class="built_in">print</span>(res1.__next__())  <span class="comment"># 12 </span></span><br><span class="line"><span class="built_in">print</span>(res1.__next__())  <span class="comment"># 23</span></span><br><span class="line"><span class="built_in">print</span>(res1.__next__())  <span class="comment"># 24</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>笔试题</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 求和</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">n, i</span>):</span></span><br><span class="line">    <span class="keyword">return</span> n + i</span><br><span class="line"><span class="comment"># 调用之前是函数 调用之后是生成器</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">g = test()  <span class="comment"># 初始化生成器对象</span></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">10</span>]:</span><br><span class="line">    g = (add(n, i) <span class="keyword">for</span> i <span class="keyword">in</span> g)</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    第一次for循环</span></span><br><span class="line"><span class="string">        g = (add(n, i) for i in g)</span></span><br><span class="line"><span class="string">    第二次for循环</span></span><br><span class="line"><span class="string">        g = (add(10, i) for i in (add(10, i) for i in g))</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">res = <span class="built_in">list</span>(g)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment">#A. res=[10,11,12,13]</span></span><br><span class="line"><span class="comment">#B. res=[11,12,13,14]</span></span><br><span class="line">C. res=[<span class="number">20</span>,<span class="number">21</span>,<span class="number">22</span>,<span class="number">23</span>]</span><br><span class="line"><span class="comment">#D. res=[21,22,23,24]</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="常见内置函数"><a href="#常见内置函数" class="headerlink" title="常见内置函数"></a>常见内置函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">abs</span>()  <span class="comment"># 取绝对值</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">abs</span>(-<span class="number">10</span>))  <span class="comment"># 10</span></span><br><span class="line">  </span><br><span class="line"><span class="number">2.</span> <span class="built_in">all</span>()  <span class="built_in">any</span>()</span><br><span class="line">   l = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">0</span>]</span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">all</span>(l))  <span class="comment"># 所有元素为True才是True</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">any</span>(l))  <span class="comment"># 所有元素有一个为True就是True</span></span><br><span class="line">  </span><br><span class="line"><span class="number">3.</span> <span class="built_in">bin</span>()  <span class="built_in">oct</span>()  <span class="built_in">hex</span>() </span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">bin</span>(<span class="number">12</span>))  <span class="comment"># 0b1100  二进制</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">oct</span>(<span class="number">12</span>))  <span class="comment"># 0o14  八进制</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">12</span>))  <span class="comment"># 0xc  十六进制</span></span><br><span class="line">  </span><br><span class="line"><span class="number">4.</span> <span class="built_in">bytes</span>()  <span class="built_in">str</span>()</span><br><span class="line">   res = <span class="string">&#x27;测试&#x27;</span></span><br><span class="line">   ret1 = <span class="built_in">bytes</span>(res, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">   <span class="built_in">print</span>(ret1)  <span class="comment"># b&#x27;\xe6\xb5\x8b\xe8\xaf\x95&#x27;</span></span><br><span class="line">   ret2 = <span class="built_in">str</span>(ret1, <span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">   <span class="built_in">print</span>(ret2)  <span class="comment"># 测试</span></span><br><span class="line">  </span><br><span class="line"><span class="number">5.</span> <span class="built_in">callable</span>()  <span class="comment"># 是否看调用(看是否能加括号运行)</span></span><br><span class="line">   i = <span class="number">1</span></span><br><span class="line">	 <span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">       <span class="keyword">pass</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">callable</span>(i), <span class="built_in">callable</span>(f))  <span class="comment"># Flse True</span></span><br><span class="line">  </span><br><span class="line"><span class="number">6.</span> <span class="built_in">chr</span>()  <span class="built_in">ord</span>()</span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">chr</span>(<span class="number">65</span>))  <span class="comment"># A  按照ASICC码表的数字打印字符</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>))  <span class="comment"># 65  按照ASICC码表的字符打印数字</span></span><br><span class="line">    </span><br><span class="line"><span class="number">7.</span> <span class="built_in">complex</span>()  复数</span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">complex</span>(<span class="number">123</span>))  <span class="comment"># (123+0j)</span></span><br><span class="line">  </span><br><span class="line"><span class="number">8.</span> <span class="built_in">dir</span>()  <span class="comment"># 查看当前对象可以调用的名字</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">       <span class="keyword">pass</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">dir</span>(f))</span><br><span class="line">  </span><br><span class="line"><span class="number">9.</span> <span class="built_in">divmod</span>()  <span class="comment"># 接收两个数字类型参数，返回一个包含商和余数的元组(a // b, a % b)</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">divmod</span>(<span class="number">101</span>, <span class="number">10</span>))  <span class="comment"># (10 1)</span></span><br><span class="line">   应用:</span><br><span class="line">      <span class="comment"># 生成页数</span></span><br><span class="line">      num, more = <span class="built_in">divmod</span>(<span class="number">201</span>, <span class="number">10</span>)</span><br><span class="line">      <span class="keyword">if</span> more:</span><br><span class="line">          num += <span class="number">1</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;总共需要%s页&#x27;</span> % num)</span><br><span class="line">      </span><br><span class="line"><span class="number">10.</span> <span class="built_in">eval</span>()  <span class="built_in">exec</span>()  <span class="comment"># 将字符串内的内容加载执行</span></span><br><span class="line">    s1 = <span class="string">&quot;print(&#x27;hello&#x27;)&quot;</span></span><br><span class="line">    s2 = <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    for i in range(10):</span></span><br><span class="line"><span class="string">        print(i)</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">eval</span>(s1)  <span class="comment"># 只能执行简单的内容</span></span><br><span class="line">    <span class="built_in">exec</span>(s2)  <span class="comment"># 可以执行复杂的内容</span></span><br><span class="line">    </span><br><span class="line"><span class="number">11.</span> <span class="built_in">isinstance</span>()  <span class="comment"># 判断是否属于某个数据类型</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="built_in">isinstance</span>(i, <span class="built_in">int</span>))  <span class="comment"># True</span></span><br><span class="line">    </span><br><span class="line"><span class="number">12.</span> <span class="built_in">pow</span>() </span><br><span class="line">		<span class="built_in">print</span>(<span class="built_in">pow</span>(<span class="number">4</span>, <span class="number">3</span>))  <span class="comment"># 64  4**3</span></span><br><span class="line">  </span><br><span class="line"><span class="number">13.</span> <span class="built_in">round</span>()</span><br><span class="line">		<span class="built_in">print</span>(<span class="built_in">round</span>(<span class="number">4.5</span>))  <span class="comment"># 4</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="built_in">round</span>(<span class="number">4.6</span>))  <span class="comment"># 5</span></span><br><span class="line"> </span><br><span class="line"><span class="number">14.</span> <span class="built_in">sum</span>()  <span class="comment"># 求和</span></span><br><span class="line">    l = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">sum</span>(l))  <span class="comment"># 110 将列表 l 中的元素求和</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-迭代器</title>
    <url>/ccf84d2b.html</url>
    <content><![CDATA[<h3 id="1-常用内置函数"><a href="#1-常用内置函数" class="headerlink" title="1. 常用内置函数"></a>1. 常用内置函数</h3><h4 id="1-1-map"><a href="#1-1-map" class="headerlink" title="1.1 map()"></a>1.1 map()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># map()  # 映射</span></span><br><span class="line">l = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line">res = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x + <span class="number">1</span>, l)  <span class="comment"># 循环获取列表中的每个元素并交给匿名函数保存返回值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(res))  <span class="comment"># [12, 23, 34, 45]</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h4 id="1-2-zip"><a href="#1-2-zip" class="headerlink" title="1.2 zip()"></a>1.2 zip()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zip() 拉链  按最少元素</span></span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">l2 = [<span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;tony&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>]</span><br><span class="line">res = <span class="built_in">zip</span>(l1, l2)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(res))</span><br><span class="line"><span class="comment"># [(1, &#x27;jason&#x27;), (2, &#x27;tony&#x27;), (3, &#x27;xxx&#x27;), (4, &#x27;tom&#x27;), (5, &#x27;bob&#x27;)]</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-max-和min"><a href="#1-3-max-和min" class="headerlink" title="1.3 max()和min()"></a>1.3 max()和min()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># max()求最大值 min()求最小值</span></span><br><span class="line">l3 = [<span class="number">115</span>, <span class="number">292</span>, <span class="number">303</span>, <span class="number">414</span>, <span class="number">526</span>, <span class="number">809</span>, <span class="number">910</span>, <span class="number">101</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(l3))  <span class="comment"># 910</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(l3))  <span class="comment"># 101</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果只接字典时会将K值进行比较</span></span><br><span class="line">d1 = &#123;<span class="string">&quot;alex&quot;</span>: <span class="number">1000000</span>,</span><br><span class="line">      <span class="string">&quot;tony&quot;</span>: <span class="number">20000</span>,</span><br><span class="line">      <span class="string">&quot;jason&quot;</span>: <span class="number">3000000</span>,</span><br><span class="line">      <span class="string">&quot;tom&quot;</span>: <span class="number">8900000000</span>,</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>(d1, key=<span class="keyword">lambda</span> key: d1[key]))  <span class="comment"># tom  循环取值再比较大小，返回K</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">min</span>(d1, key=<span class="keyword">lambda</span> key: d1[key]))  <span class="comment"># tony</span></span><br></pre></td></tr></table></figure>

<h4 id="1-4-filter"><a href="#1-4-filter" class="headerlink" title="1.4 filter()"></a>1.4 filter()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># filter() 过滤</span></span><br><span class="line">l3 = [<span class="number">115</span>, <span class="number">292</span>, <span class="number">303</span>, <span class="number">414</span>, <span class="number">526</span>, <span class="number">809</span>, <span class="number">910</span>, <span class="number">101</span>]</span><br><span class="line">res = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x &gt; <span class="number">400</span>, l3)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(res))  <span class="comment"># [414, 526, 809, 910]</span></span><br></pre></td></tr></table></figure>

<h4 id="1-5-reduce"><a href="#1-5-reduce" class="headerlink" title="1.5 reduce()"></a>1.5 reduce()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># reduce() 归总</span></span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">l3 = [<span class="number">115</span>, <span class="number">292</span>, <span class="number">303</span>, <span class="number">414</span>, <span class="number">526</span>, <span class="number">809</span>, <span class="number">910</span>, <span class="number">101</span>]</span><br><span class="line">res1 = reduce(<span class="keyword">lambda</span> x, y: x + y, l3)</span><br><span class="line">res2 = reduce(<span class="keyword">lambda</span> x, y: x + y, l3, <span class="number">100</span>)  <span class="comment"># 还可以继续添加额外的元素</span></span><br><span class="line"><span class="built_in">print</span>(res1) <span class="comment"># 3470</span></span><br><span class="line"><span class="built_in">print</span>(res2) <span class="comment"># 3570</span></span><br></pre></td></tr></table></figure>

<h3 id="2-可迭代对象"><a href="#2-可迭代对象" class="headerlink" title="2. 可迭代对象"></a>2. 可迭代对象</h3><ol>
<li>迭代:迭代即更新换代,每次的更新都必须依赖上一次的结果<br>迭代提供了一种不依赖索引取值的方  </li>
<li>可迭代对象:内置 <code>__intr__</code>方法的都称之为可迭代对象，内置可通过<code>.</code>的方式查看</li>
<li>双下滑线开头双下滑线结尾的方法叫双下方法名，面向对象的时候为了与隐藏变量名区分开</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过变量名.__查看是否有intr</span></span><br><span class="line">i = <span class="number">12</span>  <span class="comment"># 没有</span></span><br><span class="line">f = <span class="number">11.11</span>  <span class="comment"># 没有</span></span><br><span class="line">s = <span class="string">&#x27;jason&#x27;</span>  <span class="comment"># 有</span></span><br><span class="line">l = [<span class="number">111</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">4</span>]  <span class="comment"># 有</span></span><br><span class="line">d = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;jason&#x27;</span>,<span class="string">&#x27;pwd&#x27;</span>:<span class="number">123</span>&#125;  <span class="comment"># 有</span></span><br><span class="line">t = (<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>)  <span class="comment"># 有</span></span><br><span class="line">se = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;  <span class="comment"># 有</span></span><br><span class="line">b = <span class="literal">True</span>  <span class="comment"># 没有</span></span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">r&#x27;a.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">含有__iter__的有</span></span><br><span class="line"><span class="string">    字符串 列表 字典 元组 集合 文件对象</span></span><br><span class="line"><span class="string">上述通常为可迭代对象</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 两种结果一样</span></span><br><span class="line"><span class="built_in">print</span>(d.__iter__()) <span class="comment"># &lt;dict_keyiterator object at 0x7fdf258b4a98&gt;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">iter</span>(d))</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">可迭代对象调用__iter__方法会变成迭代器对象(老母猪)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">__iter__方法在调用的时候还有一个简便的写法iter()</span></span><br><span class="line"><span class="string">    一般情况下所有的双下方法都会有一个与之对应的简化版本 方法名()</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-迭代器对象"><a href="#3-迭代器对象" class="headerlink" title="3. 迭代器对象"></a>3. 迭代器对象</h3><ol>
<li>迭代器对象:即含有<code>__iter__</code>方法，又含有<code>__next__</code>方法</li>
<li>可以让可迭代对象执行<code>__iter__</code>方法后就可以生成迭代器对象</li>
<li>迭代器对象无论执行多少次<code>__iter__</code>方法还是迭代器对象(本身)</li>
<li>迭代器提供了不依赖于索引取值的方式</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过变量名.__查看是否有next方法</span></span><br><span class="line">i = <span class="number">12</span></span><br><span class="line">f = <span class="number">11.11</span></span><br><span class="line">s = <span class="string">&#x27;jason&#x27;</span></span><br><span class="line">l = [<span class="number">111</span>,<span class="number">22</span>,<span class="number">33</span>,<span class="number">4</span>]</span><br><span class="line">d = &#123;<span class="string">&#x27;username&#x27;</span>:<span class="string">&#x27;jason&#x27;</span>,<span class="string">&#x27;pwd&#x27;</span>:<span class="number">123</span>&#125;  </span><br><span class="line">t = (<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>)  </span><br><span class="line">se = &#123;<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>&#125;  </span><br><span class="line">b = <span class="literal">True</span>  </span><br><span class="line">file = <span class="built_in">open</span>(<span class="string">r&#x27;a.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">res = s.__iter__()  <span class="comment"># 转成迭代器对象</span></span><br><span class="line"><span class="built_in">print</span>(res.__next__())  <span class="comment"># 迭代器对象执行__next__方法其实就是在迭代取值(for循环) j</span></span><br><span class="line"><span class="built_in">print</span>(res.__next__())  <span class="comment"># 在取完元素之后会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面结果是一样的，每次生成新的迭代器对象再执行__next__方法</span></span><br><span class="line"><span class="built_in">print</span>(s.__iter__().__next__())  <span class="comment"># j</span></span><br><span class="line"><span class="built_in">print</span>(s.__iter__().__next__())  <span class="comment"># j</span></span><br></pre></td></tr></table></figure>

<h3 id="4-for循环本质"><a href="#4-for循环本质" class="headerlink" title="4. for循环本质"></a>4. for循环本质</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 循环打印每个元素,不使用for循环</span></span><br><span class="line"><span class="comment"># __iter__和__next__</span></span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将列表转为迭代器对象</span></span><br><span class="line">res = l1.__iter__()</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(res.__next__())  <span class="comment"># 循环执行__next__取值，当取完元素之后会报错</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> l1:</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">for 循环内部原理</span></span><br><span class="line"><span class="string">  1.将关键字in后面的数据先调用__iter__方法转为迭代器对象</span></span><br><span class="line"><span class="string">  2.循环执行__next__方法</span></span><br><span class="line"><span class="string">  3.在取完值后__next__会报错,但是for循环会自动捕获该错误并处理</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-异常捕获"><a href="#5-异常捕获" class="headerlink" title="5. 异常捕获"></a>5. 异常捕获</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 什么是异常</span></span><br><span class="line">	代码运行出错会导致异常 异常发生后如果没有解决方案则会到底整个程序结束</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 异常三个重要组成部分</span></span><br><span class="line">	<span class="number">1.</span>traceback:提示错误的行</span><br><span class="line">  <span class="number">2.</span>XXXError:错误的类型</span><br><span class="line">  <span class="number">3.</span>错误类型冒号后面的内容:错误的详细原因(仔细看可能就会找到解决的方法)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误的种类   </span></span><br><span class="line">    <span class="number">1.</span>语法错误:不被允许的,出现了应该立刻修改!!!</span><br><span class="line">    <span class="number">2.</span>逻辑错误:可以被允许的,出现了之后尽快修改即可</span><br><span class="line">   		<span class="string">&#x27;&#x27;&#x27;修改逻辑错误的过程其实就是在从头到尾理清思路的过程&#x27;&#x27;&#x27;</span></span><br><span class="line">     </span><br><span class="line"><span class="comment"># 基本语法结构</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        有可能会出错的代码</span><br><span class="line">    <span class="keyword">except</span> 错误类型 <span class="keyword">as</span> e:</span><br><span class="line">        出错之后对应的处理机制(e是错误的详细信息)</span><br><span class="line">    <span class="keyword">except</span> 错误类型 <span class="keyword">as</span> e:</span><br><span class="line">        出错之后对应的处理机制(e是错误的详细信息)</span><br><span class="line">    <span class="keyword">except</span> 错误类型 <span class="keyword">as</span> e:</span><br><span class="line">        出错之后对应的处理机制(e是错误的详细信息)</span><br><span class="line"></span><br><span class="line">  eg:</span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">      <span class="built_in">int</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">  <span class="keyword">except</span> NameError <span class="keyword">as</span> e:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;变量名name不存在&#x27;</span>,e)</span><br><span class="line">  <span class="keyword">except</span> ValueError:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;值不是纯数字&#x27;</span>)</span><br><span class="line">      </span><br><span class="line"><span class="comment"># 捕获万能异常</span></span><br><span class="line">  <span class="keyword">try</span>:</span><br><span class="line">      <span class="comment"># int(&#x27;abc&#x27;)</span></span><br><span class="line">      <span class="built_in">print</span>(name)</span><br><span class="line">      <span class="comment"># l = [11]</span></span><br><span class="line">      <span class="comment"># l[100]</span></span><br><span class="line">  <span class="keyword">except</span> Exception:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;你来啥都行 无所谓&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">异常捕获句式和万能异常</span></span><br><span class="line"><span class="string">    1.有可能会出现错误的代码才需要被监测</span></span><br><span class="line"><span class="string">    2.被监测的代码一定要越少越好</span></span><br><span class="line"><span class="string">    3.异常捕获使用频率越低越好</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># while 使用__next__方法抛出异常</span></span><br><span class="line">l1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>, <span class="number">55</span>]</span><br><span class="line">res = l1.__iter__()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="built_in">print</span>(res.__next__())</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-函数使用(三)</title>
    <url>/d5376901.html</url>
    <content><![CDATA[<h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><blockquote>
<p>函数在运行过程中，直接或间接调用了自身</p>
</blockquote>
<span id="more"></span>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 官网表示:python默认的最大递归深度为1000次</span></span><br><span class="line"><span class="comment"># import sys</span></span><br><span class="line"><span class="comment"># print(sys.getrecursionlimit())  # 查看当前递归最大深度</span></span><br><span class="line"><span class="comment"># print(sys.setrecursionlimit(2000))  # 修改递归最大深度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 无限自己调用自己，但是python限制了次数</span></span><br><span class="line"><span class="comment"># 无用递归1:</span></span><br><span class="line">count = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">global</span> count</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;from index&#x27;</span>)</span><br><span class="line">    index()</span><br><span class="line">index()  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 无用递归2:</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;from func&#x27;</span>)</span><br><span class="line">    index()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;from index&#x27;</span>)</span><br><span class="line">    func()</span><br><span class="line">index()  <span class="comment"># 两个函数互相调用</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>递归使用</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>递推:一层层往下推导,每次往下推会相对于上一次复制度一定要有所下降</span><br><span class="line"><span class="number">2.</span>回溯:依据最后的结论往上推导出最初的答案</span><br><span class="line"><span class="number">3.</span>递归一定要有结束条件</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">伪代码:可能无法运行,但是可以表述逻辑</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不打印列表，只打印数字</span></span><br><span class="line">l1 = [<span class="number">1</span>,[<span class="number">2</span>,[<span class="number">3</span>,[<span class="number">4</span>,[<span class="number">5</span>,[<span class="number">6</span>,[<span class="number">7</span>,[<span class="number">8</span>,[<span class="number">9</span>,[<span class="number">10</span>,[<span class="number">11</span>,[<span class="number">12</span>,[<span class="number">13</span>,[<span class="number">14</span>,]]]]]]]]]]]]]]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>(<span class="params">l1</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> l1:</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">type</span>(i) <span class="keyword">is</span> <span class="built_in">int</span>:</span><br><span class="line">            <span class="built_in">print</span>(i)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            func1(i)</span><br><span class="line">func1(l1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 实现阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res = n*factorial(n-<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(factorial(<span class="number">4</span>))  <span class="comment"># 24</span></span><br></pre></td></tr></table></figure>

<ul>
<li>代码可视化运行: <a href="https://pythontutor.com/">https://pythontutor.com/</a></li>
</ul>
<h3 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 在列表中查出指定数字</span></span><br><span class="line"><span class="comment"># 第一种方法 直接用for循环从左往右依次查找</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二种使用二分法,二分法使用前提数据集必须有序</span></span><br><span class="line">num = <span class="number">567</span></span><br><span class="line">l2 = [<span class="number">1</span>, <span class="number">11</span>, <span class="number">23</span>, <span class="number">43</span>, <span class="number">44</span>, <span class="number">57</span>, <span class="number">68</span>, <span class="number">76</span>, <span class="number">81</span>, <span class="number">99</span>, <span class="number">123</span>, <span class="number">222</span>, <span class="number">321</span>, <span class="number">432</span>, <span class="number">444</span>, <span class="number">567</span>, <span class="number">666</span>, <span class="number">712</span>, <span class="number">899</span>, <span class="number">999</span>, <span class="number">1111</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_num</span>(<span class="params">num, l2</span>):</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(l2) == <span class="number">0</span>:  <span class="comment"># 列表中没有这个数</span></span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    sli_num = <span class="built_in">len</span>(l2) // <span class="number">2</span>  <span class="comment"># 先从中间获取位置索引值</span></span><br><span class="line">    <span class="keyword">if</span> num &gt; l2[sli_num]:  <span class="comment"># 与列表中间的值做对比</span></span><br><span class="line">        r_list = l2[sli_num + <span class="number">1</span>:]  <span class="comment"># 如果大于中间值,截取优化右边为新列表</span></span><br><span class="line">        <span class="built_in">print</span>(r_list)</span><br><span class="line">        get_num(num, r_list)  <span class="comment"># 重新走到这个函数</span></span><br><span class="line">    <span class="keyword">elif</span> num &lt; l2[sli_num]:  <span class="comment"># 如果小于中间值,目标值就在左边</span></span><br><span class="line">        l_list = l2[:sli_num]  <span class="comment"># 将左边记录为新列表</span></span><br><span class="line">        <span class="built_in">print</span>(l_list)</span><br><span class="line">        get_num(num, l_list)  <span class="comment"># 继续走到这个函数</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(num)  <span class="comment"># 刚好等于中间值的情况</span></span><br><span class="line"></span><br><span class="line">get_num(<span class="number">444</span>, l2)</span><br></pre></td></tr></table></figure>

<h3 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>当功能需求仅仅是二选一的情况下 那么推荐使用三元表达式</span><br><span class="line"><span class="comment"># 常规使用时</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_num</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">if</span> a &gt; b:</span><br><span class="line">      <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">return</span> b</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用三元表达式后</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_num</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> b </span><br><span class="line"></span><br><span class="line"><span class="comment"># 条件成立抛出if前面的值，否则就抛出else后面的值</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>虽然可以嵌套使用,但是不推荐</span><br><span class="line"></span><br><span class="line"><span class="comment"># 求三个数最大值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_num</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">    <span class="keyword">return</span> a <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> (b <span class="keyword">if</span> b &gt; c <span class="keyword">else</span> c)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(max_num(<span class="number">10</span>, <span class="number">22</span>, <span class="number">33</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 案例二</span></span><br><span class="line">is_free = <span class="built_in">input</span>(<span class="string">&quot;是否收费Y/N:&quot;</span>).strip().upper()</span><br><span class="line">res = <span class="string">&#x27;收费&#x27;</span><span class="keyword">if</span> is_free == <span class="string">&#x27;Y&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;免费&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 案例三</span></span><br><span class="line">username = <span class="built_in">input</span>(<span class="string">&quot;username:&quot;</span>).strip()</span><br><span class="line">res = <span class="string">&#x27;NB&#x27;</span> <span class="keyword">if</span> username == <span class="string">&#x27;jason&#x27;</span> <span class="keyword">else</span> <span class="string">&#x27;LB&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<h3 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 给列表中所有的人名加上_NEW后缀</span></span><br><span class="line">name_list = [<span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;tony&#x27;</span>, <span class="string">&#x27;jerry&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式一:for循环加字符拼接</span></span><br><span class="line">new_list = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> name_list:</span><br><span class="line">    new_list.append(i + <span class="string">&#x27;_NEW&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(new_list)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二:列表生成式</span></span><br><span class="line">new_list = [<span class="string">&#x27;%s_NEW&#x27;</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> name_list]</span><br><span class="line"><span class="built_in">print</span>(new_list)</span><br></pre></td></tr></table></figure>

<h3 id="字典生成式"><a href="#字典生成式" class="headerlink" title="字典生成式"></a>字典生成式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将两个列表合成为一个字典</span></span><br><span class="line">l1 = [<span class="string">&#x27;jason&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;read&#x27;</span>]</span><br><span class="line">l2 = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;hobby&#x27;</span>]</span><br><span class="line"></span><br><span class="line">new_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(l2)):</span><br><span class="line">    new_dict[l2[i]] = l1[i]</span><br><span class="line"><span class="built_in">print</span>(new_dict)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">name_list = [<span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;tony&#x27;</span>, <span class="string">&#x27;tom&#x27;</span>]</span><br><span class="line">res = &#123;i: j <span class="keyword">for</span> i, j <span class="keyword">in</span> <span class="built_in">enumerate</span>(name_list, start=<span class="number">1</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># &#123;1: &#x27;jason&#x27;, 2: &#x27;tony&#x27;, 3: &#x27;tom&#x27;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 枚举</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">enumerate(l1)</span></span><br><span class="line"><span class="string">    针对该方法使用for循环取值 每次会产生两个结果</span></span><br><span class="line"><span class="string">        第一个是从0开始的数字</span></span><br><span class="line"><span class="string">        第二个是被循环对象里面的元素</span></span><br><span class="line"><span class="string">    还可以通过start参数控制起始位置</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 匿名函数:没有名字的函数</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">语法格式:</span></span><br><span class="line"><span class="string">    lambda 形参:返回值</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 简单使用</span></span><br><span class="line">eg1:</span><br><span class="line">a = (<span class="keyword">lambda</span> x, y: x * y)(<span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(a)</span><br><span class="line"></span><br><span class="line">eg2:</span><br><span class="line">res = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line">res2 = [(<span class="keyword">lambda</span> x:x**<span class="number">2</span>)(i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)]</span><br><span class="line"><span class="built_in">print</span>(res2)</span><br><span class="line"></span><br><span class="line">eg3:</span><br><span class="line"><span class="built_in">print</span>((<span class="keyword">lambda</span> a, b: a <span class="keyword">if</span> a &gt; b <span class="keyword">else</span> b)(<span class="number">10</span>, <span class="number">11</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 匿名函数一般不会单独使用，会配合其他函数一起使用</span></span><br><span class="line"><span class="comment"># map() 映射 </span></span><br><span class="line"><span class="comment"># 使用 map(function, iterable)</span></span><br><span class="line"><span class="comment">#         函数名,可迭代对象</span></span><br><span class="line">l = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span>(<span class="params">i</span>):</span></span><br><span class="line">    <span class="keyword">return</span> i ** <span class="number">2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(double, l)))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, l)))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-装饰器</title>
    <url>/3a5cdcf8.html</url>
    <content><![CDATA[<h3 id="1-装饰器定义"><a href="#1-装饰器定义" class="headerlink" title="1. 装饰器定义"></a>1. 装饰器定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">装饰器由名称空间，函数对象，闭包函数组合而来</span><br><span class="line"></span><br><span class="line">装饰:给被装饰对象添加额外的功能</span><br><span class="line">器:指的是工具</span><br><span class="line"></span><br><span class="line">装饰器的原则:开放封闭原则</span><br><span class="line">  开放:对扩展开放</span><br><span class="line">  封闭:对修改封闭</span><br><span class="line">    </span><br><span class="line">装饰器核心思想:在不改变被<span class="string">&quot;装饰对象内部代码&quot;</span>和<span class="string">&quot;原有调用方式&quot;</span>的基础上添加额外的功能</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">eg:</span><br><span class="line">  <span class="keyword">import</span> time</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">      time.sleep(<span class="number">3</span>)  <span class="comment"># 阻塞3秒</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;form index&#x27;</span>)</span><br><span class="line">  start_time = time.time()  <span class="comment"># 记录函数运行之前的时间戳(1970年1月1日开始计算的秒数)</span></span><br><span class="line">  index()  <span class="comment"># 调用函数</span></span><br><span class="line">  end_time = time.time()  <span class="comment"># 记录函数运行之后的时间戳</span></span><br><span class="line">  <span class="built_in">print</span>(end_time - start_time)  <span class="comment"># 计算出函数运行的时间值</span></span><br></pre></td></tr></table></figure>

<h3 id="2-装饰器简易版"><a href="#2-装饰器简易版" class="headerlink" title="2. 装饰器简易版"></a>2. 装饰器简易版</h3><blockquote>
<p>给函数添加统计执行时间的功能</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_time</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">r_time</span>():</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func()</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;程序运行时间为%s&#x27;</span> % (end_time - start_time))</span><br><span class="line">    <span class="keyword">return</span> r_time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">for_loop</span>():</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100000</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">while_loop</span>():</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">100000</span>:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">for_loop = run_time(for_loop)  <span class="comment"># 左侧的for_loop其实是r_time函数名，赋值给一个叫for_loop的变量名</span></span><br><span class="line">for_loop()  <span class="comment"># 只是在使用上感觉还是原来的函数名</span></span><br><span class="line">while_loop = run_time(while_loop)</span><br><span class="line">while_loop()</span><br></pre></td></tr></table></figure>

<h3 id="3-装饰器参数问题"><a href="#3-装饰器参数问题" class="headerlink" title="3. 装饰器参数问题"></a>3. 装饰器参数问题</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_time</span>(<span class="params">*args, **kwargs</span>):</span>  <span class="comment"># 将传入的位置参数组织成元组，关键字参数组织成字典</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        func(*args, **kwargs)  <span class="comment"># 将组织成元组的参数进行拆分成位置参数，将组织成字典的参数拆分成关键字参数</span></span><br><span class="line">        end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;程序运行时间%s&quot;</span> % (end_time - start_time))</span><br><span class="line">    <span class="keyword">return</span> run_time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_name</span>(<span class="params">name</span>):</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;from index name is %s&quot;</span> % name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_age</span>(<span class="params">age</span>):</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;from func age is %s&quot;</span> % age)</span><br><span class="line"></span><br><span class="line">get_name = outer(get_name)</span><br><span class="line">get_name(<span class="string">&#x27;jason&#x27;</span>)</span><br><span class="line">get_age = outer(get_age)</span><br><span class="line">get_age(<span class="number">18</span>)</span><br></pre></td></tr></table></figure>

<h3 id="4-装饰器返回值问题"><a href="#4-装饰器返回值问题" class="headerlink" title="4. 装饰器返回值问题"></a>4. 装饰器返回值问题</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_time</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        res = func(*args, **kwargs)  <span class="comment"># res用于接收被装饰函数的返回值</span></span><br><span class="line">        end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;程序运行时间%s&quot;</span> % (end_time - start_time))</span><br><span class="line">        <span class="keyword">return</span> res  <span class="comment"># 此时run_time函数的返回值就是被装饰函数的返回值了</span></span><br><span class="line">    <span class="keyword">return</span> run_time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">num_max</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">if</span> a &gt; b:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">num_max = outer(num_max)</span><br><span class="line"><span class="built_in">print</span>(num_max(<span class="number">11</span>, <span class="number">22</span>))</span><br></pre></td></tr></table></figure>

<h3 id="5-认证装饰器"><a href="#5-认证装饰器" class="headerlink" title="5. 认证装饰器"></a>5. 认证装饰器</h3><blockquote>
<p>小功能实现</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每次运行都校验用户名和密码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth</span>():</span></span><br><span class="line">        username = <span class="built_in">input</span>(<span class="string">&#x27;username:&#x27;</span>).strip()</span><br><span class="line">        passwd = <span class="built_in">input</span>(<span class="string">&#x27;passwd:&#x27;</span>).strip()</span><br><span class="line">        <span class="keyword">if</span> username == <span class="string">&#x27;jason&#x27;</span> <span class="keyword">and</span> passwd == <span class="string">&#x27;123&#x27;</span>:</span><br><span class="line">            func()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;认证失败&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> auth</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;功能1&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;功能2&quot;</span>)</span><br><span class="line">    </span><br><span class="line">func1 = login(func1)</span><br><span class="line">func1()</span><br><span class="line"></span><br><span class="line">func2 = login(func2)</span><br><span class="line">func2()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 记录用户登录状态,只需要认证一次</span></span><br><span class="line">login_flag = &#123;<span class="string">&#x27;flag&#x27;</span>: <span class="literal">False</span>&#125;  <span class="comment"># 数据为可变类型，则函数名称空间内可以进行修改</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth</span>():</span></span><br><span class="line">        <span class="keyword">if</span> login_flag.get(<span class="string">&#x27;flag&#x27;</span>):</span><br><span class="line">            func()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            username = <span class="built_in">input</span>(<span class="string">&quot;username:&quot;</span>).strip()</span><br><span class="line">            passwd = <span class="built_in">input</span>(<span class="string">&quot;passwd:&quot;</span>).strip()</span><br><span class="line">            <span class="keyword">if</span> username == <span class="string">&#x27;jason&#x27;</span> <span class="keyword">and</span> passwd == <span class="string">&#x27;123&#x27;</span>:</span><br><span class="line">                func()</span><br><span class="line">                login_flag[<span class="string">&#x27;flag&#x27;</span>] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;认证失败&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> auth</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;功能1&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;功能2&quot;</span>)</span><br><span class="line"></span><br><span class="line">func1 = login(func1)</span><br><span class="line">func1()</span><br><span class="line"></span><br><span class="line">func2 = login(func2)</span><br><span class="line">func2()</span><br></pre></td></tr></table></figure>

<h3 id="6-装饰器固定模板"><a href="#6-装饰器固定模板" class="headerlink" title="6. 装饰器固定模板"></a>6. 装饰器固定模板</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;执行函数之前可以添加的额外功能&#x27;</span>)</span><br><span class="line">        res = func(*args, **kwargs)  <span class="comment"># 执行被装饰的函数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;执行函数之后可以添加的额外功能&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> res  <span class="comment"># 将被装饰函数执行之后的返回值返回</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br></pre></td></tr></table></figure>

<h3 id="7-装饰器语法糖"><a href="#7-装饰器语法糖" class="headerlink" title="7. 装饰器语法糖"></a>7. 装饰器语法糖</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;执行函数之前可以添加的额外功能&#x27;</span>)</span><br><span class="line">        res = func(*args, **kwargs)  <span class="comment"># 执行被装饰的函数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;执行函数之后可以添加的额外功能&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> res  <span class="comment"># 将被装饰函数执行之后的返回值返回</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="meta">@outer  </span><span class="comment"># index = outer(index)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;from index&#x27;</span>)</span><br><span class="line"><span class="meta">@outer  </span><span class="comment"># home = outer(home)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;from home&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">装饰器语法糖书写规范</span></span><br><span class="line"><span class="string">    语法糖必须紧贴在被装饰对象的上方</span></span><br><span class="line"><span class="string">装饰器语法糖内部原理</span></span><br><span class="line"><span class="string">    会自动将下面紧贴着的被装饰对象名字当做参数传给装饰器函数调用</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="8-装饰器双层语法糖"><a href="#8-装饰器双层语法糖" class="headerlink" title="8. 装饰器双层语法糖"></a>8. 装饰器双层语法糖</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 带参数带返回值的双层装饰器</span></span><br><span class="line">login_flag = &#123;<span class="string">&#x27;flag&#x27;</span>: <span class="literal">False</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_time</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run_time</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        start_time = time.time()</span><br><span class="line">        res = func(*args, **kwargs)  <span class="comment"># 接收的返回值是func1和func2的</span></span><br><span class="line">        end_time = time.time()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;程序执行时间%s&quot;</span> % (end_time - start_time))</span><br><span class="line">        <span class="keyword">return</span> res  </span><br><span class="line">    <span class="keyword">return</span> run_time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> login_flag.get(<span class="string">&#x27;flag&#x27;</span>):</span><br><span class="line">            res = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> res</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            username = <span class="built_in">input</span>(<span class="string">&quot;username:&quot;</span>).strip()</span><br><span class="line">            passwd = <span class="built_in">input</span>(<span class="string">&quot;passwd:&quot;</span>).strip()</span><br><span class="line">            <span class="keyword">if</span> username == <span class="string">&#x27;jason&#x27;</span> <span class="keyword">and</span> passwd == <span class="string">&#x27;123&#x27;</span>:</span><br><span class="line">                res = func(*args, **kwargs)  <span class="comment"># 接收的返回值是run_time的</span></span><br><span class="line">                login_flag[<span class="string">&#x27;flag&#x27;</span>] = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">return</span> res</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;用户名或密码错误&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> auth</span><br><span class="line"></span><br><span class="line"><span class="meta">@all_time</span></span><br><span class="line"><span class="meta">@login</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;功能1%s&quot;</span> % name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;功能1-&gt;%s&#x27;</span> % name</span><br><span class="line"></span><br><span class="line"><span class="meta">@all_time</span></span><br><span class="line"><span class="meta">@login</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>(<span class="params">name</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;功能2%s&quot;</span> % name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;功能2-&gt;%s&#x27;</span> % name</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(func1(<span class="string">&#x27;购物&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(func2(<span class="string">&#x27;付款&#x27;</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="9-装饰器三层语法糖"><a href="#9-装饰器三层语法糖" class="headerlink" title="9. 装饰器三层语法糖"></a>9. 装饰器三层语法糖</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 判断七句print执行顺序</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outter1</span>(<span class="params">func1</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;加载了outter1&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper1</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;执行了wrapper1&#x27;</span>)</span><br><span class="line">        res1 = func1(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> res1</span><br><span class="line">    <span class="keyword">return</span> wrapper1</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outter2</span>(<span class="params">func2</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;加载了outter2&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper2</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;执行了wrapper2&#x27;</span>)</span><br><span class="line">        res2 = func2(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> res2</span><br><span class="line">    <span class="keyword">return</span> wrapper2</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outter3</span>(<span class="params">func3</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;加载了outter3&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper3</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;执行了wrapper3&#x27;</span>)</span><br><span class="line">        res3 = func3(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> res3</span><br><span class="line">    <span class="keyword">return</span> wrapper3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@outter1</span></span><br><span class="line"><span class="meta">@outter2</span></span><br><span class="line"><span class="meta">@outter3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;from index&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 加载了outter3</span></span><br><span class="line"><span class="comment"># 加载了outter2</span></span><br><span class="line"><span class="comment"># 加载了outter1</span></span><br><span class="line"><span class="comment"># 执行了wrapper1</span></span><br><span class="line"><span class="comment"># 执行了wrapper2</span></span><br><span class="line"><span class="comment"># 执行了wrapper3</span></span><br><span class="line"><span class="comment"># from index</span></span><br></pre></td></tr></table></figure>

<h3 id="10-装饰器修复技术"><a href="#10-装饰器修复技术" class="headerlink" title="10. 装饰器修复技术"></a>10. 装饰器修复技术</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @wraps(<span class="params">func</span>)  </span><span class="comment"># 修复技术就是为了让被装饰对象更加不容易被察觉装饰了</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;执行函数之前可以添加的额外功能&#x27;</span>)</span><br><span class="line">        res = func(*args, **kwargs)  <span class="comment"># 执行被装饰的函数</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;执行函数之后可以添加的额外功能&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> res  <span class="comment"># 将被装饰函数执行之后的返回值返回</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@outer  </span><span class="comment"># index = outer(index)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;from index&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(index)</span><br><span class="line"><span class="built_in">help</span>(index)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>():</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;这是一个home函数&quot;&quot;&quot;</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;from home&#x27;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># help(index)</span></span><br><span class="line"><span class="comment"># help(home)</span></span><br><span class="line"><span class="comment"># print(index)</span></span><br><span class="line"><span class="comment"># help(len)</span></span><br></pre></td></tr></table></figure>

<h3 id="11-有参装饰器"><a href="#11-有参装饰器" class="headerlink" title="11. 有参装饰器"></a>11. 有参装饰器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 通过第三层传值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>(<span class="params">source_data</span>):</span></span><br><span class="line">    <span class="comment"># source_data = &#x27;file&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login_auth</span>(<span class="params">func</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">auth</span>(<span class="params">*args,**kwargs</span>):</span></span><br><span class="line">            <span class="comment"># 2.校验用户名和密码是否正确</span></span><br><span class="line">            <span class="comment"># 数据的校验方式可以切换多种</span></span><br><span class="line">            <span class="keyword">if</span> source_data == <span class="string">&#x27;file&#x27;</span>:</span><br><span class="line">                <span class="comment"># 从文件中获取用户数据并比对</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;file文件获取&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> source_data == <span class="string">&#x27;MySQL&#x27;</span>:</span><br><span class="line">                <span class="comment"># 从MySQL数据库中获取数据比对</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;MySQL数据库获取&#x27;</span>)</span><br><span class="line">            <span class="keyword">elif</span> source_data == <span class="string">&#x27;postgreSQL&#x27;</span>:</span><br><span class="line">                <span class="comment"># 从postgreSQL数据库中获取数据对比</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;postgreSQL数据库获取&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;用户名或密码错误 无法执行函数&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> auth</span><br><span class="line">    <span class="keyword">return</span> login_auth</span><br><span class="line"></span><br><span class="line"><span class="meta">@outer(<span class="params"><span class="string">&#x27;file&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;from index&#x27;</span>)</span><br><span class="line"><span class="meta">@outer(<span class="params"><span class="string">&#x27;MySQL&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">home</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;from home&#x27;</span>)</span><br><span class="line"></span><br><span class="line">index()</span><br><span class="line">home()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-函数使用(二)</title>
    <url>/abc4492a.html</url>
    <content><![CDATA[<h2 id="1-名称空间作用域"><a href="#1-名称空间作用域" class="headerlink" title="1. 名称空间作用域"></a>1. 名称空间作用域</h2><ol>
<li><p>作用域</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">名称空间所能够作用的范围</span><br></pre></td></tr></table></figure></li>
<li><p>内置名称空间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">程序任何阶段位置均可使用(全局有效)</span><br></pre></td></tr></table></figure>
<span id="more"></span></li>
<li><p>全局名称空间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">程序任何阶段位置均可使用(全局有效)</span><br></pre></td></tr></table></figure></li>
<li><p>局部名称空间</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">一般情况下只在各自的局部名称空间中有效</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="2-global与nonlocal"><a href="#2-global与nonlocal" class="headerlink" title="2. global与nonlocal"></a>2. global与nonlocal</h2><h3 id="2-1-global"><a href="#2-1-global" class="headerlink" title="2.1 global"></a>2.1 global</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">eg1:</span><br><span class="line">x = <span class="number">111</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="keyword">global</span> x  <span class="comment"># 局部修改全局变量</span></span><br><span class="line">    x = <span class="number">222</span></span><br><span class="line">index()  <span class="comment"># 调用函数之后,因为有了global，x可以被修改</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 结果为222</span></span><br><span class="line"></span><br><span class="line">eg2:</span><br><span class="line">name_list = [<span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">a</span>):</span></span><br><span class="line">    name_list.append(a)</span><br><span class="line">index(<span class="string">&#x27;tony&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(name_list)  <span class="comment"># [&#x27;jason&#x27;, &#x27;xxx&#x27;, &#x27;tony&#x27;]</span></span><br><span class="line"></span><br><span class="line">结论:</span><br><span class="line">  如果想在局部修改全局数据</span><br><span class="line">    数据为不可变类型则需要关键字<span class="keyword">global</span>声明</span><br><span class="line">    数据为可变类型则不需要关键字<span class="keyword">global</span>声明</span><br></pre></td></tr></table></figure>

<h3 id="2-2-nolocal"><a href="#2-2-nolocal" class="headerlink" title="2.2 nolocal"></a>2.2 nolocal</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">eg1:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    x = <span class="number">111</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">        <span class="keyword">nonlocal</span> x  <span class="comment"># 内部的局部修改外部的局部数据使用 nonlocal </span></span><br><span class="line">        x = <span class="number">222</span></span><br><span class="line">    func()  <span class="comment"># 此时已经将 x 重新赋值为222</span></span><br><span class="line">    <span class="built_in">print</span>(x)  <span class="comment"># 打印x</span></span><br><span class="line">index()  <span class="comment"># 调用index函数,结果为222</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">eg2:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    l1 = [<span class="string">&#x27;jason&#x27;</span>, <span class="number">18</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">        l1.append(<span class="string">&#x27;male&#x27;</span>)</span><br><span class="line">    func()</span><br><span class="line">    <span class="built_in">print</span>(l1)  <span class="comment"># [&#x27;jason&#x27;, 18, &#x27;male&#x27;]</span></span><br></pre></td></tr></table></figure>



<h2 id="3-函数使用"><a href="#3-函数使用" class="headerlink" title="3. 函数使用"></a>3. 函数使用</h2><h3 id="3-1-函数对象-函数名"><a href="#3-1-函数对象-函数名" class="headerlink" title="3.1 函数对象(函数名)"></a>3.1 函数对象(函数名)</h3><blockquote>
<p><strong>函数名遇到括号就会被调用</strong></p>
</blockquote>
<ol>
<li><p>用法一：函数名可以当做变量名赋值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;from index&quot;</span>)</span><br><span class="line">a = index</span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># &lt;function index at 0x7fcb278c5ea0&gt; 相当于函数的内存地址</span></span><br><span class="line">a()  <span class="comment"># 相当于调用index() 结果为 from index</span></span><br></pre></td></tr></table></figure></li>
<li><p>用法二：函数名可以当做函数的参数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;from index&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;from func&quot;</span>)</span><br><span class="line">    <span class="built_in">print</span>(a)  <span class="comment"># 函数的内存地址</span></span><br><span class="line">    a()</span><br><span class="line">func(index) </span><br><span class="line"><span class="comment"># from func</span></span><br><span class="line"><span class="comment"># from index</span></span><br></pre></td></tr></table></figure></li>
<li><p>用法三：函数名可以当做函数的返回值</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;from index&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;from func&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> index</span><br><span class="line">res = func()  <span class="comment"># 先得到 from func</span></span><br><span class="line"><span class="built_in">print</span>(res)  <span class="comment"># 得到func函数的返回值，是index函数的内存地址</span></span><br><span class="line">res()  <span class="comment"># 得到 from index</span></span><br></pre></td></tr></table></figure></li>
<li><p>用法四：函数名可以当做容器类型(内部可以存放多个数据)的元素</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">eg1:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;from index&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;from func&quot;</span>)</span><br><span class="line">l1 = [index, func]</span><br><span class="line">l1[<span class="number">0</span>]()  <span class="comment"># 本质就是index() 即调用函数index</span></span><br><span class="line">l1[<span class="number">1</span>]()  <span class="comment"># 本质就是func()  即调用函数func</span></span><br><span class="line"><span class="built_in">print</span>(l1)  <span class="comment"># 得到函数index和func的内存地址</span></span><br><span class="line"></span><br><span class="line">eg2:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;功能1&quot;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;功能2&quot;</span>)</span><br><span class="line">choice_dict = &#123;<span class="string">&#x27;1&#x27;</span>: func1,</span><br><span class="line">               <span class="string">&#x27;2&#x27;</span>: func2&#125;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        1.功能1</span></span><br><span class="line"><span class="string">        2.功能2</span></span><br><span class="line"><span class="string">        3.退出</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br><span class="line">    choice = <span class="built_in">input</span>(<span class="string">&quot;请输入选项&gt;&gt;&gt;: &quot;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> choice == <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;退出&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 比if-elif-else格式精简</span></span><br><span class="line">        <span class="keyword">if</span> choice <span class="keyword">in</span> choice_dict:</span><br><span class="line">            func_name = choice_dict.get(choice)</span><br><span class="line">            func_name()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;选项不存在&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-2-函数嵌套调用"><a href="#3-2-函数嵌套调用" class="headerlink" title="3.2 函数嵌套调用"></a>3.2 函数嵌套调用</h3><ul>
<li><p>函数内部调用其他函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">eg1:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>():</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;from index&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    index()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;from func&#x27;</span>)</span><br><span class="line">func()</span><br><span class="line"></span><br><span class="line">eg2:</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">two_max</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">if</span> a &gt; b:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">four_max</span>(<span class="params">x, y, m, n</span>):</span></span><br><span class="line">    res1 = two_max(x, y)</span><br><span class="line">    res2 = two_max(res1, m)</span><br><span class="line">    res3 = two_max(res2, n)</span><br><span class="line">    <span class="keyword">return</span> res3</span><br><span class="line"><span class="built_in">max</span> = four_max(<span class="number">11</span>, <span class="number">23</span>, <span class="number">9</span>, <span class="number">59</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">max</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-3-函数嵌套定义"><a href="#3-3-函数嵌套定义" class="headerlink" title="3.3 函数嵌套定义"></a>3.3 函数嵌套定义</h3><ul>
<li><p>函数体内部定义其他函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将复杂的功能全部隐藏起来，暴露一个简单的接口</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_func</span>(<span class="params"><span class="built_in">type</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;功能一&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;功能二&#x27;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func3</span>():</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;功能三&#x27;</span>)</span><br><span class="line">    all_dict = &#123;<span class="string">&#x27;1&#x27;</span>: func1,</span><br><span class="line">                <span class="string">&#x27;2&#x27;</span>: func2,</span><br><span class="line">                <span class="string">&#x27;3&#x27;</span>: func3&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">type</span> <span class="keyword">in</span> all_dict:</span><br><span class="line">        func_name = all_dict.get(<span class="built_in">type</span>)</span><br><span class="line">        func_name()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;功能不存在&quot;</span>)</span><br><span class="line">        </span><br><span class="line">all_func(<span class="string">&#x27;2&#x27;</span>)  <span class="comment"># 功能二</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-4-闭包函数"><a href="#3-4-闭包函数" class="headerlink" title="3.4 闭包函数"></a>3.4 闭包函数</h3><ol>
<li><p>闭包函数定义</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">闭:定义在函数内部的函数</span><br><span class="line">包:内部函数使用了外部函数名称空间中的名字</span><br><span class="line">  </span><br><span class="line">eg:</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">outer</span>():</span></span><br><span class="line">      x = <span class="number">111</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&#x27;form func&#x27;</span>, x)</span><br><span class="line">      <span class="keyword">return</span> func</span><br><span class="line">  <span class="built_in">print</span>(outer())</span><br><span class="line">  a = outer()</span><br><span class="line">  a()</span><br></pre></td></tr></table></figure></li>
<li><p>函数传参的两种方式</p>
<ol>
<li><p>方式一:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 函数体代码需要用到的数据直接在括号内定义形参即可</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">username</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(username)</span><br><span class="line">index(<span class="string">&#x27;jason&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
<li><p>方式二:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 闭包函数</span></span><br><span class="line">eg1:</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">outer</span>(<span class="params">x, y</span>):</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">          <span class="keyword">if</span> x &gt; y:</span><br><span class="line">              <span class="keyword">return</span> x</span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">              <span class="keyword">return</span> y</span><br><span class="line">      <span class="keyword">return</span> func</span><br><span class="line">  res = outer(<span class="number">23</span>, <span class="number">5</span>)</span><br><span class="line">  <span class="built_in">print</span>(res())  <span class="comment"># 23</span></span><br><span class="line">  <span class="built_in">print</span>(res())  <span class="comment"># 23</span></span><br><span class="line">  </span><br><span class="line">eg2:</span><br><span class="line">  <span class="keyword">import</span> requests</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">outer</span>(<span class="params">url</span>):</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">get_content</span>():</span></span><br><span class="line">          res = requests.get(url)</span><br><span class="line">          <span class="keyword">if</span> res.status_code == <span class="number">200</span>:</span><br><span class="line">              <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;xxx.html&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                  f.write(res.content)</span><br><span class="line">      <span class="keyword">return</span> get_content</span><br><span class="line"></span><br><span class="line">  res = outer(<span class="string">&#x27;https://jd.com&#x27;</span>)  <span class="comment"># 需要爬哪个网站直接替换实参，比定义全局url更灵活</span></span><br><span class="line">  res()</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx安装配置使用</title>
    <url>/13085aa8.html</url>
    <content><![CDATA[<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#全一些的依赖</span></span><br><span class="line">yum install -y libxml2 libxml2-devel openssl \</span><br><span class="line">openssl-devel bzip2 bzip2-devel libcurl \</span><br><span class="line">libcurl-devel libjpeg libjpeg-devel \</span><br><span class="line">libpng libpng-devel freetype freetype-devel \</span><br><span class="line">gmp gmp-devel libmcrypt libmcrypt-devel \</span><br><span class="line">readline readline-devel libxslt libxslt-devel  \</span><br><span class="line">libicu-devel  openldap  openldap-devel \</span><br><span class="line">make zlib zlib-devel gcc-c++ libtool \</span><br><span class="line">pcre pcre-devel  cmake gcc  ncurses ncurses-devel \</span><br><span class="line">bison bison-devel libgcrypt perl wget</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#最小依赖</span></span><br><span class="line">yum -y install gcc zlib zlib-devel pcre-devel openssl openssl-devel</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建www用户管理nginx并设置为不可登录</span></span><br><span class="line">useradd www</span><br><span class="line">usermod -s nologin www</span><br><span class="line"></span><br><span class="line"><span class="comment">#www用户一步到位#</span></span><br><span class="line">useradd -s nologin www</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建nginx工作目录</span></span><br><span class="line">mkdir -p /usr/<span class="built_in">local</span>/nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建存放nginx下载的目录</span></span><br><span class="line">mkdir -p /data/tools &amp;&amp; <span class="built_in">cd</span> /data/tools</span><br><span class="line"></span><br><span class="line"><span class="comment">#版本选择</span></span><br><span class="line"><span class="comment">#http://nginx.org/en/download.html  #下载地址</span></span><br><span class="line"><span class="comment">#Stable version		 稳定版本</span></span><br><span class="line"><span class="comment">#Mainline version 	 新版本（不推荐，无特殊要求稳定版即可）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下载安装包</span></span><br><span class="line">wget http://nginx.org/download/nginx-1.20.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#解压nginx</span></span><br><span class="line">tar xf nginx-1.20.1.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#隐藏版本，看需要是否隐藏nginx版本</span></span><br><span class="line">sed -i <span class="string">&#x27;s/1.20.1//g&#x27;</span> nginx-1.20.1/src/core/nginx.h</span><br><span class="line"></span><br><span class="line"><span class="comment">#编译参数开始编译</span></span><br><span class="line"><span class="built_in">cd</span> nginx-1.20.1</span><br><span class="line">./configure --user=www --group=www \</span><br><span class="line">--prefix=/usr/<span class="built_in">local</span>/nginx  \</span><br><span class="line">--with-http_stub_status_module  \</span><br><span class="line">--with-http_ssl_module --with-pcre </span><br><span class="line"></span><br><span class="line"><span class="comment">#nginx -V 可查看安装的nginx的编译参数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#编译</span></span><br><span class="line">make -j `cat /proc/cpuinfo |grep processor |wc -l` &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="comment">#添加环境变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=/usr/local/nginx/sbin:$PATH&#x27;</span> &gt;&gt; /etc/profile</span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment">#给nginx工作目录www权限</span></span><br><span class="line">chown -R www.www /usr/<span class="built_in">local</span>/nginx</span><br></pre></td></tr></table></figure>

<h2 id="nginx命令"><a href="#nginx命令" class="headerlink" title="nginx命令"></a>nginx命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#启动</span></span><br><span class="line">nginx </span><br><span class="line"></span><br><span class="line"><span class="comment">#平滑重载</span></span><br><span class="line">nginx -s reload </span><br><span class="line"></span><br><span class="line"><span class="comment">#停止</span></span><br><span class="line">nginx -s stop </span><br><span class="line"></span><br><span class="line"><span class="comment">#查找nginx进程，杀死PID</span></span><br><span class="line">ps -ef |grep nginx </span><br><span class="line"><span class="built_in">kill</span> nginxPID</span><br><span class="line"></span><br><span class="line"><span class="comment">#检查语法，修改配置文件后必做</span></span><br><span class="line">nginx -t</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看编译参数及版本</span></span><br><span class="line">nginx -V</span><br></pre></td></tr></table></figure>

<h2 id="nginx配置文件"><a href="#nginx配置文件" class="headerlink" title="nginx配置文件"></a>nginx配置文件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/conf</span><br><span class="line">cp nginx.conf&#123;,.bak&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#得到最简单的配置文件</span></span><br><span class="line">egrep -v <span class="string">&quot;^$|#&quot;</span> nginx.conf.bak &gt; nginx.conf</span><br></pre></td></tr></table></figure>

<p>最简配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat nginx.conf</span><br><span class="line">worker_processes  1;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        error_page   500 502 503 504  /50x.html;</span><br><span class="line">        location = /50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>相对优化后的主配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#相对优化后的配置文件</span></span><br><span class="line">user  www www;					<span class="comment">#用户</span></span><br><span class="line">worker_processes 2;				<span class="comment">#进程数，可根据自身配置调配  可选 auto </span></span><br><span class="line">events</span><br><span class="line">    &#123;</span><br><span class="line">        use epoll;</span><br><span class="line">        worker_connections 8192;</span><br><span class="line">        multi_accept on;</span><br><span class="line">    &#125;</span><br><span class="line">http</span><br><span class="line">    &#123;</span><br><span class="line">        include       mime.types;</span><br><span class="line">        default_type  application/octet-stream;</span><br><span class="line">        charset UTF-8;</span><br><span class="line">        server_names_hash_bucket_size 128;</span><br><span class="line">        client_header_buffer_size 32k;</span><br><span class="line">        large_client_header_buffers 4 32k;</span><br><span class="line">        client_max_body_size 50m;</span><br><span class="line">        <span class="comment">#####################################</span></span><br><span class="line">        sendfile   on;</span><br><span class="line">        tcp_nopush on;</span><br><span class="line">        keepalive_timeout 60;</span><br><span class="line">        tcp_nodelay on;</span><br><span class="line">        <span class="comment">#####################################</span></span><br><span class="line">        fastcgi_connect_timeout 300;</span><br><span class="line">        fastcgi_send_timeout 300;</span><br><span class="line">        fastcgi_read_timeout 300;</span><br><span class="line">        fastcgi_buffer_size 64k;</span><br><span class="line">        fastcgi_buffers 4 64k;</span><br><span class="line">        fastcgi_busy_buffers_size 128k;</span><br><span class="line">        fastcgi_temp_file_write_size 256k;</span><br><span class="line">        <span class="comment">#####################################</span></span><br><span class="line">        gzip on;</span><br><span class="line">        gzip_min_length  1k;</span><br><span class="line">        gzip_buffers     4 16k;</span><br><span class="line">        gzip_http_version 1.1;</span><br><span class="line">        gzip_comp_level 2;</span><br><span class="line">        gzip_vary on;</span><br><span class="line">        gzip_proxied   expired no-cache no-store private auth;</span><br><span class="line">        server_tokens off;</span><br><span class="line">        include vhost/*.conf;<span class="comment">#conf/vhost下存放虚拟主机配置文件，将每个域名配置文件写到此目录下以 .conf结尾即可，实现多域名</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>站点配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/conf/vhost</span><br><span class="line">cat www.conf</span><br><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  localhost;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#charset koi8-r;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#access_log  logs/host.access.log  main;  #配置访问日志文件位置</span></span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        root   /usr/<span class="built_in">local</span>/nginx/html;  <span class="comment">#站点目录位置</span></span><br><span class="line">        index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="动态添加模块"><a href="#动态添加模块" class="headerlink" title="动态添加模块"></a>动态添加模块</h2><p><strong>扩展模块nginx-rtmp-module为例</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载rtmp模块</span></span><br><span class="line"><span class="built_in">cd</span> /data/tools/</span><br><span class="line">wget https://github.com/arut/nginx-rtmp-module/archive/master.zip</span><br><span class="line"></span><br><span class="line"><span class="comment">#解压并查看模块</span></span><br><span class="line">unzip master.zip</span><br><span class="line">ls nginx-rtmp-module-master</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看之前的编译参数</span></span><br><span class="line">nginx -V</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入到之前编译的nginx的目录</span></span><br><span class="line"><span class="built_in">cd</span> /data/tools/nginx-1.20.1/</span><br><span class="line"></span><br><span class="line"><span class="comment">#重新编译增加一个模块</span></span><br><span class="line">./configure  --user=www --group=www \</span><br><span class="line">--prefix=/usr/<span class="built_in">local</span>/nginx \</span><br><span class="line">--with-http_stub_status_module \</span><br><span class="line">--with-http_ssl_module --with-pcre \</span><br><span class="line">--add-module=/data/tools/nginx-rtmp-module-master</span><br><span class="line"></span><br><span class="line"><span class="comment">#不能make install 否则出问题</span></span><br><span class="line">make</span><br><span class="line"></span><br><span class="line"><span class="comment">#备份之前的nginx软件</span></span><br><span class="line">cp /usr/<span class="built_in">local</span>/nginx/sbin/nginx&#123;,.bak&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#替换旧版本nginx软件</span></span><br><span class="line">cp ./objs/nginx&#123;,.bak&#125;</span><br><span class="line">mv ./objs/nginx /usr/<span class="built_in">local</span>/nginx/sbin/</span><br><span class="line"></span><br><span class="line"><span class="comment">#重新检查当前是否添加了rtmp模块</span></span><br><span class="line">nginx -V</span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<h2 id="模块的使用"><a href="#模块的使用" class="headerlink" title="模块的使用"></a>模块的使用</h2><h4 id="下载服务器"><a href="#下载服务器" class="headerlink" title="下载服务器"></a>下载服务器</h4><p>编辑做下载的配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/nginx/conf/vhost/download.conf</span><br><span class="line">server &#123;</span><br><span class="line">        listen       8000;  <span class="comment">#端口</span></span><br><span class="line">        server_name  localhost;</span><br><span class="line">        location / &#123;</span><br><span class="line">            root /download;  <span class="comment">#下载目录</span></span><br><span class="line">            autoindex on;  <span class="comment">#开启索引功能</span></span><br><span class="line">            autoindex_exact_size off; <span class="comment">#关闭计算文件确切大小（单位bytes），只显示大概大小（单位kb、mb、gb）</span></span><br><span class="line">            autoindex_localtime on; <span class="comment">#显示本机时间而非 GMT 时间</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建存放文件的下载目录</span></span><br><span class="line"> mkdir /download</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#改变属主属组</span></span><br><span class="line"> chown -R www.www /download/</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#检查nginx语法配置</span></span><br><span class="line"> nginx -t</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#平滑重启nginx</span></span><br><span class="line"> nginx -s reload </span><br></pre></td></tr></table></figure>
<p>测试</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> 1 &gt; /download/test.txt</span><br></pre></td></tr></table></figure>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/vedTHQ.png" alt="vedTHQ"></p>
<h4 id="https证书配置"><a href="#https证书配置" class="headerlink" title="https证书配置"></a>https证书配置</h4>]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-命令记录-02</title>
    <url>/36b9df2b.html</url>
    <content><![CDATA[<h3 id="去除文件空行和-开头的行"><a href="#去除文件空行和-开头的行" class="headerlink" title="去除文件空行和#开头的行"></a>去除文件空行和#开头的行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grep ^[^<span class="comment">#] file</span></span><br><span class="line">grep -Ev <span class="string">&quot;^$|[#;]&quot;</span>  file</span><br><span class="line">egrep -v <span class="string">&quot;^$|#&quot;</span>  file</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h3 id="修改文件最大打开数"><a href="#修改文件最大打开数" class="headerlink" title="修改文件最大打开数"></a>修改文件最大打开数</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ulimit</span> -n 1048576</span><br><span class="line">sed -i <span class="string">&quot;/nofile/d&quot;</span> /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;* hard nofile 1048576&quot;</span> &gt;&gt; /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;* soft nofile 1048576&quot;</span> &gt;&gt; /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;root hard nofile 1048576&quot;</span> &gt;&gt; /etc/security/limits.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;root soft nofile 1048576&quot;</span> &gt;&gt; /etc/security/limits.conf</span><br></pre></td></tr></table></figure>

<h3 id="优化ssh"><a href="#优化ssh" class="headerlink" title="优化ssh"></a>优化ssh</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line">Port 52113                 <span class="comment">#10000以上的端口</span></span><br><span class="line">PermitRootLogin no         <span class="comment">#禁止root远程登录</span></span><br><span class="line">PermitEmptyPasswords no    <span class="comment">#禁止空密码登录</span></span><br><span class="line">UseDNS no                  <span class="comment">#不使用解析。</span></span><br><span class="line">GSSAPIAuthentication no    <span class="comment">#连接慢的解决配置。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#检查sshd语法</span></span><br><span class="line">sshd -t  </span><br><span class="line"></span><br><span class="line"><span class="comment">#重启ssh</span></span><br><span class="line">service sshd restart</span><br></pre></td></tr></table></figure>

<h3 id="Centos常用包"><a href="#Centos常用包" class="headerlink" title="Centos常用包"></a>Centos常用包</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y libxml2 libxml2-devel openssl \</span><br><span class="line">openssl-devel bzip2 bzip2-devel libcurl \</span><br><span class="line">libcurl-devel libjpeg libjpeg-devel \</span><br><span class="line">libpng libpng-devel freetype freetype-devel \</span><br><span class="line">gmp gmp-devel libmcrypt libmcrypt-devel \</span><br><span class="line">readline readline-devel libxslt libxslt-devel  \</span><br><span class="line">libicu-devel  openldap  openldap-devel \</span><br><span class="line">make zlib zlib-devel gcc-c++ libtool \</span><br><span class="line">pcre pcre-devel  cmake gcc  ncurses ncurses-devel \</span><br><span class="line">bison bison-devel libgcrypt perl</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>python-函数参数(一)</title>
    <url>/c86b83ee.html</url>
    <content><![CDATA[<h3 id="1-函数参数分类"><a href="#1-函数参数分类" class="headerlink" title="1. 函数参数分类"></a>1. 函数参数分类</h3><h4 id="1-1-形式参数"><a href="#1-1-形式参数" class="headerlink" title="1.1 形式参数"></a>1.1 形式参数</h4><p>在函数定义阶段括号内所填写的参数，简称形参</p>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># a和b就是函数func的形参</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-实际参数"><a href="#1-2-实际参数" class="headerlink" title="1.2 实际参数"></a>1.2 实际参数</h4><p>在函数调用阶段括号内传入的参数，简称实参</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">func(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># 数据1和2就是函数func的实参</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-关系"><a href="#1-3-关系" class="headerlink" title="1.3 关系"></a>1.3 关系</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">形参可以看成变量名,实参可以看成变量值</span><br><span class="line">两者在函数调用阶段临时绑定,函数运行结束断开</span><br><span class="line"></span><br><span class="line">形参的表现形式只有一种就是变量名</span><br><span class="line">实参的表现形式有很多中(核心是数据值)</span><br></pre></td></tr></table></figure>

<h3 id="2-位置参数"><a href="#2-位置参数" class="headerlink" title="2. 位置参数"></a>2. 位置参数</h3><ol>
<li><p>位置参数</p>
<p>按照从左往右的顺序依次填入的参数</p>
</li>
<li><p>位置形参</p>
<p>在函数定义阶段括号内按照从左往右的顺序依次填入的变量名</p>
</li>
<li><p>位置实参</p>
<p>在函数调用阶段括号内按照从左往右的顺序依次传入的数据值</p>
</li>
<li><p>关键字实参</p>
<p>可以打破位置顺序</p>
<p>在函数调用阶段可以通过 <code>形参名=数据值</code>  的形式进行传值</p>
</li>
<li><p>总结</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>位置形参与位置实参在函数调用阶段，按照位置一一对应</span><br><span class="line"><span class="number">2.</span>位置参数在绑定的时候个数一致</span><br><span class="line"><span class="number">3.</span>格式越简单的越靠前，格式越复杂的越靠后</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-默认参数"><a href="#3-默认参数" class="headerlink" title="3. 默认参数"></a>3. 默认参数</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">默认参数描述的是默认形参:</span><br><span class="line">  <span class="number">1.</span>函数在定义阶段就给形参赋值了</span><br><span class="line">  <span class="number">2.</span>该形参在调用阶段如果不给值，则使用默认值</span><br><span class="line">  <span class="number">3.</span>该形参在函数调用阶段也可以继续给值，则使用所给的值</span><br><span class="line">  <span class="number">4.</span>位置形参与默认形参在定义的时候，位置形参必须在默认形参的前面</span><br><span class="line">  </span><br><span class="line">  eg:</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">name, age, gender=<span class="string">&#x27;male&#x27;</span></span>):</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s:%s:%s&#x27;</span> % (name, age, gender))</span><br><span class="line"></span><br><span class="line">    register(<span class="string">&#x27;jason&#x27;</span>, <span class="number">18</span>)  <span class="comment"># jason:18:male</span></span><br><span class="line">    register(<span class="string">&#x27;lili&#x27;</span>, <span class="number">18</span>, <span class="string">&#x27;female&#x27;</span>)  <span class="comment"># lili:18:female</span></span><br></pre></td></tr></table></figure>

<h3 id="4-可变长参数"><a href="#4-可变长参数" class="headerlink" title="4. 可变长参数"></a>4. 可变长参数</h3><h4 id="4-1-形参"><a href="#4-1-形参" class="headerlink" title="4.1 形参"></a>4.1 形参</h4><h5 id="4-1-1-位置参数"><a href="#4-1-1-位置参数" class="headerlink" title="4.1.1 位置参数"></a>4.1.1 位置参数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">函数无论传入多少位置参数都可以正常运行</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b, *c</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(a, b, c)</span><br><span class="line"></span><br><span class="line">  func(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># 1 2 ()</span></span><br><span class="line">  func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)  <span class="comment"># 1 2 (3,)</span></span><br><span class="line">  func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)  <span class="comment"># 1 2 (3, 4)</span></span><br><span class="line"></span><br><span class="line">* 在形参数中的使用，用于接收多余位置的参数，并组织成元组的形式赋值给*号后面的变量名</span><br></pre></td></tr></table></figure>

<h5 id="4-1-2-关键字参数"><a href="#4-1-2-关键字参数" class="headerlink" title="4.1.2 关键字参数"></a>4.1.2 关键字参数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">函数无论传入多少关键字参数都可以正常运行</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b, **c</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(a, b, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  func(a=<span class="number">1</span>, b=<span class="number">2</span>)  <span class="comment"># 1 2 &#123;&#125;</span></span><br><span class="line">  func(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>)  <span class="comment"># 1 2 &#123;&#x27;c&#x27;: 3&#125;</span></span><br><span class="line">  func(a=<span class="number">1</span>, b=<span class="number">2</span>, c=<span class="number">3</span>, d=<span class="number">4</span>)  <span class="comment"># 1 2 &#123;&#x27;c&#x27;: 3, &#x27;d&#x27;: 4&#125; </span></span><br><span class="line">  </span><br><span class="line">** 号在形参中的使用，用于接收多余的关键字参数，并组织成字典的形式赋值给给**号后面的变量名</span><br></pre></td></tr></table></figure>

<h5 id="4-1-3-位置参数-关键字参数"><a href="#4-1-3-位置参数-关键字参数" class="headerlink" title="4.1.3 位置参数+关键字参数"></a>4.1.3 位置参数+关键字参数</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">函数无论传入多少位置参数和关键字参数都可以正常运行</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">*a, **b</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(a, b)</span><br><span class="line"></span><br><span class="line">  func()  <span class="comment"># () &#123;&#125;</span></span><br><span class="line">  func(<span class="number">1</span>, <span class="number">2</span>)  <span class="comment"># (1, 2) &#123;&#125;</span></span><br><span class="line">  func(a=<span class="number">1</span>, b=<span class="number">2</span>  <span class="comment"># () &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span></span><br><span class="line">  func(<span class="number">1</span>, <span class="number">2</span>, a=<span class="number">1</span>, b=<span class="number">2</span>)  <span class="comment"># (1, 2) &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2&#125;</span></span><br><span class="line"></span><br><span class="line">规定:</span><br><span class="line">    可变长形参 *和**后面的变量名可以随便定义，但是python中推荐使用</span><br><span class="line">       *args</span><br><span class="line">       **kwargs</span><br></pre></td></tr></table></figure>

<h4 id="4-2-实参"><a href="#4-2-实参" class="headerlink" title="4.2 实参"></a>4.2 实参</h4><h5 id="4-2-1-在实参中使用"><a href="#4-2-1-在实参中使用" class="headerlink" title="4.2.1 *在实参中使用"></a>4.2.1 <code>*</code>在实参中使用</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">a, b, c</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">list1 = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line"><span class="comment"># func(list1)  # 报错，list1是一个整体给了a，后面的b和c参数没有传入</span></span><br><span class="line">func(list1[<span class="number">0</span>], list1[<span class="number">1</span>], list1[<span class="number">2</span>])  <span class="comment"># 需要拆散一一传值</span></span><br><span class="line"></span><br><span class="line">当形参是*args，列表里面的元素如何按照位置一一传值</span><br><span class="line">eg:</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">*args</span>):</span></span><br><span class="line">      <span class="built_in">print</span>(args)</span><br><span class="line">  list1 = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>]</span><br><span class="line">  func(*list1)  <span class="comment"># (11, 22, 33, 44)</span></span><br><span class="line">*号在实参中的使用，会将列表、元组内的元素打散成位置参数的形式一一传值</span><br></pre></td></tr></table></figure>

<h5 id="4-2-3-在实参中使用"><a href="#4-2-3-在实参中使用" class="headerlink" title="4.2.3 **在实参中使用"></a>4.2.3 <code>**</code>在实参中使用</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">**kwargs</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(kwargs)</span><br><span class="line">dict1 = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;pwd&#x27;</span>: <span class="number">123</span>&#125;</span><br><span class="line">func(**dict1)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;xxx&#x27;, &#x27;pwd&#x27;: 123&#125;</span></span><br><span class="line"><span class="comment"># name=&#x27;xxx&#x27;  --&gt; &#x27;name&#x27;: &#x27;xxx&#x27;</span></span><br><span class="line"><span class="comment"># pwd=123     --&gt; &#x27;pwd&#x27;: 123</span></span><br><span class="line"></span><br><span class="line">**号在实参中的使用，会将字典内的键值对打散成关键字参数传入</span><br></pre></td></tr></table></figure>

<h3 id="5-函数参数补充"><a href="#5-函数参数补充" class="headerlink" title="5. 函数参数补充"></a>5. 函数参数补充</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">name, age, *a, sex, height</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(name, age, a, sex, height)</span><br><span class="line"></span><br><span class="line"><span class="comment"># func(&#x27;jason&#x27;, 18, &#x27;male&#x27;, 183)  # 报错</span></span><br><span class="line">func(<span class="string">&#x27;lili&#x27;</span>, <span class="number">18</span>, sex=<span class="string">&#x27;male&#x27;</span>, height=<span class="number">183</span>) </span><br><span class="line"></span><br><span class="line">当*号后面还有参数时，后面传入实参的时候必须以关键字参数的形式，该形式不常用</span><br></pre></td></tr></table></figure>

<h3 id="6-名称空间"><a href="#6-名称空间" class="headerlink" title="6. 名称空间"></a>6. 名称空间</h3><p>用于存放变量名与变量值绑定关系的地方</p>
<h5 id="6-1-分类"><a href="#6-1-分类" class="headerlink" title="6.1 分类"></a>6.1 分类</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>内置名称空间</span><br><span class="line">  python解释器定义好的，如 <span class="built_in">len</span>()</span><br><span class="line">  </span><br><span class="line"><span class="number">2.</span>全局名称空间</span><br><span class="line">	在py文件中顶格编写的代码运行之后都会存入全局名称空间</span><br><span class="line">	        	name = <span class="string">&#x27;jason&#x27;</span>  <span class="comment"># name全局</span></span><br><span class="line">            <span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span>  <span class="comment"># func全局</span></span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">1</span>:</span><br><span class="line">                a = <span class="number">123</span>  <span class="comment"># a全局</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">                <span class="built_in">print</span>(i)  <span class="comment"># i全局</span></span><br><span class="line">            <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">                a = <span class="number">123</span>  <span class="comment"># a全局</span></span><br><span class="line">                </span><br><span class="line"><span class="number">3.</span>局部名称空间</span><br><span class="line">  函数体代码运行之后产生的都是局部名称空间</span><br></pre></td></tr></table></figure>

<h5 id="6-2-存活周期"><a href="#6-2-存活周期" class="headerlink" title="6.2 存活周期"></a>6.2 存活周期</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>内置名称空间</span><br><span class="line">  python解释器启动与关闭而创建和销毁</span><br><span class="line"><span class="number">2.</span>全局名称空间</span><br><span class="line">  随着py文件的运行与结束而创建和销毁</span><br><span class="line"><span class="number">3.</span>局部名称空间</span><br><span class="line">  随着函数体代码的执行与结束而创建和销毁</span><br></pre></td></tr></table></figure>

<h5 id="6-3-查找顺序"><a href="#6-3-查找顺序" class="headerlink" title="6.3 查找顺序"></a>6.3 查找顺序</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>查找名字的时候，先确定自己当前在哪儿</span><br><span class="line">  如果在局部</span><br><span class="line">    局部 --&gt; 全局 --&gt; 内置</span><br><span class="line">  如果在全局</span><br><span class="line">    全局 --&gt; 内置</span><br><span class="line">    </span><br><span class="line"><span class="number">2.</span>局部名称空间的嵌套</span><br><span class="line">x = <span class="number">111</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span>():</span></span><br><span class="line">    x = <span class="number">222</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f2</span>():</span></span><br><span class="line">        x = <span class="number">333</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f3</span>():</span></span><br><span class="line">            x = <span class="number">444</span>  <span class="comment"># 如果没在这定义 x 会向上查找，依次类推</span></span><br><span class="line">            <span class="built_in">print</span>(x)</span><br><span class="line">            <span class="comment"># x = 444 # 当x定义在这时，会报错</span></span><br><span class="line">        f3()</span><br><span class="line">    f2()</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 调用f1() 执行所有函数</span></span><br><span class="line">f1()  <span class="comment"># 444</span></span><br></pre></td></tr></table></figure>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">func_dic = &#123;<span class="string">&#x27;1&#x27;</span>: register, <span class="string">&#x27;2&#x27;</span>: login&#125;</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    1.注册</span></span><br><span class="line"><span class="string">    2.登录</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span>)</span><br><span class="line">    choice = <span class="built_in">input</span>(<span class="string">&#x27;please&gt;&gt;&gt;:&#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> choice <span class="keyword">in</span> func_dic:</span><br><span class="line">        func_name = func_dic.get(choice)</span><br><span class="line">        func_name()</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;功能编号不存在&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Bond4配置</title>
    <url>/c2b5b878.html</url>
    <content><![CDATA[<h3 id="Ubuntu配置"><a href="#Ubuntu配置" class="headerlink" title="Ubuntu配置"></a>Ubuntu配置</h3><span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/netplan/00-installer-config.yaml</span><br><span class="line">network:</span><br><span class="line">  ethernets:</span><br><span class="line">    ens3f1: &#123;&#125;</span><br><span class="line">    ens3f0: &#123;&#125;</span><br><span class="line">  renderer: networkd</span><br><span class="line">  bonds:</span><br><span class="line">    bond4:</span><br><span class="line">      addresses: [10.10.2.1/16]</span><br><span class="line">      gateway4: 10.10.1.254</span><br><span class="line">      nameservers:</span><br><span class="line">        addresses: [114.114.114.114,202.96.128.86,8.8.8.8]</span><br><span class="line">      interfaces:</span><br><span class="line">        - ens3f1</span><br><span class="line">        - ens3f0</span><br><span class="line">      parameters:</span><br><span class="line">        mode: 802.3ad</span><br><span class="line">        mii-monitor-interval:</span><br><span class="line">        lacp-rate: fast</span><br><span class="line">        transmit-hash-policy: layer3+4</span><br><span class="line">        </span><br><span class="line"><span class="comment">#生效        </span></span><br><span class="line">netplan apply</span><br></pre></td></tr></table></figure>

<h3 id="Centos配置"><a href="#Centos配置" class="headerlink" title="Centos配置"></a>Centos配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">参考文档：https://support.huawei.com/enterprise/zh/knowledge/EKB1100053867</span><br><span class="line"></span><br><span class="line"><span class="comment">#双bond配置</span></span><br><span class="line"><span class="comment">#备份原本的网卡配置信息</span></span><br><span class="line">mkdir /opt/net_bak</span><br><span class="line"><span class="built_in">cd</span> /etc/sysconfig/network-scripts</span><br><span class="line">cp ifcfg-* /opt/net_bak</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成bond网卡配置文件名称为bond4</span></span><br><span class="line">nmcli connection add <span class="built_in">type</span> bond ifname bond4 mode 4</span><br><span class="line"></span><br><span class="line"><span class="comment">#将ens1f0和ens6f0网卡绑定到bond4</span></span><br><span class="line"><span class="comment">#f0为两个网卡的第一口</span></span><br><span class="line">nmcli connection add <span class="built_in">type</span> bond-slave ifname ens1f0 master bond4</span><br><span class="line">nmcli connection add <span class="built_in">type</span> bond-slave ifname ens6f0 master bond4</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成bond网卡配置文件名称为bond20</span></span><br><span class="line">nmcli connection add <span class="built_in">type</span> bond ifname bond20 mode 4</span><br><span class="line"></span><br><span class="line"><span class="comment">#将ens1f1和ens6f1网卡绑定到bond20</span></span><br><span class="line"><span class="comment">#f1为两个网卡的第一口</span></span><br><span class="line">nmcli connection add <span class="built_in">type</span> bond-slave ifname ens1f1 master bond20</span><br><span class="line">nmcli connection add <span class="built_in">type</span> bond-slave ifname ens6f1 master bond20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看生成的bond配置文件</span></span><br><span class="line">ls ifcfg-bond-*</span><br><span class="line">ifcfg-bond-bond0 ifcfg-bond-slave-enp125s0f0 ifcfg-bond-slave-enp125s0f1</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看生成的bond配置信息</span></span><br><span class="line">nmcli con show</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置网卡，将IP、网关、掩码、DNS配置</span></span><br><span class="line">vim ifcfg-bond-bond4</span><br><span class="line">vim ifcfg-bond-bond20</span><br><span class="line"></span><br><span class="line"><span class="comment">#网卡模式选择：</span></span><br><span class="line"><span class="comment">#bond4配置：</span></span><br><span class="line">BONDING_OPTS=<span class="string">&#x27;mode=4 miimon=100 xmit_hash_policy=layer3+4&#x27;</span></span><br><span class="line"><span class="comment">#刻录系统需要将网卡内的UUID删除</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#重启网卡</span></span><br><span class="line">nmcli con reload</span><br><span class="line">systemctl restart network.service </span><br><span class="line"></span><br><span class="line"><span class="comment">#检查配置情况</span></span><br><span class="line"><span class="comment">#查看是否配置成功</span></span><br><span class="line">ip addr</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看生成的bond是否正常</span></span><br><span class="line">cat /proc/net/bond/bond0</span><br><span class="line">ethtool bond0</span><br></pre></td></tr></table></figure>

<p>交换机配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#bond4需要交换机配置</span></span><br><span class="line">interface Eth-Trunk10</span><br><span class="line">mode lacp-static</span><br><span class="line"></span><br><span class="line">interface GigabitEthernet0/0/1</span><br><span class="line">eth-trunk 10</span><br><span class="line"></span><br><span class="line">interface GigabitEthernet0/0/2</span><br><span class="line">eth-trunk 10</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>Bond</tag>
      </tags>
  </entry>
  <entry>
    <title>python-文件与函数初识</title>
    <url>/a7f42e80.html</url>
    <content><![CDATA[<h2 id="1-文件"><a href="#1-文件" class="headerlink" title="1. 文件"></a>1. 文件</h2><h3 id="1-1-二进制模式读"><a href="#1-1-二进制模式读" class="headerlink" title="1.1 二进制模式读"></a>1.1 二进制模式读</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;a.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read())  <span class="comment"># 读取的是二进制内容</span></span><br><span class="line">    <span class="built_in">print</span>(f.read().decode(<span class="string">&#x27;utf8&#x27;</span>))  <span class="comment"># 经过住解码，能正常读取内容</span></span><br><span class="line">    <span class="built_in">print</span>(f.read(<span class="number">3</span>).decode(<span class="string">&#x27;utf8&#x27;</span>))  <span class="comment"># 三个字节为一个中文</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">read()  括号内可以放数字</span></span><br><span class="line"><span class="string">    在t模式下表示字符个数</span></span><br><span class="line"><span class="string">    在b模式下表示字节个数</span></span><br><span class="line"><span class="string">英文字符统一使用一个bytes来表示</span></span><br><span class="line"><span class="string">中文字符统一使用三个bytes来表示</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>


<h3 id="1-2-文件内光标的移动"><a href="#1-2-文件内光标的移动" class="headerlink" title="1.2 文件内光标的移动"></a>1.2 文件内光标的移动</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;a.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read(<span class="number">6</span>).decode(<span class="string">&#x27;utf8&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(f.tell())  <span class="comment"># 查看光标移动了多少字节</span></span><br><span class="line">    <span class="built_in">print</span>(f.seek(<span class="number">8</span>, <span class="number">1</span>))  <span class="comment"># 从上面第6字节位置开始往后移动8个字节</span></span><br><span class="line">    <span class="built_in">print</span>(f.read().decode(<span class="string">&#x27;utf8&#x27;</span>))  <span class="comment"># 查看上面移动后的结果</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">seek()</span></span><br><span class="line"><span class="string">  控制文件光标的移动,eg:</span></span><br><span class="line"><span class="string">  f.seek(offset,whence)</span></span><br><span class="line"><span class="string">      offset表示位移量,始终以字节为最小单位,正数从左往右，负数从右往左</span></span><br><span class="line"><span class="string">      </span></span><br><span class="line"><span class="string">      whence表示模式</span></span><br><span class="line"><span class="string">          0:以文件开头为参考(支持tb两种模式)</span></span><br><span class="line"><span class="string">          1:以当前位置为参考,只支持b模式</span></span><br><span class="line"><span class="string">          2:以文件末尾为参考,只支持b模</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p>通过光标实现动态查看日志</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;a.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 直接将光标移动到文件末尾</span></span><br><span class="line">    f.seek(<span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># 从文件末尾一直读取文件内容</span></span><br><span class="line">        line = f.readline()</span><br><span class="line">        <span class="comment"># 判断读取的内容是否为0</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(line) == <span class="number">0</span>:</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(line.decode(<span class="string">&#x27;utf8&#x27;</span>), end=<span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="1-3-文件内容修改"><a href="#1-3-文件内容修改" class="headerlink" title="1.3 文件内容修改"></a>1.3 文件内容修改</h3><h4 id="1-3-1-覆盖"><a href="#1-3-1-覆盖" class="headerlink" title="1.3.1 覆盖"></a>1.3.1 覆盖</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;c.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">     data = f.read()  <span class="comment"># 取出内容</span></span><br><span class="line">     <span class="comment"># print(type(data))</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;c.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">     new_data = data.replace(<span class="string">&#x27;tony&#x27;</span>,<span class="string">&#x27;jason&#x27;</span>)  <span class="comment"># 替换</span></span><br><span class="line">     f1.write(new_data)  <span class="comment"># 重新写入</span></span><br></pre></td></tr></table></figure>



<h4 id="1-3-2-新建"><a href="#1-3-2-新建" class="headerlink" title="1.3.2 新建"></a>1.3.2 新建</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;c.txt&#x27;</span>, mode=<span class="string">&#x27;rt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> read_f, \</span><br><span class="line">        <span class="built_in">open</span>(<span class="string">&#x27;c.txt.swap&#x27;</span>, mode=<span class="string">&#x27;wt&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> write_f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> read_f:</span><br><span class="line">        write_f.write(line.replace(<span class="string">&#x27;SB&#x27;</span>, <span class="string">&#x27;kevin&#x27;</span>))</span><br><span class="line">os.remove(<span class="string">&#x27;c.txt&#x27;</span>)  <span class="comment"># 删除原文件</span></span><br><span class="line">os.rename(<span class="string">&#x27;c.txt.swap&#x27;</span>, <span class="string">&#x27;c.txt&#x27;</span>)  <span class="comment"># 重命名文件</span></span><br></pre></td></tr></table></figure>

<h2 id="2-函数"><a href="#2-函数" class="headerlink" title="2. 函数"></a>2. 函数</h2><h3 id="2-1-函数语法结构"><a href="#2-1-函数语法结构" class="headerlink" title="2.1 函数语法结构"></a>2.1 函数语法结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名(<span class="params">参数<span class="number">1</span>,参数<span class="number">2</span></span>):</span></span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;函数注释&#x27;&#x27;&#x27;</span></span><br><span class="line">  函数体代码</span><br><span class="line">  <span class="keyword">return</span> 返回值</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1.def 定义函数的关键字 必要的</span></span><br><span class="line"><span class="string">2.函数名  相当于变量名,命名规范与风格遵循变量名 必要的</span></span><br><span class="line"><span class="string">3.参数 参数可以没有也可以有多个,表示在使用函数之前需要满足的一些条件 非必要</span></span><br><span class="line"><span class="string">4.函数注释 介绍函数功能 参数使用,以及其他情况 非必要</span></span><br><span class="line"><span class="string">5.函数体代码 函数核心的代码逻辑 必要的</span></span><br><span class="line"><span class="string">6.return返回值 使用函数之后反馈给使用者的结果 非必要</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-定义与调用"><a href="#2-2-定义与调用" class="headerlink" title="2.2 定义与调用"></a>2.2 定义与调用</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>函数必须先定义后调用(顺序不能乱)</span><br><span class="line"><span class="number">2.</span>函数在定义阶段只检测语法不执行代码</span><br><span class="line"><span class="number">3.</span>函数在调用阶段才会执行函数体代码</span><br><span class="line">调用函数:函数名加括号,如果函数在定义阶段有参数则在调用阶段也需要给参数</span><br><span class="line">  </span><br><span class="line">函数在定义与调用阶段底层原理</span><br><span class="line"><span class="number">1.</span>在内存空间中申请一块空间存储函数体代码</span><br><span class="line"><span class="number">2.</span>将函数体代码所在的空间地址绑定给函数名</span><br><span class="line"><span class="number">3.</span>函数名加括号则会执行函数体代码</span><br></pre></td></tr></table></figure>

<h3 id="2-3-分类"><a href="#2-3-分类" class="headerlink" title="2.3 分类"></a>2.3 分类</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>内置函数</span><br><span class="line">  python解释器自带的(提前已经定义好,直接使用即可)</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>自定义函数</span><br><span class="line">  自己写的函数</span><br><span class="line">    <span class="number">1.</span>无参函数:在定义函数阶段括号内没有写参数(变量名)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">my_func</span>():</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">    <span class="number">2.</span>有参函数:在定义函数阶段括号内写了参数(变量名)</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">my_func</span>(<span class="params">a, b</span>)</span></span><br><span class="line"><span class="function">            <span class="title">print</span>(<span class="params"><span class="string">&quot;hello&quot;</span></span>)</span></span><br><span class="line"><span class="function">    3.空函数:</span>函数体代码为空(<span class="keyword">pass</span>),虽然空函数本身没有意义,但是空函数可以提前规定好编写代码的思路</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">run</span>():</span></span><br><span class="line">          <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>YAML格式</title>
    <url>/2391e1e4.html</url>
    <content><![CDATA[<h2 id="资源清单"><a href="#资源清单" class="headerlink" title="资源清单"></a>资源清单</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>在Kubernetes 环境下可以使用 kubectl run 运行应用，但是不推荐，而是希望使用资源清单的东西来描述应用，资源清单可以使用YAML和JSON文件来编写，一般YAML更方便阅读</p>
<p>通过一个资源清单文件定义好一个应用后，可以使用kubectl工具直接运行</p>
<span id="more"></span>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kuebctl create -f xxx.yaml</span><br></pre></td></tr></table></figure>

<p>资源清单提交给了 APIServer，然后集群获取到清单描述的应用信息后存入到 etcd 数据库中，然后 <code>kube-scheduler</code> 组件发现这个时候有一个 Pod 还没有绑定到节点上，就会对这个 Pod 进行一系列的调度，把它调度到一个最合适的节点上，然后把这个节点和 Pod 绑定到一起（写回到 etcd），然后节点上的 kubelet 组件这个时候 watch 到有一个 Pod 被分配过来了，就去把这个 Pod 的信息拉取下来，然后根据描述通过容器运行时把容器创建出来，最后当然同样把 Pod 状态再写回到 etcd 中去</p>
<p>示例:</p>
<p>nginx-deployment.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span>  <span class="comment"># API版本</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span>  <span class="comment"># API对象类型</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-deploy</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">chapter:</span> <span class="string">first-app</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">2</span>  <span class="comment"># Pod 副本数量</span></span><br><span class="line">  <span class="attr">template:</span>  <span class="comment"># Pod 模板</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">nginx</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">        <span class="attr">image:</span> <span class="string">nginx:1.7.9</span></span><br><span class="line">        <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>创建应用:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f nginx-deployment.yaml</span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure>

<p>创建应用之后可以看到有两个副本，由定义的属性<code>replicas: 2</code> 决定的</p>
<p>可以使用<code>kubectl describe</code> 命令查看资源对象的详细信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl  describe pod nginx-deploy-75b69bd684-h4sc2  <span class="comment">#后面编号随机的</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到看到很多这个 Pod 的详细信息，比如调度到的节点、状态、IP 等，一般我们比较关心的是下面的 <code>Events</code> 部分，可以看到这个Pod是如何创建的</p>
<p>在集群中删除这个应用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl delete -f nginx-deployment.yaml</span><br></pre></td></tr></table></figure>

<h3 id="YAML文件"><a href="#YAML文件" class="headerlink" title="YAML文件"></a>YAML文件</h3><p><code>YAML</code> 是专门用来写配置文件的语言，非常简洁和强大，远比 <code>JSON</code> 格式方便，为了方便人类读写，实质上是一种通用的数据串行化格式。</p>
<h4 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h4><ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系</li>
<li>缩进时不允许使用<code>Tab</code>键，只允许使用空格</li>
<li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li>
<li><code>#</code> 表示注释</li>
</ul>
<h4 id="结构类型"><a href="#结构类型" class="headerlink" title="结构类型"></a>结构类型</h4><p>在kubernets中只需要了解以下结构类型</p>
<ul>
<li>Lists(列表)</li>
<li>Maps(字典)</li>
</ul>
<h4 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h4><p>字典，key:value的键值对，例如:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">Kind:</span> <span class="string">Pod</span></span><br></pre></td></tr></table></figure>

<p>转换为JSON</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;apiVersion&quot;: &quot;v1&quot;,</span><br><span class="line">    &quot;kind&quot;: &quot;pod&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建复杂一点的Maps，</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ydzs-site</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">web</span></span><br></pre></td></tr></table></figure>

<p>metadata对应的值又可以是一个Maps，转换为JSON</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;apiVersion&quot;</span>: <span class="string">&quot;v1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;Pod&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;kube100-site&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;labels&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;app&quot;</span>: <span class="string">&quot;web&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h4><p>列表，也就是一个数组，定义：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">args</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Cat</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Dog</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Fish</span></span><br></pre></td></tr></table></figure>

<p>对应的JSON格式:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;args&quot;</span>: [ &#x27;Cat&#x27;, &#x27;Dog&#x27;, &#x27;Fish&#x27; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Lists 的子项也可以是 Maps，Maps 的子项也可以是 Lists 如下所示：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">ydzs-site</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">front-end</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">flaskapp-demo</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">cnych/flaskapp</span></span><br><span class="line">      <span class="attr">ports:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">5000</span></span><br></pre></td></tr></table></figure>

<p>转换为JSON格式如下:</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;apiVersion&quot;</span>: <span class="string">&quot;v1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;kind&quot;</span>: <span class="string">&quot;Pod&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;metadata&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;ydzs-site&quot;</span>,</span><br><span class="line">        <span class="attr">&quot;labels&quot;</span>: &#123;</span><br><span class="line">            <span class="attr">&quot;app&quot;</span>: <span class="string">&quot;web&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;spec&quot;</span>: &#123;</span><br><span class="line">        <span class="attr">&quot;containers&quot;</span>: [&#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;front-end&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;image&quot;</span>: <span class="string">&quot;nginx&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;ports&quot;</span>: [&#123;</span><br><span class="line">                <span class="attr">&quot;containerPort&quot;</span>: <span class="string">&quot;80&quot;</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;flaskapp-demo&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;image&quot;</span>: <span class="string">&quot;cnych/flaskapp&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;ports&quot;</span>: [&#123;</span><br><span class="line">                <span class="attr">&quot;containerPort&quot;</span>: <span class="string">&quot;5000&quot;</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Kuberneters</category>
      </categories>
      <tags>
        <tag>Kuberneters</tag>
        <tag>YAML</tag>
      </tags>
  </entry>
  <entry>
    <title>python-文件操作(二)</title>
    <url>/19603b60.html</url>
    <content><![CDATA[<h3 id="1-文件操作方法"><a href="#1-文件操作方法" class="headerlink" title="1. 文件操作方法"></a>1. 文件操作方法</h3><h4 id="1-1-读方法"><a href="#1-1-读方法" class="headerlink" title="1.1 读方法"></a>1.1 读方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;a.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read())  <span class="comment"># 一次性读取文件所有的内容</span></span><br><span class="line">    <span class="built_in">print</span>(f.readline())  <span class="comment"># 每次值读文件一行内容</span></span><br><span class="line">    <span class="built_in">print</span>(f.readlines())  <span class="comment"># 读取文件所有内容,组织成列表,每个元素是文件的每行内容</span></span><br><span class="line">    <span class="built_in">print</span>(f.readable())  <span class="comment"># 判断当前文件是否可读,返回布尔值</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>

<h4 id="1-2-写方法"><a href="#1-2-写方法" class="headerlink" title="1.2 写方法"></a>1.2 写方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;a.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&#x27;这是写入的内容&#x27;</span>)  <span class="comment"># 向文件写入内容</span></span><br><span class="line">    f.write(<span class="number">123</span>)  <span class="comment"># 写入的内容必须是字符串,这句会报错</span></span><br><span class="line">    f.writelines([<span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;tom&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>])  <span class="comment"># 将列表中的每个字符串元素写入文件</span></span><br><span class="line">    <span class="built_in">print</span>(f.writable())  <span class="comment"># 判断忘记拿是否可写</span></span><br><span class="line">    f.flush()  <span class="comment"># 将内存文件数据刷到硬盘</span></span><br></pre></td></tr></table></figure>

<h3 id="2-文件优化操作"><a href="#2-文件优化操作" class="headerlink" title="2. 文件优化操作"></a>2. 文件优化操作</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;a.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br><span class="line"></span><br><span class="line">read() 会一次性读取文件内所有的内容</span><br><span class="line">弊端:</span><br><span class="line">  <span class="number">1.</span>一次性读完内容之后,光标停留在文件末尾,无法再次读取内容</span><br><span class="line">  <span class="number">2.</span>该方法在读取大文件的时候,可能会造成内存溢出的情况</span><br><span class="line">  </span><br><span class="line">解决:逐行读取文件内容</span><br><span class="line">  <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;a.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">        <span class="built_in">print</span>(line)</span><br><span class="line">        </span><br><span class="line"> <span class="comment"># 涉及到文件多行内容读取的情况一般采用for循环读取</span></span><br></pre></td></tr></table></figure>

<h3 id="3-文件操作模式"><a href="#3-文件操作模式" class="headerlink" title="3. 文件操作模式"></a>3. 文件操作模式</h3><h4 id="3-1-文本模式"><a href="#3-1-文本模式" class="headerlink" title="3.1 文本模式"></a>3.1 文本模式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t 文本模式</span><br><span class="line"><span class="number">1.</span>默认的模式, r w a 其实是rt wt at</span><br><span class="line"><span class="number">2.</span>该模式所有操作都是以字符串为基本单位(文本)</span><br><span class="line"><span class="number">3.</span>该模式必须要指定encoding参数</span><br><span class="line"><span class="number">4.</span>该模式只能操作文本文件</span><br></pre></td></tr></table></figure>

<h4 id="3-2-二进制模式"><a href="#3-2-二进制模式" class="headerlink" title="3.2 二进制模式"></a>3.2 二进制模式</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">b 二进制模式</span><br><span class="line"><span class="number">1.</span>该模式可以操作任意类型的文件</span><br><span class="line"><span class="number">2.</span>该模式所有操作都是以<span class="built_in">bytes</span>类型(二进制)基本单位</span><br><span class="line"><span class="number">3.</span>该模式不需要指定encoding参数</span><br><span class="line">指定模式的时候就需要rb wb ab</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">  读:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;a.txt&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read()</span><br><span class="line">        <span class="built_in">print</span>(data, <span class="built_in">type</span>(data))  <span class="comment"># 英文正常显示,中文是一串字符, 类型是bytes</span></span><br><span class="line">      </span><br><span class="line">  写:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;a.txt&#x27;</span>, <span class="string">&#x27;ab&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    data = <span class="string">&#x27;您好&#x27;</span></span><br><span class="line">    res = data.encode(<span class="string">&#x27;utf8&#x27;</span>)  <span class="comment"># 将中文进行编码</span></span><br><span class="line">    f.write(res)  <span class="comment"># 编码之后再写入,文本中正常写入</span></span><br></pre></td></tr></table></figure>

<h3 id="4-练习"><a href="#4-练习" class="headerlink" title="4. 练习"></a>4. 练习</h3><h4 id="4-1-文件版登录注册功能"><a href="#4-1-文件版登录注册功能" class="headerlink" title="4.1 文件版登录注册功能"></a>4.1 文件版登录注册功能</h4><p>注册功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要求用户输入用户名和密码</span></span><br><span class="line">username = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名&gt;&gt;&gt;: &quot;</span>).strip()</span><br><span class="line">password = <span class="built_in">input</span>(<span class="string">&quot;请输入密码&gt;&gt;&gt;: &quot;</span>).strip()</span><br><span class="line"><span class="comment"># 格式化输入的信息,添加分隔符和换行符</span></span><br><span class="line">msg = <span class="string">&quot;%s|%s\n&quot;</span> % (username, password)</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;user.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f_reg:</span><br><span class="line">    <span class="comment"># for循环读取文件内容</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f_reg:</span><br><span class="line">      <span class="comment"># 取到用户名的值</span></span><br><span class="line">      name = line.split(<span class="string">&quot;|&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">      <span class="comment"># 如果用户输入的用户名与存在的用户名一致就退出</span></span><br><span class="line">      <span class="keyword">if</span> name == username:</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;用户名已存在!&quot;</span>)</span><br><span class="line">          <span class="keyword">break</span></span><br><span class="line">       <span class="keyword">else</span>:</span><br><span class="line">          <span class="comment"># 否则就将用户输入的信息写入到文件</span></span><br><span class="line">          <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;user.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f_reg_insert:</span><br><span class="line">              f_reg_insert.write(msg)</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;%s注册成功&quot;</span> % username)</span><br></pre></td></tr></table></figure>



<p>登录功能</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 接收输入的用户名和密码</span></span><br><span class="line">name = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名&gt;&gt;&gt;: &quot;</span>).strip()</span><br><span class="line">pwd = <span class="built_in">input</span>(<span class="string">&quot;请输入密码&gt;&gt;&gt;: &quot;</span>).strip()</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;user.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f_log:</span><br><span class="line">    <span class="comment"># for循环读取文件每行内容</span></span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> f_log:</span><br><span class="line">        <span class="comment"># 将文件中的用户名与密码处理出来并解压赋值</span></span><br><span class="line">        u_name, passwd = line.split(<span class="string">&quot;|&quot;</span>)</span><br><span class="line">        <span class="comment"># 判断用户输入的用户名密码和文件存在的用户密码是否相等,密码后面有换行符也进行处理</span></span><br><span class="line">        <span class="comment"># 如果相等就登录成功,否则就显示登录失败</span></span><br><span class="line">        <span class="keyword">if</span> u_name == name <span class="keyword">and</span> passwd.strip(<span class="string">&quot;\n&quot;</span>) == pwd:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;登录成功!&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;登录失败,用户名或密码错误!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>整体功能实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">        1.用户注册</span></span><br><span class="line"><span class="string">        2.用户登录</span></span><br><span class="line"><span class="string">        3.退出系统</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span>)</span><br><span class="line">    <span class="comment"># 接收用户想要的功能编号</span></span><br><span class="line">    options = <span class="built_in">input</span>(<span class="string">&quot;请输入选项&gt;&gt;&gt;: &quot;</span>).strip()</span><br><span class="line">    <span class="comment"># 当编号为1的时候,实现用户注册功能</span></span><br><span class="line">    <span class="keyword">if</span> options == <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">        <span class="comment"># 要求用户输入用户名和密码</span></span><br><span class="line">        username = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名&gt;&gt;&gt;: &quot;</span>).strip()</span><br><span class="line">        password = <span class="built_in">input</span>(<span class="string">&quot;请输入密码&gt;&gt;&gt;: &quot;</span>).strip()</span><br><span class="line">        <span class="comment"># 格式化输入的信息,添加分隔符和换行符</span></span><br><span class="line">        msg = <span class="string">&quot;%s|%s\n&quot;</span> % (username, password)</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;user.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f_reg:</span><br><span class="line">            <span class="comment"># for循环读取文件内容</span></span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f_reg:</span><br><span class="line">                <span class="comment"># 取到用户名的值</span></span><br><span class="line">                name = line.split(<span class="string">&quot;|&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">                <span class="comment"># 如果用户输入的用户名与存在的用户名一致就退出</span></span><br><span class="line">                <span class="keyword">if</span> name == username:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;用户名已存在!&quot;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 否则就将用户输入的信息写入到文件</span></span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;user.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f_reg_insert:</span><br><span class="line">                    f_reg_insert.write(msg)</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;%s注册成功&quot;</span> % username)</span><br><span class="line">    <span class="comment"># 当用户输入编号为2时,就是登录功能</span></span><br><span class="line">    <span class="keyword">elif</span> options == <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">        <span class="comment"># 接收输入的用户名和密码</span></span><br><span class="line">        name = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名&gt;&gt;&gt;: &quot;</span>).strip()</span><br><span class="line">        pwd = <span class="built_in">input</span>(<span class="string">&quot;请输入密码&gt;&gt;&gt;: &quot;</span>).strip()</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;user.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f_log:</span><br><span class="line">            <span class="comment"># for循环读取文件每行内容</span></span><br><span class="line">            <span class="keyword">for</span> line <span class="keyword">in</span> f_log:</span><br><span class="line">                <span class="comment"># 将文件中的用户名与密码处理出来并解压赋值</span></span><br><span class="line">                u_name, passwd = line.split(<span class="string">&quot;|&quot;</span>)</span><br><span class="line">                <span class="comment"># 判断用户输入的用户名密码和文件存在的用户密码是否相等,密码后面有换行符也进行处理</span></span><br><span class="line">                <span class="comment"># 如果相等就登录成功,否则就显示登录失败</span></span><br><span class="line">                <span class="keyword">if</span> u_name == name <span class="keyword">and</span> passwd.strip(<span class="string">&quot;\n&quot;</span>) == pwd:</span><br><span class="line">                    <span class="built_in">print</span>(<span class="string">&quot;登录成功!&quot;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;登录失败,用户名或密码错误!&quot;</span>)</span><br><span class="line">    <span class="comment"># 当用户输入3就退出整个循环</span></span><br><span class="line">    <span class="keyword">elif</span> options == <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;退出系统!!!&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;输入的选项不正确,请重新输入!&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="4-2-简易拷贝功能"><a href="#4-2-简易拷贝功能" class="headerlink" title="4.2 简易拷贝功能"></a>4.2 简易拷贝功能</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">src_path = <span class="built_in">input</span>(<span class="string">&#x27;源文件绝对路径: &#x27;</span>).strip()</span><br><span class="line">dst_path = <span class="built_in">input</span>(<span class="string">&#x27;目标文件绝对路径: &#x27;</span>).strip()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;%s&#x27;</span> % src_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;%s&#x27;</span> % dst_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> copy_f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            copy_f.write(line)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-编码和文件操作</title>
    <url>/b8f382b7.html</url>
    <content><![CDATA[<h3 id="1-字符编码"><a href="#1-字符编码" class="headerlink" title="1. 字符编码"></a>1. 字符编码</h3><p>只跟文本和字符串有关<br>由于计算机内部只是别二进制,但是用户在使用计算机的时候却可以看到各种语言字符,字符编码就是内部记录了人类字符与数字对应关系的数据</p>
<span id="more"></span>
<h4 id="1-1-字符编码史"><a href="#1-1-字符编码史" class="headerlink" title="1.1 字符编码史"></a>1.1 字符编码史</h4><ol>
<li>一家独大</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">计算机由美国发明,因此美国人为了能让计算机识别英文字符诞生了ASCII码表</span><br><span class="line">特点:</span><br><span class="line">  只有英文字符与数字的一一对应关系</span><br><span class="line">  一个英文字符对应1Bytes,1Bytes=8bit,8bit最多包含<span class="number">256</span>个数字,可以对应<span class="number">256</span>个字符,足够表示所有的英文字符,目前只用到<span class="number">127</span>个,剩下的为了后续发现新的语言</span><br><span class="line">需要记住的是:</span><br><span class="line">  A-Z: <span class="number">65</span>-<span class="number">90</span></span><br><span class="line">  a-z: <span class="number">97</span>-<span class="number">122</span></span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/L7G4SM.jpg" alt="L7G4SM"></p>
<ol>
<li>群雄割据</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">中国:</span><br><span class="line">  GBK码:记录了英文中文与数字的对应关系</span><br><span class="line">        对于英文还是使用一个字节</span><br><span class="line">        中文使用了两个字节甚至更多字节,两个字节也不能够全部表示出所有的中文,需要生僻字需要更多位</span><br><span class="line">        </span><br><span class="line">日本:</span><br><span class="line">  shift_JIS码:记录了日文英文与数字的对应关系</span><br><span class="line">韩国</span><br><span class="line">  Euc_kr码:记录了韩文英文与数字的对应关系</span><br></pre></td></tr></table></figure>
<ol>
<li>分久必合</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">为了能够实现不同国家之间的文本数据能够彼此无障碍交流需要对编码统一</span><br><span class="line">unicode(万国码)出现了</span><br><span class="line">  特点:统一使用两个及以上字符记录字符与数字的对应关系</span><br><span class="line">    </span><br><span class="line">utf8(万国码的优化版)</span><br><span class="line">  英文还是用一个字节存储,中文使用三个字节或更多字节存储</span><br><span class="line"> </span><br><span class="line">现在默认使用的编码是uft8</span><br></pre></td></tr></table></figure>

<h4 id="1-2-编码操作"><a href="#1-2-编码操作" class="headerlink" title="1.2 编码操作"></a>1.2 编码操作</h4><ol>
<li>如何解决文件乱码</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">文件当初以什么编码编的,打开的时候就以什么编码解</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>python解释器不同版本的编码差异</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">python2.x内部使用的编码默认是ASCII</span><br><span class="line">  <span class="number">1.</span>文件头</span><br><span class="line">  <span class="comment"># coding:utf8</span></span><br><span class="line"></span><br><span class="line">  <span class="number">2.</span>在python2中定义字符串前面需要加一个u</span><br><span class="line">    s = <span class="string">u&#x27;你&#x27;</span></span><br><span class="line">  </span><br><span class="line">python3.x内部使用utf8</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Pycharm定义文件模板内容</li>
</ol>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/uJTsDP.png" alt="uJTsDP"></p>
<ol start="4">
<li>编码与解码</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">编码</span><br><span class="line">  将人类能够读懂的字符按照指定的编码转换成数字</span><br><span class="line">解码</span><br><span class="line">  将数字按照指定的编码转换成人类能够读懂的字符</span><br><span class="line">  </span><br><span class="line">eg:</span><br><span class="line"> <span class="comment"># 编码</span></span><br><span class="line">   s = <span class="string">&#x27;这是一段文字&#x27;</span></span><br><span class="line">   res = s.encode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">   <span class="built_in">print</span>(res, <span class="built_in">type</span>(res))  <span class="comment"># b&#x27;\xe8\xbf\x99\xe6\x98\xaf\xe4\xb8\x80\xe6\xae\xb5\xe6\x96\x87\xe5\xad\x97&#x27; &lt;class &#x27;bytes&#x27;&gt;</span></span><br><span class="line">  </span><br><span class="line"> <span class="comment"># 解码</span></span><br><span class="line">  res1 = res.decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">  <span class="built_in">print</span>(res1)  <span class="comment"># 这是一段文字</span></span><br></pre></td></tr></table></figure>

<h3 id="2-文件"><a href="#2-文件" class="headerlink" title="2. 文件"></a>2. 文件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">文件其实是操作系统暴露给用户操作硬盘的接口</span><br></pre></td></tr></table></figure>

<h4 id="2-1-文件操作"><a href="#2-1-文件操作" class="headerlink" title="2.1 文件操作"></a>2.1 文件操作</h4><h5 id="2-1-1-如何操作文件"><a href="#2-1-1-如何操作文件" class="headerlink" title="2.1.1 如何操作文件"></a>2.1.1 如何操作文件</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">关键字<span class="built_in">open</span>()</span><br><span class="line">    <span class="number">1.</span><span class="built_in">open</span>()打开文件</span><br><span class="line">    <span class="number">2.</span>其他方法操作文件</span><br><span class="line">    <span class="number">3.</span>关闭文件</span><br></pre></td></tr></table></figure>

<h5 id="2-1-2-路径斜杠"><a href="#2-1-2-路径斜杠" class="headerlink" title="2.1.2 路径斜杠"></a>2.1.2 路径斜杠</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">在路径中出现字母与斜杠的组合产生了特殊含义如何取消</span><br><span class="line">在路径字符串前面加一个r</span><br><span class="line">  <span class="string">r&#x27;D:\py20\day08\a.txt&#x27;</span></span><br></pre></td></tr></table></figure>

<h5 id="2-1-3-操作文件"><a href="#2-1-3-操作文件" class="headerlink" title="2.1.3 操作文件"></a>2.1.3 操作文件</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">格式:</span><br><span class="line">  <span class="built_in">open</span>(文件路径,读写模式,字符编码)</span><br><span class="line">       文件路径与读写模式是必须的</span><br><span class="line">       字符编码是可选的(有些模式需要编码)</span><br><span class="line">      </span><br><span class="line">  eg:</span><br><span class="line">    res = <span class="built_in">open</span>(<span class="string">&#x27;a.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(res.read())</span><br><span class="line">    res.close()</span><br></pre></td></tr></table></figure>

<h5 id="2-1-4-with上下文管理"><a href="#2-1-4-with上下文管理" class="headerlink" title="2.1.4 with上下文管理"></a>2.1.4 with上下文管理</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">可以自动close()</span><br><span class="line">eg:</span><br><span class="line">   <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;a.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">       <span class="built_in">print</span>(f1.read())</span><br></pre></td></tr></table></figure>

<h4 id="2-2-读写模式"><a href="#2-2-读写模式" class="headerlink" title="2.2 读写模式"></a>2.2 读写模式</h4><h5 id="2-2-1-只读模式-r"><a href="#2-2-1-只读模式-r" class="headerlink" title="2.2.1 只读模式 r"></a>2.2.1 只读模式 r</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">只能查看不能修改</span><br><span class="line"><span class="comment"># 当路径不存在时,直接报错</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;b.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    <span class="keyword">pass</span>  <span class="comment"># 运行代码报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当路劲存在时,读取没有问题,写操作时报错</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;a.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>,encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    <span class="built_in">print</span>(f1.read())  <span class="comment"># 能读取文件内容</span></span><br><span class="line">    f1.write(<span class="string">&#x27;123&#x27;</span>)  <span class="comment"># 报错,无法写入</span></span><br></pre></td></tr></table></figure>

<h5 id="2-2-2-只写模式-w"><a href="#2-2-2-只写模式-w" class="headerlink" title="2.2.2 只写模式 w"></a>2.2.2 只写模式 w</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当路劲不存在时,不会报错,会创建该文件</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;b.txt&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f2:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 路劲存在时,写入会先清空文件内容,再写入内容</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;a.txt&#x27;</span>,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">    <span class="built_in">print</span>(f1.read())  <span class="comment"># 读取会报错</span></span><br><span class="line">    f1.write(<span class="string">&#x27;123&#x27;</span>)  <span class="comment"># 写入的都会在一行,不会自动换行</span></span><br><span class="line">    f1.write(<span class="string">&#x27;\n123\n&#x27;</span>)  <span class="comment"># 需要加入换行符</span></span><br></pre></td></tr></table></figure>

<h5 id="2-2-3-只追加模式-a"><a href="#2-2-3-只追加模式-a" class="headerlink" title="2.2.3 只追加模式 a"></a>2.2.3 只追加模式 a</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当路劲不存在时,不会报错,同样会创建该文件</span></span><br><span class="line">  <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;c.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f3:</span><br><span class="line">      <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 当路劲存在时,写入不会清空文件</span></span><br><span class="line">  <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">r&#x27;a.txt&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, encoding=<span class="string">&#x27;utf8&#x27;</span>) <span class="keyword">as</span> f1:</span><br><span class="line">      f1.write(<span class="string">&#x27;\nwoooooo&#x27;</span>)  <span class="comment"># 需要加入换行符,否则都会在一行</span></span><br><span class="line">      f1.write(<span class="string">&#x27;\nwoooooo&#x27;</span>)</span><br><span class="line">      <span class="built_in">print</span>(f1.read())  <span class="comment"># 读取会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># r w a读写模式都只能操作文本文件</span></span><br></pre></td></tr></table></figure>

<h3 id="3-debug代码调试"><a href="#3-debug代码调试" class="headerlink" title="3. debug代码调试"></a>3. debug代码调试</h3><ol>
<li>在代码右侧使用右键标记，空白处右键出现在Run下面有Debug运行</li>
</ol>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/JSfh9B.png" alt="JSfh9B"></p>
<ol start="2">
<li>debug运行的时候会一步步执行,并给出每一步的结果</li>
</ol>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/AMmZCZ.png" alt="AMmZCZ"></p>
<ol start="3">
<li>停止debug</li>
</ol>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/BrFJ9l.png" alt="BrFJ9l"></p>
<p>取消小点</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/xfnoQa.png" alt="xfnoQa"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Containerd相关使用</title>
    <url>/4610149.html</url>
    <content><![CDATA[<h2 id="Containerd安装"><a href="#Containerd安装" class="headerlink" title="Containerd安装"></a>Containerd安装</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#依赖安装</span></span><br><span class="line">rpm -qa |grep libseccomp</span><br><span class="line">yum install wget -y</span><br><span class="line">wget http://mirror.centos.org/centos/7/os/x86_64/Packages/libseccomp-2.3.1-4.el7.x86_64.rpm</span><br><span class="line">yum install libseccomp-2.3.1-4.el7.x86_64.rpm -y</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载</span></span><br><span class="line">wget https://github.com/containerd/containerd/releases/download/v1.5.5/cri-containerd-cni-1.5.5-linux-amd64.tar.gz</span><br><span class="line"><span class="comment"># 如果有限制，也可以替换成下面的 URL 加速下载</span></span><br><span class="line"><span class="comment"># wget https://download.fastgit.org/containerd/containerd/releases/download/v1.5.5/cri-containerd-cni-1.5.5-linux-amd64.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#解压到系统各个目录中去</span></span><br><span class="line">tar -C / -xzf cri-containerd-cni-1.5.5-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#环境变量设置</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:/usr/local/bin:/usr/local/sbin&#x27;</span> &gt;&gt; ~/.bashrc </span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment">#生成默认配置</span></span><br><span class="line">mkdir -p /etc/containerd</span><br><span class="line">containerd config default &gt; /etc/containerd/config.toml</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看启动配置文件</span></span><br><span class="line">cat /etc/systemd/system/containerd.service</span><br><span class="line"></span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line">systemctl <span class="built_in">enable</span> containerd --now</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看版本</span></span><br><span class="line">ctr version</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看插件列表</span></span><br><span class="line">ctr plugin ls</span><br><span class="line"></span><br><span class="line"><span class="comment">#配置加速器</span></span><br><span class="line">[plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry]</span><br><span class="line">  [plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry.mirrors]</span><br><span class="line">    [plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry.mirrors.<span class="string">&quot;docker.io&quot;</span>]</span><br><span class="line">      endpoint = [<span class="string">&quot;https://bqr1dr1n.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">    [plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry.mirrors.<span class="string">&quot;k8s.gcr.io&quot;</span>]</span><br><span class="line">      endpoint = [<span class="string">&quot;https://registry.aliyuncs.com/k8sxio&quot;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="Containerd使用"><a href="#Containerd使用" class="headerlink" title="Containerd使用"></a>Containerd使用</h2><h3 id="镜像相关"><a href="#镜像相关" class="headerlink" title="镜像相关"></a>镜像相关</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#要注意的是镜像地址需要加上 docker.io Host 地址,  --platform 选项指定对应平台的镜像</span></span><br><span class="line">ctr image pull docker.io/library/nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment">#推送镜像,如果是私有镜像则在推送的时候可以通过 --user 来自定义仓库的用户名和密码</span></span><br><span class="line">ctr image push</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出本地镜像  -q 参数只打印镜像名称</span></span><br><span class="line">ctr image ls</span><br><span class="line"></span><br><span class="line"><span class="comment">#检测本地镜像,主要查看其中的 STATUS, complete 表示镜像是完整可用的状态</span></span><br><span class="line">ctr image check</span><br><span class="line"></span><br><span class="line"><span class="comment">#重新打标签</span></span><br><span class="line">ctr image tag docker.io/library/nginx:alpine harbor.k8s.local/course/nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除镜像 加上 --sync 选项可以同步删除镜像和所有相关的资源</span></span><br><span class="line">ctr image rm harbor.k8s.local/course/nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment">#将镜像挂载到主机目录</span></span><br><span class="line">ctr image mount docker.io/library/nginx:alpine /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment">#将镜像从主机目录上卸载</span></span><br><span class="line">ctr image unmount /mnt</span><br><span class="line"></span><br><span class="line"><span class="comment">#将镜像到处为压缩包</span></span><br><span class="line">ctr image <span class="built_in">export</span>  --all-platforms nginx.tar.gz docker.io/library/nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment">#将压缩包导入镜像</span></span><br><span class="line">ctr image import nginx.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接导入可能会出现类似于 ctr: content digest sha256:xxxxxx not found 的错误，要解决这个办法需要 pull 所有平台镜像：</span></span><br><span class="line">ctr i pull --all-platforms docker.io/library/nginx:alpine</span><br><span class="line">ctr i <span class="built_in">export</span> --all-platforms nginx.tar.gz docker.io/library/nginx:alpine</span><br><span class="line">ctr i rm docker.io/library/nginx:alpine</span><br><span class="line">ctr i import nginx.tar.gz</span><br></pre></td></tr></table></figure>

<h3 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建容器</span></span><br><span class="line">ctr container create docker.io/library/nginx:alpine nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出容器 -q 精简内容</span></span><br><span class="line">ctr container ls</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看容器详细配置,类似docker inspect</span></span><br><span class="line">ctr container info nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除容器 也可以使用 delete 或者 del 删除容器</span></span><br><span class="line">ctr container rm nginx</span><br><span class="line">ctr container ls</span><br></pre></td></tr></table></figure>

<h3 id="任务相关"><a href="#任务相关" class="headerlink" title="任务相关"></a>任务相关</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#container create 命令创建的容器，并没有处于运行状态，只是一个静态的容器</span></span><br><span class="line"><span class="comment">#一个 container 对象只是包含了运行一个容器所需的资源及相关配置数据，表示 namespaces、rootfs 和容器的配置都已经初始化成功了，只是用户进程还没有启动</span></span><br><span class="line"><span class="comment">#一个容器真正运行起来是由 Task 任务实现的，Task 可以为容器设置网卡，还可以配置工具来对容器进行监控等</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#运行容器</span></span><br><span class="line">ctr container create docker.io/library/nginx:alpine nginx</span><br><span class="line">ctr task start -d nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看正在运行的容器</span></span><br><span class="line">ctr task ls</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取容器的cgroup相关信息,还有内存、CPU 和 PID 的限额与使用量</span></span><br><span class="line">ctr task metrics nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看容器中所有进程在宿主机中的 PID</span></span><br><span class="line">ctr task ps nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入容器操作 --exec-id 后的id可以随意,唯一即可</span></span><br><span class="line">ctr task exex --exec-id 0 -t nginx sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#暂停容器</span></span><br><span class="line">ctr task pause nginx</span><br><span class="line">ctr task ls  <span class="comment"># STATUS 变成了PAUSED</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#恢复容器</span></span><br><span class="line">ctr task resume nginx</span><br><span class="line">ctr task ls  <span class="comment"># STATUS 变成了RUNING</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#杀掉容器  没有stop,只有暂停或者杀死</span></span><br><span class="line">ctr task <span class="built_in">kill</span> nginx</span><br><span class="line">ctr task ls  <span class="comment"># STATUS 变成了STOPPED</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除task</span></span><br><span class="line">ctr task rm nginx</span><br><span class="line">ctr task ls  <span class="comment"># 此时没有了</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#containerd支持命名空间概念,不指定命名空间就是在default</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看命名空间</span></span><br><span class="line">ctr ns ls</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建命名空间</span></span><br><span class="line">ctr ns creat <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#删除命名空间</span></span><br><span class="line">ctr ns rm <span class="built_in">test</span>  <span class="comment"># ctr ns remove test</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#操作资源的时候就可以指定命名空间,使用 -n 参数指定即可</span></span><br><span class="line">ctr -n <span class="built_in">test</span> image ls</span><br><span class="line"></span><br><span class="line"><span class="comment">#Docker 使用的 containerd 下面的命名空间默认是 moby，而不是 default，所以假如我们有用 docker 启动容器，那么我们也可以通过 ctr -n moby 来定位下面的容器</span></span><br><span class="line">ctr -n moby container ls</span><br><span class="line"></span><br><span class="line"><span class="comment">#同样 Kubernetes 下使用的 containerd 默认命名空间是 k8s.io，所以我们可以使用 ctr -n k8s.io 来查看 Kubernetes 下面创建的容器</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Containerd高级工具nerdctl"><a href="#Containerd高级工具nerdctl" class="headerlink" title="Containerd高级工具nerdctl"></a>Containerd高级工具nerdctl</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 如果没有安装 containerd，则可以下载 nerdctl-full-&lt;VERSION&gt;-linux-amd64.tar.gz 包进行安装</span></span><br><span class="line">wget https://github.com/containerd/nerdctl/releases/download/v0.12.1/nerdctl-0.12.1-linux-amd64.tar.gz</span><br><span class="line"><span class="comment"># 如果有限制，也可以替换成下面的 URL 加速下载</span></span><br><span class="line"><span class="comment"># wget https://download.fastgit.org/containerd/nerdctl/releases/download/v0.12.1/nerdctl-0.12.1-linux-amd64.tar.gz</span></span><br><span class="line">mkdir -p /usr/<span class="built_in">local</span>/containerd/bin/ &amp;&amp; tar -zxvf nerdctl-0.12.1-linux-amd64.tar.gz nerdctl &amp;&amp; mv nerdctl /usr/<span class="built_in">local</span>/containerd/bin/</span><br><span class="line"></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/containerd/bin/nerdctl /usr/<span class="built_in">local</span>/bin/nerdctl</span><br><span class="line"></span><br><span class="line">nerdctl version</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="使用命令"><a href="#使用命令" class="headerlink" title="使用命令"></a>使用命令</h3><h4 id="容器相关-1"><a href="#容器相关-1" class="headerlink" title="容器相关"></a>容器相关</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#运行容器</span></span><br><span class="line">nerdctl run -d -p 80:80 --name=nginx --restart=always nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment">#进入容器</span></span><br><span class="line">nerdctl <span class="built_in">exec</span> -it nginx /bin/sh</span><br><span class="line"></span><br><span class="line"><span class="comment">#列出容器 -a -q</span></span><br><span class="line">nerdctl ps </span><br><span class="line"></span><br><span class="line"><span class="comment">#获取容器详细信息</span></span><br><span class="line">nerdctl inspect nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看容器日志</span></span><br><span class="line">nerdctl logs -f nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#停止容器</span></span><br><span class="line">nerdctl stop nginx</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除容器 -f 或者 --force 强制删除</span></span><br><span class="line">nerdctl rm nginx</span><br></pre></td></tr></table></figure>

<h4 id="镜像相关-1"><a href="#镜像相关-1" class="headerlink" title="镜像相关"></a>镜像相关</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看所有镜像</span></span><br><span class="line">nerdctl images</span><br><span class="line"></span><br><span class="line"><span class="comment">#拉取镜像</span></span><br><span class="line">nerdctl pull docker.io/library/busybox:latest</span><br><span class="line"></span><br><span class="line"><span class="comment">#推送镜像</span></span><br><span class="line">nerdctl login --username xxx --password xxx  <span class="comment">#登录</span></span><br><span class="line">nerdctl <span class="built_in">logout</span>  <span class="comment">#注销退出登录</span></span><br><span class="line">nerdctl push</span><br><span class="line"></span><br><span class="line"><span class="comment">#重新给镜像打标签</span></span><br><span class="line">nerdctl tag nginx:alpine harbor.k8s.local/course/nginx:alpine</span><br><span class="line"></span><br><span class="line"><span class="comment">#导出镜像</span></span><br><span class="line">nerdctl save -o busybox.tar.gz busybox:lastest</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除镜像</span></span><br><span class="line">nerdctl rmi busybox</span><br><span class="line"></span><br><span class="line"><span class="comment">#导入镜像</span></span><br><span class="line">nerdctl load -i busybox.tar.gz</span><br></pre></td></tr></table></figure>

<h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><h5 id="安装-buildctl"><a href="#安装-buildctl" class="headerlink" title="安装 buildctl"></a>安装 buildctl</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nerdctl build 需要依赖 buildkit 工具</span><br><span class="line"></span><br><span class="line">buildkit 项目也是 Docker 公司开源的一个构建工具包，支持 OCI 标准的镜像构建。它主要包含以下部分</span><br><span class="line">		服务端 buildkitd：当前支持 runc 和 containerd 作为 worker，默认是 runc，我们这里使用 containerd</span><br><span class="line">		客户端 buildctl：负责解析 Dockerfile，并向服务端 buildkitd 发出构建请求</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">buildkit 是典型的 C/S 架构，客户端和服务端是可以不在一台服务器上，而 nerdctl 在构建镜像的时候也作为 buildkitd 的客户端，所以需要我们安装并运行 buildkitd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">wget https://github.com/moby/buildkit/releases/download/v0.9.1/buildkit-v0.9.1.linux-amd64.tar.gz</span><br><span class="line"><span class="comment"># 如果有限制，也可以替换成下面的 URL 加速下载</span></span><br><span class="line"><span class="comment"># wget https://download.fastgit.org/moby/buildkit/releases/download/v0.9.1/buildkit-v0.9.1.linux-amd64.tar.gz</span></span><br><span class="line">tar -zxvf buildkit-v0.9.1.linux-amd64.tar.gz -C /usr/<span class="built_in">local</span>/containerd/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/containerd/bin/buildkitd /usr/<span class="built_in">local</span>/bin/buildkitd</span><br><span class="line">ln -s /usr/<span class="built_in">local</span>/containerd/bin/buildctl /usr/<span class="built_in">local</span>/bin/buildctl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat /etc/systemd/system/buildkit.service</span><br><span class="line">[Unit]</span><br><span class="line">Description=BuildKit</span><br><span class="line">Documentation=https://github.com/moby/buildkit</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/usr/<span class="built_in">local</span>/bin/buildkitd --oci-worker=<span class="literal">false</span> --containerd-worker=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">systemctl daemon-reload </span><br><span class="line">systemctl <span class="built_in">enable</span> buildkit --now</span><br><span class="line">systemctl status buildkit</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h5 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat Dockerfile </span><br><span class="line">FROM nginx</span><br><span class="line">RUN <span class="built_in">echo</span> <span class="string">&#x27;Hello Nerdctl From Containerd&#x27;</span> &gt; /usr/share/nginx/html/index.html</span><br><span class="line"></span><br><span class="line"><span class="comment">#一定要关闭防火墙和selinux</span></span><br><span class="line">nerdctl build -t nginx:nerdctl -f Dockerfile .</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看是否构建成功</span></span><br><span class="line">nerdctl images </span><br><span class="line"></span><br><span class="line"><span class="comment">#测试是否成功</span></span><br><span class="line">nerdctl run -d -p 80:80 --name=nginx --restart=always nginx:nerdctl</span><br><span class="line"></span><br><span class="line">crul 127.0.0.1</span><br></pre></td></tr></table></figure>
<p>文档整理:<a href="https://www.qikqiak.com/k3s/">https://www.qikqiak.com/k3s/</a></p>
]]></content>
      <categories>
        <category>Containerd</category>
      </categories>
      <tags>
        <tag>Containerd</tag>
      </tags>
  </entry>
  <entry>
    <title>python-内置方法(三)</title>
    <url>/bb5f959.html</url>
    <content><![CDATA[<h3 id="1-列表其他方法"><a href="#1-列表其他方法" class="headerlink" title="1. 列表其他方法"></a>1. 列表其他方法</h3><h4 id="1-1-排序"><a href="#1-1-排序" class="headerlink" title="1.1 排序"></a>1.1 排序</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">33</span>, <span class="number">22</span>, <span class="number">77</span>, <span class="number">99</span>, <span class="number">11</span>, <span class="number">88</span>, <span class="number">44</span>, <span class="number">55</span>]</span><br><span class="line"><span class="number">1.</span>sort()  <span class="comment"># 默认是升序</span></span><br><span class="line">  l1.sort()</span><br><span class="line">  <span class="built_in">print</span>(l1)  <span class="comment"># [11, 22, 33, 44, 55, 77, 88, 99]</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2.</span>sort(reverse=<span class="literal">True</span>)  <span class="comment"># 降序</span></span><br><span class="line">  l1.sort(reverse=<span class="literal">True</span>)</span><br><span class="line">  <span class="built_in">print</span>(l1)  <span class="comment"># [99, 88, 77, 55, 44, 33, 22, 11]</span></span><br><span class="line">  </span><br><span class="line"><span class="number">3.</span>revers()  <span class="comment"># 顺序颠倒</span></span><br><span class="line">  l1.reverse()</span><br><span class="line">	<span class="built_in">print</span>(l1)  <span class="comment"># [55, 44, 88, 11, 99, 77, 22, 33]</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-切片"><a href="#1-2-切片" class="headerlink" title="1.2 切片"></a>1.2 切片</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">33</span>, <span class="number">22</span>, <span class="number">77</span>, <span class="number">99</span>, <span class="number">11</span>, <span class="number">88</span>, <span class="number">44</span>, <span class="number">55</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(l1[<span class="number">1</span>:<span class="number">3</span>])  <span class="comment"># [22, 77]</span></span><br><span class="line"><span class="built_in">print</span>(l1[:])  <span class="comment"># [33, 22, 77, 99, 11, 88, 44, 55]</span></span><br><span class="line"><span class="built_in">print</span>(l1[<span class="number">3</span>:])  <span class="comment"># [99, 11, 88, 44, 55]</span></span><br><span class="line"><span class="built_in">print</span>(l1[:<span class="number">3</span>])  <span class="comment"># [33, 22, 77]</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-比较"><a href="#1-3-比较" class="headerlink" title="1.3 比较"></a>1.3 比较</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">l1 = [<span class="number">99</span>, <span class="number">22</span>]</span><br><span class="line">l2 = [<span class="number">88</span>, <span class="number">44</span>, <span class="number">33</span>]</span><br><span class="line"><span class="built_in">print</span>(l1 &gt; l2)  <span class="comment"># True</span></span><br><span class="line"><span class="comment"># 列表比较运算采用相同索引的元素进行比较,只要有一个比出了结果就直接得出结论</span></span><br><span class="line"></span><br><span class="line">s1 = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">s2 = <span class="string">&#x27;world&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(s1 &gt; s2)  <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 字符串比较也会根据索引位置内部转成ASCII对应的数字进行比较</span></span><br></pre></td></tr></table></figure>

<h3 id="2-字典内置方法"><a href="#2-字典内置方法" class="headerlink" title="2. 字典内置方法"></a>2. 字典内置方法</h3><h4 id="2-1-取值"><a href="#2-1-取值" class="headerlink" title="2.1 取值"></a>2.1 取值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dic = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;jason&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="string">&#x27;hobbies&#x27;</span>: [<span class="string">&#x27;play game&#x27;</span>, <span class="string">&#x27;basketball&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>按K取值,K不存在会直接报错,不太推荐此方式</span><br><span class="line">  <span class="built_in">print</span>(dic[<span class="string">&#x27;name&#x27;</span>])  <span class="comment">#	jason</span></span><br><span class="line">  <span class="built_in">print</span>(dic[<span class="string">&#x27;pwd&#x27;</span>])  <span class="comment"># 报错</span></span><br><span class="line">  </span><br><span class="line"><span class="number">2.</span>get() 键值不存在返回<span class="literal">None</span>,不会报错</span><br><span class="line">	<span class="built_in">print</span>(dic.get(<span class="string">&#x27;xxx&#x27;</span>))  <span class="comment"># None  键不存在 不会报错返回None</span></span><br><span class="line">  <span class="built_in">print</span>(dic.get(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;哈哈哈&#x27;</span>))  <span class="comment"># 第二个参数 可以在k不存在的时候自定义返回信息</span></span><br><span class="line">  <span class="built_in">print</span>(dic.get(<span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;哈哈哈&#x27;</span>))  <span class="comment"># 第二个参数 可以在k不存在的时候自定义返回信息</span></span><br></pre></td></tr></table></figure>

<h4 id="2-2-修改值"><a href="#2-2-修改值" class="headerlink" title="2.2 修改值"></a>2.2 修改值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>键值存在则修改</span><br><span class="line">dic[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;jasonxx&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(dic)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;jasonxx&#x27;, &#x27;age&#x27;: 18, &#x27;hobbies&#x27;: [&#x27;play game&#x27;, &#x27;basketball&#x27;]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>键不存在就新增键值对</span><br><span class="line">dic[<span class="string">&#x27;pwd&#x27;</span>] = <span class="number">123</span></span><br><span class="line"><span class="built_in">print</span>(dic)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;jason&#x27;, &#x27;age&#x27;: 18, &#x27;hobbies&#x27;: [&#x27;play game&#x27;, &#x27;basketball&#x27;, &#x27;read&#x27;], &#x27;pwd&#x27;: 123&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>hobbies的 V 是一个列表,可以用append()为列表增加一个值</span><br><span class="line">dic[<span class="string">&#x27;hobbies&#x27;</span>].append(<span class="string">&#x27;read&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(dic)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;jason&#x27;, &#x27;age&#x27;: 18, &#x27;hobbies&#x27;: [&#x27;play game&#x27;, &#x27;basketball&#x27;, &#x27;read&#x27;]&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-3-统计"><a href="#2-3-统计" class="headerlink" title="2.3 统计"></a>2.3 统计</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">统计字典内部键值对的个数</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(dic))  <span class="comment"># 3</span></span><br></pre></td></tr></table></figure>

<h4 id="2-4-成员运算"><a href="#2-4-成员运算" class="headerlink" title="2.4 成员运算"></a>2.4 成员运算</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> dic)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;jason&#x27;</span> <span class="keyword">in</span> dic)  <span class="comment"># False</span></span><br><span class="line"><span class="comment"># 默认只暴露K</span></span><br></pre></td></tr></table></figure>

<h4 id="2-5-删除元素"><a href="#2-5-删除元素" class="headerlink" title="2.5 删除元素"></a>2.5 删除元素</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>方式<span class="number">1</span> <span class="keyword">del</span> 根据K删除键值对</span><br><span class="line">	<span class="keyword">del</span> dic[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">	<span class="built_in">print</span>(dic)  <span class="comment"># &#123;&#x27;age&#x27;: 18, &#x27;hobbies&#x27;: [&#x27;play game&#x27;, &#x27;basketball&#x27;]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>方式<span class="number">2</span> 弹出指定K的键值对pop()</span><br><span class="line">  <span class="built_in">print</span>(dic.pop(<span class="string">&#x27;age&#x27;</span>))  <span class="comment"># 18</span></span><br><span class="line">  <span class="built_in">print</span>(dic)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;jason&#x27;, &#x27;hobbies&#x27;: [&#x27;play game&#x27;, &#x27;basketball&#x27;]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>方式<span class="number">3</span> 直接弹出键值对,组织成元组的形式,第一个元素K,第二个元素是V</span><br><span class="line">  <span class="built_in">print</span>(dic.popitem())  <span class="comment"># (&#x27;hobbies&#x27;, [&#x27;play game&#x27;, &#x27;basketball&#x27;])</span></span><br><span class="line">  <span class="built_in">print</span>(dic)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;jason&#x27;, &#x27;age&#x27;: 18&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-6-取值"><a href="#2-6-取值" class="headerlink" title="2.6 取值"></a>2.6 取值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>keys()</span><br><span class="line"><span class="built_in">print</span>(dic.keys())  <span class="comment"># dict_keys([&#x27;name&#x27;, &#x27;age&#x27;, &#x27;hobbies&#x27;])  获取字典所有的键 看成列表即可</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>values()</span><br><span class="line"><span class="built_in">print</span>(dic.values())  <span class="comment"># dict_values([&#x27;jason&#x27;, 18, [&#x27;play game&#x27;, &#x27;basketball&#x27;]])  获取字典所有的值 看成列表即可</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>items()</span><br><span class="line"><span class="built_in">print</span>(dic.items())  <span class="comment"># dict_items([(&#x27;name&#x27;, &#x27;jason&#x27;), (&#x27;age&#x27;, 18), (&#x27;hobbies&#x27;, [&#x27;play game&#x27;, &#x27;basketball&#x27;])])</span></span><br><span class="line"><span class="comment"># 获取字典里面所有的键值对 组织成列表套元组的形式 元组内有两个元素 第一个是k第二个是v</span></span><br></pre></td></tr></table></figure>

<h4 id="2-7-更新字典"><a href="#2-7-更新字典" class="headerlink" title="2.7 更新字典"></a>2.7 更新字典</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">update()  键存在则修改 不存在则创建</span><br><span class="line">dic.update(&#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;jasonNB&#x27;</span>, <span class="string">&#x27;pwd&#x27;</span>: <span class="number">123</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(dic)  <span class="comment"># &#123;&#x27;name&#x27;: &#x27;jasonNB&#x27;, &#x27;age&#x27;: 18, &#x27;hobbies&#x27;: [&#x27;play game&#x27;, &#x27;basketball&#x27;], &#x27;pwd&#x27;: 123&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="2-8-初始化字典"><a href="#2-8-初始化字典" class="headerlink" title="2.8 初始化字典"></a>2.8 初始化字典</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">dict</span>.fromkeys([<span class="string">&#x27;k1&#x27;</span>, <span class="string">&#x27;k2&#x27;</span>, <span class="string">&#x27;k3&#x27;</span>], []))</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;笔试题&#x27;&#x27;&#x27;</span></span><br><span class="line">res = <span class="built_in">dict</span>.fromkeys([<span class="string">&#x27;k1&#x27;</span>, <span class="string">&#x27;k2&#x27;</span>, <span class="string">&#x27;k3&#x27;</span>], [])</span><br><span class="line">res[<span class="string">&#x27;k1&#x27;</span>].append(<span class="number">111</span>)</span><br><span class="line">res[<span class="string">&#x27;k2&#x27;</span>].append(<span class="number">222</span>)</span><br><span class="line">res[<span class="string">&#x27;k3&#x27;</span>].append(<span class="number">333</span>)</span><br><span class="line"><span class="comment"># V 是相同的一个列表,对该列表操作,V的值是一样的</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当对k1对应的V重新赋值后,就会被单独出来了</span></span><br><span class="line">res[<span class="string">&#x27;k1&#x27;</span>] = [<span class="number">111</span>,<span class="number">222</span>,<span class="number">333</span>]</span><br><span class="line">res[<span class="string">&#x27;k1&#x27;</span>].append(<span class="number">444</span>)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>

<h4 id="2-9-setdefault"><a href="#2-9-setdefault" class="headerlink" title="2.9 setdefault()"></a>2.9 setdefault()</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">当键存在的情况下 不修改而是获取该键对应的值</span><br><span class="line"><span class="comment"># print(dic.setdefault(&#x27;name&#x27;, &#x27;jasonNB&#x27;))</span></span><br><span class="line"><span class="comment"># print(dic)</span></span><br><span class="line"><span class="comment"># 当键不存在的情况下 新增一组键值对 并且该方法的结果是新增的值</span></span><br><span class="line"><span class="built_in">print</span>(dic.setdefault(<span class="string">&#x27;pwd&#x27;</span>, <span class="string">&#x27;123&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(dic)</span><br></pre></td></tr></table></figure>



<h3 id="3-元组内置方法"><a href="#3-元组内置方法" class="headerlink" title="3. 元组内置方法"></a>3. 元组内置方法</h3><h4 id="3-1-类型转换"><a href="#3-1-类型转换" class="headerlink" title="3.1 类型转换"></a>3.1 类型转换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>能够支持<span class="keyword">for</span>循环的数据都可以转换成元组</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(<span class="string">&#x27;hello&#x27;</span>))  <span class="comment"># (&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>([<span class="number">11</span>,<span class="number">22</span>,<span class="number">33</span>]))  <span class="comment"># (11, 22, 33)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">tuple</span>(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;jason&#x27;</span>,<span class="string">&#x27;pwd&#x27;</span>:<span class="number">123</span>&#125;))  <span class="comment"># (&#x27;name&#x27;, &#x27;pwd&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>元组类型的定义</span><br><span class="line">t1 = (<span class="number">111</span>)  <span class="comment"># 整型</span></span><br><span class="line">t2 = (<span class="number">11.11</span>)  <span class="comment"># 浮点型</span></span><br><span class="line">t3 = (<span class="string">&#x27;hello&#x27;</span>)  <span class="comment"># 字符串</span></span><br><span class="line">t1 = (<span class="number">11</span>, )  <span class="comment"># 第一个元素后一定需要加逗号才会被定义为元组,否则就不是元组类型</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-取值"><a href="#3-2-取值" class="headerlink" title="3.2 取值"></a>3.2 取值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">t = (<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>, <span class="number">444</span>, <span class="number">555</span>)</span><br><span class="line"><span class="built_in">print</span>(t[<span class="number">1</span>])  <span class="comment"># 222</span></span><br><span class="line"><span class="built_in">print</span>(t[-<span class="number">1</span>])  <span class="comment"># 555</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-切片"><a href="#3-3-切片" class="headerlink" title="3.3 切片"></a>3.3 切片</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(t[<span class="number">1</span>:<span class="number">3</span>])  <span class="comment"># (222, 333)</span></span><br><span class="line"><span class="built_in">print</span>(t[<span class="number">1</span>:<span class="number">5</span>:<span class="number">2</span>])  <span class="comment"># (222, 444)</span></span><br></pre></td></tr></table></figure>

<h4 id="3-4-统计元素个数"><a href="#3-4-统计元素个数" class="headerlink" title="3.4 统计元素个数"></a>3.4 统计元素个数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(t))  <span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<h4 id="3-5-for循环取值"><a href="#3-5-for循环取值" class="headerlink" title="3.5 for循环取值"></a>3.5 for循环取值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> t:</span><br><span class="line">		<span class="built_in">print</span>(i)</span><br></pre></td></tr></table></figure>

<h4 id="3-6-计数"><a href="#3-6-计数" class="headerlink" title="3.6 计数"></a>3.6 计数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">count()</span><br><span class="line"><span class="built_in">print</span>(t.cont(<span class="number">111</span>))  <span class="comment"># 1  111只出现一次</span></span><br></pre></td></tr></table></figure>

<h3 id="4-集合操作"><a href="#4-集合操作" class="headerlink" title="4. 集合操作"></a>4. 集合操作</h3><h4 id="4-1-类型转换"><a href="#4-1-类型转换" class="headerlink" title="4.1 类型转换"></a>4.1 类型转换</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">能够支持<span class="keyword">for</span>循环的数据类型都可以转成集合(元素要是不可变类型)</span><br><span class="line">集合内元素是无序的</span><br><span class="line"></span><br><span class="line">s1 = <span class="built_in">set</span>()</span><br></pre></td></tr></table></figure>



<h4 id="4-2-去重"><a href="#4-2-去重" class="headerlink" title="4.2 去重"></a>4.2 去重</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1)  <span class="comment"># &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>去重练习<span class="number">1</span></span><br><span class="line">name_list = [<span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;kevin&#x27;</span>]</span><br><span class="line">s2 = <span class="built_in">set</span>(name_list)</span><br><span class="line">l1 = <span class="built_in">list</span>(s2)</span><br><span class="line"><span class="built_in">print</span>(l1)  <span class="comment"># [&#x27;jason&#x27;, &#x27;kevin&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>练习<span class="number">2</span></span><br><span class="line">  ll = [<span class="number">33</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">22</span>, <span class="number">11</span>, <span class="number">44</span>, <span class="number">33</span>, <span class="number">22</span>, <span class="number">55</span>, <span class="number">66</span>, <span class="number">77</span>, <span class="number">77</span>, <span class="number">66</span>, <span class="number">55</span>, <span class="number">44</span>]</span><br><span class="line">  <span class="comment"># 基本要求:去重即可</span></span><br><span class="line">  s3 = <span class="built_in">set</span>(ll)</span><br><span class="line">  ll1 = <span class="built_in">list</span>(s3)</span><br><span class="line">  <span class="built_in">print</span>(ll1)  <span class="comment"># [33, 66, 11, 44, 77, 22, 55]</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 拔高要求:去重并保留原来的顺序</span></span><br><span class="line">    l2 = []  <span class="comment"># 定义一个新列表</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> ll:  <span class="comment"># 循环取值列表ll</span></span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">not</span> <span class="keyword">in</span> l2:  <span class="comment"># 判断取到的值是不是在新列表l2里,如果在说明重复,则不操作</span></span><br><span class="line">            l2.append(i)  <span class="comment"># 如果值不在新列表里就追加进去,达到去重且按顺序</span></span><br><span class="line">    <span class="built_in">print</span>(l2)  <span class="comment"># [33, 22, 11, 44, 55, 66, 77]</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-关系运算"><a href="#4-3-关系运算" class="headerlink" title="4.3 关系运算"></a>4.3 关系运算</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">两个群体之间做差异比较</span><br><span class="line"></span><br><span class="line">friends1 = &#123;<span class="string">&quot;zero&quot;</span>, <span class="string">&quot;kevin&quot;</span>, <span class="string">&quot;jason&quot;</span>, <span class="string">&quot;eg&quot;</span>&#125;  <span class="comment"># 用户1的好友们</span></span><br><span class="line">friends2 = &#123;<span class="string">&quot;Jy&quot;</span>, <span class="string">&quot;ricky&quot;</span>, <span class="string">&quot;jason&quot;</span>, <span class="string">&quot;eg&quot;</span>&#125;  <span class="comment"># 用户2的好友们</span></span><br></pre></td></tr></table></figure>

<h5 id="4-3-1-交集"><a href="#4-3-1-交集" class="headerlink" title="4.3.1 交集"></a>4.3.1 交集</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 共同的好友</span></span><br><span class="line"><span class="built_in">print</span>(friends1 &amp; friends2)  <span class="comment">#&#123;&#x27;jason&#x27;, &#x27;eg&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-3-2-并集"><a href="#4-3-2-并集" class="headerlink" title="4.3.2 并集"></a>4.3.2 并集</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 求两个用户所有的好友</span></span><br><span class="line"><span class="built_in">print</span>(friends1 | friends2)  <span class="comment"># &#123;&#x27;kevin&#x27;, &#x27;ricky&#x27;, &#x27;jason&#x27;, &#x27;zero&#x27;, &#x27;Jy&#x27;, &#x27;eg&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-3-3-差集"><a href="#4-3-3-差集" class="headerlink" title="4.3.3 差集"></a>4.3.3 差集</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 求用户1独有的好友</span></span><br><span class="line">  <span class="built_in">print</span>(friends1 - friends2)  <span class="comment"># &#123;&#x27;zero&#x27;, &#x27;kevin&#x27;&#125;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 求用户2独有的好友</span></span><br><span class="line">  <span class="built_in">print</span>(friends2 - friends1)  <span class="comment"># &#123;&#x27;ricky&#x27;, &#x27;Jy&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-3-4-对称差集"><a href="#4-3-4-对称差集" class="headerlink" title="4.3.4 对称差集"></a>4.3.4 对称差集</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 求用户1和用户2各自的好友</span></span><br><span class="line">  <span class="built_in">print</span>(friends1 ^ friends2)  <span class="comment"># &#123;&#x27;Jy&#x27;, &#x27;zero&#x27;, &#x27;kevin&#x27;, &#x27;ricky&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-3-5-父集与子集"><a href="#4-3-5-父集与子集" class="headerlink" title="4.3.5 父集与子集"></a>4.3.5 父集与子集</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">11</span>, <span class="number">33</span>&#125;</span><br><span class="line"><span class="built_in">print</span>(s1 &gt; s2)  <span class="comment"># 判断s1是否是s2的父集   True</span></span><br><span class="line"><span class="built_in">print</span>(s2 &lt; s1)  <span class="comment"># 判断s2是否是s1的子集   True</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python-内置方法(二)</title>
    <url>/d645d15c.html</url>
    <content><![CDATA[<h2 id="1-字符串内置方法"><a href="#1-字符串内置方法" class="headerlink" title="1. 字符串内置方法"></a>1. 字符串内置方法</h2><h3 id="1-1-大小写转换"><a href="#1-1-大小写转换" class="headerlink" title="1.1 大小写转换"></a>1.1 大小写转换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = <span class="string">&#x27;jasOn123 JAsOn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>全转大写upper()</span><br><span class="line">  <span class="built_in">print</span>(res.upper())  <span class="comment"># JASON123 JASON</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">2.</span>全转小写lower()</span><br><span class="line">  <span class="built_in">print</span>(res.lower())  <span class="comment"># jason123 jason</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>eg:</span><br><span class="line">  old_code = <span class="string">&#x27;jAson123&#x27;</span></span><br><span class="line">  code = <span class="built_in">input</span>(<span class="string">&quot;请输入验证码:%s&gt;&gt;&gt;:&quot;</span> % old_code).strip()</span><br><span class="line">  <span class="keyword">if</span> code.upper() == old_code.upper():  <span class="comment"># 这里也可以用lower()</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;验证码输入正确&quot;</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;验证码输入错误&quot;</span>)</span><br><span class="line"> <span class="comment"># 忽略大小写,全部转为大写或者小写</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-判断大小写"><a href="#1-2-判断大小写" class="headerlink" title="1.2 判断大小写"></a>1.2 判断大小写</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res1 = <span class="string">&#x27;JASON&#x27;</span></span><br><span class="line">res2 = <span class="string">&#x27;jason&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>判断是否纯大写isupper()</span><br><span class="line">  <span class="built_in">print</span>(res1.isupper())  <span class="comment"># True</span></span><br><span class="line">  <span class="built_in">print</span>(res2.isupper())  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>判断是否纯小写islower()</span><br><span class="line">  <span class="built_in">print</span>(res1.islower())  <span class="comment"># False</span></span><br><span class="line">  <span class="built_in">print</span>(res2.islower())  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h3 id="1-3-判断指定字符开头、结尾"><a href="#1-3-判断指定字符开头、结尾" class="headerlink" title="1.3 判断指定字符开头、结尾"></a>1.3 判断指定字符开头、结尾</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">s1 = <span class="string">&#x27;jason 123 newapeman heiheihei oldgirl&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>判断字符串是否以指定的字符开头startswith()</span><br><span class="line">  <span class="built_in">print</span>(s1.startswith(<span class="string">&#x27;jon&#x27;</span>))  <span class="comment"># False</span></span><br><span class="line">  <span class="built_in">print</span>(s1.startswith(<span class="string">&#x27;jas&#x27;</span>))  <span class="comment"># True</span></span><br><span class="line">  <span class="built_in">print</span>(s1.startswith(<span class="string">&#x27;jason 123&#x27;</span>))  <span class="comment">#True</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>判断字符串是否以指定的字符结尾endswith()</span><br><span class="line">  <span class="built_in">print</span>(s1.endswith(<span class="string">&#x27;oldboy&#x27;</span>))  <span class="comment"># False</span></span><br><span class="line">  <span class="built_in">print</span>(s1.endswith(<span class="string">&#x27;girl&#x27;</span>))  <span class="comment"># True</span></span><br><span class="line">  <span class="built_in">print</span>(s1.endswith(<span class="string">&#x27;hei oldgirl&#x27;</span>))  <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h3 id="1-4-格式化输出format"><a href="#1-4-格式化输出format" class="headerlink" title="1.4 格式化输出format"></a>1.4 格式化输出format</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>之前使用的是占位符 %s %d</span><br><span class="line"><span class="number">2.</span>字符串内置方法 <span class="built_in">format</span>()</span><br><span class="line"></span><br><span class="line">使用方式<span class="number">1</span>:相当于占位符</span><br><span class="line">  s1 = <span class="string">&#x27;my name is &#123;&#125; my age is &#123;&#125;&#x27;</span></span><br><span class="line">  <span class="built_in">print</span>(s1.<span class="built_in">format</span>(<span class="string">&#x27;jason&#x27;</span>, <span class="number">18</span>))  <span class="comment"># my name is jason my age is 18</span></span><br><span class="line"></span><br><span class="line">使用方式<span class="number">2</span>:大括号内写索引值可以打破顺序,并且可以反复使用相同位置的数据</span><br><span class="line">  s2 = <span class="string">&#x27;&#123;1&#125; my name is &#123;0&#125; my age is &#123;1&#125; &#123;1&#125; &#123;0&#125;&#x27;</span>  <span class="comment"># 18 my name is jason my age is 18 18 jason</span></span><br><span class="line">  <span class="built_in">print</span>(s2.<span class="built_in">format</span>(<span class="string">&#x27;jason&#x27;</span>, <span class="number">18</span>))</span><br><span class="line"></span><br><span class="line">使用方式<span class="number">3</span>:大括号内写变量名</span><br><span class="line">  s3 = <span class="string">&#x27; my name is &#123;name&#125; my age is  &#123;age&#125;&#x27;</span></span><br><span class="line">  <span class="built_in">print</span>(s3.<span class="built_in">format</span>(name=<span class="string">&#x27;jason&#x27;</span>, age=<span class="number">18</span>))  <span class="comment"># my name is jason my age is  18</span></span><br></pre></td></tr></table></figure>

<h3 id="1-5-字符串的拼接"><a href="#1-5-字符串的拼接" class="headerlink" title="1.5 字符串的拼接"></a>1.5 字符串的拼接</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>使用 +</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello&#x27;</span> + <span class="string">&#x27;world&#x27;</span>)  <span class="comment"># hello world</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>使用join()</span><br><span class="line">  l = [<span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;tony&#x27;</span>, <span class="string">&#x27;kevin&#x27;</span>]</span><br><span class="line">  <span class="built_in">print</span>(l[<span class="number">0</span>] + <span class="string">&#x27;|&#x27;</span> + l[<span class="number">1</span>] + <span class="string">&#x27;|&#x27;</span> + l[<span class="number">2</span>])  <span class="comment"># jason|tony|kevin</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;|&#x27;</span>.join(l))  <span class="comment"># jason|tony|kevin</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># l1 = [&#x27;jason&#x27;, 123, &#x27;tony&#x27;]</span></span><br><span class="line"><span class="comment"># print(&#x27;$&#x27;.join(l1))  # 报错</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;必须是字符串类型 (在python不同数据类型之间无法直接操作)&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-6-替换字符串中指定的字符"><a href="#1-6-替换字符串中指定的字符" class="headerlink" title="1.6 替换字符串中指定的字符"></a>1.6 替换字符串中指定的字符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">replace()</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">  s4 = <span class="string">&#x27;my name is tony tony tony my age is 18&#x27;</span></span><br><span class="line">  <span class="built_in">print</span>(s4.replace(<span class="string">&#x27;tony&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>))  <span class="comment"># my name is Bob Bob Bob my age is 18</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换指定字符的次数</span></span><br><span class="line">  s4 = <span class="string">&#x27;my name is tony tony tony my age is 18&#x27;</span></span><br><span class="line">  <span class="built_in">print</span>(s4.replace(<span class="string">&#x27;tony&#x27;</span>, <span class="string">&#x27;Bob&#x27;</span>, <span class="number">1</span>))  <span class="comment"># my name is Bob tony tony my age is 18</span></span><br></pre></td></tr></table></figure>

<h3 id="1-7-判断是否纯数字"><a href="#1-7-判断是否纯数字" class="headerlink" title="1.7 判断是否纯数字"></a>1.7 判断是否纯数字</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">isdigit()</span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line">  s1 = <span class="string">&#x27;asd123&#x27;</span></span><br><span class="line">  s2 = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  <span class="built_in">print</span>(s1.isdigit())  <span class="comment"># False</span></span><br><span class="line">  <span class="built_in">print</span>(s2.isdigit())  <span class="comment"># True</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 案例:判断用户输入的是否是纯数字</span></span><br><span class="line">  real_age = <span class="number">20</span></span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      age = <span class="built_in">input</span>(<span class="string">&quot;请输入猜测的年龄:&quot;</span>).strip()  <span class="comment"># 去除首尾的空格</span></span><br><span class="line">      <span class="keyword">if</span> age.isdigit():  <span class="comment"># 判断输入的是否是纯数字</span></span><br><span class="line">          <span class="keyword">if</span> <span class="built_in">int</span>(age) == real_age:  <span class="comment"># 将输入的整数字符串转换为整型</span></span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;猜对了&quot;</span>)</span><br><span class="line">              <span class="keyword">break</span>  <span class="comment"># 猜对了就退出循环</span></span><br><span class="line">          <span class="keyword">else</span>:</span><br><span class="line">              <span class="built_in">print</span>(<span class="string">&quot;猜错了&quot;</span>)</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;请输入正确的数字&quot;</span>)  <span class="comment"># 如果用户输入的不是纯数字提示并再次循环</span></span><br></pre></td></tr></table></figure>

<h3 id="1-8-字体格式相关"><a href="#1-8-字体格式相关" class="headerlink" title="1.8 字体格式相关"></a>1.8 字体格式相关</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str1 = <span class="string">&#x27;my namE iS Bob&#x27;</span></span><br><span class="line">str2 = <span class="string">&#x27;but&#x27;</span></span><br><span class="line">str3 = <span class="string">&#x27;tony123&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>title()  <span class="comment"># 所有单词首字母大写</span></span><br><span class="line">  <span class="built_in">print</span>(str1.title())  <span class="comment"># My Name Is Bob</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>capitalize()  <span class="comment"># 第一个单词首字母大写</span></span><br><span class="line">  <span class="built_in">print</span>(str1.capitalize())  <span class="comment"># My name is bob</span></span><br><span class="line"></span><br><span class="line"><span class="number">3.</span>swapcase()  <span class="comment"># 大小写互换</span></span><br><span class="line">  <span class="built_in">print</span>(str1.swapcase())  <span class="comment"># MY NAMe Is bOB</span></span><br><span class="line"></span><br><span class="line"><span class="number">4.</span>find()  <span class="comment"># 查看指定字符对应的起始索引值,从左往右找到一个就结束</span></span><br><span class="line">  <span class="built_in">print</span>(str1.find(<span class="string">&#x27;n&#x27;</span>))  <span class="comment"># 3</span></span><br><span class="line">  <span class="built_in">print</span>(str1.find(<span class="string">&#x27;nam&#x27;</span>))  <span class="comment"># 3  返回的是第三个字母n的索引值</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.</span>center()  <span class="comment"># 指定字符补齐指定个数,居中显示</span></span><br><span class="line">  <span class="built_in">print</span>(str2.center(<span class="number">15</span>, <span class="string">&#x27;$&#x27;</span>))  <span class="comment"># $$$$$$but$$$$$$</span></span><br><span class="line"></span><br><span class="line"><span class="number">6.</span>ljust()  <span class="comment"># 指定字符补齐指定个数,左对齐</span></span><br><span class="line">  <span class="built_in">print</span>(str2.ljust(<span class="number">15</span>, <span class="string">&#x27;*&#x27;</span>))  <span class="comment"># but************</span></span><br><span class="line"></span><br><span class="line"><span class="number">7.</span>rjust()  <span class="comment"># 指定字符补齐指定个数,右对齐</span></span><br><span class="line">  <span class="built_in">print</span>(str2.rjust(<span class="number">15</span>, <span class="string">&#x27;%&#x27;</span>))  <span class="comment"># %%%%%%%%%%%%but</span></span><br><span class="line"></span><br><span class="line"><span class="number">8.</span>isalnum()  <span class="comment"># 字符串中即可以包含数字也可以包含字母,返回布尔值</span></span><br><span class="line">  <span class="built_in">print</span>(str2.isalnum())  <span class="comment"># True</span></span><br><span class="line">  <span class="built_in">print</span>(str3.isalnum())  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="number">9.</span>isalpha()  <span class="comment"># 字符串中只包含字母,返回布尔值</span></span><br><span class="line">  <span class="built_in">print</span>(str2.isalpha())  <span class="comment"># True</span></span><br><span class="line">  <span class="built_in">print</span>(str3.isalpha())  <span class="comment"># False	</span></span><br></pre></td></tr></table></figure>

<h2 id="2-列表内置方法"><a href="#2-列表内置方法" class="headerlink" title="2.列表内置方法"></a>2.列表内置方法</h2><h3 id="2-1-基本方法"><a href="#2-1-基本方法" class="headerlink" title="2.1 基本方法"></a>2.1 基本方法</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>列表内一般都会存储相同数据类型的数据</span><br><span class="line"><span class="number">2.</span><span class="built_in">list</span>()  转换为列表类型,可以将支持<span class="keyword">for</span>循环的数据类型转换成列表</span><br><span class="line">eg:</span><br><span class="line">  <span class="comment"># print(list(123))  # 报错</span></span><br><span class="line">  <span class="comment"># print(list(123.21))  # 报错</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">list</span>(<span class="string">&#x27;hello&#x27;</span>))  <span class="comment"># [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">list</span>(&#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;pwd&#x27;</span>: <span class="number">123</span>&#125;))  <span class="comment"># [&#x27;username&#x27;, &#x27;pwd&#x27;]</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">list</span>((<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>)))  <span class="comment"># [11, 22, 33]</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">list</span>(&#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>&#125;))  <span class="comment"># [33, 11, 22]</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-列表增改数据"><a href="#2-2-列表增改数据" class="headerlink" title="2.2 列表增改数据"></a>2.2 列表增改数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;tony&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>改</span><br><span class="line">  name_list[<span class="number">0</span>] = <span class="number">666</span></span><br><span class="line">  <span class="built_in">print</span>(name_list)  <span class="comment"># [666, &#x27;kevin&#x27;, &#x27;tony&#x27;, &#x27;jack&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>增</span><br><span class="line">  方式<span class="number">1</span>: append()</span><br><span class="line">    <span class="comment"># 尾部追加</span></span><br><span class="line">    name_list.appernd(<span class="number">666</span>)</span><br><span class="line">    <span class="built_in">print</span>(name_list)  <span class="comment"># [&#x27;jason&#x27;, &#x27;kevin&#x27;, &#x27;tony&#x27;, &#x27;jack&#x27;, 666]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 尾部追加(将括号内的数据当成一个整体追加到列表末尾)</span></span><br><span class="line">    name_list.append([<span class="number">111</span>, <span class="number">222</span>, <span class="number">333</span>]) </span><br><span class="line">	  <span class="built_in">print</span>(name_list)  <span class="comment"># [&#x27;jason&#x27;, &#x27;kevin&#x27;, &#x27;tony&#x27;, &#x27;jack&#x27;, [111, 222, 333]]</span></span><br><span class="line">    </span><br><span class="line">  方式<span class="number">2</span>: insert()</span><br><span class="line">    <span class="comment"># 可以在指定索引值插入元素</span></span><br><span class="line">    name_list.insert(<span class="number">3</span>, <span class="string">&#x27;vae&#x27;</span>)</span><br><span class="line">		<span class="built_in">print</span>(name_list)  <span class="comment"># [&#x27;jason&#x27;, &#x27;kevin&#x27;, &#x27;tony&#x27;, &#x27;vae&#x27;, &#x27;jack&#x27;]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 元素会被当成一个整体插入到指定索引位置</span></span><br><span class="line">    name_list.insert(<span class="number">2</span>, [<span class="number">11</span>, <span class="number">22</span>])</span><br><span class="line">		<span class="built_in">print</span>(name_list)  <span class="comment"># [&#x27;jason&#x27;, &#x27;kevin&#x27;, [11, 22], &#x27;tony&#x27;, &#x27;jack&#x27;]</span></span><br><span class="line"> </span><br><span class="line"> 方式<span class="number">3</span>: extend()</span><br><span class="line">    <span class="comment"># 扩展元素</span></span><br><span class="line">    name_list.extend([<span class="number">11</span>, <span class="number">22</span>])</span><br><span class="line">		<span class="built_in">print</span>(name_list)  <span class="comment"># [&#x27;jason&#x27;, &#x27;kevin&#x27;, &#x27;tony&#x27;, &#x27;jack&#x27;, 11, 22]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 相当于for循环+append()</span></span><br><span class="line">    l1 = [<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>]</span><br><span class="line">    l2 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> l2:</span><br><span class="line">    		l1.append(i)</span><br><span class="line">		<span class="built_in">print</span>(l1)</span><br></pre></td></tr></table></figure>

<h3 id="2-3-列表删除数据"><a href="#2-3-列表删除数据" class="headerlink" title="2.3 列表删除数据"></a>2.3 列表删除数据</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">name_list = [<span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;tony&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>]</span><br><span class="line"><span class="number">1.</span>通过<span class="keyword">del</span>删除</span><br><span class="line">  <span class="keyword">del</span> name_list[<span class="number">0</span>]  <span class="comment"># 直接删除索引为0的值</span></span><br><span class="line">  <span class="built_in">print</span>(name_list)  <span class="comment"># [&#x27;kevin&#x27;, &#x27;tony&#x27;, &#x27;jack&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>remove()</span><br><span class="line">  <span class="comment"># 移除括号内的元素值</span></span><br><span class="line">  name_list.remove(<span class="string">&#x27;jack&#x27;</span>)</span><br><span class="line">	<span class="built_in">print</span>(name_list)  <span class="comment"># [&#x27;jason&#x27;, &#x27;kevin&#x27;, &#x27;tony&#x27;]</span></span><br><span class="line">  <span class="built_in">print</span>(name_list.remove(<span class="string">&#x27;jack&#x27;</span>))  <span class="comment"># None</span></span><br><span class="line">  </span><br><span class="line"><span class="number">3.</span>pop()</span><br><span class="line">  <span class="comment"># 弹出括号内的元素索引值,如果括号没有值,则默认弹出列表尾部的元素</span></span><br><span class="line">  <span class="built_in">print</span>(name_list.pop(<span class="number">0</span>))  <span class="comment"># jason</span></span><br><span class="line">  <span class="built_in">print</span>(name_list)  <span class="comment"># [&#x27;kevin&#x27;, &#x27;tony&#x27;, &#x27;jack&#x27;]</span></span><br></pre></td></tr></table></figure>



<h2 id="可变类型与不可变类型"><a href="#可变类型与不可变类型" class="headerlink" title="可变类型与不可变类型"></a>可变类型与不可变类型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">可变类型: 列表</span><br><span class="line">    值改变,内存地址不变,修改的是原值</span><br><span class="line">不可变类型: 整型 浮点型 字符串</span><br><span class="line">    值改变,内存地址肯定变,产生了新值</span><br><span class="line">    </span><br><span class="line">eg:</span><br><span class="line">  <span class="comment"># 不可变类型</span></span><br><span class="line">  str1 = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">  <span class="built_in">print</span>(str1.title())  <span class="comment"># Hello World 结果操作之后的值,是一个新的值</span></span><br><span class="line">  <span class="built_in">print</span>(str1)  <span class="comment"># hello world 原值并没有改变</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 可变类型</span></span><br><span class="line">  name_list = [<span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;tony&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>]</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">id</span>(name_list))  <span class="comment"># 现在的值为 140618704502856 (不固定值)</span></span><br><span class="line">	name_list[<span class="number">0</span>] = <span class="number">666</span></span><br><span class="line">  <span class="built_in">print</span>(name_list)  <span class="comment"># [666, &#x27;kevin&#x27;, &#x27;tony&#x27;, &#x27;jack&#x27;]</span></span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">id</span>(name_list))  <span class="comment"># 修改之后值还是 140618704502856 </span></span><br></pre></td></tr></table></figure>

<h2 id="实现队列与堆栈"><a href="#实现队列与堆栈" class="headerlink" title="实现队列与堆栈"></a>实现队列与堆栈</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">list1 = <span class="built_in">list</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    list1.append(i)</span><br><span class="line">    <span class="built_in">print</span>(list1)  <span class="comment"># 一个个进,从0开始</span></span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 队列 先进先出</span></span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">del</span> list1[<span class="number">0</span>]  <span class="comment"># 一个个删除,相当于一个个出来,每次出来都从索引0开始,从0开始删除到9</span></span><br><span class="line">    <span class="built_in">print</span>(list1)  <span class="comment"># 根据循环打印出过程,可以直观看出先进先出</span></span><br><span class="line"><span class="built_in">print</span>(list1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 堆栈 先进后出</span></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    list1.pop()  <span class="comment"># 从尾部开始删除,相当于最后进来的先删除</span></span><br><span class="line">    <span class="built_in">print</span>(list1)</span><br><span class="line"><span class="built_in">print</span>(list1)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>for循环及内置方法</title>
    <url>/5bfa71b5.html</url>
    <content><![CDATA[<h3 id="1-while循环"><a href="#1-while循环" class="headerlink" title="1. while循环"></a>1. while循环</h3><h4 id="1-1-continue"><a href="#1-1-continue" class="headerlink" title="1.1 continue"></a>1.1 continue</h4><span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">contiue可以让循环体代码直接回到条件判断处重新判断,相当于跳出本次循环</span><br><span class="line">eg:</span><br><span class="line">  <span class="comment"># 使用while循环打印0-10但是不打印4</span></span><br><span class="line">  num = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> num &lt; <span class="number">11</span>:</span><br><span class="line">      <span class="keyword">if</span> num == <span class="number">4</span>:</span><br><span class="line">          num += <span class="number">1</span>  <span class="comment"># 跳出的时候将num加1到num为5,好继续下次的循环,否则会卡在4一直循环</span></span><br><span class="line">          <span class="keyword">continue</span>  <span class="comment"># 当num为4时跳出本次循环</span></span><br><span class="line">      <span class="built_in">print</span>(num)</span><br><span class="line">      num += <span class="number">1</span></span><br></pre></td></tr></table></figure>



<h4 id="1-2-else"><a href="#1-2-else" class="headerlink" title="1.2 else"></a>1.2 else</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">当<span class="keyword">while</span>循环没有被人为中断(<span class="keyword">break</span>)的情况下才会走<span class="keyword">else</span></span><br><span class="line">eg:</span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">      <span class="built_in">print</span>(count)</span><br><span class="line">      count += <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;被执行了&quot;</span>)  <span class="comment"># 结果:在打印了0-4之后,这段代码被执行了</span></span><br><span class="line">    </span><br><span class="line">  </span><br><span class="line">  count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">      <span class="built_in">print</span>(count)</span><br><span class="line">      count += <span class="number">1</span></span><br><span class="line">      <span class="keyword">break</span>  <span class="comment"># 遇到break之后跳出了循环</span></span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;不被执行了&quot;</span>)  <span class="comment"># 这段就没有执行</span></span><br></pre></td></tr></table></figure>

<h4 id="1-3-死循环"><a href="#1-3-死循环" class="headerlink" title="1.3 死循环"></a>1.3 死循环</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">一个靠自身控制无法终止的程序叫死循环,死循环会让CPU极度繁忙</span><br><span class="line">eg：</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span></span><br><span class="line">      <span class="built_in">print</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>



<h3 id="2-for循环"><a href="#2-for循环" class="headerlink" title="2. for循环"></a>2. for循环</h3><h4 id="2-1-基本使用"><a href="#2-1-基本使用" class="headerlink" title="2.1 基本使用"></a>2.1 基本使用</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span><span class="keyword">for</span>循环能做到的事情 <span class="keyword">while</span>循环都可以做到,但是<span class="keyword">for</span>循环语法更加简洁 并且在循环取值问题上更加方便</span><br><span class="line"><span class="number">2.</span><span class="keyword">for</span>循环一般用于遍历任意可迭代对象中的元素,可迭代对象包括字符串,列表,元组,集合和字典,字典默认只能取到K</span><br><span class="line"><span class="number">3.</span>变量名如果没有合适的名称,可以使用i,j,k,v,item</span><br><span class="line"><span class="number">4.</span>结构：</span><br><span class="line">  <span class="keyword">for</span> 变量 <span class="keyword">in</span> 迭代对象:</span><br><span class="line">      重复执行的代码</span><br><span class="line"> <span class="number">5.</span>eg:</span><br><span class="line">   name_list = [<span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;tony&#x27;</span>, <span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;jack&#x27;</span>, <span class="string">&#x27;xxx&#x27;</span>]</span><br><span class="line">   <span class="comment"># 循环打印列表中的每一个元素</span></span><br><span class="line">   <span class="comment"># while实现</span></span><br><span class="line">     count = <span class="number">0</span></span><br><span class="line">     <span class="keyword">while</span> count &lt; <span class="number">5</span>:</span><br><span class="line">         <span class="built_in">print</span>(name_list[count])</span><br><span class="line">         count += <span class="number">1</span></span><br><span class="line">   <span class="comment"># for实现</span></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> name_list:</span><br><span class="line">         <span class="built_in">print</span>(i)</span><br><span class="line">   <span class="comment"># for循环打印字符串中每个字符</span></span><br><span class="line">     <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">         <span class="built_in">print</span>(i)  <span class="comment"># 每个字母都会被打印,中间的空格也回被打印</span></span><br><span class="line">   <span class="comment"># for循环字典,默认只能取到K</span></span><br><span class="line">     d = &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;pwd&#x27;</span>: <span class="number">123</span>, <span class="string">&#x27;hobby&#x27;</span>: <span class="string">&#x27;read&#x27;</span>&#125;</span><br><span class="line">     <span class="keyword">for</span> k <span class="keyword">in</span> d:</span><br><span class="line">         <span class="built_in">print</span>(k, d[k])  <span class="comment"># 结果:前面是K值,后面是V值</span></span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/uVzeKa.png" alt="uVzeKa"></p>
<h4 id="2-2-range"><a href="#2-2-range" class="headerlink" title="2.2 range"></a>2.2 range</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>第一种:一个参数,从零开始,顾头不顾尾</span><br><span class="line">  eg:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(i)  <span class="comment"># 循环打印0-9</span></span><br><span class="line"><span class="number">2.</span>第二种:两个参数,自定义起始位置,顾头不顾尾</span><br><span class="line">  eg:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>,<span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(i)  <span class="comment"># 循环打印4-9</span></span><br><span class="line"><span class="number">3.</span>第三种:三个参数,第三个数字用来控制等差值</span><br><span class="line">  eg:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="number">100</span>, <span class="number">10</span>):</span><br><span class="line">        <span class="built_in">print</span>(i)  <span class="comment"># 循环打印从2开始每隔10个数的值,2 12 22...92</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">扩展:</span></span><br><span class="line"><span class="string">    https://movie.douban.com/top250  第一页</span></span><br><span class="line"><span class="string">    https://movie.douban.com/top250?start=25&amp;filter=  第二页 每页相差25</span></span><br><span class="line"><span class="string">    https://movie.douban.com/top250?start=50&amp;filter=  第三页</span></span><br><span class="line"><span class="string">    https://movie.douban.com/top250?start=75&amp;filter=  第四页</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">base_url = <span class="string">&#x27;https://movie.douban.com/top250?start=%s&amp;filter=&#x27;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">250</span>, <span class="number">25</span>):</span><br><span class="line">  <span class="built_in">print</span>(base_url % i)  <span class="comment"># 打印出了豆瓣top250每页的url</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># range()在python2.x和python3.x返回值不同</span></span><br><span class="line">  在python2.x中<span class="built_in">range</span>()会生成一个列表,但有个xrange()也是迭代器</span><br><span class="line">  在python3.x中<span class="built_in">range</span>()是一个迭代器,相对于python2.x生成列表更加节省内存</span><br><span class="line"><span class="comment"># python2.x中的xrange()就是python3.x中的range()</span></span><br></pre></td></tr></table></figure>



<h4 id="2-3-break"><a href="#2-3-break" class="headerlink" title="2.3 break"></a>2.3 break</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">结束本层循环</span><br><span class="line">eg:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 当i等于4的时候遇到了break,直接结束这层的for循环</span></span><br><span class="line">    <span class="built_in">print</span>(i)  <span class="comment"># 结果是打印0-3</span></span><br></pre></td></tr></table></figure>



<h4 id="2-4-continue"><a href="#2-4-continue" class="headerlink" title="2.4 continue"></a>2.4 continue</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">结束本次循环</span><br><span class="line">eg:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">continue</span>  <span class="comment"># 当i等于4的时候,结束本次循环,不影响</span></span><br><span class="line">    <span class="built_in">print</span>(i)  <span class="comment"># 打印0-3,5-9</span></span><br></pre></td></tr></table></figure>



<h4 id="2-5-else"><a href="#2-5-else" class="headerlink" title="2.5 else"></a>2.5 else</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">在<span class="keyword">for</span>循环正常结束的情况下才会被执行</span><br><span class="line">eg:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> rnage(<span class="number">10</span>)：</span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这段被执行了&quot;</span>)  <span class="comment"># 在循环打印了0-9之后,会继续执行这段代码,打印 这段被执行了</span></span><br><span class="line"></span><br><span class="line">eg:</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> i == <span class="number">4</span>:</span><br><span class="line">        <span class="keyword">break</span>  <span class="comment"># 在循环打印了0-3之后,就被跳出了本层循环</span></span><br><span class="line">    <span class="built_in">print</span>(i)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;这段代码没有被执行&quot;</span>)  <span class="comment">#这段代码就没有被执行</span></span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h4 id="2-6-嵌套"><a href="#2-6-嵌套" class="headerlink" title="2.6 嵌套"></a>2.6 嵌套</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># for i in range(3):</span></span><br><span class="line"><span class="comment">#     for j in range(5):</span></span><br><span class="line"><span class="comment">#         print(&quot;*&quot;, end=&#x27;&#x27;)</span></span><br><span class="line"><span class="comment">#     print()</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, i + <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s*%s=%s&#x27;</span> % (i, j, i * j), end=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>



<h3 id="3-数据类型内置方法"><a href="#3-数据类型内置方法" class="headerlink" title="3. 数据类型内置方法"></a>3. 数据类型内置方法</h3><h4 id="3-1-整型"><a href="#3-1-整型" class="headerlink" title="3.1 整型"></a>3.1 整型</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>类型转换 <span class="built_in">int</span>()</span><br><span class="line"><span class="comment"># 只能转换成纯数字,且在转换的时候只识别整数,遇到其他类型的都会报错,如小数,带字母的等</span></span><br><span class="line">eg:</span><br><span class="line">  res = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(res))  <span class="comment"># 输出结果是 str</span></span><br><span class="line">  <span class="built_in">int</span>(res)</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(res))  <span class="comment"># 输出结果是 int</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">int</span>(<span class="number">123.123</span>)  <span class="comment"># 报错,不识别小数</span></span><br><span class="line">  <span class="built_in">int</span>(t123)  <span class="comment"># 报错，不识别除数字以外的</span></span><br><span class="line">  </span><br><span class="line"> <span class="number">2.</span>进制转换</span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">bin</span>(<span class="number">100</span>))  <span class="comment"># 将十进制的100转换成二进制  0b1100100</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">oct</span>(<span class="number">100</span>))  <span class="comment"># 将十进制的100转换成八进制  0o144</span></span><br><span class="line">   <span class="built_in">print</span>(<span class="built_in">hex</span>(<span class="number">100</span>))  <span class="comment"># 将十进制的100转换成十六进制  0x64</span></span><br><span class="line">  <span class="comment"># 0b开头为二进制数  0o开头为八进制数  0x开头为十六进制数</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&#x27;0b1100100&#x27;</span>, <span class="number">2</span>))  <span class="comment"># 使用int()将0b1100100以二进制的方式转换为十进制</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&#x27;0o144&#x27;</span>, <span class="number">8</span>))  <span class="comment"># 使用int()将0o144以八进制的方式转换为十进制</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">int</span>(<span class="string">&#x27;0x64&#x27;</span>, <span class="number">16</span>))  <span class="comment"># 使用int()将0x64以十六进制的方式转换为十进制</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-浮点型"><a href="#3-2-浮点型" class="headerlink" title="3.2 浮点型"></a>3.2 浮点型</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">类型转换 <span class="built_in">float</span>()</span><br><span class="line">可以转换成小数,在转换的时候可以识别整数和小数,遇到其他类型的都会报错</span><br><span class="line">eg:</span><br><span class="line">  res1 = <span class="string">&#x27;123.123&#x27;</span></span><br><span class="line">  res2 = <span class="string">&#x27;123&#x27;</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(res1))  <span class="comment"># 没被转换前类型是 str</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(res2))  <span class="comment"># 没被转换前类型是 str</span></span><br><span class="line">  <span class="built_in">float</span>(res1)  <span class="comment"># 使用float()进行转换</span></span><br><span class="line">  <span class="built_in">float</span>(res2)  <span class="comment"># 使用float()进行转换</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(res1))  <span class="comment"># 转换后res1类型是整型</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(res2))  <span class="comment"># 转换后res2类型是整型</span></span><br><span class="line">  <span class="built_in">print</span>(res2)  <span class="comment"># res2的结果变成 123.0</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-字符串"><a href="#3-3-字符串" class="headerlink" title="3.3 字符串"></a>3.3 字符串</h4><h5 id="3-3-1-类型转换str"><a href="#3-3-1-类型转换str" class="headerlink" title="3.3.1 类型转换str()"></a>3.3.1 类型转换str()</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">任何类型都可以转换成字符串类型 <span class="built_in">str</span>()</span><br><span class="line"><span class="built_in">str</span>(<span class="number">123</span>)</span><br><span class="line"><span class="built_in">str</span>(<span class="number">123.123</span>)</span><br><span class="line"><span class="built_in">str</span>([<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;paswd&#x27;</span>])</span><br><span class="line"><span class="built_in">str</span>(&#123;<span class="string">&#x27;name&#x27;</span>:<span class="string">&#x27;xxx&#x27;</span>, <span class="string">&#x27;passwd&#x27;</span>: <span class="number">123</span>&#125;)</span><br><span class="line">...</span><br><span class="line"><span class="comment">#最终结果都会是str类型</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-2-索引取值"><a href="#3-3-2-索引取值" class="headerlink" title="3.3.2 索引取值"></a>3.3.2 索引取值</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = <span class="string">&#x27;hello world!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(res[<span class="number">1</span>])  <span class="comment"># 结果为e</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#还可以支持负数索引</span></span><br><span class="line"><span class="built_in">print</span>(res[-<span class="number">1</span>])  <span class="comment"># 结果为 ！ </span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-3-切片操作"><a href="#3-3-3-切片操作" class="headerlink" title="3.3.3 切片操作"></a>3.3.3 切片操作</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = <span class="string">&#x27;hello world!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(res[<span class="number">1</span>:<span class="number">4</span>])  <span class="comment"># 结果为ell</span></span><br><span class="line"><span class="comment">#切片操作顾头不顾尾,左闭右开</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-4-步长操作"><a href="#3-3-4-步长操作" class="headerlink" title="3.3.4 步长操作"></a>3.3.4 步长操作</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">res = <span class="string">&#x27;hello world!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(res[<span class="number">1</span>:<span class="number">10</span>:<span class="number">2</span>])  <span class="comment"># 结果为el ol</span></span><br><span class="line"><span class="comment">#先取到1到10的字符为在ello worl,同样顾头不顾尾</span></span><br><span class="line"><span class="comment">#再每隔两个取,结果就是el ol</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(res[-5:-1])  # orld  顾头不顾尾</span></span><br><span class="line"><span class="comment"># print(res[-5:-1:-1])  # 方向冲突</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-5-len"><a href="#3-3-5-len" class="headerlink" title="3.3.5 len()"></a>3.3.5 len()</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">统计字符串内部字符的个数 <span class="built_in">len</span>()</span><br><span class="line">res = <span class="string">&#x27;hello world!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(res))  <span class="comment"># 结果为12</span></span><br></pre></td></tr></table></figure>

<h5 id="3-3-6-strip"><a href="#3-3-6-strip" class="headerlink" title="3.3.6 strip()"></a>3.3.6 strip()</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">移除字符串首尾指定的字符,默认移除的是首位的空格 strip()</span><br><span class="line">eg1:</span><br><span class="line">  name = <span class="string">&#x27;  jason  &#x27;</span></span><br><span class="line">  <span class="built_in">print</span>(name, <span class="built_in">len</span>(name))</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">len</span>(name.strip()))  <span class="comment"># 默认移除首尾的空格</span></span><br><span class="line">eg2:</span><br><span class="line">  name1 = <span class="string">&#x27;$$jason$$&#x27;</span></span><br><span class="line">  <span class="built_in">print</span>(name1.strip(<span class="string">&#x27;$&#x27;</span>))  <span class="comment"># 移除指定字符$ 结果为jason</span></span><br><span class="line">  <span class="built_in">print</span>(name1.lstrip(<span class="string">&#x27;$&#x27;</span>))  <span class="comment"># 移除左边的$$ 结果为jason$$  </span></span><br><span class="line">  <span class="built_in">print</span>(name1.rstrip(<span class="string">&#x27;$&#x27;</span>))  <span class="comment"># 移除右边的$$ 结果为$$jason</span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 在应用中,用户在输入的时候在首位手残输入了空格之后的解决办法</span></span><br><span class="line">  username = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名:&quot;</span>).strip()  <span class="comment"># 用户在输入的时候前后输入了空格将不受影响</span></span><br><span class="line">  <span class="keyword">if</span> username == <span class="string">&#x27;root&#x27;</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;用户名输入正确&#x27;</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&quot;用户名输入错误&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="3-3-7-split"><a href="#3-3-7-split" class="headerlink" title="3.3.7 split()"></a>3.3.7 split()</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">按照指定的字符切割字符串,该方法返回的是一个列表 split()</span><br><span class="line">res = <span class="string">&#x27;root|123|test&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(res.split(<span class="string">&#x27;|&#x27;</span>))  <span class="comment"># [&#x27;root&#x27;, &#x27;123&#x27;, &#x27;test&#x27;] 以|进行分割,返回列表</span></span><br><span class="line"><span class="built_in">print</span>(res.split(<span class="string">&#x27;|&#x27;</span>, maxsplit=<span class="number">1</span>))  <span class="comment"># [&#x27;root&#x27;, &#x27;123|test&#x27;]  maxsplit用于控制切割的次数</span></span><br><span class="line"><span class="built_in">print</span>(res.rsplit(<span class="string">&#x27;|&#x27;</span>, maxsplit=<span class="number">1</span>))  <span class="comment"># [&#x27;root|123&#x27;, &#x27;test&#x27;] 从右边开始分割</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes安装</title>
    <url>/60b500c7.html</url>
    <content><![CDATA[<h3 id="规划"><a href="#规划" class="headerlink" title="规划"></a>规划</h3><table>
<thead>
<tr>
<th>IP</th>
<th>Hostname</th>
<th>配置</th>
<th>系统</th>
</tr>
</thead>
<tbody><tr>
<td>192.168.0.11</td>
<td>master1</td>
<td>4c8g</td>
<td>Centos7.6</td>
</tr>
<tr>
<td>192.168.0.12</td>
<td>node1</td>
<td>4c8g</td>
<td>Centos7.6</td>
</tr>
<tr>
<td>192.168.0.13</td>
<td>node2</td>
<td>4c8g</td>
<td>Centos7.6</td>
</tr>
</tbody></table>
<span id="more"></span>

<h3 id="hosts文件"><a href="#hosts文件" class="headerlink" title="hosts文件"></a>hosts文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat /etc/hosts</span><br><span class="line">192.168.0.11 master1</span><br><span class="line">192.168.0.12 node1</span><br><span class="line">192.168.0.13 node2</span><br></pre></td></tr></table></figure>

<h3 id="关闭防火墙及selinux"><a href="#关闭防火墙及selinux" class="headerlink" title="关闭防火墙及selinux"></a>关闭防火墙及selinux</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl <span class="built_in">disable</span> firewalld</span><br><span class="line"></span><br><span class="line">setenforce 0</span><br><span class="line">sed -i  s<span class="comment">#enforcing#disabled#g /etc/selinux/config</span></span><br></pre></td></tr></table></figure>

<h3 id="加载内核模块"><a href="#加载内核模块" class="headerlink" title="加载内核模块"></a>加载内核模块</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#由于开启内核 ipv4 转发需要加载 br_netfilter 模块，所以加载下该模块：</span></span><br><span class="line"></span><br><span class="line">modprobe br_netfilter</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.ip_forward = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.bridge.bridge-nf-call-ip6tables = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.bridge.bridge-nf-call-iptables = 1&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sysctl --system</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<h3 id="安装ipvs"><a href="#安装ipvs" class="headerlink" title="安装ipvs"></a>安装ipvs</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat &gt; /etc/sysconfig/modules/ipvs.modules &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">#!/bin/bash</span></span><br><span class="line"><span class="string">modprobe -- ip_vs</span></span><br><span class="line"><span class="string">modprobe -- ip_vs_rr</span></span><br><span class="line"><span class="string">modprobe -- ip_vs_wrr</span></span><br><span class="line"><span class="string">modprobe -- ip_vs_sh</span></span><br><span class="line"><span class="string">modprobe -- nf_conntrack_ipv4</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line">chmod 755 /etc/sysconfig/modules/ipvs.modules &amp;&amp; bash /etc/sysconfig/modules/ipvs.modules &amp;&amp; lsmod | grep -e ip_vs -e nf_conntrack_ipv4</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="安装必要软件"><a href="#安装必要软件" class="headerlink" title="安装必要软件"></a>安装必要软件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install ipset ipvsadm wget vim net-tools curl chrony  -y</span><br><span class="line"></span><br><span class="line"><span class="comment">#同步服务器时间</span></span><br><span class="line">systemctl <span class="built_in">enable</span> chronyd</span><br><span class="line">systemctl start chronyd</span><br><span class="line">chronyc sources</span><br><span class="line"></span><br><span class="line"><span class="comment">#关闭swap</span></span><br><span class="line"></span><br><span class="line">swapoff -a</span><br><span class="line"><span class="comment">#修改/etc/fstab文件，注释掉 SWAP 的自动挂载</span></span><br></pre></td></tr></table></figure>

<h3 id="安装Containerd"><a href="#安装Containerd" class="headerlink" title="安装Containerd"></a>安装Containerd</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#国内会被限制下载</span></span><br><span class="line"><span class="comment">#wget https://github.com/containerd/containerd/releases/download/v1.5.5/cri-containerd-cni-1.5.5-linux-amd64.tar.gz</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果有限制，也可以替换成下面的 URL 加速下载</span></span><br><span class="line">wget https://download.fastgit.org/containerd/containerd/releases/download/v1.5.5/cri-containerd-cni-1.5.5-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#直接将压缩包解压到系统的各个目录中</span></span><br><span class="line">tar -C / -xzf cri-containerd-cni-1.5.5-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#然后要将 /usr/local/bin 和 /usr/local/sbin 追加到 ~/.bashrc 文件的 PATH 环境变量中：</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export PATH=$PATH:/usr/local/bin:/usr/local/sbin&#x27;</span> &gt;&gt; /root/.bashrc</span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment">#命令生成一个默认的配置</span></span><br><span class="line">mkdir -p /etc/containerd</span><br><span class="line">containerd config default &gt; /etc/containerd/config.toml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#修改一:</span></span><br><span class="line">[plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.containerd.runtimes.runc.options]</span><br><span class="line">    SystemdCgroup = <span class="literal">true</span></span><br><span class="line"><span class="comment">#修改二:配置加速器国内版本</span></span><br><span class="line"> [plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>]</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment"># sandbox_image = &quot;k8s.gcr.io/pause:3.5&quot;</span></span><br><span class="line">  sandbox_image = <span class="string">&quot;registry.aliyuncs.com/k8sxio/pause:3.5&quot;</span></span><br><span class="line">  ...</span><br><span class="line">  [plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry]</span><br><span class="line">    [plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry.mirrors]</span><br><span class="line">      [plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry.mirrors.<span class="string">&quot;docker.io&quot;</span>]</span><br><span class="line">        endpoint = [<span class="string">&quot;https://bqr1dr1n.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">      [plugins.<span class="string">&quot;io.containerd.grpc.v1.cri&quot;</span>.registry.mirrors.<span class="string">&quot;k8s.gcr.io&quot;</span>]</span><br><span class="line">        endpoint = [<span class="string">&quot;https://registry.aliyuncs.com/k8sxio&quot;</span>]</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"><span class="comment">#启动</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> containerd --now</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看版本情况</span></span><br><span class="line">ctr version</span><br><span class="line">crictl version</span><br></pre></td></tr></table></figure>


<h3 id="下载kubeadm、kubelet"><a href="#下载kubeadm、kubelet" class="headerlink" title="下载kubeadm、kubelet"></a>下载kubeadm、kubelet</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#能上外网版本</span></span><br><span class="line">cat &lt;&lt;<span class="string">EOF &gt; /etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=1</span></span><br><span class="line"><span class="string">repo_gpgcheck=1</span></span><br><span class="line"><span class="string">gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg</span></span><br><span class="line"><span class="string">        https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#国内版本</span></span><br><span class="line">cat &lt;&lt;<span class="string">EOF &gt; /etc/yum.repos.d/kubernetes.repo</span></span><br><span class="line"><span class="string">[kubernetes]</span></span><br><span class="line"><span class="string">name=Kubernetes</span></span><br><span class="line"><span class="string">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span></span><br><span class="line"><span class="string">enabled=1</span></span><br><span class="line"><span class="string">gpgcheck=0</span></span><br><span class="line"><span class="string">repo_gpgcheck=0</span></span><br><span class="line"><span class="string">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span></span><br><span class="line"><span class="string">        http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#下载</span></span><br><span class="line"><span class="comment"># --disableexcludes 禁掉除了kubernetes之外的别的仓库</span></span><br><span class="line">yum makecache fast -y</span><br><span class="line">yum install -y kubelet-1.22.2 kubeadm-1.22.2 kubectl-1.22.2 --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看版本</span></span><br><span class="line">kubeadm version</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置开机自启</span></span><br><span class="line">systemctl <span class="built_in">enable</span> --now kubelet</span><br></pre></td></tr></table></figure>

<h3 id="初始化集群"><a href="#初始化集群" class="headerlink" title="初始化集群"></a>初始化集群</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm config <span class="built_in">print</span> init-defaults --component-configs KubeletConfiguration &gt; kubeadm.yaml</span><br></pre></td></tr></table></figure>
<p>kubeadm.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta3</span></span><br><span class="line"><span class="attr">bootstrapTokens:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">groups:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">system:bootstrappers:kubeadm:default-node-token</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">abcdef.0123456789abcdef</span></span><br><span class="line">  <span class="attr">ttl:</span> <span class="string">24h0m0s</span></span><br><span class="line">  <span class="attr">usages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">signing</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">authentication</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">InitConfiguration</span></span><br><span class="line"><span class="attr">localAPIEndpoint:</span></span><br><span class="line">  <span class="attr">advertiseAddress:</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.11</span>  <span class="comment"># 指定master节点内网IP</span></span><br><span class="line">  <span class="attr">bindPort:</span> <span class="number">6443</span></span><br><span class="line"><span class="attr">nodeRegistration:</span></span><br><span class="line">  <span class="attr">criSocket:</span> <span class="string">/run/containerd/containerd.sock</span>  <span class="comment"># 使用 containerd的Unix socket 地址</span></span><br><span class="line">  <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">master</span></span><br><span class="line">  <span class="attr">taints:</span>  <span class="comment"># 给master添加污点，master节点不能调度应用</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">effect:</span> <span class="string">&quot;NoSchedule&quot;</span></span><br><span class="line">    <span class="attr">key:</span> <span class="string">&quot;node-role.kubernetes.io/master&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeproxy.config.k8s.io/v1alpha1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">KubeProxyConfiguration</span></span><br><span class="line"><span class="attr">mode:</span> <span class="string">ipvs</span>  <span class="comment"># kube-proxy 模式</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiServer:</span></span><br><span class="line">  <span class="attr">timeoutForControlPlane:</span> <span class="string">4m0s</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubeadm.k8s.io/v1beta3</span></span><br><span class="line"><span class="attr">certificatesDir:</span> <span class="string">/etc/kubernetes/pki</span></span><br><span class="line"><span class="attr">clusterName:</span> <span class="string">kubernetes</span></span><br><span class="line"><span class="attr">controllerManager:</span> &#123;&#125;</span><br><span class="line"><span class="attr">dns:</span> &#123;&#125;</span><br><span class="line"><span class="attr">etcd:</span></span><br><span class="line">  <span class="attr">local:</span></span><br><span class="line">    <span class="attr">dataDir:</span> <span class="string">/var/lib/etcd</span></span><br><span class="line"><span class="attr">imageRepository:</span> <span class="string">registry.aliyuncs.com/k8sxio</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterConfiguration</span></span><br><span class="line"><span class="attr">kubernetesVersion:</span> <span class="number">1.22</span><span class="number">.2</span></span><br><span class="line"><span class="attr">networking:</span></span><br><span class="line">  <span class="attr">dnsDomain:</span> <span class="string">cluster.local</span></span><br><span class="line">  <span class="attr">serviceSubnet:</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.0</span><span class="string">/12</span></span><br><span class="line">  <span class="attr">podSubnet:</span> <span class="number">10.244</span><span class="number">.0</span><span class="number">.0</span><span class="string">/16</span>  <span class="comment"># 指定 pod 子网</span></span><br><span class="line"><span class="attr">scheduler:</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">kubelet.config.k8s.io/v1beta1</span></span><br><span class="line"><span class="attr">authentication:</span></span><br><span class="line">  <span class="attr">anonymous:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">webhook:</span></span><br><span class="line">    <span class="attr">cacheTTL:</span> <span class="string">0s</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">x509:</span></span><br><span class="line">    <span class="attr">clientCAFile:</span> <span class="string">/etc/kubernetes/pki/ca.crt</span></span><br><span class="line"><span class="attr">authorization:</span></span><br><span class="line">  <span class="attr">mode:</span> <span class="string">Webhook</span></span><br><span class="line">  <span class="attr">webhook:</span></span><br><span class="line">    <span class="attr">cacheAuthorizedTTL:</span> <span class="string">0s</span></span><br><span class="line">    <span class="attr">cacheUnauthorizedTTL:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">clusterDNS:</span></span><br><span class="line"><span class="bullet">-</span> <span class="number">10.96</span><span class="number">.0</span><span class="number">.10</span></span><br><span class="line"><span class="attr">clusterDomain:</span> <span class="string">cluster.local</span></span><br><span class="line"><span class="attr">cpuManagerReconcilePeriod:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">evictionPressureTransitionPeriod:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">fileCheckFrequency:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">healthzBindAddress:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br><span class="line"><span class="attr">healthzPort:</span> <span class="number">10248</span></span><br><span class="line"><span class="attr">httpCheckFrequency:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">imageMinimumGCAge:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">KubeletConfiguration</span></span><br><span class="line"><span class="attr">cgroupDriver:</span> <span class="string">systemd</span>  <span class="comment"># 配置 cgroup driver</span></span><br><span class="line"><span class="attr">logging:</span> &#123;&#125;</span><br><span class="line"><span class="attr">memorySwap:</span> &#123;&#125;</span><br><span class="line"><span class="attr">nodeStatusReportFrequency:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">nodeStatusUpdateFrequency:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">rotateCertificates:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">runtimeRequestTimeout:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">shutdownGracePeriod:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">shutdownGracePeriodCriticalPods:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">staticPodPath:</span> <span class="string">/etc/kubernetes/manifests</span></span><br><span class="line"><span class="attr">streamingConnectionIdleTimeout:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">syncFrequency:</span> <span class="string">0s</span></span><br><span class="line"><span class="attr">volumeStatsAggPeriod:</span> <span class="string">0s</span></span><br></pre></td></tr></table></figure>

<h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#只下载镜像</span></span><br><span class="line">kubeadm config images pull --config kubeadm.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment">#上面coredns镜像有问题需要单独拉</span></span><br><span class="line">ctr -n k8s.io i pull docker.io/coredns/coredns:1.8.4</span><br><span class="line"></span><br><span class="line"><span class="comment">#拉下来后进行改名</span></span><br><span class="line">ctr -n k8s.io i tag docker.io/coredns/coredns:1.8.4 registry.aliyuncs.com/k8sxio/coredns:v1.8.4</span><br></pre></td></tr></table></figure>

<h3 id="初始化集群-1"><a href="#初始化集群-1" class="headerlink" title="初始化集群"></a>初始化集群</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm init --config kubeadm.yaml</span><br><span class="line"></span><br><span class="line"> mkdir -p <span class="variable">$HOME</span>/.kube</span><br><span class="line"> sudo cp -i /etc/kubernetes/admin.conf <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"> sudo chown $(id -u):$(id -g) <span class="variable">$HOME</span>/.kube/config</span><br><span class="line"> </span><br><span class="line"> <span class="comment">#在初始化完成后会出现其他节点加入进来的命令</span></span><br><span class="line"> kubeadm join 192.168.31.31:6443 --token abcdef.0123456789abcdef \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:ca0c87226c69309d7779096c15b6a41e14b077baf4650bfdb6f9d3178d4da645</span><br></pre></td></tr></table></figure>

<h3 id="查看是否初始化成功"><a href="#查看是否初始化成功" class="headerlink" title="查看是否初始化成功"></a>查看是否初始化成功</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>

<h3 id="安装flannel"><a href="#安装flannel" class="headerlink" title="安装flannel"></a>安装flannel</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br><span class="line"><span class="comment"># 如果有节点是多网卡，则需要在资源清单文件中指定内网网卡</span></span><br><span class="line"><span class="comment"># 搜索到名为 kube-flannel-ds 的 DaemonSet，在kube-flannel容器下面</span></span><br><span class="line">vim kube-flannel.yml</span><br><span class="line">......</span><br><span class="line">containers:</span><br><span class="line">- name: kube-flannel</span><br><span class="line">  image: quay.io/coreos/flannel:v0.15.0</span><br><span class="line">  <span class="built_in">command</span>:</span><br><span class="line">  - /opt/bin/flanneld</span><br><span class="line">  args:</span><br><span class="line">  - --ip-masq</span><br><span class="line">  - --kube-subnet-mgr</span><br><span class="line">  - --iface=eth0  <span class="comment"># 如果是多网卡的话，指定内网网卡的名称</span></span><br><span class="line">......</span><br><span class="line">kubectl apply -f kube-flannel.yml  <span class="comment"># 安装 flannel 网络插件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看flannel情况</span></span><br><span class="line">kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure>

<h3 id="Dashboard安装"><a href="#Dashboard安装" class="headerlink" title="Dashboard安装"></a>Dashboard安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推荐使用下面这种方式</span></span><br><span class="line">wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.3.1/aio/deploy/recommended.yaml</span><br><span class="line">➜  ~ vi recommended.yaml</span><br><span class="line"><span class="comment"># 修改Service为NodePort类型</span></span><br><span class="line">......</span><br><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">    - port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  <span class="built_in">type</span>: NodePort  <span class="comment"># 加上type=NodePort变成NodePort类型的服务</span></span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">kubectl apply -f recommended.yaml</span><br><span class="line"></span><br><span class="line">kubectl get pods -n kubernetes-dashboard -o wide</span><br></pre></td></tr></table></figure>

<h3 id="更换cni网络"><a href="#更换cni网络" class="headerlink" title="更换cni网络"></a>更换cni网络</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#每个节点都需要操作</span></span><br><span class="line">mv /etc/cni/net.d/10-containerd-net.conflist /etc/cni/net.d/10-containerd-net.conflist.bak</span><br><span class="line"></span><br><span class="line">ifconfig cni0 down &amp;&amp; ip link delete cni0</span><br><span class="line"></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"></span><br><span class="line">systemctl restart containerd kubelet</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除coredns达到重启目的</span></span><br><span class="line">kubectl  -n kube-system delete pod coredns-7568f67dbd-9wcv4</span><br><span class="line"></span><br><span class="line"><span class="comment">#重启dashboard</span></span><br><span class="line">kubectl delete -f recommended.yaml</span><br><span class="line">kubectl apply -f recommended.yaml</span><br></pre></td></tr></table></figure>

<h3 id="进入Dashboard"><a href="#进入Dashboard" class="headerlink" title="进入Dashboard"></a>进入Dashboard</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#查看dashboard的端口</span></span><br><span class="line">kubectl get svc -n kubernetes-dashboard</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建权限</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br></pre></td></tr></table></figure>

<p>创建并生成token</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f admin.yaml</span><br><span class="line"></span><br><span class="line">kubectl get secret -n kubernetes-dashboard|grep admin-token</span><br><span class="line"><span class="comment">#得到一个以 admin-token-xxx 的一个</span></span><br><span class="line"></span><br><span class="line">kubectl get secret &#123;admin-token-xxx&#125; -o jsonpath=&#123;.data.token&#125; -n kubernetes-dashboard |base64 -d</span><br><span class="line"><span class="comment"># 会生成一串很长的base64后的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#谷歌浏览器访问的时候会打不开</span></span><br><span class="line"><span class="comment">#解决方法一: 更换火狐浏览器</span></span><br><span class="line"><span class="comment">#解决方法二: 谷歌浏览器非安全页面,空白处输入thisisunsafe即可</span></span><br></pre></td></tr></table></figure>

<h3 id="kubectl命令补全"><a href="#kubectl命令补全" class="headerlink" title="kubectl命令补全"></a>kubectl命令补全</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install -y bash-completion*</span><br><span class="line"><span class="built_in">source</span> &lt;(kubectl completion bash)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;source &lt;(kubectl completion bash)&quot;</span> &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>

<h3 id="master污点"><a href="#master污点" class="headerlink" title="master污点"></a>master污点</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#去除污点变成可调度</span></span><br><span class="line">kubectl taint node master node-role.kubernetes.io/master-</span><br><span class="line"></span><br><span class="line"><span class="comment">#打上污点补课调度</span></span><br><span class="line">kubectl taint node master node-role.kubernetes.io/master=<span class="string">&quot;&quot;</span>:NoSchedule</span><br></pre></td></tr></table></figure>

<h3 id="剔除节点并重新加入"><a href="#剔除节点并重新加入" class="headerlink" title="剔除节点并重新加入"></a>剔除节点并重新加入</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">###简易版本###</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##master节点上操作</span></span><br><span class="line"><span class="comment">#驱逐节点上的pod</span></span><br><span class="line">kubectl drain node3 --delete-local-data --ignore-daemonsets --force</span><br><span class="line"></span><br><span class="line"><span class="comment">#主节点上删除node节点</span></span><br><span class="line">kubectl  delete nodes node3</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看加入集群命令</span></span><br><span class="line">kubeadm token create --print-join-command</span><br><span class="line"></span><br><span class="line"><span class="comment">##node3节点上操作</span></span><br><span class="line"><span class="comment">#在node3上重置</span></span><br><span class="line">kubeadm reset</span><br><span class="line"></span><br><span class="line"><span class="comment">#得到上面加入集群的命令重新加入</span></span><br><span class="line">kubeadm join  xxx</span><br></pre></td></tr></table></figure>


<h3 id="kubectl远程"><a href="#kubectl远程" class="headerlink" title="kubectl远程"></a>kubectl远程</h3><p>mac(zsh下)操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">brew install kubectl</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;source &lt;(kubectl completion zsh)&#x27;</span> &gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line">mkdir ~/.kube</span><br><span class="line"></span><br><span class="line"><span class="comment">#将k8s集群下的/etc/kubernetes/admin.conf拷贝到本机的~/.kube/config</span></span><br><span class="line"><span class="comment">#在k8s集群master上查看，DNS 区域就是包含的校验的域名，后面还有 IP</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> /etc/kubernetes/pki/apiserver.crt -noout -text</span><br><span class="line">...</span><br><span class="line">DNS:kubernetes, DNS:kubernetes.default, DNS:kubernetes.default.svc, DNS:kubernetes.default.svc.cluster.local, DNS:master1, IP Address:10.96.0.1, IP Address:192.168.0.21</span><br><span class="line">    Signature Algorithm: sha256WithRSAEncryption</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">#本地，将k8s的master外网IP和上面得到的DNS后面的映射信息写入到/etc/hosts中</span></span><br><span class="line"><span class="comment">#将本地~/.kube/config中  server:6443 改成写入到/etc/hosts中的DNS映射信息</span></span><br><span class="line">cat ~/.kube/config</span><br><span class="line">...</span><br><span class="line">server: https://master1:6443  <span class="comment"># 这里如果直接用公网IP不行</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cat /etc/hosts </span><br><span class="line">139.155.237.70 master1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这个时候就可以愉快的本地操作k8s集群了</span><br></pre></td></tr></table></figure>
<p>brew安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://zhuanlan.zhihu.com/p/111014448</span><br><span class="line"></span><br><span class="line"><span class="comment">#全部国内源，下载速度快</span></span><br><span class="line"><span class="comment">#常规安装</span></span><br><span class="line">/bin/zsh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#急速安装</span></span><br><span class="line">/bin/zsh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/Homebrew.sh)</span>&quot;</span> speed</span><br><span class="line"></span><br><span class="line"><span class="comment">#卸载脚本</span></span><br><span class="line">/bin/zsh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/cunkai/HomebrewCN/raw/master/HomebrewUninstall.sh)</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#项目地址</span></span><br><span class="line">https://gitee.com/cunkai/HomebrewCN/blob/master/error.md</span><br></pre></td></tr></table></figure>



<p>文档整理:<a href="https://www.qikqiak.com/k3s/">https://www.qikqiak.com/k3s/</a></p>
]]></content>
      <categories>
        <category>Kuberneters</category>
      </categories>
      <tags>
        <tag>Kuberneters</tag>
        <tag>kubeadm</tag>
      </tags>
  </entry>
  <entry>
    <title>python-流程控制</title>
    <url>/26ba1150.html</url>
    <content><![CDATA[<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><h3 id="1-定义及说明"><a href="#1-定义及说明" class="headerlink" title="1. 定义及说明"></a>1. 定义及说明</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">流程控制即控制事物的执行过程</span><br><span class="line">任何使用执行流程只有三种情况:</span><br><span class="line">  <span class="number">1.</span>顺序结构  <span class="comment"># 自上而下依次运行</span></span><br><span class="line">  <span class="number">2.</span>分支结构  <span class="comment"># 在运行过程中根据条件的不同可能会执行不同的流程</span></span><br><span class="line">  <span class="number">3.</span>循环结构  <span class="comment"># 在运行过程中有些代码需要反复执行</span></span><br></pre></td></tr></table></figure>
<span id="more"></span>


<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>条件都会转成布尔值  从而决定子代码是否执行</span><br><span class="line"><span class="number">2.</span>在python中 使用缩进来表示代码的从属关系</span><br><span class="line"><span class="number">3.</span>并不是所有的代码都可以拥有子代码</span><br><span class="line"><span class="number">4.</span>同属于某个代码的多行子代码 必须要保持相同的缩进量</span><br><span class="line">	在python中推荐使用四个空格来缩进</span><br><span class="line">ps:小技巧 上一行代码的结尾如果是冒号 那么下一行代码必缩进</span><br></pre></td></tr></table></figure>

<h3 id="2-顺序结构"><a href="#2-顺序结构" class="headerlink" title="2.  顺序结构"></a>2.  顺序结构</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">从上到下依次执行</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/T8iFeL.png" alt="T8iFeL"></p>
<h3 id="3-分支结构"><a href="#3-分支结构" class="headerlink" title="3. 分支结构"></a>3. 分支结构</h3><h4 id="3-1-if基本使用"><a href="#3-1-if基本使用" class="headerlink" title="3.1 if基本使用"></a>3.1 if基本使用</h4><h5 id="3-1-1-if单分支"><a href="#3-1-1-if单分支" class="headerlink" title="3.1.1 if单分支"></a>3.1.1 if单分支</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">格式:</span><br><span class="line">  <span class="keyword">if</span> 条件:</span><br><span class="line">    条件成立之后执行的子代码块</span><br><span class="line">eg:</span><br><span class="line">  age = <span class="number">20</span></span><br><span class="line">  <span class="keyword">if</span> age &lt; <span class="number">28</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;小姐姐好&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/sizMEI.png" alt="sizMEI"></p>
<h5 id="3-1-2-if-else使用"><a href="#3-1-2-if-else使用" class="headerlink" title="3.1.2 if-else使用"></a>3.1.2 if-else使用</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">格式:</span><br><span class="line">  <span class="keyword">if</span> 条件:</span><br><span class="line">    条件成立之后执行的子代码块</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    条件不成立执行的子代码块</span><br><span class="line">    </span><br><span class="line"> <span class="comment"># if与else连用情况下,两者子代码永远只会执行一个</span></span><br><span class="line">eg:</span><br><span class="line">  age = <span class="number">20</span></span><br><span class="line">  <span class="keyword">if</span> age &lt; <span class="number">28</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;小姐姐好&#x27;</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;认错人了&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/alOv1n.png" alt="alOv1n"></p>
<h5 id="3-1-3-if-elif-else使用"><a href="#3-1-3-if-elif-else使用" class="headerlink" title="3.1.3 if-elif-else使用"></a>3.1.3 if-elif-else使用</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">格式:</span><br><span class="line">  <span class="keyword">if</span> 条件<span class="number">1</span>:</span><br><span class="line">    条件<span class="number">1</span>成立之后执行的子代码块</span><br><span class="line">  <span class="keyword">elif</span> 条件<span class="number">2</span>:</span><br><span class="line">    条件<span class="number">1</span>不成立 条件<span class="number">2</span>成立之后执行的子代码块</span><br><span class="line">  <span class="keyword">elif</span> 条件<span class="number">3</span>:</span><br><span class="line">    条件<span class="number">1</span>和<span class="number">2</span>都不成立 条件<span class="number">3</span>成立之后执行的子代码块</span><br><span class="line">  ...  </span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">   上述条件都不成立 执行的子代码块</span><br><span class="line">  <span class="comment"># elif 可以有多个,三者连用也只会执行其中一个子代码块</span></span><br><span class="line">eg:</span><br><span class="line">    score = <span class="number">79</span></span><br><span class="line">    <span class="keyword">if</span> score &gt; <span class="number">90</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;优秀&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> score &gt; <span class="number">80</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;良好&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> score &gt; <span class="number">70</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;一般&#x27;</span>)</span><br><span class="line">    <span class="keyword">elif</span> score <span class="number">78</span>&gt; <span class="number">60</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;及格&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;挂科重修&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/GYHxdd.png" alt="GYHxdd"></p>
<h4 id="3-2-if嵌套使用"><a href="#3-2-if嵌套使用" class="headerlink" title="3.2 if嵌套使用"></a>3.2 if嵌套使用</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">格式:</span><br><span class="line"><span class="keyword">if</span> 条件 <span class="number">1</span>:</span><br><span class="line">	条件 <span class="number">1</span> 成立执行的代码</span><br><span class="line">	<span class="keyword">if</span> 条件 <span class="number">2</span>:</span><br><span class="line">		条件 <span class="number">2</span> 成立执行的代码</span><br><span class="line">eg:</span><br><span class="line">  age = <span class="number">26</span></span><br><span class="line">  height = <span class="number">165</span></span><br><span class="line">  weight = <span class="number">99</span></span><br><span class="line">  is_beautiful = <span class="literal">True</span></span><br><span class="line">  is_success = <span class="literal">True</span></span><br><span class="line">  <span class="keyword">if</span> age &lt; <span class="number">28</span> <span class="keyword">and</span> height &gt; <span class="number">160</span> <span class="keyword">and</span> weight &lt; <span class="number">100</span> <span class="keyword">and</span> is_beautiful:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;小姐姐能否加个微信&#x27;</span>)</span><br><span class="line">      <span class="comment"># 判断小姐姐是否会给微信</span></span><br><span class="line">      <span class="keyword">if</span> is_success:</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&#x27;吃饭 看电影 天黑了...&#x27;</span>)</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&#x27;去你妹的 变态!&#x27;</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">      <span class="built_in">print</span>(<span class="string">&#x27;可惜了&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/voz9xF.png" alt="voz9xF"></p>
<h4 id="3-3-小练习"><a href="#3-3-小练习" class="headerlink" title="3.3 小练习"></a>3.3 小练习</h4><p>1.编写一个用户登录功能 ,用户名是jaso, 密码是123,用户如果输入正确则打印来宾三位,否则登录失败</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义默认用户名和密码</span></span><br><span class="line">NAME = <span class="string">&#x27;jason&#x27;</span></span><br><span class="line">PASSWD = <span class="number">123</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将用户输入的用户名和密码传给username和passwd</span></span><br><span class="line">username = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名:&quot;</span>)</span><br><span class="line">passwd = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入密码:&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断用户输入的用户名和密码是否和定义默认的用户名密码相同</span></span><br><span class="line"><span class="keyword">if</span> NAME == username <span class="keyword">and</span> PASSWD == passwd:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;来宾三位&quot;</span>)  <span class="comment"># 如果相同,则打印来宾三位</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;登录失败&quot;</span>)  <span class="comment"># 其中一个不同都会显示登录失败</span></span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/Ma5Orf.png" alt="Ma5Orf"></p>
<p>2.根据用户名的不同打印不同的用户身份<br>jason管理员 tony安保人员 kevin财务 jack销售 其他普通员工</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将用户输入的用户名给变量username,然后判断</span></span><br><span class="line">username = <span class="built_in">input</span>(<span class="string">&quot;请输入用户名:&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> username == <span class="string">&quot;jason&quot;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;管理员&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> username == <span class="string">&#x27;tony&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;安保人员&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> username == <span class="string">&#x27;kevin&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;财务&quot;</span>)</span><br><span class="line"><span class="keyword">elif</span> username == <span class="string">&#x27;jack&#x27;</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;销售&quot;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;普通员工&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/eqPxPs.png" alt="eqPxPs"></p>
<h3 id="4-循环结构"><a href="#4-循环结构" class="headerlink" title="4. 循环结构"></a>4. 循环结构</h3><h4 id="4-1-while循环"><a href="#4-1-while循环" class="headerlink" title="4.1 while循环"></a>4.1 while循环</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">格式:</span><br><span class="line">  <span class="keyword">while</span> 条件:</span><br><span class="line">    条件成立之后循环执行的子代码</span><br><span class="line">eg:</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      <span class="comment"># 1.获取用户输入的用户名和密码</span></span><br><span class="line">      username = <span class="built_in">input</span>(<span class="string">&#x27;username&gt;&gt;&gt;:&#x27;</span>)</span><br><span class="line">      password = <span class="built_in">input</span>(<span class="string">&#x27;password&gt;&gt;&gt;:&#x27;</span>)</span><br><span class="line">      <span class="comment"># 2.判断用户名和密码是否正确</span></span><br><span class="line">      <span class="keyword">if</span> username == <span class="string">&#x27;jason&#x27;</span> <span class="keyword">and</span> password == <span class="string">&#x27;123&#x27;</span>:</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&#x27;来宾三位&#x27;</span>)</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&#x27;登录失败&#x27;</span>)</span><br><span class="line"> <span class="comment"># 含义:这段代码执行后,当用户输入用户名密码进行判断是否是jason和123,不管用户输入对错与否,都会一直执行下去,因为True一直成立,是个死循环</span></span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/7bpWCy.png" alt="7bpWCy"></p>
<h4 id="4-2-while-break"><a href="#4-2-while-break" class="headerlink" title="4.2 while-break"></a>4.2 while-break</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">break</span>:结束本层循环</span><br><span class="line">eg:</span><br><span class="line">  <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">     <span class="comment"># 1.获取用户输入的用户名和密码</span></span><br><span class="line">     username = <span class="built_in">input</span>(<span class="string">&#x27;username&gt;&gt;&gt;:&#x27;</span>)</span><br><span class="line">     password = <span class="built_in">input</span>(<span class="string">&#x27;password&gt;&gt;&gt;:&#x27;</span>)</span><br><span class="line">     <span class="comment"># 2.判断用户名和密码是否正确</span></span><br><span class="line">     <span class="keyword">if</span> username == <span class="string">&#x27;jason&#x27;</span> <span class="keyword">and</span> password == <span class="string">&#x27;123&#x27;</span>:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&#x27;来宾三位&#x27;</span>)</span><br><span class="line">         <span class="keyword">break</span>  <span class="comment"># 直接跳出本层循环</span></span><br><span class="line">     <span class="keyword">else</span>:</span><br><span class="line">         <span class="built_in">print</span>(<span class="string">&#x27;登录失败&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="4-3-全局标志位"><a href="#4-3-全局标志位" class="headerlink" title="4.3 全局标志位"></a>4.3 全局标志位</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 标志位的使用</span></span><br><span class="line">flag = <span class="literal">True</span></span><br><span class="line"><span class="keyword">while</span> flag:</span><br><span class="line">    <span class="comment"># 1.获取用户输入的用户名和密码</span></span><br><span class="line">    username = <span class="built_in">input</span>(<span class="string">&#x27;username&gt;&gt;&gt;:&#x27;</span>)</span><br><span class="line">    password = <span class="built_in">input</span>(<span class="string">&#x27;password&gt;&gt;&gt;:&#x27;</span>)</span><br><span class="line">    <span class="comment"># 2.判断用户名和密码是否正确</span></span><br><span class="line">    <span class="keyword">if</span> username == <span class="string">&#x27;jason&#x27;</span> <span class="keyword">and</span> password == <span class="string">&#x27;123&#x27;</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;来宾三位&#x27;</span>)</span><br><span class="line">        <span class="keyword">while</span> flag:</span><br><span class="line">            cmd = <span class="built_in">input</span>(<span class="string">&#x27;请输入您的指令&gt;&gt;&gt;:&#x27;</span>)</span><br><span class="line">            <span class="comment"># 判断用户是否想退出</span></span><br><span class="line">            <span class="keyword">if</span> cmd == <span class="string">&#x27;q&#x27;</span>:</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;正在执行您的指令:%s&#x27;</span> % cmd)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;去你妹的 没钱滚蛋&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="5-练习"><a href="#5-练习" class="headerlink" title="5. 练习"></a>5. 练习</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">猜年龄的游戏</span><br><span class="line">	<span class="number">1.</span>要求<span class="number">1</span></span><br><span class="line">    	用户可以有三次猜错的机会 如果过程中猜对了直接退出</span><br><span class="line">  <span class="number">2.</span>要求<span class="number">2</span></span><br><span class="line">    	三次机会用完之后提示用户是否继续尝试 如果是则再给三次机会 如果否则直接结束</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 数据类型转换提示</span></span><br><span class="line">		age = <span class="built_in">input</span>(<span class="string">&#x27;age&gt;&gt;&gt;:&#x27;</span>)</span><br><span class="line">    real_age = <span class="number">18</span></span><br><span class="line">    <span class="comment"># 将字符串的数字转换成整型</span></span><br><span class="line">    age = <span class="built_in">int</span>(age)</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要求1:</span></span><br><span class="line">AGE = <span class="number">26</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">3</span>:</span><br><span class="line">    age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你猜的年龄:&quot;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> age == AGE:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;猜对了,年龄是%s&quot;</span> % age)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;猜错了&quot;</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 要求2:</span></span><br><span class="line">AGE = <span class="number">26</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">3</span>:</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">    age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入你猜的年龄: &quot;</span>))</span><br><span class="line">    <span class="keyword">if</span> age == AGE:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;猜对了,年龄是%s&quot;</span> % age)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">elif</span> count == <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            again = <span class="built_in">input</span>(<span class="string">&quot;已经答错三次,是否继续三次Y/N: &quot;</span>)</span><br><span class="line">            <span class="keyword">if</span> again == <span class="string">&#x27;Y&#x27;</span>:</span><br><span class="line">                count = <span class="number">0</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">elif</span> again == <span class="string">&#x27;N&#x27;</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;输入正确的字符&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;答错了请继续!&quot;</span>)</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础-02</title>
    <url>/43f82467.html</url>
    <content><![CDATA[<h2 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h2><h3 id="1-1-字符串str"><a href="#1-1-字符串str" class="headerlink" title="1.1 字符串str"></a>1.1 字符串str</h3><span id="more"></span>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">作用:主要记录描述性质的数据，例如姓名、地址、邮箱......</span><br><span class="line"></span><br><span class="line">定义:</span><br><span class="line">  方式<span class="number">1</span>:使用单引号,eg:</span><br><span class="line">      name = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">  方式<span class="number">2</span>:使用双引号,eg:</span><br><span class="line">      name = <span class="string">&quot;hello&quot;</span></span><br><span class="line">  方式<span class="number">3</span>:使用三引号,eg:</span><br><span class="line">      name = <span class="string">&#x27;&#x27;&#x27;hello&#x27;&#x27;&#x27;</span></span><br><span class="line">  方式<span class="number">4</span>:使用三引号,eg:</span><br><span class="line">      name = <span class="string">&quot;&quot;&quot;hello&quot;&quot;&quot;</span></span><br><span class="line">      </span><br><span class="line">  类型查看:</span><br><span class="line">    str_a = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">		<span class="built_in">print</span>(<span class="built_in">type</span>(str_a))</span><br><span class="line">    结果:&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;</span></span><br><span class="line"><span class="class">      </span></span><br><span class="line"><span class="class">  三引号说明:</span></span><br><span class="line">    <span class="number">1.</span>两个三引号都支持换行</span><br><span class="line">    <span class="number">2.</span>定义字符的多种方式原因</span><br><span class="line">    	<span class="built_in">print</span>(<span class="string">&#x27;鲁迅说：&#x27;</span>我没说过这句话<span class="string">&#x27;&#x27;</span>)  <span class="comment"># 这语句就是错误的了</span></span><br><span class="line">			<span class="built_in">print</span>(<span class="string">&#x27;鲁迅说：&quot;我没说过这句话&quot;&#x27;</span>)  <span class="comment"># 这条语句就正确了</span></span><br><span class="line">    <span class="number">3.</span><span class="built_in">print</span>(<span class="string">&#x27;It\&#x27;s a dog&#x27;</span>)  <span class="comment"># 可以用\ 进行转义为本身含义</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-列表list"><a href="#1-2-列表list" class="headerlink" title="1.2 列表list"></a>1.2 列表list</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">作用:能够存储多个数据并且可以方便的取出任意个数</span><br><span class="line">特征:中括号括起来,内部可以存放多个元素,元素与元素之间用逗号隔开,元素可以是任意类型</span><br><span class="line">eg:</span><br><span class="line">  first_list = [<span class="string">&quot;hello&quot;</span>, <span class="string">&quot;world&quot;</span>, <span class="number">123</span>, <span class="number">12344</span>, [<span class="string">&quot;test&quot;</span>, <span class="number">555</span>, [<span class="string">&quot;two&quot;</span>, <span class="string">&quot;results&quot;</span>, <span class="number">777</span>]]]</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(first_list))    <span class="comment"># 结果:&lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line">索引取值(从<span class="number">0</span>开始的连续数字)</span><br><span class="line">  <span class="built_in">print</span>(first_list[<span class="number">1</span>])  <span class="comment"># world</span></span><br><span class="line">  <span class="built_in">print</span>(first_list[<span class="number">3</span>])  <span class="comment"># 12344</span></span><br><span class="line">  </span><br><span class="line">取值练习:</span><br><span class="line">  取例中的results</span><br><span class="line">  方法一:逐一提取</span><br><span class="line">    l1 = first_list[<span class="number">4</span>]  <span class="comment"># [&#x27;test&#x27;, 555, [&#x27;two&#x27;, &#x27;results&#x27;, 777]]</span></span><br><span class="line">    l2 = l1[<span class="number">2</span>]  <span class="comment"># [&#x27;two&#x27;, &#x27;results&#x27;, 777]</span></span><br><span class="line">    l3 = l2[<span class="number">1</span>]  <span class="comment"># results</span></span><br><span class="line">    <span class="built_in">print</span>(l3)</span><br><span class="line">  方法二:熟悉之后一步到位</span><br><span class="line">    <span class="built_in">print</span>(first_list[<span class="number">4</span>][<span class="number">2</span>][<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<h3 id="1-3-字典dict"><a href="#1-3-字典dict" class="headerlink" title="1.3 字典dict"></a>1.3 字典dict</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">作用:能够更加精准的存储数据</span><br><span class="line">定义:大括号括起来,内存可以存放多个元素,元素与元素之间逗号隔开,元素是K:V键值对的形式</span><br><span class="line">    K是对数据的描述,V是所存的数据</span><br><span class="line">eg:</span><br><span class="line">  first_dict = &#123;</span><br><span class="line">    <span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;passwd&#x27;</span>: <span class="string">&#x27;123456&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;hostname&#x27;</span>: <span class="string">&#x27;node1&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(first_dict))  <span class="comment"># &lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line">取值:</span><br><span class="line">  <span class="number">1.</span>字典无法索取值</span><br><span class="line">  <span class="number">2.</span>字典取值需要借助K,eg:</span><br><span class="line">    <span class="built_in">print</span>(first_dict[<span class="string">&#x27;username&#x27;</span>])  <span class="comment"># root</span></span><br><span class="line">    </span><br><span class="line">取值练习:</span><br><span class="line">info = &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;addr&#x27;</span>: [<span class="string">&#x27;安徽&#x27;</span>, <span class="string">&#x27;芜湖&#x27;</span>, &#123;<span class="string">&#x27;国家&#x27;</span>: <span class="string">&#x27;中国&#x27;</span>, <span class="string">&#x27;编号&#x27;</span>: [<span class="number">11</span>, <span class="number">22</span>, <span class="string">&#x27;中国最牛逼&#x27;</span>]&#125;]&#125;</span><br><span class="line">方式一:</span><br><span class="line">    d1 = info[<span class="string">&#x27;addr&#x27;</span>]  <span class="comment"># &#x27;安徽&#x27;, &#x27;芜湖&#x27;, &#123;&#x27;国家&#x27;: &#x27;中国&#x27;, &#x27;编号&#x27;: [11, 22, &#x27;中国最牛逼&#x27;]&#125;]</span></span><br><span class="line">  	d2 = d1[<span class="number">2</span>]  <span class="comment"># &#123;&#x27;国家&#x27;: &#x27;中国&#x27;, &#x27;编号&#x27;: [11, 22, &#x27;中国最牛逼&#x27;]&#125;</span></span><br><span class="line">    d3 = d2[<span class="string">&#x27;编号&#x27;</span>]  <span class="comment"># [11, 22, &#x27;中国最牛逼&#x27;]</span></span><br><span class="line">    d4 = d3[<span class="number">2</span>]  <span class="comment"># 中国最牛逼</span></span><br><span class="line">方式二:</span><br><span class="line">		<span class="built_in">print</span>(info[<span class="string">&#x27;addr&#x27;</span>][<span class="number">2</span>][<span class="string">&#x27;编号&#x27;</span>][<span class="number">2</span>])</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="1-4-布尔值-bool"><a href="#1-4-布尔值-bool" class="headerlink" title="1.4 布尔值 bool"></a>1.4 布尔值 bool</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">作用:用于判断事物的对错</span><br><span class="line">定义:</span><br><span class="line">  <span class="literal">True</span>  <span class="comment"># 正确的</span></span><br><span class="line">  <span class="literal">False</span>  <span class="comment"># 错误的</span></span><br><span class="line">  <span class="comment">#ps: 首字母大写</span></span><br><span class="line">  </span><br><span class="line">布尔变量的命名一般采用<span class="keyword">is</span>开头,eg:</span><br><span class="line">  is_right = <span class="literal">True</span></span><br><span class="line">  is_delete = <span class="literal">False</span></span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(is_right))  <span class="comment"># &lt;class &#x27;bool&#x27;&gt;</span></span><br><span class="line">数据类型转换为布尔值的注意点:</span><br><span class="line">  <span class="number">0</span>, <span class="literal">None</span>, <span class="string">&#x27;&#x27;</span>, [], &#123;&#125;</span><br><span class="line">以上转换为布尔值的<span class="literal">False</span>,其他情况都是<span class="literal">True</span></span><br><span class="line"></span><br><span class="line">其他:生活中数据存储的销户,很大概率并没有删除用户的数据,而是通过数据的唯一标识进行过滤掉,从而对外显示已删除</span><br></pre></td></tr></table></figure>

<h3 id="1-5-元组tuple"><a href="#1-5-元组tuple" class="headerlink" title="1.5 元组tuple"></a>1.5 元组tuple</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">作用:与列表几乎一致,内部可以存放多个元素(可以看成是不可变的列表)</span><br><span class="line">定义:用小括号括起来,存放多个元素,元素与元素之间逗号隔开,元素不支持修改</span><br><span class="line">eg:</span><br><span class="line">  t = (<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>)  </span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(t))  <span class="comment"># &lt;class &#x27;tuple&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="1-6-集合set"><a href="#1-6-集合set" class="headerlink" title="1.6 集合set"></a>1.6 集合set</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">作用:去重和关系运算</span><br><span class="line">定义:用大括号括起来,内存可以存放多个元素,元素与元素之间逗号隔开,元素不是K:V键值对</span><br><span class="line">eg:</span><br><span class="line">  s = &#123;<span class="number">11</span>, <span class="number">22</span>, <span class="number">33</span>, <span class="number">44</span>&#125;</span><br><span class="line">	<span class="built_in">print</span>(<span class="built_in">type</span>(s))  <span class="comment"># &lt;class &#x27;set&#x27;&gt;</span></span><br><span class="line">  </span><br><span class="line">定义空集合</span><br><span class="line">  s = <span class="built_in">set</span>()</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(s))  <span class="comment"># &lt;class &#x27;set&#x27;&gt;</span></span><br><span class="line">  </span><br><span class="line">默认情况下使用&#123;&#125;是空字典</span><br><span class="line">  s = &#123;&#125;</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(s))  <span class="comment"># &lt;class &#x27;dict&#x27;&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2、输入与输出"><a href="#2、输入与输出" class="headerlink" title="2、输入与输出"></a>2、输入与输出</h2><h3 id="2-1-输入"><a href="#2-1-输入" class="headerlink" title="2.1 输入"></a>2.1 输入</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输入:程序接收用户输入的数据功能,使用内置函数<span class="built_in">input</span>()</span><br><span class="line">  <span class="built_in">input</span>()</span><br><span class="line">  	<span class="number">1.</span>接收到的任意输入的数据都会处理为字符串类型</span><br><span class="line">    <span class="number">2.</span>程序执行到<span class="built_in">input</span>时会等待输入数据才开始进行下一步操作</span><br><span class="line">eg: </span><br><span class="line">  username = <span class="built_in">input</span>(<span class="string">&quot;请输入你的名字:&quot;</span>)</span><br><span class="line">  age = <span class="built_in">input</span>(<span class="string">&quot;请输入你的年龄:&quot;</span>)</span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(username))		<span class="comment"># 查看username的数据类型</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="built_in">type</span>(age))  <span class="comment"># 查看age的数据类型</span></span><br><span class="line">  <span class="built_in">print</span>(username, age)  <span class="comment"># 将输入的数据进行打印</span></span><br><span class="line">  </span><br><span class="line">res:</span><br><span class="line">  请输入你的名字:tom  <span class="comment"># 输入的tom</span></span><br><span class="line">  请输入你的年龄:<span class="number">18</span>   <span class="comment"># 输入的18</span></span><br><span class="line">  &lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">str</span>&#x27;&gt;  # 显示<span class="title">username</span>的数据类型为<span class="title">str</span></span></span><br><span class="line"><span class="class">  &lt;<span class="title">class</span> &#x27;<span class="title">str</span>&#x27;&gt;  # 显示<span class="title">age</span>的数据类型也是<span class="title">str</span></span></span><br><span class="line"><span class="class">  <span class="title">tom</span> 18  # 输出结果与输入结果一致</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-输出"><a href="#2-2-输出" class="headerlink" title="2.2 输出"></a>2.2 输出</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">输出:程序输出内容给用户,内置函数<span class="built_in">print</span>()</span><br><span class="line">  <span class="built_in">print</span>()</span><br><span class="line">    <span class="number">1.</span>括号内可以使用逗号将多个元素一起打印</span><br><span class="line">    <span class="number">2.</span>自带end参数控制打印的排版</span><br><span class="line">    	eg:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;test&#x27;</span>, end=<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">123</span>)</span><br><span class="line">      res:</span><br><span class="line">        test&amp;<span class="number">123</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-格式化输出"><a href="#2-3-格式化输出" class="headerlink" title="2.3 格式化输出"></a>2.3 格式化输出</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">格式化输出:将字符串中某些内容替换掉再输出就是格式化输出</span><br><span class="line"><span class="number">1.</span>先使用占位符 %s</span><br><span class="line"><span class="number">2.</span>再使用%按照位置进行替换</span><br><span class="line">eg:</span><br><span class="line">  res = <span class="string">&#x27;亲爱的%s你好！你%s月的话费是%s，余额是%s&#x27;</span></span><br><span class="line">	<span class="built_in">print</span>(res % (<span class="string">&#x27;jason&#x27;</span>, <span class="number">11</span>, <span class="number">100</span>, <span class="number">999</span>))</span><br><span class="line">	<span class="built_in">print</span>(res % (<span class="string">&#x27;tony&#x27;</span>, <span class="number">11</span>, <span class="number">200</span>, -<span class="number">100</span>))</span><br><span class="line">	<span class="built_in">print</span>(res % (<span class="string">&#x27;kevin&#x27;</span>, <span class="number">11</span>, <span class="number">500</span>, -<span class="number">999</span>))</span><br><span class="line">res:</span><br><span class="line">  亲爱的jason你好！你<span class="number">11</span>月的话费是<span class="number">100</span>，余额是<span class="number">999</span></span><br><span class="line">	亲爱的tony你好！你<span class="number">11</span>月的话费是<span class="number">200</span>，余额是-<span class="number">100</span></span><br><span class="line">	亲爱的kevin你好！你<span class="number">11</span>月的话费是<span class="number">500</span>，余额是-<span class="number">999</span></span><br><span class="line">  </span><br><span class="line">%d占位符只能给数字占位</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%08d&#x27;</span> % <span class="number">123</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;%08d&#x27;</span> % <span class="number">6666666666666</span>)</span><br><span class="line"></span><br><span class="line">res:</span><br><span class="line">  00000123</span><br><span class="line">  <span class="number">6666666666666</span></span><br><span class="line"><span class="comment"># 08导致输出结果会保留8位,不足的用0补齐,超过的直接显示源数据</span></span><br></pre></td></tr></table></figure>

<h2 id="3、基本运算符"><a href="#3、基本运算符" class="headerlink" title="3、基本运算符"></a>3、基本运算符</h2><h3 id="3-1-算数运算符"><a href="#3-1-算数运算符" class="headerlink" title="3.1 算数运算符"></a>3.1 算数运算符</h3><p>a = 10 , b = 20</p>
<table>
<thead>
<tr>
<th align="center">运算符</th>
<th align="center">描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td align="center">+</td>
<td align="center">两个对象相加</td>
<td>a + b 值为 30</td>
</tr>
<tr>
<td align="center">-</td>
<td align="center">得到负数或是一个数减去另一个数</td>
<td>a - b 值为 -10</td>
</tr>
<tr>
<td align="center">*</td>
<td align="center">两个数相乘或是返回一个被重复若干次的字符串</td>
<td>a * b 值为 200</td>
</tr>
<tr>
<td align="center">/</td>
<td align="center">x除以y</td>
<td>b / a 值为  2</td>
</tr>
<tr>
<td align="center">//</td>
<td align="center">取整除 - 返回商的整数部分（<strong>向下取整</strong>）</td>
<td>9 // 2 值为 4</td>
</tr>
<tr>
<td align="center">%</td>
<td align="center">取模,返回除法的余数</td>
<td>b % a 输出结果 0</td>
</tr>
<tr>
<td align="center">**</td>
<td align="center">返回x的y次幂</td>
<td>2 ** 3 值为8</td>
</tr>
</tbody></table>
<h3 id="3-2-比较运算符"><a href="#3-2-比较运算符" class="headerlink" title="3.2 比较运算符"></a>3.2 比较运算符</h3><table>
<thead>
<tr>
<th align="center">比较运算符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">==</td>
<td>等于,两边相等为True,否则返回False</td>
</tr>
<tr>
<td align="center">!=</td>
<td>不等于,两边不相等为True,否则返回False</td>
</tr>
<tr>
<td align="center">&gt;</td>
<td>大于</td>
</tr>
<tr>
<td align="center">&gt;=</td>
<td>大于等于</td>
</tr>
<tr>
<td align="center">&lt;</td>
<td>小于</td>
</tr>
<tr>
<td align="center">&lt;=</td>
<td>小于等于</td>
</tr>
</tbody></table>
<h3 id="3-3-赋值运算符"><a href="#3-3-赋值运算符" class="headerlink" title="3.3 赋值运算符"></a>3.3 赋值运算符</h3><h4 id="3-3-1-增量赋值"><a href="#3-3-1-增量赋值" class="headerlink" title="3.3.1 增量赋值"></a>3.3.1 增量赋值</h4><table>
<thead>
<tr>
<th>赋值运算符</th>
<th>描述</th>
<th>实例</th>
</tr>
</thead>
<tbody><tr>
<td>=</td>
<td>简单赋值运算</td>
<td>a = 10</td>
</tr>
<tr>
<td>+=</td>
<td>加法赋值运算</td>
<td>a +=1 相当于a = a+1</td>
</tr>
<tr>
<td>-=</td>
<td>减法赋值运算</td>
<td>a -= 1 相当于a = a-1</td>
</tr>
<tr>
<td>*=</td>
<td>乘法赋值运算</td>
<td></td>
</tr>
<tr>
<td>/=</td>
<td>除法赋值运算</td>
<td></td>
</tr>
<tr>
<td>//=</td>
<td>取整赋值运算</td>
<td></td>
</tr>
<tr>
<td>%=</td>
<td>取余赋值运算</td>
<td></td>
</tr>
<tr>
<td>**=</td>
<td>幂赋值运算</td>
<td></td>
</tr>
</tbody></table>
<h4 id="3-3-2-链式赋值"><a href="#3-3-2-链式赋值" class="headerlink" title="3.3.2 链式赋值"></a>3.3.2 链式赋值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">可以把同一个值同时赋值个多个变量名</span><br><span class="line">eg:</span><br><span class="line">  a = <span class="number">10</span></span><br><span class="line">  b = a</span><br><span class="line">  c = b</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 链式赋值可以一行解决</span></span><br><span class="line">  a = b = c = <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-3-交叉赋值"><a href="#3-3-3-交叉赋值" class="headerlink" title="3.3.3 交叉赋值"></a>3.3.3 交叉赋值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">eg: </span><br><span class="line">  a = <span class="number">10</span></span><br><span class="line">  b = <span class="number">22</span></span><br><span class="line">  </span><br><span class="line">  需要a和b交换</span><br><span class="line">  方式<span class="number">1</span>:</span><br><span class="line"> 		tmp = a  <span class="comment"># 引入第三变量暂存a的值</span></span><br><span class="line">		a = b  <span class="comment"># 变量a指向变量b,此时a的值为22</span></span><br><span class="line">		b = tmp  <span class="comment"># 变量b指向tmp,此时b的值就是10，完成互换吧</span></span><br><span class="line">		<span class="built_in">print</span>(a, b)    </span><br><span class="line">  方式<span class="number">2</span>:</span><br><span class="line">    a, b = <span class="number">22</span>, <span class="number">10</span>  <span class="comment"># 简单粗暴</span></span><br></pre></td></tr></table></figure>

<h4 id="3-3-4-解压赋值"><a href="#3-3-4-解压赋值" class="headerlink" title="3.3.4 解压赋值"></a>3.3.4 解压赋值</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">将列表中的多个值取出来依次赋值给多个变量名</span><br><span class="line">eg:</span><br><span class="line">  eg_list = [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]</span><br><span class="line">  a = eg_list[<span class="number">0</span>]</span><br><span class="line">  b = eg_list[<span class="number">1</span>]</span><br><span class="line">  c = eg_list[<span class="number">2</span>]</span><br><span class="line">  d = eg_list[<span class="number">3</span>]</span><br><span class="line">  <span class="built_in">print</span>(a, b, c, d,)  <span class="comment"># 输出为12 13 14 15</span></span><br><span class="line">  </span><br><span class="line">  解压赋值可以这样写:</span><br><span class="line">    a, b, c, d = eg_list</span><br><span class="line">    </span><br><span class="line">  解压赋值注意事项:</span><br><span class="line">    <span class="number">1.</span>等号左边的变量名格式化必须与右面包含的格式相同</span><br><span class="line">    <span class="number">2.</span>可以使用*_打破上述规则</span><br><span class="line">      eg:</span><br><span class="line">        a, *_, d = eg_list</span><br><span class="line">        <span class="built_in">print</span>(a, _, b)  <span class="comment"># 结果为 12 [13, 14] 15</span></span><br><span class="line">     说明:</span><br><span class="line">      * 可以接收多余的元素,组成列表赋值给后面的变量名</span><br><span class="line">      _ 作为单独变量名时,通常表达指向的值无用</span><br></pre></td></tr></table></figure>

<h3 id="3-4-逻辑运算符"><a href="#3-4-逻辑运算符" class="headerlink" title="3.4 逻辑运算符"></a>3.4 逻辑运算符</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">在python逻辑运算符就三个</span><br><span class="line"><span class="keyword">and</span>	与:</span><br><span class="line">	用于连接多个条件并且多个条件必须都成立才可以</span><br><span class="line"><span class="keyword">or</span>	或:</span><br><span class="line">	用于连接多个条件并且多个条件只要有一个成立即可</span><br><span class="line"><span class="keyword">not</span> 非:</span><br><span class="line">	取反</span><br><span class="line">  </span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> &gt; <span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span> != <span class="number">1</span> <span class="keyword">and</span> <span class="literal">True</span> <span class="keyword">and</span> <span class="number">3</span> &gt; <span class="number">2</span>)  <span class="comment"># False</span></span><br><span class="line"><span class="built_in">print</span>(<span class="number">2</span> &gt; <span class="number">1</span> <span class="keyword">or</span> <span class="number">1</span> != <span class="number">1</span> <span class="keyword">or</span> <span class="literal">True</span> <span class="keyword">or</span> <span class="number">3</span> &gt; <span class="number">2</span>)  <span class="comment"># True</span></span><br><span class="line"><span class="built_in">print</span>(<span class="keyword">not</span> <span class="literal">True</span>)  <span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ps:三个连接符在混合使用的时候是有优先级的,但是我们在编写的时候应该人为的规定好优先级,()优先级最高</span></span><br></pre></td></tr></table></figure>

<h3 id="3-5-成员运算"><a href="#3-5-成员运算" class="headerlink" title="3.5 成员运算"></a>3.5 成员运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">定义:判断某个个体在不在某个群体内</span><br><span class="line">关键字: </span><br><span class="line">  <span class="keyword">in</span>  			(在)</span><br><span class="line">  <span class="keyword">not</span> <span class="keyword">in</span>    (不在)</span><br><span class="line">eg:</span><br><span class="line">   name_list = [<span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;tony&#x27;</span>, <span class="string">&#x27;jackson&#x27;</span>]</span><br><span class="line">    name = <span class="built_in">input</span>(<span class="string">&#x27;请输入您要查询的学生姓名&gt;&gt;&gt;:&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(name <span class="keyword">in</span> name_list)</span><br><span class="line">    <span class="built_in">print</span>(name <span class="keyword">not</span> <span class="keyword">in</span> name_list)</span><br><span class="line">    <span class="comment"># 最终返回的是True或者False</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#字典默认暴露给外界的只有K</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;jason&#x27;</span> <span class="keyword">in</span> &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;)  <span class="comment"># False</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;username&#x27;</span> <span class="keyword">in</span> &#123;<span class="string">&#x27;username&#x27;</span>: <span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">18</span>&#125;) <span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<h3 id="3-6-身份运算"><a href="#3-6-身份运算" class="headerlink" title="3.6 身份运算"></a>3.6 身份运算</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">定义:判断两个数据 值和内存地址是否相等</span><br><span class="line">符号:</span><br><span class="line">  ==  (只判断值)</span><br><span class="line">  <span class="keyword">is</span>  (判断内存地址)</span><br><span class="line">eg:</span><br><span class="line">    s1 = [<span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;tony&#x27;</span>, <span class="string">&#x27;jackson&#x27;</span>]</span><br><span class="line">    s2 = [<span class="string">&#x27;jason&#x27;</span>, <span class="string">&#x27;kevin&#x27;</span>, <span class="string">&#x27;tony&#x27;</span>, <span class="string">&#x27;jackson&#x27;</span>]</span><br><span class="line">    <span class="built_in">print</span>(s1 == s2)  <span class="comment"># True</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">id</span>(s1),<span class="built_in">id</span>(s2))  <span class="comment"># 查看相当于内存地址的数字</span></span><br><span class="line">    <span class="built_in">print</span>(s1 <span class="keyword">is</span> s2)  <span class="comment"># False</span></span><br><span class="line">结论:</span><br><span class="line">  值相等内存地址不一定相等</span><br><span class="line">  内存地址相等值一定相等</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python基础-01</title>
    <url>/daf175dd.html</url>
    <content><![CDATA[<h2 id="1、Pycharm基本使用"><a href="#1、Pycharm基本使用" class="headerlink" title="1、Pycharm基本使用"></a>1、Pycharm基本使用</h2><h3 id="1-1-新建项目"><a href="#1-1-新建项目" class="headerlink" title="1.1 新建项目"></a>1.1 新建项目</h3><span id="more"></span>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/Fg5CT2.png" alt="Fg5CT2"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/koHl29.png" alt="koHl29"></p>
<h3 id="1-2-主题设置"><a href="#1-2-主题设置" class="headerlink" title="1.2 主题设置"></a>1.2 主题设置</h3><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/Yr8VSa.png" alt="Yr8VSa"></p>
<h3 id="1-3-Pycharm切换解释器"><a href="#1-3-Pycharm切换解释器" class="headerlink" title="1.3 Pycharm切换解释器"></a>1.3 Pycharm切换解释器</h3><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/xy5MbY.png" alt="xy5MbY"></p>
<h3 id="1-4-调整字体"><a href="#1-4-调整字体" class="headerlink" title="1.4 调整字体"></a>1.4 调整字体</h3><p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/kBm63I.png" alt="kBm63I"></p>
<h3 id="1-5-运行python脚本文件"><a href="#1-5-运行python脚本文件" class="headerlink" title="1.5 运行python脚本文件"></a>1.5 运行python脚本文件</h3><p>鼠标右键到项目目录之后可以创建文件夹与文件，在代码空白处右键选择如下的Run即可运行python脚本</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/dI0FCk.png" alt="dI0FCk"></p>
<h2 id="2、Python的注释语法"><a href="#2、Python的注释语法" class="headerlink" title="2、Python的注释语法"></a>2、Python的注释语法</h2><h3 id="2-1-注释"><a href="#2-1-注释" class="headerlink" title="2.1 注释"></a>2.1 注释</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;注释是代码之母&quot;&quot;&quot;</span></span><br><span class="line">注释：对代码的解释和说明，目的是为了让人们能够轻松的了解代码，注释不参与持续的运行</span><br></pre></td></tr></table></figure>

<h3 id="2-2-使用注释"><a href="#2-2-使用注释" class="headerlink" title="2.2 使用注释"></a>2.2 使用注释</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">方式一:使用井号</span><br><span class="line">  <span class="comment"># 这是一行注释</span></span><br><span class="line">方式二:使用三引号(单引号和双引号)</span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  这是多行注释</span></span><br><span class="line"><span class="string">  这是多行注释</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>2.3 Pycharm注释快捷键</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Windows： ctrl + ?</span><br><span class="line">Mac:      command + ?</span><br><span class="line">选中多行代码之后执行快捷键就会被一起注释</span><br></pre></td></tr></table></figure>

<h2 id="3、变量"><a href="#3、变量" class="headerlink" title="3、变量"></a>3、变量</h2><h3 id="3-1-什么是变量"><a href="#3-1-什么是变量" class="headerlink" title="3.1 什么是变量"></a>3.1 什么是变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">变量即变化的量，用于记录事物的某种状态，是模仿人类事物记忆能力</span><br></pre></td></tr></table></figure>

<h3 id="3-2-使用变量"><a href="#3-2-使用变量" class="headerlink" title="3.2 使用变量"></a>3.2 使用变量</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">日常生活种:</span><br><span class="line">  姓名:xxx</span><br><span class="line">  年龄:<span class="number">28</span></span><br><span class="line">  爱好:学习</span><br><span class="line">程序中:</span><br><span class="line">  username = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">  age      = <span class="number">18</span></span><br><span class="line">  hobby    = <span class="string">&#x27;music&#x27;</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-语法格式"><a href="#3-3-语法格式" class="headerlink" title="3.3 语法格式"></a>3.3 语法格式</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">username = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">变量名  赋值号 变量值</span><br></pre></td></tr></table></figure>

<h3 id="3-4-变量三要素"><a href="#3-4-变量三要素" class="headerlink" title="3.4 变量三要素"></a>3.4 变量三要素</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>变量的值 </span><br><span class="line"><span class="number">2.</span>变量的内存地址</span><br><span class="line"><span class="number">3.</span>变量的数据类型</span><br><span class="line"></span><br><span class="line">name = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(name)         <span class="comment"># 变量值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">id</span>(name))     <span class="comment"># 返回一串数字 相当于是内存地址编号</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(name))   <span class="comment"># 返回数据类型  &lt;class &#x27;str&#x27;&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/I6iPWT.png" alt="I6iPWT"></p>
<h3 id="3-5-底层原理"><a href="#3-5-底层原理" class="headerlink" title="3.5 底层原理"></a>3.5 底层原理</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># eg:</span></span><br><span class="line">  age = <span class="number">18</span></span><br><span class="line">  </span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">  遇到赋值号先看符号右边，再看到左边</span></span><br><span class="line"><span class="string">  1.在内存中申请到了一块内存空间来存储18这个数字</span></span><br><span class="line"><span class="string">  2.将18所在的内存空间地址指向绑定给变量名age</span></span><br><span class="line"><span class="string">  3.后续如果要访问18可以直接通过访问变量age</span></span><br><span class="line"><span class="string">  &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/gyg2Ck.png" alt="gyg2Ck"></p>
<h3 id="3-6-Python底层优化"><a href="#3-6-Python底层优化" class="headerlink" title="3.6 Python底层优化"></a>3.6 Python底层优化</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">当值数据量很小的时候 如果有多个变量名需要使用 那么会指向同一块地址</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">一个变量名只能指向一个内存地址</span></span><br><span class="line"><span class="string">一个内存地址可以有多个变量名指向</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="4、常量"><a href="#4、常量" class="headerlink" title="4、常量"></a>4、常量</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">常量:主要记录一些不变的状态</span><br><span class="line">  </span><br><span class="line">在python中没有真正意义上的常量 我们墨守成规的将全大写的变量看成是常量</span><br><span class="line">	HOST = <span class="string">&#x27;127.0.0.1&#x27;</span>  <span class="comment"># 一般情况下在配置文件中使用较多</span></span><br><span class="line">在其他编程语言中是存在真正意义上的常量 定义了就无法修改</span><br><span class="line"><span class="comment"># JavaScript代码</span></span><br><span class="line">	const pi = <span class="number">3.14</span>  <span class="comment"># 定义常量</span></span><br><span class="line">    pi = <span class="number">4</span>  <span class="comment"># 不支持修改</span></span><br><span class="line"><span class="comment"># golang常量声明</span></span><br><span class="line">const MAX = <span class="number">1024</span></span><br><span class="line">const (</span><br><span class="line">  a = iota</span><br><span class="line">  b = iota</span><br><span class="line">  c = iota</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="5、垃圾回收机制"><a href="#5、垃圾回收机制" class="headerlink" title="5、垃圾回收机制"></a>5、垃圾回收机制</h2><h3 id="5-1-垃圾数据的定义"><a href="#5-1-垃圾数据的定义" class="headerlink" title="5.1 垃圾数据的定义"></a>5.1 垃圾数据的定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">在内存中没有任何变量名指向的数据</span><br></pre></td></tr></table></figure>

<h3 id="5-2-回收方案"><a href="#5-2-回收方案" class="headerlink" title="5.2 回收方案"></a>5.2 回收方案</h3><h4 id="5-2-1-引用记数"><a href="#5-2-1-引用记数" class="headerlink" title="5.2.1 引用记数"></a>5.2.1 引用记数</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">内存中变量值身上有几个变量名绑定引用计数就是几,只要不为<span class="number">0</span>就不是垃圾</span><br></pre></td></tr></table></figure>

<h4 id="5-2-2-标记清除"><a href="#5-2-2-标记清除" class="headerlink" title="5.2.2 标记清除"></a>5.2.2 标记清除</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">当内存即将沾满的时候,python会自动暂停程序的执行,从头到尾将内存中数据进行扫描,并打上标记,之后一次性清除掉标记的数据</span><br></pre></td></tr></table></figure>

<h4 id="5-2-3-分代回收"><a href="#5-2-3-分代回收" class="headerlink" title="5.2.3 分代回收"></a>5.2.3 分代回收</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">会将数据的监管分为三个层次,随着层级的下降监督的频率降低</span><br><span class="line">用时间换空间</span><br></pre></td></tr></table></figure>

<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/CR2fkx.png" alt="CR2fkx"></p>
<h2 id="6、数据类型"><a href="#6、数据类型" class="headerlink" title="6、数据类型"></a>6、数据类型</h2><h3 id="6-1-什么是数据类型"><a href="#6-1-什么是数据类型" class="headerlink" title="6.1 什么是数据类型"></a>6.1 什么是数据类型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">存储数据的方式和表现形式有很多种，例如文本文件，视频文件，音频文件......</span><br></pre></td></tr></table></figure>

<h3 id="6-2-int类型"><a href="#6-2-int类型" class="headerlink" title="6.2 int类型"></a>6.2 int类型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># int类型:整数类型,长度与其他语言对比无限</span></span><br><span class="line">作用:可以记录人的年龄，人数......</span><br><span class="line">eg:</span><br><span class="line">  age = <span class="number">18</span>  <span class="comment"># 直接些整数就是整型</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-float类型"><a href="#6-3-float类型" class="headerlink" title="6.3 float类型"></a>6.3 float类型</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># float可以理解为小数</span></span><br><span class="line">作用:记录人的体重，薪资......</span><br><span class="line">eg:</span><br><span class="line">  salary = <span class="number">3.14</span>  <span class="comment"># 直接写小数就是浮点型</span></span><br></pre></td></tr></table></figure>

<h2 id="7、代码规范"><a href="#7、代码规范" class="headerlink" title="7、代码规范"></a>7、代码规范</h2><h3 id="7-1-注释规范"><a href="#7-1-注释规范" class="headerlink" title="7.1 注释规范"></a>7.1 注释规范</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1.警号与注释文本之间一定要有一个空格</span></span><br><span class="line"><span class="string">2.如果单行注释跟在了一行代码的后面 需要先空两个再写</span></span><br><span class="line"><span class="string">pycharm也提供自动化格式代码的功能 </span></span><br><span class="line"><span class="string">code </span></span><br><span class="line"><span class="string">reformat code</span></span><br><span class="line"><span class="string">Windows快捷键：ctrl + alt + l</span></span><br><span class="line"><span class="string">Mac快捷键： option + command + L </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">python代码编写规范  &gt;&gt;&gt;: PEP8规范</span><br><span class="line"><span class="comment"># 如何快速掌握 借助于pycharm的自动化提示 前后对比 每天记忆</span></span><br></pre></td></tr></table></figure>



<h3 id="7-2-命名规范"><a href="#7-2-命名规范" class="headerlink" title="7.2 命名规范"></a>7.2 命名规范</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命名规范</span></span><br><span class="line">	  <span class="number">1.</span>变量名只能由数字、字母、下划线任意组合</span><br><span class="line">    	user@name(不对)、_(可以)、pwd_123_aaa(可以)</span><br><span class="line">    <span class="number">2.</span>变量名不能以数字开头，下划线建议不要开头因为有特殊含义</span><br><span class="line">    <span class="number">3.</span>变量名不能与关键字冲突</span><br><span class="line">    <span class="number">4.</span>变量名的命名一定要做到见名知意(重要)</span><br><span class="line">    	<span class="string">&#x27;&#x27;&#x27;变量名见名知意是核心 无论变量多长&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 命名风格</span></span><br><span class="line">	<span class="number">1.</span>驼峰体  </span><br><span class="line">    	大驼峰  <span class="comment"># 所有单词首字母大写</span></span><br><span class="line">        	UserNameFromDb</span><br><span class="line">        小驼峰  <span class="comment"># 第一首字母小写其余首字母大写</span></span><br><span class="line">        	userNameFromDB</span><br><span class="line">        <span class="string">&quot;&quot;&quot;JavaScript推荐使用驼峰体&quot;&quot;&quot;</span></span><br><span class="line">    <span class="number">2.</span>下划线  <span class="comment"># 单词与单词之间下划线隔开</span></span><br><span class="line">    	user_name_from_db </span><br><span class="line">        <span class="string">&quot;&quot;&quot;python推荐使用下划线&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 好东西！！！输入中文即可给出对应英文命名</span></span><br><span class="line">https://unbug.github.io/codelf/</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python解释器与Pycharm</title>
    <url>/c1fd5357.html</url>
    <content><![CDATA[<h1 id="1、Python解释器安装"><a href="#1、Python解释器安装" class="headerlink" title="1、Python解释器安装"></a>1、Python解释器安装</h1><h2 id="1-1-Python下载"><a href="#1-1-Python下载" class="headerlink" title="1.1 Python下载"></a>1.1 Python下载</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#官网，下载速度慢</span></span><br><span class="line">https://www.python.org</span><br><span class="line"></span><br><span class="line"><span class="comment">#国内下载</span></span><br><span class="line">https://npm.taobao.org/mirrors/python</span><br></pre></td></tr></table></figure>
<span id="more"></span>

<ol>
<li>找到下载位置并点击</li>
</ol>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/NoHxoM.png" alt="NoHxoM"></p>
<ol start="2">
<li><p>选择对应的版本以及操作系统进行下载</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/enrDoA.png" alt="enrDoA"></p>
</li>
</ol>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/Se7Gmo.png" alt="Se7Gmo"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/J0BKed.png" alt="J0BKed"></p>
<h2 id="1-2-Python安装"><a href="#1-2-Python安装" class="headerlink" title="1.2 Python安装"></a>1.2 Python安装</h2><h3 id="1-2-1-Mac安装"><a href="#1-2-1-Mac安装" class="headerlink" title="1.2.1 Mac安装"></a>1.2.1 Mac安装</h3><p>根据提示下载的安装包如下：</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/LdenzD.png" alt="LdenzD"></p>
<p>双击打开之后直接继续即可</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/Dl1wXm.png" alt="Dl1wXm"></p>
<h3 id="1-2-2-Windows安装"><a href="#1-2-2-Windows安装" class="headerlink" title="1.2.2 Windows安装"></a>1.2.2 Windows安装</h3><p>第一个红框选择自定义安装，可选择python安装路径。第二个红框是自动配置环境变量</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/tjeIhK.png" alt="tjeIhK"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/XhyZ3E.png" alt="XhyZ3E"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/3YqU60.png" alt="d"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/Ja6EtC.png" alt="Ja6EtC"></p>
<p>环境变量设置</p>
<p>此时还无法直接使用python</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/A717xq.png" alt="A717xq"></p>
<p>此电脑右键，选择属性，选择高级系统设置，选择环境变量，选择Path，编辑，再变量最后使用英文状态下的 ; 进行结尾，将Python安装的路径复制出来，粘贴到最后然后选择确定。最后新打开命令提示符输入python即可</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/dhoaNQ.png" alt="dhoaNQ"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/DGvRCE.png" alt="DGvRCE"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/KZmLEE.png" alt="KZmLEE"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/aOntw1.png" alt="aOntw1"></p>
<h3 id="1-2-3-多版本"><a href="#1-2-3-多版本" class="headerlink" title="1.2.3 多版本"></a>1.2.3 多版本</h3><ol>
<li><p>Mac系统下</p>
<p>可以使用pyenv进行多版本控制</p>
</li>
<li><p>Windows</p>
</li>
</ol>
<p>python2.7安装：</p>
<p>下载加速地址：<a href="https://npm.taobao.org/mirrors/python">https://npm.taobao.org/mirrors/python</a></p>
<p>下载完成后继续将Python2.7的路径放入到Path的最后，将对应版本的exe改名，最后在终端输入对应版本</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/cBrS1B.png" alt="cBrS1B">     </p>
<p>更对应版本的名称</p>
<p>此时就可以多版本试用</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/Ciyvlb.png" alt="Ciyvlb"></p>
<h1 id="2、Pycharm安装"><a href="#2、Pycharm安装" class="headerlink" title="2、Pycharm安装"></a>2、Pycharm安装</h1><ol>
<li>下载安装</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#官网</span></span><br><span class="line">https://www.jetbrains.com/pycharm/download/</span><br></pre></td></tr></table></figure>



<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/aJKd3J.png" alt="aJKd3J"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/dag3R6.png" alt="dag3R6"></p>
<p>下载完成后下一步下一步安装即可</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/BJbgci.png" alt="BJbgci"></p>
<ol start="2">
<li><p>2021.3版本破解</p>
<p>无限期试用方法参考：<a href="https://www.macwk.com/article/jetbrains-crack">https://www.macwk.com/article/jetbrains-crack</a></p>
</li>
</ol>
<p>最新版本试用需要登录账号才可以</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/3u8VVR.png" alt="3u8VVR"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/ddVmoo.png" alt="ddVmoo"></p>
<p>破解：</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/ZEJ0Od.png" alt="ZEJ0Od"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/3kEn2a.png" alt="3kEn2a"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/kdhtq0.png" alt="kdhtq0"></p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/7IwHNz.png" alt="7IwHNz"></p>
<p>使用插件即可重置试用时间</p>
<p><img src="https://klcc-img-1251900471.cos.ap-chengdu.myqcloud.com/img/p1l5h0.png" alt="p1l5h0"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>pycharm</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown使用</title>
    <url>/28cddff3.html</url>
    <content><![CDATA[<h2 id="1、Markdown"><a href="#1、Markdown" class="headerlink" title="1、Markdown"></a>1、Markdown</h2><h3 id="1-1-Typora软件"><a href="#1-1-Typora软件" class="headerlink" title="1.1 Typora软件"></a>1.1 Typora软件</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Typora：最好用的Markdown语法编辑器</span></span><br><span class="line"><span class="comment">#官网</span></span><br><span class="line">https://www.typora.io</span><br><span class="line"><span class="comment">#下载地址</span></span><br><span class="line">https://www.typora.io/<span class="comment">#download</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#源代码模式快捷键</span></span><br><span class="line">Windows系统 ctrl + /</span><br><span class="line">mac command + /</span><br></pre></td></tr></table></figure>
<span id="more"></span>


<h3 id="1-2-Markdown基础语法"><a href="#1-2-Markdown基础语法" class="headerlink" title="1.2 Markdown基础语法"></a>1.2 Markdown基础语法</h3><h4 id="1-2-1-生成目录"><a href="#1-2-1-生成目录" class="headerlink" title="1.2.1 生成目录"></a>1.2.1 生成目录</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#源代码模式下在文档最上方输入以下，就会在文档最上方根据标题生成目录</span></span><br><span class="line">[toc]</span><br></pre></td></tr></table></figure>

<h4 id="1-2-2-标题"><a href="#1-2-2-标题" class="headerlink" title="1.2.2 标题"></a>1.2.2 标题</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 一级标题</span></span><br><span class="line"><span class="comment">## 二级标题</span></span><br><span class="line"><span class="comment">### 三级标题</span></span><br><span class="line"><span class="comment">#### 四级标题</span></span><br><span class="line"><span class="comment">##### 五级标题</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2-3-子标题"><a href="#1-2-3-子标题" class="headerlink" title="1.2.3 子标题"></a>1.2.3 子标题</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#无序子标题</span></span><br><span class="line">* 子标题<span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#有序子标题</span></span><br><span class="line"><span class="number">1.</span> 子标题<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#源代码模式下上一级与下一级多敲三个空格即可</span></span><br><span class="line"><span class="comment">#Typora内使用Tab键即可</span></span><br></pre></td></tr></table></figure>
<h4 id="1-2-4-代码块"><a href="#1-2-4-代码块" class="headerlink" title="1.2.4 代码块"></a>1.2.4 代码块</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#&quot;\&quot; 是注释</span></span><br><span class="line">\```源码类型</span><br><span class="line">\```</span><br></pre></td></tr></table></figure>


<h4 id="1-2-5-制表"><a href="#1-2-5-制表" class="headerlink" title="1.2.5 制表"></a>1.2.5 制表</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#使用管道符分割,Typora内可以使用如下</span></span><br><span class="line">|user|passwd|hostname|</span><br><span class="line"></span><br><span class="line"><span class="comment">#源码如下</span></span><br><span class="line">| user | passwd | hostname |</span><br><span class="line">| ---- | :------: | -------- |</span><br><span class="line">|root|<span class="number">123456</span>|test1|</span><br><span class="line"><span class="comment">#::这两个代表着表格内文字整体居中</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="1-2-6-超链接"><a href="#1-2-6-超链接" class="headerlink" title="1.2.6 超链接"></a>1.2.6 超链接</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 文本超链接</span></span><br><span class="line">[文本](超链接) <span class="comment">#eg: [测试](www.baidu.com)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#图片超链接，插入图片</span></span><br><span class="line">![图片](超链接) <span class="comment">#此处超链接可以是本地图片地址或者图片的url</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-7-单选框"><a href="#1-2-7-单选框" class="headerlink" title="1.2.7 单选框"></a>1.2.7 单选框</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">- [ ] 单选框 <span class="comment">#创建完成后可点</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-8-字体"><a href="#1-2-8-字体" class="headerlink" title="1.2.8 字体"></a>1.2.8 字体</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">**加粗**</span><br><span class="line">*斜体*</span><br><span class="line">~~删除线~~</span><br><span class="line">~~***倾斜加粗删除线***~~</span><br></pre></td></tr></table></figure>

<h2 id="2、编程与编程语言"><a href="#2、编程与编程语言" class="headerlink" title="2、编程与编程语言"></a>2、编程与编程语言</h2><h3 id="2-1-语言"><a href="#2-1-语言" class="headerlink" title="2.1 语言"></a>2.1 语言</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">中文、日文、韩文等等都是人类的语言，语言是为了人与人沟通的媒介</span><br></pre></td></tr></table></figure>



<h3 id="2-2-编程语言"><a href="#2-2-编程语言" class="headerlink" title="2.2 编程语言"></a>2.2 编程语言</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">因此编程语言就是人与计算机之间沟通交流的媒介,为了让计算机代替人力无休止的干活</span><br></pre></td></tr></table></figure>



<h3 id="2-3-编程"><a href="#2-3-编程" class="headerlink" title="2.3 编程"></a>2.3 编程</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">编程是程序员使用计算机能够读懂的语言<span class="string">&quot;将自己的思维逻辑和想法&quot;</span>写下来的过程</span><br></pre></td></tr></table></figure>



<h2 id="3、计算机基础"><a href="#3、计算机基础" class="headerlink" title="3、计算机基础"></a>3、计算机基础</h2><h3 id="3-1-计算机五大组成部分"><a href="#3-1-计算机五大组成部分" class="headerlink" title="3.1 计算机五大组成部分"></a>3.1 计算机五大组成部分</h3><h4 id="3-1-1-控制器"><a href="#3-1-1-控制器" class="headerlink" title="3.1.1 控制器"></a>3.1.1 控制器</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">控制计算机各个硬件的工作</span><br><span class="line"><span class="comment">#相当于人的大脑</span></span><br></pre></td></tr></table></figure>



<h4 id="3-1-2-运算器"><a href="#3-1-2-运算器" class="headerlink" title="3.1.2 运算器"></a>3.1.2 运算器</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">控制数学运算与逻辑运算</span><br><span class="line">  数学运算:数字相关的运算</span><br><span class="line">  逻辑运算:根据条件判断是否可行</span><br><span class="line"><span class="comment">#相当于人的大脑</span></span><br></pre></td></tr></table></figure>



<h4 id="3-1-3-存储设备"><a href="#3-1-3-存储设备" class="headerlink" title="3.1.3 存储设备"></a>3.1.3 存储设备</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">内存:存取数据的速度很快，但是它是基于电工作的，断电后数据会立刻丢失，不能永久保存数据。<span class="comment">#eg:内存条,相当于人的短期记忆，</span></span><br><span class="line">  </span><br><span class="line">外存:存取数据的速度较慢，但是它断电之后数据也不受影响 可以永久保存数据。<span class="comment">#eg:磁带,磁盘,u盘,硬盘,相当于人的长期记忆</span></span><br></pre></td></tr></table></figure>



<h4 id="3-1-4-输入设备"><a href="#3-1-4-输入设备" class="headerlink" title="3.1.4 输入设备"></a>3.1.4 输入设备</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">作用:将外界的数据传递给计算机</span><br><span class="line"><span class="comment">#eg:鼠标,键盘,麦克风</span></span><br><span class="line"><span class="comment">#相当于人的眼睛,嘴巴,耳朵</span></span><br></pre></td></tr></table></figure>



<h4 id="3-1-5-输出设备"><a href="#3-1-5-输出设备" class="headerlink" title="3.1.5 输出设备"></a>3.1.5 输出设备</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">作用:将计算机内部的数据传递给外部</span><br><span class="line"><span class="comment">#eg:显示屏,音响,打印机</span></span><br><span class="line"><span class="comment">#相当于人的嘴巴...</span></span><br></pre></td></tr></table></figure>





<h3 id="3-2-计算机三大核心硬件"><a href="#3-2-计算机三大核心硬件" class="headerlink" title="3.2 计算机三大核心硬件"></a>3.2 计算机三大核心硬件</h3><h4 id="3-2-1-中央处理器"><a href="#3-2-1-中央处理器" class="headerlink" title="3.2.1 中央处理器"></a>3.2.1 中央处理器</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">CPU去内存中取程序的指令并运行，相当于控制器+运算器</span><br></pre></td></tr></table></figure>



<h4 id="3-2-2-内存"><a href="#3-2-2-内存" class="headerlink" title="3.2.2 内存"></a>3.2.2 内存</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">程序要想运行必须先存在于内存中</span><br></pre></td></tr></table></figure>



<h4 id="3-2-3-硬盘"><a href="#3-2-3-硬盘" class="headerlink" title="3.2.3 硬盘"></a>3.2.3 硬盘</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">永久保存相应数据</span><br></pre></td></tr></table></figure>



<h3 id="3-3-操作系统"><a href="#3-3-操作系统" class="headerlink" title="3.3 操作系统"></a>3.3 操作系统</h3><h4 id="3-3-1-概念"><a href="#3-3-1-概念" class="headerlink" title="3.3.1 概念"></a>3.3.1 概念</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">作用:协调、管理、控制计算机各个硬件的工作</span><br><span class="line">计算机硬件--&gt;操作系统--&gt;应用程序</span><br><span class="line">我们日常生活中所使用的 程序员所编写的程序都必须基于操作系统之上</span><br></pre></td></tr></table></figure>



<h4 id="3-3-2-分类"><a href="#3-3-2-分类" class="headerlink" title="3.3.2 分类"></a>3.3.2 分类</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">PC端：</span><br><span class="line">windows</span><br><span class="line">linux</span><br><span class="line">macos</span><br><span class="line"></span><br><span class="line">移动端：</span><br><span class="line">安卓</span><br><span class="line">ios</span><br><span class="line">鸿蒙</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux-命令记录-01</title>
    <url>/afb08e91.html</url>
    <content><![CDATA[<h2 id="Ubuntu扩容lvm"><a href="#Ubuntu扩容lvm" class="headerlink" title="Ubuntu扩容lvm"></a>Ubuntu扩容lvm</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lvextend -l +100%FREE /dev/mapper/ubuntu--vg-ubuntu--lv</span><br><span class="line">resize2fs /dev/mapper/ubuntu--vg-ubuntu--lv</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h2 id="测试硬盘灯"><a href="#测试硬盘灯" class="headerlink" title="测试硬盘灯"></a>测试硬盘灯</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">time dd if=/dev/sdb of=/dev/null bs=4k</span><br><span class="line"></span><br><span class="line">for i in `lsblk |grep -w sd[a-z] |grep T  |awk &#x27;&#123;print $1&#125;&#x27;`</span><br><span class="line">do</span><br><span class="line">	nohup  dd if=/dev/$i of=/dev/null bs=4k &gt; /tmp/$&#123;i&#125;.log   &amp;</span><br><span class="line">done</span><br></pre></td></tr></table></figure>
<h2 id="CPU高压测试"><a href="#CPU高压测试" class="headerlink" title="CPU高压测试"></a>CPU高压测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for i in `seq 1 30`; do dd if=/dev/zero of=/dev/null &amp; done</span><br><span class="line">ps -ef |grep -v grep|grep &#x27;dd if=/dev/zero of=/dev/null&#x27;|awk &#x27;&#123;print $2&#125;&#x27;|xargs kill -9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">top</span><br><span class="line">Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class="line"></span><br><span class="line">id 前面数值是空闲率</span><br></pre></td></tr></table></figure>


<h2 id="ip排序"><a href="#ip排序" class="headerlink" title="ip排序"></a>ip排序</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sort -t . -k 4,4n tt</span><br><span class="line">sort -t<span class="string">&#x27;.&#x27;</span> -k1,1n -k2,2n -k3,3n -k4,4n</span><br></pre></td></tr></table></figure>
<h2 id="mdadm软raid"><a href="#mdadm软raid" class="headerlink" title="mdadm软raid"></a>mdadm软raid</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mdadm -C /dev/md1 -l raid0 -n 2 /dev/nvme2n2 /dev/nvme3n1 </span><br></pre></td></tr></table></figure>
<h2 id="dpkg-error"><a href="#dpkg-error" class="headerlink" title="dpkg-error"></a>dpkg-error</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">dpkg: error processing package</span><br><span class="line"></span><br><span class="line">mv /var/lib/dpkg/info /var/lib/dpkg/info.bak</span><br><span class="line">mkdir /var/lib/dpkg/info</span><br><span class="line">apt update</span><br><span class="line"></span><br><span class="line">apt install sl</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mv /var/lib/dpkg/info       /var/lib/dpkg/info.ori</span><br><span class="line">mv /var/lib/dpkg/info.bak   /var/lib/dpkg/info</span><br><span class="line"></span><br><span class="line">apt install lrzsz </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="CPU温度查看"><a href="#CPU温度查看" class="headerlink" title="CPU温度查看"></a>CPU温度查看</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">apt-get install lm-sensors sensors-applet -y</span><br><span class="line">yes| sensors-detect</span><br><span class="line"></span><br><span class="line">cat /sys/class/hwmon/hwmon0/device/hwmon/hwmon0/temp1_input</span><br><span class="line"></span><br><span class="line">sensors</span><br></pre></td></tr></table></figure>
<h2 id="无交互修改密码"><a href="#无交互修改密码" class="headerlink" title="无交互修改密码"></a>无交互修改密码</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;root:test123.&quot;</span>|chpasswd</span><br></pre></td></tr></table></figure>
<h2 id="开启yum缓存"><a href="#开启yum缓存" class="headerlink" title="开启yum缓存"></a>开启yum缓存</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/yum.conf</span><br><span class="line"><span class="meta">#</span><span class="bash">修改为1</span></span><br><span class="line">keepcache=1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">默认存放目录在/var/cache</span></span><br></pre></td></tr></table></figure>
<h2 id="find找出的移动或删除"><a href="#find找出的移动或删除" class="headerlink" title="find找出的移动或删除"></a>find找出的移动或删除</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">find ./ -name &#x27;means&#x27;|xargs -i mv &#123;&#125;  /k-means/</span><br><span class="line">find ./ -name &#x27;means&#x27;|xargs -i cp &#123;&#125;  /k-means/</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">找出小于90G的文件</span></span><br><span class="line">find ./ -type f   -size -90G</span><br></pre></td></tr></table></figure>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="bash错误修复"><a href="#bash错误修复" class="headerlink" title="-bash错误修复"></a>-bash错误修复</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-bash-4.2$</span><br><span class="line">cp /etc/skel/.bashrc  /home/user/</span><br><span class="line">cp /etc/skel/.bash_profile   /home/user</span><br></pre></td></tr></table></figure>
<h2 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">指定目录</span></span><br><span class="line">-d </span><br></pre></td></tr></table></figure>
<h2 id="设置免密"><a href="#设置免密" class="headerlink" title="设置免密"></a>设置免密</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -f ~/.ssh/id_rsa  -P &#x27;&#x27; -q</span><br><span class="line">sshpass -p123456</span><br><span class="line"></span><br><span class="line">ssh-copy-id -f -i ~/.ssh/id_rsa.pub &quot;-o StrictHostKeyChecking=no&quot; 10.0.0.100</span><br></pre></td></tr></table></figure>
<h2 id="rpm管理命令"><a href="#rpm管理命令" class="headerlink" title="rpm管理命令"></a>rpm管理命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rpm -ql  nginx		#列出所有相关目录</span><br><span class="line">rpm -qc  nginx		#列出配置目录</span><br><span class="line">rpm -e	 nginx		#单独卸载</span><br></pre></td></tr></table></figure>
<h2 id="输出格式化整理"><a href="#输出格式化整理" class="headerlink" title="输出格式化整理"></a>输出格式化整理</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">column -t    <span class="comment">#格式化整理</span></span><br></pre></td></tr></table></figure>
<h2 id="自动补全命令"><a href="#自动补全命令" class="headerlink" title="自动补全命令"></a>自动补全命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install bash-completion #自动补全命令</span><br></pre></td></tr></table></figure>
<h2 id="VMware相关"><a href="#VMware相关" class="headerlink" title="VMware相关"></a>VMware相关</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">VM安装linux在docker中装mysql挂起再启动后无法连接解决方法</span></span><br><span class="line">vim /usr/lib/sysctl.d/00-system.conf</span><br><span class="line">net.ipv4.ip_forward = 1</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">重启网络服务</span></span><br><span class="line">systemctl restart network</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">查看IPv4转发状态</span></span><br><span class="line">sysctl net.ipv4.ip_forward</span><br><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure>
<h2 id="history设置"><a href="#history设置" class="headerlink" title="history设置"></a>history设置</h2><h3 id="历史命令显示时间"><a href="#历史命令显示时间" class="headerlink" title="历史命令显示时间"></a>历史命令显示时间</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">写入/etc/bashrc或者/etc/profile</span></span><br><span class="line">HISTFILESIZE=4000 #默认保存命令是1000条，这里修改为4000条</span><br><span class="line">HISTSIZE=4000</span><br><span class="line">USER_IP=`who -u am i 2&gt;/dev/null| awk &#x27;&#123;print $NF&#125;&#x27;|sed -e &#x27;s/[()]//g&#x27;` #取得登录客户端的IP</span><br><span class="line">if [ -z $USER_IP ]</span><br><span class="line">then</span><br><span class="line">USER_IP=`hostname`</span><br><span class="line">fi</span><br><span class="line">HISTTIMEFORMAT=&quot;%F %T $USER_IP:`whoami` &quot; #设置新的显示history的格式</span><br><span class="line">export HISTTIMEFORMAT</span><br><span class="line"></span><br><span class="line">. /etc/bashrc</span><br></pre></td></tr></table></figure>
<h3 id="记录用户bash"><a href="#记录用户bash" class="headerlink" title="记录用户bash"></a>记录用户bash</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#####记录用户bash######################################################</span></span><br><span class="line"><span class="built_in">history</span></span><br><span class="line">USER=`whoami`</span><br><span class="line">USER_IP=`who -u am i 2&gt;/dev/null| awk <span class="string">&#x27;&#123;print $NF&#125;&#x27;</span>|sed -e <span class="string">&#x27;s/[()]//g&#x27;</span>`</span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;<span class="variable">$USER_IP</span>&quot;</span> = <span class="string">&quot;&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">USER_IP=`hostname`</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d /var/<span class="built_in">log</span>/<span class="built_in">history</span> ]; <span class="keyword">then</span></span><br><span class="line">mkdir /var/<span class="built_in">log</span>/<span class="built_in">history</span></span><br><span class="line">chmod 777 /var/<span class="built_in">log</span>/<span class="built_in">history</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="keyword">if</span> [ ! -d /var/<span class="built_in">log</span>/<span class="built_in">history</span>/<span class="variable">$&#123;LOGNAME&#125;</span> ]; <span class="keyword">then</span></span><br><span class="line">mkdir /var/<span class="built_in">log</span>/<span class="built_in">history</span>/<span class="variable">$&#123;LOGNAME&#125;</span></span><br><span class="line">chmod 300 /var/<span class="built_in">log</span>/<span class="built_in">history</span>/<span class="variable">$&#123;LOGNAME&#125;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">export</span> HISTSIZE=4096</span><br><span class="line">DT=`date +<span class="string">&quot;%Y%m%d_%H:%M:%S&quot;</span>`</span><br><span class="line"><span class="built_in">export</span> HISTFILE=<span class="string">&quot;/var/log/history/<span class="variable">$&#123;LOGNAME&#125;</span>/<span class="variable">$&#123;USER&#125;</span>@<span class="variable">$&#123;USER_IP&#125;</span>_<span class="variable">$DT</span>&quot;</span></span><br><span class="line">chmod 600 /var/<span class="built_in">log</span>/<span class="built_in">history</span>/<span class="variable">$&#123;LOGNAME&#125;</span>/*<span class="built_in">history</span>* 2&gt;/dev/null</span><br><span class="line"><span class="comment">#######################################################################</span></span><br></pre></td></tr></table></figure>
<h2 id="vim设置"><a href="#vim设置" class="headerlink" title="vim设置"></a>vim设置</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">TAB 键为四个空格 永久显示行号</span></span><br><span class="line">vim /etc/vimrc</span><br><span class="line">set ts=4</span><br><span class="line">set sw=4</span><br><span class="line">set number</span><br></pre></td></tr></table></figure>
<h2 id="分区扩容"><a href="#分区扩容" class="headerlink" title="分区扩容"></a>分区扩容</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">umount /data/</span><br><span class="line">fdisk /dev/vdb</span><br><span class="line">d</span><br><span class="line">n</span><br><span class="line">p</span><br><span class="line"></span><br><span class="line">w</span><br><span class="line"></span><br><span class="line">e2fsck -f /dev/vdb1</span><br><span class="line">resize2fs /dev/vdb1 </span><br><span class="line">mount /dev/vdb1 /data/</span><br><span class="line">df -h </span><br><span class="line">cd /data/</span><br><span class="line">ls</span><br></pre></td></tr></table></figure>
<h2 id="随机数生成"><a href="#随机数生成" class="headerlink" title="随机数生成"></a>随机数生成</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">openssl rand -base64 3</span><br></pre></td></tr></table></figure>
<h2 id="tcpdump使用"><a href="#tcpdump使用" class="headerlink" title="tcpdump使用"></a>tcpdump使用</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">参数：</span><br><span class="line">-i 指定网卡</span><br><span class="line">-c 指定抓包数量</span><br></pre></td></tr></table></figure>
<h2 id="时间同步"><a href="#时间同步" class="headerlink" title="时间同步"></a>时间同步</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">如果不是北京时间先改成北京时间</span></span><br><span class="line">1.删除自带的localtime</span><br><span class="line">  rm -rf /etc/localtime</span><br><span class="line">2.创建软链接到localtime</span><br><span class="line">ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">同步阿里云</span></span><br><span class="line">ntpdate ntp.aliyun.com</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">写入硬件主板</span></span><br><span class="line">hwclock -w</span><br></pre></td></tr></table></figure>
<h2 id="终端颜色"><a href="#终端颜色" class="headerlink" title="终端颜色"></a>终端颜色</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#写入到环境变量内</span></span><br><span class="line">RED:</span><br><span class="line">PS1=<span class="string">&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;31;40m\]\u\[\033[00;00;40m\]@\[\033[01;31;40m\]\h\[\033[00;31;40m\]:\[\033[00;00;40m\]\w \[\033[01;32;40m\]\$ \[\033[01;37;40m\]&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">YELLOW:</span><br><span class="line">PS1=<span class="string">&#x27;$&#123;debian_chroot:+($debian_chroot)&#125;\[\033[01;33;40m\]\u\[\033[00;00;40m\]@\[\033[01;33;40m\]\h\[\033[00;33;40m\]:\[\033[00;00;40m\]\w \[\033[01;32;40m\]\$ \[\033[01;37;40m\]&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="linux格式问题"><a href="#linux格式问题" class="headerlink" title="linux格式问题"></a>linux格式问题</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">检查文件格式，如果带M即是Windows，需要使用dosunix转换</span></span><br><span class="line">cat -v filename</span><br><span class="line">apt install dosunix -y</span><br><span class="line">yum install dosunix -y</span><br><span class="line">dos2unix filename</span><br><span class="line"></span><br><span class="line">参考：</span><br><span class="line">https://www.cnblogs.com/chuyiwang/p/13823551.html</span><br></pre></td></tr></table></figure>
<h2 id="文件分割"><a href="#文件分割" class="headerlink" title="文件分割"></a>文件分割</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">split</span><br></pre></td></tr></table></figure>

<h2 id="hexo插件"><a href="#hexo插件" class="headerlink" title="hexo插件"></a>hexo插件</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">npm install hexo-generator-cname</span><br><span class="line">npm install hexo-generator-search --save</span><br><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
